(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["gviz_par"] = factory();
	else
		root["gviz_par"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ascending)
/* harmony export */ });
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bisectCenter: () => (/* binding */ bisectCenter),
/* harmony export */   bisectLeft: () => (/* binding */ bisectLeft),
/* harmony export */   bisectRight: () => (/* binding */ bisectRight),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisector.js */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");




const ascendingBisect = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_number_js__WEBPACK_IMPORTED_MODULE_2__["default"]).center;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bisectRight);


/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bisector)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-array/src/descending.js");



function bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    compare2 = (d, x) => (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"] || f === _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"] ? f : zero;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function zero() {
  return 0;
}


/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ descending)
/* harmony export */ });
function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/extent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/extent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ extent)
/* harmony export */ });
function extent(values, valueof) {
  let min;
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }
  return [min, max];
}


/***/ }),

/***/ "./node_modules/d3-array/src/greatest.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/greatest.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ greatest)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");


function greatest(values, compare = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  let max;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, maxValue) > 0
          : (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, value) === 0) {
        max = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, max) > 0
          : compare(value, value) === 0) {
        max = value;
        defined = true;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/maxIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/maxIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ maxIndex)
/* harmony export */ });
function maxIndex(values, valueof) {
  let max;
  let maxIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  }
  return maxIndex;
}


/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}


/***/ }),

/***/ "./node_modules/d3-array/src/minIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/minIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ minIndex)
/* harmony export */ });
function minIndex(values, valueof) {
  let min;
  let minIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  }
  return minIndex;
}


/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number),
/* harmony export */   numbers: () => (/* binding */ numbers)
/* harmony export */ });
function number(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ permute)
/* harmony export */ });
function permute(source, keys) {
  return Array.from(keys, key => source[key]);
}


/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile),
/* harmony export */   quantileIndex: () => (/* binding */ quantileIndex),
/* harmony export */   quantileSorted: () => (/* binding */ quantileSorted)
/* harmony export */ });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max.js */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _maxIndex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./maxIndex.js */ "./node_modules/d3-array/src/maxIndex.js");
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./min.js */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var _minIndex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./minIndex.js */ "./node_modules/d3-array/src/minIndex.js");
/* harmony import */ var _quickselect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./quickselect.js */ "./node_modules/d3-array/src/quickselect.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-array/src/sort.js");
/* harmony import */ var _greatest_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./greatest.js */ "./node_modules/d3-array/src/greatest.js");









function quantile(values, p, valueof) {
  values = Float64Array.from((0,_number_js__WEBPACK_IMPORTED_MODULE_0__.numbers)(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return (0,_min_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values);
  if (p >= 1) return (0,_max_js__WEBPACK_IMPORTED_MODULE_2__["default"])(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = (0,_max_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(values, i0).subarray(0, i0 + 1)),
      value1 = (0,_min_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function quantileIndex(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  if (isNaN(p = +p)) return;
  numbers = Float64Array.from(values, (_, i) => (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)));
  if (p <= 0) return (0,_minIndex_js__WEBPACK_IMPORTED_MODULE_4__["default"])(numbers);
  if (p >= 1) return (0,_maxIndex_js__WEBPACK_IMPORTED_MODULE_5__["default"])(numbers);
  var numbers,
      index = Uint32Array.from(values, (_, i) => i),
      j = numbers.length - 1,
      i = Math.floor(j * p);
  (0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(index, i, 0, j, (i, j) => (0,_sort_js__WEBPACK_IMPORTED_MODULE_6__.ascendingDefined)(numbers[i], numbers[j]));
  i = (0,_greatest_js__WEBPACK_IMPORTED_MODULE_7__["default"])(index.subarray(0, i + 1), (i) => numbers[i]);
  return i >= 0 ? i : -1;
}


/***/ }),

/***/ "./node_modules/d3-array/src/quickselect.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-array/src/quickselect.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quickselect)
/* harmony export */ });
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-array/src/sort.js");


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = Infinity, compare) {
  k = Math.floor(k);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array.length - 1, right));

  if (!(left <= k && k <= right)) return array;

  compare = compare === undefined ? _sort_js__WEBPACK_IMPORTED_MODULE_0__.ascendingDefined : (0,_sort_js__WEBPACK_IMPORTED_MODULE_0__.compareDefined)(compare);

  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }

  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}


/***/ }),

/***/ "./node_modules/d3-array/src/sort.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/sort.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascendingDefined: () => (/* binding */ ascendingDefined),
/* harmony export */   compareDefined: () => (/* binding */ compareDefined),
/* harmony export */   "default": () => (/* binding */ sort)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _permute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./permute.js */ "./node_modules/d3-array/src/permute.js");



function sort(values, ...F) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);
  let [f] = F;
  if ((f && f.length !== 2) || F.length > 1) {
    const index = Uint32Array.from(values, (d, i) => i);
    if (F.length > 1) {
      F = F.map(f => values.map(f));
      index.sort((i, j) => {
        for (const f of F) {
          const c = ascendingDefined(f[i], f[j]);
          if (c) return c;
        }
      });
    } else {
      f = values.map(f);
      index.sort((i, j) => ascendingDefined(f[i], f[j]));
    }
    return (0,_permute_js__WEBPACK_IMPORTED_MODULE_0__["default"])(values, index);
  }
  return values.sort(compareDefined(f));
}

function compareDefined(compare = _ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
  if (compare === _ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a, b) => {
    const x = compare(a, b);
    if (x || x === 0) return x;
    return (compare(b, b) === 0) - (compare(a, a) === 0);
  };
}

function ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}


/***/ }),

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   Rgb: () => (/* binding */ Rgb),
/* harmony export */   brighter: () => (/* binding */ brighter),
/* harmony export */   darker: () => (/* binding */ darker),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   hsl: () => (/* binding */ hsl),
/* harmony export */   hslConvert: () => (/* binding */ hslConvert),
/* harmony export */   rgb: () => (/* binding */ rgb),
/* harmony export */   rgbConvert: () => (/* binding */ rgbConvert)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extend: () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hcl: () => (/* binding */ Hcl),
/* harmony export */   Lab: () => (/* binding */ Lab),
/* harmony export */   "default": () => (/* binding */ lab),
/* harmony export */   gray: () => (/* binding */ gray),
/* harmony export */   hcl: () => (/* binding */ hcl),
/* harmony export */   lch: () => (/* binding */ lch)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Lab, lab, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Hcl, hcl, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   radians: () => (/* binding */ radians)
/* harmony export */ });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nonpassive: () => (/* binding */ nonpassive),
/* harmony export */   nonpassivecapture: () => (/* binding */ nonpassivecapture),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csvFormat: () => (/* binding */ csvFormat),
/* harmony export */   csvFormatBody: () => (/* binding */ csvFormatBody),
/* harmony export */   csvFormatRow: () => (/* binding */ csvFormatRow),
/* harmony export */   csvFormatRows: () => (/* binding */ csvFormatRows),
/* harmony export */   csvFormatValue: () => (/* binding */ csvFormatValue),
/* harmony export */   csvParse: () => (/* binding */ csvParse),
/* harmony export */   csvParseRows: () => (/* binding */ csvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var csv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tsvFormat: () => (/* binding */ tsvFormat),
/* harmony export */   tsvFormatBody: () => (/* binding */ tsvFormatBody),
/* harmony export */   tsvFormatRow: () => (/* binding */ tsvFormatRow),
/* harmony export */   tsvFormatRows: () => (/* binding */ tsvFormatRows),
/* harmony export */   tsvFormatValue: () => (/* binding */ tsvFormatValue),
/* harmony export */   tsvParse: () => (/* binding */ tsvParse),
/* harmony export */   tsvParseRows: () => (/* binding */ tsvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var tsv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cubicIn: () => (/* binding */ cubicIn),
/* harmony export */   cubicInOut: () => (/* binding */ cubicInOut),
/* harmony export */   cubicOut: () => (/* binding */ cubicOut)
/* harmony export */ });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/dsv.js":
/*!******************************************!*\
  !*** ./node_modules/d3-fetch/src/dsv.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csv: () => (/* binding */ csv),
/* harmony export */   "default": () => (/* binding */ dsv),
/* harmony export */   tsv: () => (/* binding */ tsv)
/* harmony export */ });
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-fetch/src/text.js");



function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = (0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__["default"])(delimiter);
  return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_2__.csvParse);
var tsv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_3__.tsvParse);


/***/ }),

/***/ "./node_modules/d3-fetch/src/json.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseJson);
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/text.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/text.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseText);
}


/***/ }),

/***/ "./node_modules/d3-format/src/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/defaultLocale.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultLocale),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   formatPrefix: () => (/* binding */ formatPrefix)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-format/src/exponent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/exponent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatDecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatDecimal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   formatDecimalParts: () => (/* binding */ formatDecimalParts)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatGroup.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatGroup.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatNumerals.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/formatNumerals.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatPrefixAuto.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-format/src/formatPrefixAuto.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   prefixExponent: () => (/* binding */ prefixExponent)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatRounded.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatRounded.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatSpecifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/formatSpecifier.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormatSpecifier: () => (/* binding */ FormatSpecifier),
/* harmony export */   "default": () => (/* binding */ formatSpecifier)
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./node_modules/d3-format/src/formatTrim.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-format/src/formatTrim.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "./node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"])(x * 100, p),
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});


/***/ }),

/***/ "./node_modules/d3-format/src/identity.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/identity.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-format/src/locale.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-format/src/locale.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "./node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "./node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTrim.js */ "./node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTypes.js */ "./node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__["default"])(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__["default"])(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basis: () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nogamma),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   hue: () => (/* binding */ hue)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lab)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start)).l, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(end)).l),
      a = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.a, end.a),
      b = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.b, end.b),
      opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rgbBasis: () => (/* binding */ rgbBasis),
/* harmony export */   rgbBasisClosed: () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interpolateTransformCss: () => (/* binding */ interpolateTransformCss),
/* harmony export */   interpolateTransformSvg: () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseCss: () => (/* binding */ parseCss),
/* harmony export */   parseSvg: () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-random/src/defaultSource.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-random/src/defaultSource.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Math.random);


/***/ }),

/***/ "./node_modules/d3-random/src/normal.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-random/src/normal.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _defaultSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultSource.js */ "./node_modules/d3-random/src/defaultSource.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
})(_defaultSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "./node_modules/d3-scale/src/init.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/init.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initInterpolator: () => (/* binding */ initInterpolator),
/* harmony export */   initRange: () => (/* binding */ initRange)
/* harmony export */ });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.quantileSorted)(domain, i / n);
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[(0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_2__["default"]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ array)
/* harmony export */ });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   childMatcher: () => (/* binding */ childMatcher),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event, node) {
  event = (0,_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function* __WEBPACK_DEFAULT_EXPORT__() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return (0,_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = (0,_selectorAll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   timer: () => (/* binding */ timer),
/* harmony export */   timerFlush: () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.SCHEDULED && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   active: () => (/* reexport safe */ _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   interrupt: () => (/* reexport safe */ _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   transition: () => (/* reexport safe */ _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");






/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.STARTING && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDING;
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return this.each(function() {
    (0,_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/cubic.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_0__.cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0,_transition_index_js__WEBPACK_IMPORTED_MODULE_1__.newId)(), (timing = defaultTiming).time = (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__.now)(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0,_transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(groups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.interpolateTransformSvg : _interpolate_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_3__.tweenValue)(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).delay;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).duration;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).ease;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(subgroups, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transition: () => (/* binding */ Transition),
/* harmony export */   "default": () => (/* binding */ transition),
/* harmony export */   newId: () => (/* binding */ newId)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/string.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["default"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_1__["default"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"]
      : (c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(merges, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__.init : _schedule_js__WEBPACK_IMPORTED_MODULE_0__.set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.on("end.remove", removeFunction(this._id));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CREATED: () => (/* binding */ CREATED),
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   ENDING: () => (/* binding */ ENDING),
/* harmony export */   RUNNING: () => (/* binding */ RUNNING),
/* harmony export */   SCHEDULED: () => (/* binding */ SCHEDULED),
/* harmony export */   STARTED: () => (/* binding */ STARTED),
/* harmony export */   STARTING: () => (/* binding */ STARTING),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   set: () => (/* binding */ set)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timeout.js");



var emptyOn = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = (0,d3_timer__WEBPACK_IMPORTED_MODULE_1__.timer)(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selector.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(subgroup[i], name, id, i, subgroup, (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.constructor;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new Selection(this._groups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        string1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.set)(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.interpolateTransformCss : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_4__.tweenValue)(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction((0,_tween_js__WEBPACK_IMPORTED_MODULE_0__.tweenValue)(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var name = this._name,
      id0 = this._id,
      id1 = (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.newId)();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id0);
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(groups, this._parents, name, id1);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   tweenValue: () => (/* binding */ tweenValue)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZoomEvent)
/* harmony export */ });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   zoom: () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   zoomIdentity: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.identity),
/* harmony export */   zoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");




/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform),
/* harmony export */   "default": () => (/* binding */ transform),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_3__.identity;
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"],
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_6__["default"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_3__.identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_2__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__["default"])(event.view);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    g.mouse = [p, this.__zoom.invert(p)];
    (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
    g.start();

    function mousemoved(event) {
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__.yesdrag)(event.view, g.moved);
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    if (duration > 0) (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
}


/***/ }),

/***/ "./node_modules/gridviz/src/button/Button.js":
/*!***************************************************!*\
  !*** ./node_modules/gridviz/src/button/Button.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: () => (/* binding */ Button)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");


/**
 * Parent class for button elements used to interact with the gridviz viewer.
 *
 * @module button
 * @author Joseph Davies, Julien Gaffuri
 */
class Button {
    /**
     * @param {Object} opts
     * opts.parentNode
     * opts.id
     * opts.title
     * opts.class
     * opts.onClickFunction
     * opts.x
     * opts.y
     */
    constructor(opts = {}) {

        this.map = opts.map
        this.parentNode = opts.parentNode || opts.map.container

        // the div element
        if (this.id) this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + this.id)

        if (!this.div || this.div.empty()) {
            this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(document.createElement('div'))
            if (this.id) this.div.attr('id', this.id)
        }

        if (opts.title) this.div.attr('title', opts.title)
        if (opts.class) this.div.attr('class', opts.class)

        // add events
        if (opts.onClickFunction) this.div.on('click', opts.onClickFunction)

        //set styles
        this.style('box-shadow', '0 7px 8px rgba(0,47,103,.08), 0 0 22px rgba(0,47,103,.04), 0 12px 17px rgba(0,47,103,.04), 0 -4px 4px rgba(0,47,103,.04)') //.ecl-u-shadow-3
        this.style('background-color', '#ffffff')
        this.style('position', 'absolute')
        this.style('cursor', 'pointer')
        this.style('display', 'flex')
        this.style('justify-content', 'center')
        this.style('align-items', 'center')
        this.style('width', '30px')
        this.style('height', '30px')
        // this.style(padding , '4px'


        // append to parent
        this.parentNode.appendChild(this.div.node())
    }

    /**
     * Apply a style to the button div.
     * @param {string} k
     * @param {string} v
     * @returns {this}
     */
    style(k, v) {
        this.div.style(k, v)
        return this
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/button/FullscreenButton.js":
/*!*************************************************************!*\
  !*** ./node_modules/gridviz/src/button/FullscreenButton.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FullscreenButton: () => (/* binding */ FullscreenButton)
/* harmony export */ });
/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ "./node_modules/gridviz/src/button/Button.js");


/**
 * Button for toggling fullscreen mode
 *
 * @module button
 * @author Joseph Davies, Julien Gaffuri
 */
class FullscreenButton extends _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button {
    /**
     * @param {Object} opts
     * opts.parentNode - the node that the button is appended to
     * opts.canvas - the gridviz canvas
     * opts.id
     * opts.title - HTML title attribute
     * opts.class - css class
     * opts.onClickFunction
     * opts.x - x position of the button
     * opts.y - y position of the button
     */

    // default state
    isFullscreen = false

    constructor(opts) {
        super(opts)

        // append fullscreen icon to button container
        this.div.node().innerHTML = `
        <svg
            style="height: 1.2rem; width: 1.2rem; fill:black; margin:0;"
            focusable="false"
            aria-hidden="true"
        >
            <svg fill="#000000" viewBox="0 0 96 96" xmlns="http://www.w3.org/2000/svg">
            <title/>
            <g>
            <path d="M30,0H6A5.9966,5.9966,0,0,0,0,6V30a6,6,0,0,0,12,0V12H30A6,6,0,0,0,30,0Z"/>
            <path d="M90,0H66a6,6,0,0,0,0,12H84V30a6,6,0,0,0,12,0V6A5.9966,5.9966,0,0,0,90,0Z"/>
            <path d="M30,84H12V66A6,6,0,0,0,0,66V90a5.9966,5.9966,0,0,0,6,6H30a6,6,0,0,0,0-12Z"/>
            <path d="M90,60a5.9966,5.9966,0,0,0-6,6V84H66a6,6,0,0,0,0,12H90a5.9966,5.9966,0,0,0,6-6V66A5.9966,5.9966,0,0,0,90,60Z"/>
            </g>
            </svg>
        </svg>
        `

        //save initial map dimensions
        this.defaultHeight = this.map.h
        this.defaultWidth = this.map.w

        // event handler
        this.div.on('click', (e) => {
            this.onClickFunction(e)
        })
        this.div.on('mouseover', (e) => {
            this.style('background-color', 'lightgrey')
        })
        this.div.on('mouseout', (e) => {
            this.style('background-color', '#ffffff')
        })

        //set position
        if (opts.x) {
            this.style('left', opts.x + 'px')
        } else {
            this.style('right', '10px')
        }
        if (opts.y) {
            this.style('top', opts.y + 'px')
        } else {
            this.style('top', '90px')
        }
    }

    onClickFunction(e) {
        if (this.isFullscreen) {
            this.closeFullscreen(this.map.container)
            //resize canvas to default
            this.map.h = this.defaultHeight
            this.map.w = this.defaultWidth
            this.map.geoCanvas.h = this.defaultHeight
            this.map.geoCanvas.w = this.defaultWidth
            this.map.geoCanvas.canvas.setAttribute('width', '' + this.defaultWidth)
            this.map.geoCanvas.canvas.setAttribute('height', '' + this.defaultHeight)
            this.map.redraw()
            this.isFullscreen = false
        } else {
            this.openFullscreen(this.map.container)
            //resize canvas to fullscreen
            this.map.h = window.screen.height
            this.map.w = window.screen.width
            this.isFullscreen = true
        }
    }

    /* Open fullscreen */
    openFullscreen(elem) {
        if (elem.requestFullscreen) {
            elem.requestFullscreen()
        } else if (elem.webkitRequestFullscreen) {
            /* Safari */
            elem.webkitRequestFullscreen()
        } else if (elem.msRequestFullscreen) {
            /* IE11 */
            elem.msRequestFullscreen()
        }
    }

    /* Close fullscreen */
    closeFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen()
        } else if (document.webkitExitFullscreen) {
            /* Safari */
            document.webkitExitFullscreen()
        } else if (document.msExitFullscreen) {
            /* IE11 */
            document.msExitFullscreen()
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/button/ZoomButtons.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/button/ZoomButtons.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZoomButtons: () => (/* binding */ ZoomButtons)
/* harmony export */ });
/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ "./node_modules/gridviz/src/button/Button.js");


/**
 * Button for toggling fullscreen mode
 *
 * @module button
 * @author Joseph Davies, Julien Gaffuri
 */
class ZoomButtons extends _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button {
    /**
     * @param {Object} opts
     */
    constructor(opts) {
        super(opts)

        this.onZoom = opts.onZoom // custom user event handler
        this.delta = opts.delta || 0.2

        // zoom in btn
        this.zoomInBtn = document.createElement('a')
        this.zoomInBtn.innerHTML = `<a id="zoomin" class="gridviz-zoom-button" title="Zoom in">+</a>`
        this.zoomInBtn.title = 'Zoom in'
        this.zoomInBtn.addEventListener('click', (e) => {
            this.zoomIn(e)
        })
        this.zoomInBtn.addEventListener('mouseover', (e) => {
            this.zoomInBtn.style.backgroundColor = 'lightgrey'
        })
        this.zoomInBtn.addEventListener('mouseout', (e) => {
            this.zoomInBtn.style.backgroundColor = '#ffffff'
        })

        // zoom out btn
        this.zoomOutBtn = document.createElement('a')
        this.zoomOutBtn.innerHTML = `<a id="zoomin" class="gridviz-zoom-button" title="Zoom out">-</a>`
        this.zoomOutBtn.title = 'Zoom out'
        this.zoomOutBtn.addEventListener('click', (e) => {
            this.zoomOut(e)
        })
        this.zoomOutBtn.addEventListener('mouseover', (e) => {
            this.zoomOutBtn.style.backgroundColor = 'lightgrey'
        })
        this.zoomOutBtn.addEventListener('mouseout', (e) => {
            this.zoomOutBtn.style.backgroundColor = '#ffffff'
        })

        //set styles
        let btns = [this.zoomInBtn, this.zoomOutBtn]
        btns.forEach((btn, i) => {
            btn.style.alignItems = 'center'
            btn.style.justifyContent = 'center'
            btn.style.display = 'flex'
            btn.style.border = 'none'
            btn.style.color = 'black'
            btn.style.textAlign = 'center'
            btn.style.textDecoration = 'none'
            btn.style.padding = '4px'
            btn.style.fontSize = '20px'
            btn.style.fontWeight = 'bold'
            btn.style.userSelect = 'none'
            if (i == 0) btn.style.borderBottom = '1px solid grey'
        })

        // unset parent class height and display for dual buttons
        this.style('height', 'unset')
        this.style('display', 'unset')

        //set position
        if (opts.x) {
            this.style('left', opts.x + 'px')
        } else {
            this.style('right', '10px')
        }
        if (opts.y) {
            this.style('top', opts.y + 'px')
        } else {
            this.style('top', '10px')
        }

        // append to button container
        this.div.node().appendChild(this.zoomInBtn)
        this.div.node().appendChild(this.zoomOutBtn)
    }

    /* Zoom in */
    zoomIn(e) {
        this.map.setZoom(this.map.getZoom() * (1 - this.delta)).redraw()
        if (this.onZoom) this.onZoom(e)
    }

    /* Zoom out */
    zoomOut(e) {
        this.map.setZoom(this.map.getZoom() * (1 + this.delta)).redraw()
        if (this.onZoom) this.onZoom(e)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/core/Dataset.js":
/*!**************************************************!*\
  !*** ./node_modules/gridviz/src/core/Dataset.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dataset: () => (/* binding */ Dataset)
/* harmony export */ });
//@ts-check


/**
 * A grid cell.
 * @typedef {{x: number, y: number}} Cell */

/**
 * A dataset component, of grid cells.
 * @abstract
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class Dataset {
    /**
     * @param {import("./Map.js").Map} map The map.
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution, in the CRS geographical unit.
     * @param {{preprocess?:function(Cell):boolean, mixedResolution?:function(Cell):number}} opts
     * @abstract
     */
    constructor(map, url, resolution, opts = {}) {

        /**
         * The map.
         * @protected
         * @type {import("./Map.js").Map} */
        this.map = map

        /**
         * The url of the dataset.
         * @protected
         * @type {string} */
        this.url = url

        /**
         * The dataset resolution in geographical unit.
         * @protected
         * @type {number} */
        this.resolution = resolution

        /**
        * In case the dataset is a dataset with cells having different resolution,
        * this is the function returning the resolution of each cell.
        * @protected
        * @type {(function(Cell):number )| undefined } */
        this.mixedResolution = opts.mixedResolution

        /**
         * A preprocess to run on each cell after loading. It can be used to apply some specific treatment before or compute a new column. And also to determine which cells to keep after loading.
         * @type {(function(Cell):boolean )| undefined } */
        this.preprocess = opts.preprocess || undefined

        /** The cells within the view
         * @protected
         * @type {Array.<Cell>} */
        this.cellsViewCache = []
    }

    /**
     * Request data within a geographic envelope.
     *
     * @abstract
     * @param {import("./GeoCanvas").Envelope|undefined} extGeo
     * @returns {this}
     */
    getData(extGeo = undefined) {
        throw new Error('Method getData not implemented.')
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     * @abstract
     * @param {import("./GeoCanvas").Envelope} extGeo The view geographical envelope.
     * @returns {void}
     */
    updateViewCache(extGeo) {
        throw new Error('Method updateViewCache not implemented.')
    }

    /**
     * Get a cell under a given position, if any.
     *
     * @param {{x:number,y:number}} posGeo
     * @param {Array.<Cell>} cells Some cells from the dataset (a subset if necessary, usually the view cache).
     * @returns {Cell|undefined}
     */
    getCellFromPosition(posGeo, cells) {
        //compute candidate cell position
        /** @type {number} */
        //const r = this.getResolution()
        /** @type {number} */
        //const cellX = r * Math.floor(posGeo.x / r)
        /** @type {number} */
        //const cellY = r * Math.floor(posGeo.y / r)

        /*/get cell
        for (const cell of cells) {
            if (cell.x != cellX) continue
            if (cell.y != cellY) continue
            return cell
        }
        return undefined*/

        //rare case of mixed resolution dataset
        if (this.mixedResolution) {
            for (const c of cells) {
                /** @type {number} */
                const r = this.mixedResolution(c)
                if (posGeo.x < c.x) continue
                else if (c.x + r < posGeo.x) continue
                else if (posGeo.y < c.y) continue
                else if (c.y + r < posGeo.y) continue
                else return c
            }
            return undefined
        }

        //common case

        /** @type {number} */
        const r = this.getResolution()
        for (const cell of cells) {
            if (posGeo.x < cell.x) continue
            else if (cell.x + r < posGeo.x) continue
            else if (posGeo.y < cell.y) continue
            else if (cell.y + r < posGeo.y) continue
            else return cell
        }
        return undefined

    }

    //getters and setters

    /** @returns {number} */
    getResolution() {
        return this.resolution
    }

    /** @returns {Array.<Cell>} */
    getViewCache() {
        return this.cellsViewCache
    }

    /**
     * Return the relevant dataset for a specified zoom.
     * @param {number} z
     * @param {number} minPixelsPerCell
     * @returns {Dataset|undefined}
     * */
    getDataset(z, minPixelsPerCell) {
        return this
    }

}


/***/ }),

/***/ "./node_modules/gridviz/src/core/Drawable.js":
/*!***************************************************!*\
  !*** ./node_modules/gridviz/src/core/Drawable.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Drawable: () => (/* binding */ Drawable)
/* harmony export */ });
//@ts-check


/**
 * This is an abstract class used to group elements shared between Layer and Style classes.
 * 
 * @abstract
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class Drawable {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** A function specifying if the element should be visible or not.
         * The function parameter is the zoom level.
        * @type {function(number):boolean} */
        this.visible = opts.visible

        /** A function returning the alpha (transparency/opacity), between 0.0 (fully transparent) and 1.0 (fully opaque).
         *  The function parameter is the zoom level.
         * (see CanvasRenderingContext2D: globalAlpha property)
         * @type {(function(number):number)|undefined} */
        this.alpha = opts.alpha

        /** A function returning the blend operation.
         * The function parameter is the zoom level.
         * (see CanvasRenderingContext2D: globalCompositeOperation property)
         * @type {function(number):GlobalCompositeOperation} */
        this.blendOperation = opts.blendOperation || (z => "source-over")

        /** @type {(function(number):string)|undefined} */
        this.filterColor = opts.filterColor // (z) => "#eee7"
    }

    /**
     * Draw layer filter.
     * 
     * @param {import("./GeoCanvas.js").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     * @abstract
     */
    drawFilter(geoCanvas) {
        //no filter: return
        if (!this.filterColor) return

        //get filter
        const fc = this.filterColor(geoCanvas.view.z)

        //no filter: return
        if (!fc || fc == 'none') return

        //draw filter
        geoCanvas.ctx.fillStyle = fc
        geoCanvas.ctx.fillRect(0, 0, geoCanvas.w, geoCanvas.h)
    }

}


/***/ }),

/***/ "./node_modules/gridviz/src/core/GeoCanvas.js":
/*!****************************************************!*\
  !*** ./node_modules/gridviz/src/core/GeoCanvas.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeoCanvas: () => (/* binding */ GeoCanvas)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
//@ts-check


/** @typedef { {xMin: number, xMax: number, yMin: number, yMax: number} } Envelope */

/**
 * A viewshed.
 * @typedef {{x: number, y: number, z: number}} View */

;


/**
 * A HTML canvas for geo data display, enhanced with zoom and pan capabilities.
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class GeoCanvas {
    /**
     * @constructor
     * @param {HTMLCanvasElement} canvas
     * @param {number} x The x coordinate of the view
     * @param {number} y The y coordinate of the view
     * @param {number} z The zoom level of the view (pixel size, in ground m)
     * @param {object} opts
     */
    constructor(canvas, x = 0, y = 0, z = 0, opts = undefined) {
        this.opts = opts || {}

        /** @type {HTMLCanvasElement} */
        this.canvas = canvas

        /** @type {number} */
        this.w = this.canvas.offsetWidth
        /** @type {number} */
        this.h = this.canvas.offsetHeight

        this.canvas.width = this.w
        this.canvas.height = this.h

        const ctx = this.canvas.getContext('2d')
        if (!ctx) throw 'Impossible to create canvas 2D context'
        /**@type {CanvasRenderingContext2D} */
        this.ctx = ctx

        /** 
         * z: pixel size, in m/pix
         * @type {View}  */
        this.view = { x: x, y: y, z: z }

        /** Background color.
         * @type {string} */
        this.backgroundColor = opts.backgroundColor || 'white'

        /** @type {function(object|undefined):void} */
        this.onZoomStartFun = opts.onZoomStartFun

        /** @type {function(object|undefined):void} */
        this.onZoomEndFun = opts.onZoomEndFun

        /** @type {function(object|undefined):void} */
        this.onZoomFun = opts.onZoomFun

        //current extent
        /** @type {Envelope} */
        this.extGeo = { xMin: NaN, xMax: NaN, yMin: NaN, yMax: NaN }
        this.updateExtentGeo()

        //rely on d3 zoom for pan/zoom
        if (!opts.disableZoom) {
            let tP = d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity
            const z = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()
                //to make the zooming a bit faster
                .wheelDelta((e) => -e.deltaY * (e.deltaMode === 1 ? 0.07 : e.deltaMode ? 1 : 0.004))
                .on('zoom', (e) => {
                    const t = e.transform
                    const f = tP.k / t.k
                    if (f == 1) {
                        //pan
                        const dx = tP.x - t.x
                        const dy = tP.y - t.y
                        this.pan(dx * this.view.z, -dy * this.view.z)
                    } else {
                        const se = e.sourceEvent
                        if (se instanceof WheelEvent) {
                            //zoom at the mouse position
                            this.zoom(
                                f,
                                this.pixToGeoX(e.sourceEvent.offsetX),
                                this.pixToGeoY(e.sourceEvent.offsetY)
                            )
                        } else if (se instanceof TouchEvent) {
                            //compute average position of the touches
                            let tx = 0,
                                ty = 0
                            for (let tt of se.targetTouches) {
                                tx += tt.clientX
                                ty += tt.clientY
                            }
                            tx /= se.targetTouches.length
                            ty /= se.targetTouches.length
                            //zoom at this average position
                            this.zoom(f, this.pixToGeoX(tx), this.pixToGeoY(ty))
                        }
                    }
                    tP = t

                    if (this.onZoomFun) this.onZoomFun(e)
                })
                .on('start', (e) => {
                    this.canvasSave.c = document.createElement('canvas')
                    this.canvasSave.c.setAttribute('width', '' + this.w);
                    this.canvasSave.c.setAttribute('height', '' + this.h);
                    this.canvasSave.c.getContext('2d')?.drawImage(this.canvas, 0, 0);
                    this.canvasSave.dx = 0;
                    this.canvasSave.dy = 0;
                    this.canvasSave.f = 1;

                    if (this.onZoomStartFun) this.onZoomStartFun(e)
                })
                .on('end', (e) => {
                    this.redraw()
                    this.canvasSave = { c: null, dx: 0, dy: 0, f: 1 }

                    if (this.onZoomEndFun) this.onZoomEndFun(e)
                })
            z((0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this.canvas))
        }
        //select(this.canvas).call(z);

        /** Zoom extent, to limit zoom in and out
         *  @type {Array.<number>} */
        this.zoomExtent = opts.zoomExtent || [0, Infinity]

        /** Canvas state, to be used to avoid unnecessary redraws on zoom/pan
         *  @type {{c:HTMLCanvasElement|null,dx:number,dy:number,f:number}} */
        this.canvasSave = { c: null, dx: 0, dy: 0, f: 1 }
    }

    /** @returns {View} */
    getView() { return this.view }


    /** @param {Array.<number>} v */
    setZoomExtent(v) {
        this.zoomExtent = v
    }
    /** @returns {Array.<number>} */
    getZoomExtent() {
        return this.zoomExtent
    }

    /** Initialise canvas transform with identity transformation. */
    initCanvasTransform() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0)
    }

    /** Initialise canvas transform with geo to screen transformation, so that geo objects can be drawn directly in geo coordinates. */
    setCanvasTransform() {
        const k = 1 / this.view.z
        const tx = -this.view.x / this.view.z + this.w * 0.5
        const ty = this.view.y / this.view.z + this.h * 0.5
        this.ctx.setTransform(k, 0, 0, -k, tx, ty)
    }

    /** Get the transformation matrix to webGL screen coordinates, within [-1,1]*[-1,1] */
    getWebGLTransform() {
        const kx = 2.0 / (this.w * this.view.z)
        const ky = 2.0 / (this.h * this.view.z)
        return [kx, 0.0, 0.0, 0.0, ky, 0.0, -kx * this.view.x, -ky * this.view.y, 1.0]
    }

    /** The function specifying how to draw the map. */
    redraw() {
        throw new Error('Method redraw not implemented.')
    }

    /**
     * Clear. To be used before a redraw for example.
     * @param {string} color
     */
    clear(color = 'white') {
        if (this.opts.transparentBackground) {
            this.ctx.clearRect(0, 0, this.w, this.h)
        } else {
            if (this.ctx) this.ctx.fillStyle = color
            this.ctx.fillRect(0, 0, this.w, this.h)
        }
    }

    /**
     * @param {number} dxGeo
     * @param {number} dyGeo
     */
    pan(dxGeo = 0, dyGeo = 0) {
        //TODO force extend to remain
        this.view.x += dxGeo
        this.view.y += dyGeo
        this.updateExtentGeo()

        if (this.canvasSave.c) {
            this.canvasSave.dx -= dxGeo / this.view.z
            this.canvasSave.dy += dyGeo / this.view.z
            this.clear(this.backgroundColor)
            // this doesnt work on mobile https://github.com/eurostat/gridviz/issues/98
            this.ctx.drawImage(this.canvasSave.c, this.canvasSave.dx, this.canvasSave.dy)
        }
    }

    /**
     * Zoom.
     * @param {number} f The , within ]0, Infinity]. 1 is for no change. <1 to zoom-in, >1 to zoom-out.
     * @param {number} xGeo The x geo position fixed in the screen.
     * @param {number} yGeo The y geo position fixed in the screen.
     */
    zoom(f = 1, xGeo = this.view.x, yGeo = this.view.y) {
        //TODO force geo extend to remain

        //trying to zoom in/out beyond limit
        if (this.zoomExtent[0] == this.view.z && f <= 1) return
        if (this.zoomExtent[1] == this.view.z && f >= 1) return

        //ensure zoom extent preserved
        const newZf = f * this.view.z
        if (newZf < this.zoomExtent[0]) f = this.zoomExtent[0] / this.view.z
        if (newZf > this.zoomExtent[1]) f = this.zoomExtent[1] / this.view.z

        this.view.z *= f
        const dxGeo = (xGeo - this.view.x) * (1 - f)
        this.view.x += dxGeo
        const dyGeo = (yGeo - this.view.y) * (1 - f)
        this.view.y += dyGeo
        this.updateExtentGeo()

        if (this.canvasSave.c) {
            this.clear(this.backgroundColor)
            this.canvasSave.f /= f
            this.canvasSave.dx = this.geoToPixX(xGeo) * (1 - this.canvasSave.f)
            this.canvasSave.dy = this.geoToPixY(yGeo) * (1 - this.canvasSave.f)
            this.clear(this.backgroundColor)
            this.ctx.drawImage(
                this.canvasSave.c,
                this.canvasSave.dx,
                this.canvasSave.dy,
                this.canvasSave.f * this.canvasSave.c.width,
                this.canvasSave.f * this.canvasSave.c.height
            )
        }
    }

    /**
     * @param {number} marginPx
     * @returns {Envelope} The envelope of the view, in geo coordinates.
     */
    updateExtentGeo(marginPx = 20) {
        this.extGeo = {
            xMin: this.pixToGeoX(-marginPx),
            xMax: this.pixToGeoX(this.w + marginPx),
            yMin: this.pixToGeoY(this.h + marginPx),
            yMax: this.pixToGeoY(-marginPx),
        }
        return this.extGeo
    }

    /**
     * Check if the object has to be drawn
     *
     * @param {{x:number,y:number}} obj
     */
    toDraw(obj) {
        if (obj.x < this.extGeo.xMin) return false
        if (obj.x > this.extGeo.xMax) return false
        if (obj.y < this.extGeo.yMin) return false
        if (obj.y > this.extGeo.yMax) return false
        return true
    }

    //conversion functions
    /**
     * @param {number} xGeo Geo x coordinate, in m.
     * @returns {number} Screen x coordinate, in pix.
     */
    geoToPixX(xGeo) {
        return (xGeo - this.view.x) / this.view.z + this.w * 0.5
    }
    /**
     * @param {number} yGeo Geo y coordinate, in m.
     * @returns {number} Screen y coordinate, in pix.
     */
    geoToPixY(yGeo) {
        return -(yGeo - this.view.y) / this.view.z + this.h * 0.5
    }
    /**
     * @param {number} x Screen x coordinate, in pix.
     * @returns {number} Geo x coordinate, in m.
     */
    pixToGeoX(x) {
        return (x - this.w * 0.5) * this.view.z + this.view.x
    }
    /**
     * @param {number} y Screen y coordinate, in pix.
     * @returns {number} Geo y coordinate, in m.
     */
    pixToGeoY(y) {
        return -(y - this.h * 0.5) * this.view.z + this.view.y
    }

    /** Get x,y,z elements from URL and assign them to the view. */
    setViewFromURL() {
        const x = GeoCanvas.getParameterByName('x'),
            y = GeoCanvas.getParameterByName('y'),
            z = GeoCanvas.getParameterByName('z')
        if (x != null && x != undefined && !isNaN(+x)) this.view.x = +x
        if (y != null && y != undefined && !isNaN(+y)) this.view.y = +y
        if (z != null && z != undefined && !isNaN(+z)) this.view.z = +z
    }

    /**
     * Get a URL parameter by name.
     *
     * @param {string} name
     * @returns {string | null}
     */
    static getParameterByName(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
        var regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
            results = regex.exec(location.search)
        return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/core/Layer.js":
/*!************************************************!*\
  !*** ./node_modules/gridviz/src/core/Layer.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Layer: () => (/* binding */ Layer)
/* harmony export */ });
/* harmony import */ var _Drawable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Drawable.js */ "./node_modules/gridviz/src/core/Drawable.js");
//@ts-check


;

/**
 * @module core
 * @abstract
 * @author Joseph Davies, Julien Gaffuri
 */
class Layer extends _Drawable_js__WEBPACK_IMPORTED_MODULE_0__.Drawable {

    /**
     * Draw layer.
     * 
     * @param {import("./GeoCanvas").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @param {object} legend
     * @returns {void}
     * @abstract
     */
    draw(geoCanvas, legend = undefined) {
        throw new Error('Method draw not implemented.')
    }

}


/***/ }),

/***/ "./node_modules/gridviz/src/core/Legend.js":
/*!*************************************************!*\
  !*** ./node_modules/gridviz/src/core/Legend.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Legend: () => (/* binding */ Legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


;

/**
 * A legend container.
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class Legend {
    /**
     * @param {Object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** @type {string} */
        this.id = opts.id

        //TODO stop using it. Use style method below instead.

        /** @type {number} @deprecated */
        this.top = opts.top
        /** @type {number} @deprecated */
        this.bottom = opts.bottom
        /** @type {number} @deprecated */
        this.left = opts.left
        /** @type {number} @deprecated */
        this.right = opts.right
        /** @type {string} @deprecated */
        this.background = opts.background || 'none'
        /** @type {string} @deprecated */
        this.padding = opts.padding || '5px'
        /** @type {string} @deprecated */
        this.border = opts.border || '0px'
        /** @type {string} @deprecated */
        this['border-radius'] = opts['border-radius'] || 'none'
        /** @type {string} @deprecated */
        this['box-shadow'] = opts['box-shadow'] || 'none'
        /** @type {string} @deprecated */
        this['font-family'] = opts['font-family'] || 'Helvetica, Arial, sans-serif'
        /** @type {string} @deprecated */
        //this.width = opts.width
        /** @type {string} @deprecated */
        //this.height = opts.height

        //the div element
        if (this.id) this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + this.id)

        if (!this.div || this.div.empty()) {
            this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(document.createElement('div'))
            if (this.id) this.div.attr('id', this.id)
        }

        //set style
        this.div.style('background', this.background)
        this.div.style('padding', this.padding)
        this.div.style('border', this.border)
        this.div.style('border-radius', this['border-radius'])
        this.div.style('box-shadow', this['box-shadow'])
        this.div.style('font-family', this['font-family'])

        //if (this.width) this.div.style('width', this.width)
        //if (this.height) this.div.style('height', this.height)

        //title
        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
        this.labelUnitText = opts.labelUnitText || ''
        this.labelFormat = opts.labelFormat
    }


    makeTitle() {
        if (!this.title) return
        this.div
            .append('div')
            .style('font-size', this.titleFontSize)
            .style('font-weight', this.titleFontWeight)
            .style('margin-bottom', '7px')
            .text(this.title)
    }


    /**
     * Apply a style to the legend div.
     * @param {string} k
     * @param {string} v
     * @returns {this|string}
     */
    style(k, v) {
        if (arguments.length == 1) return this.div.style(k)
        this.div.style(k, v)
        return this
    }

    /**
     * @param {Object} opts
     * @abstract
     */
    update(opts = {}) {
        console.error('Legend update not implemented yet.')
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/core/Map.js":
/*!**********************************************!*\
  !*** ./node_modules/gridviz/src/core/Map.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Map: () => (/* binding */ Map)
/* harmony export */ });
/* harmony import */ var _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GeoCanvas.js */ "./node_modules/gridviz/src/core/GeoCanvas.js");
/* harmony import */ var _Tooltip_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Tooltip.js */ "./node_modules/gridviz/src/core/Tooltip.js");
/* harmony import */ var _button_ZoomButtons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../button/ZoomButtons.js */ "./node_modules/gridviz/src/button/ZoomButtons.js");
/* harmony import */ var _button_FullscreenButton_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../button/FullscreenButton.js */ "./node_modules/gridviz/src/button/FullscreenButton.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


// internal imports
;




// external imports


/**
 * A gridviz application.
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class Map {
    /**
     * @param {HTMLDivElement} container
     * @param {object} opts
     */
    constructor(container, opts) {
        opts = opts || {}

        /**
         * The layers.
         * @type {Array.<import("./Layer.js").Layer>}
         * */
        this.layers = opts.layers || []

        //get container element
        this.container = container || document.getElementById('gridviz')
        if (!this.container) {
            console.error('Cannot find gridviz container element.')
            return
        }

        //https://css-tricks.com/absolute-positioning-inside-relative-positioning/
        this.container.style.position = "relative"; // container element must have relative positioning

        //set dimensions
        /** @type {number} */
        this.w = opts.w || this.container.offsetWidth
        /** @type {number} */
        this.h = opts.h || this.container.offsetHeight

        //create canvas element if not specified
        /** @type {HTMLCanvasElement} */
        this._canvas = opts.canvas || this.initialiseCanvas()

        /** Make geo canvas
         * @type {GeoCanvas}
         * @private */
        this.geoCanvas = new _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_0__.GeoCanvas(this._canvas, opts.x, opts.y, opts.z, opts)
        this.geoCanvas.redraw = () => { this.redraw() }

        // legend div
        this.legendDivId = opts.legendDivId || 'gvizLegend'
        this.legend = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])('#' + this.legendDivId)
        if (this.legend.empty()) this.initialiseLegend()


        //tooltip

        // set App container as default parent element for tooltip
        if (!opts.tooltip) opts.tooltip = {}
        if (!opts.tooltip.parentElement) opts.tooltip.parentElement = this.container

        /**
         * @private
         * @type {Tooltip} */
        this.tooltip = new _Tooltip_js__WEBPACK_IMPORTED_MODULE_1__.Tooltip(opts.tooltip)

        // add event listeners to container
        this.mouseOverHandler = (e) => this.focusCell(e)
        this.mouseMoveHandler = (e) => this.focusCell(e)
        this.mouseOutHandler = (e) => this.tooltip.hide()
        this.geoCanvas.canvas.addEventListener('mouseover', this.mouseOverHandler)
        this.geoCanvas.canvas.addEventListener('mousemove', this.mouseMoveHandler)
        this.geoCanvas.canvas.addEventListener('mouseout', this.mouseOutHandler)

        // add extra logic to onZoomStartFun
        this.geoCanvas.onZoomStartFun = (e) => {
            if (opts.onZoomStartFun) opts.onZoomStartFun(e)
            this.tooltip.hide()
        }

        //for mouse over
        /**
         * @private
         * @type {HTMLCanvasElement|null} */
        this.canvasSave = null

        this.selectionRectangleColor = opts.selectionRectangleColor || 'red'
        this.selectionRectangleWidthPix = opts.selectionRectangleWidthPix || (() => 4) //(r,z) => {}

        // transparent background (e.g. leaflet) 'red painting' fix
        this.transparentBackground = opts.transparentBackground

        //set default globalCompositeOperation
        this.defaultGlobalCompositeOperation =
            opts.defaultGlobalCompositeOperation || this.geoCanvas.ctx.globalCompositeOperation
    }

    /** 
     * @protected 
     * @returns {HTMLCanvasElement}
    */
    initialiseCanvas() {
        const canvas = document.createElement('canvas')
        canvas.setAttribute('width', '' + this.w)
        canvas.setAttribute('height', '' + this.h)
        this.container.appendChild(canvas)
        return canvas
    }


    initialiseLegend() {
        this.legend = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.container.id && this.container.id != '' ? '#' + this.container.id : 'body')
            .append('div')
            .attr('id', this.legendDivId)
            .style('position', 'absolute')
            .style('width', 'auto')
            .style('height', 'auto')
            .style('background', '#FFFFFF')
            //.style("padding", this.padding)
            .style('border', '0px')
            //.style('border-radius', '5px')
            .style('box-shadow', '3px 3px 3px grey, -3px -3px 3px #ddd')
            .style('font-family', 'Helvetica, Arial, sans-serif')
            .style('bottom', '15px')
            .style('right', '15px')
        //hide
        //.style("visibility", "hidden")
    }

    /**
     * Set/get layer stack.
     * 
     * @param {undefined|import("./Layer.js").Layer|import("./Layer.js").Layer[]} layers 
     * @returns { this | import("./Layer.js").Layer[] }
     */
    layers_(layers) {
        if (arguments.length === 0) return this.layers
        if (arguments.length === 1)
            if (Array.isArray(layers)) this.layers = layers
            else this.layers = [layers]
        else this.layers = arguments
        return this
    }

    /** @returns {this} */
    redraw() {
        //remove legend elements
        if (this.legend) this.legend.selectAll('*').remove()

        //clear
        this.geoCanvas.initCanvasTransform()
        this.geoCanvas.clear(this.geoCanvas.backgroundColor)

        const z = this.geoCanvas.view.z
        this.updateExtentGeo()

        //go through the layers
        for (const layer of this.layers) {

            //check if layer is visible
            if (layer.visible && !layer.visible(z)) continue

            //set layer alpha and blend mode
            this.geoCanvas.ctx.globalAlpha = layer.alpha ? layer.alpha(z) : 1.0
            if (layer.blendOperation)
                this.geoCanvas.ctx.globalCompositeOperation = layer.blendOperation(z)

            //set affin transform to draw with geographical coordinates
            this.geoCanvas.setCanvasTransform()

            //draw layer
            layer.draw(this.geoCanvas, this.legend)

            //draw layer filter
            if (layer.filterColor)
                layer.drawFilter(this.geoCanvas)

            //restore default alpha and blend operation
            this.geoCanvas.ctx.globalAlpha = 1.0
            this.geoCanvas.ctx.globalCompositeOperation = this.defaultGlobalCompositeOperation
        }

        //
        this.canvasSave = null

        // listen for resize events on the App's container and handle them
        this.defineResizeObserver(this.container, this._canvas)

        return this
    }


    /**
     * @param {number} marginPx
     * @returns {import('./GeoCanvas.js').Envelope}
     * @public
     */
    updateExtentGeo(marginPx = 20) {
        return this.geoCanvas.updateExtentGeo(marginPx)
    }



    /** @param {MouseEvent} e */
    focusCell(e) {
        //compute mouse geo position
        const mousePositionGeo = {
            x: this.geoCanvas.pixToGeoX(e.offsetX + this.tooltip.xMouseOffset),
            y: this.geoCanvas.pixToGeoY(e.offsetY + this.tooltip.yMouseOffset),
        }
        /** @type {{cell:import('./Dataset.js').Cell,html:string,resolution:number} | undefined} */
        const focus = this.getCellFocusInfo(mousePositionGeo)

        // transparent background (e.g. leaflet) 'red painting' fix
        if (this.transparentBackground) {
            if (focus) {
                this.tooltip.html(focus.html)
                this.tooltip.setPosition(e)
                this.tooltip.show()
            } else {
                this.tooltip.hide()
            }
            this.canvasSave = document.createElement('canvas')
            this.canvasSave.setAttribute('width', '' + this.w)
            this.canvasSave.setAttribute('height', '' + this.h)
            this.canvasSave.getContext('2d')?.drawImage(this.geoCanvas.canvas, 0, 0)
            this.geoCanvas.initCanvasTransform()
            return
        }

        if (focus) {
            this.tooltip.html(focus.html)
            this.tooltip.setPosition(e)
            this.tooltip.show()

            //show cell position as a rectangle
            if (!this.canvasSave) {
                this.canvasSave = document.createElement('canvas')
                this.canvasSave.setAttribute('width', '' + this.w)
                this.canvasSave.setAttribute('height', '' + this.h)
                this.canvasSave.getContext('2d')?.drawImage(this.geoCanvas.canvas, 0, 0)
            } else {
                this.geoCanvas.ctx.drawImage(this.canvasSave, 0, 0)
            }

            //draw image saved + draw rectangle
            const rectWPix = this.selectionRectangleWidthPix
                ? this.selectionRectangleWidthPix(focus.resolution, this.geoCanvas.view.z)
                : 4
            this.geoCanvas.initCanvasTransform()
            this.geoCanvas.ctx.strokeStyle = this.selectionRectangleColor
            this.geoCanvas.ctx.lineWidth = rectWPix
            this.geoCanvas.ctx.beginPath()

            this.geoCanvas.ctx.rect(
                this.geoCanvas.geoToPixX(focus.cell.x) - rectWPix / 2,
                this.geoCanvas.geoToPixY(focus.cell.y) + rectWPix / 2,
                focus.resolution / this.geoCanvas.view.z + rectWPix,
                -focus.resolution / this.geoCanvas.view.z - rectWPix
            )
            this.geoCanvas.ctx.stroke()
        } else {
            this.tooltip.hide()
            if (this.canvasSave) this.geoCanvas.ctx.drawImage(this.canvasSave, 0, 0)
        }
    }


    /**
     * Return the cell HTML info at a given geo position.
     * This is usefull for user interactions, to show this info where the user clicks for example.
     *
     * @param {{x:number,y:number}} posGeo
     * @returns {{cell:import('./Dataset.js').Cell,html:string,resolution:number} | undefined}
     * @protected
     */
    getCellFocusInfo(posGeo) {
        //go through the layers, starting from top
        const z = this.geoCanvas.view.z
        for (let i = this.layers.length - 1; i >= 0; i--) {
            /** @type {import("./Layer.js").Layer} */
            const layer = this.layers[i]
            if (layer.visible && !layer.visible(z)) continue
            if (!layer.cellInfoHTML) continue
            //if (layer.cellInfoHTML === 'none') continue
            if (!layer.getDataset) continue
            const dsc = layer.getDataset(z)
            if (!dsc) continue

            //get cell at mouse position
            /** @type {import('./Dataset.js').Cell|undefined} */
            const cell = dsc.getCellFromPosition(posGeo, dsc.getViewCache())
            //console.log(cell, dsc.resolution)
            if (!cell) return undefined

            //rare case for a dataset with mixed resolutions
            if (dsc.mixedResolution) {
                const r = dsc.mixedResolution(cell)
                const html = layer.cellInfoHTML(cell, r)
                if (!html) return undefined
                return { cell: cell, html: html, resolution: r }
            }

            const html = layer.cellInfoHTML(cell, dsc.getResolution())
            if (!html) return undefined
            return { cell: cell, html: html, resolution: dsc.getResolution() }
        }
    }


    /** 
     * @param {number} x
     * @param {number} y
     * @param {number|undefined} z
     */
    setView(x, y, z = undefined) {
        this.geoCanvas.view.x = x
        this.geoCanvas.view.y = y
        if (z != undefined) this.geoCanvas.view.z = z
        return this
    }

    /** @returns {import('./GeoCanvas.js').View} */
    getView() { return this.geoCanvas.view }

    /** @returns {number} */
    getZoom() {
        return this.geoCanvas.view.z
    }
    /** @param {number} z @returns {this} */
    setZoom(z) {
        this.geoCanvas.view.z = z
        return this
    }


    /** @returns {Array.<number>} */
    getZoomExtent() {
        return this.geoCanvas.getZoomExtent()
    }
    /** @param {Array.<number>} val @returns {this} */
    setZoomExtent(val) {
        this.geoCanvas.setZoomExtent(val)
        return this
    }



    /** @returns {string} */
    getBackgroundColor() {
        return this.geoCanvas.backgroundColor
    }
    /** @param {string} val @returns {this} */
    setBackgroundColor(val) {
        this.geoCanvas.backgroundColor = val
        return this
    }

    /**
     * Adds a set of zoom buttons to the map
     *
     * @param {object} opts
     * @returns {this}
     */
    addZoomButtons(opts) {
        // * opts.id
        // * opts.onZoom - custom event handler function
        // * opts.x
        // * opts.y
        // * opts.delta - zoom delta applied on each click

        this.zoomButtons = new _button_ZoomButtons_js__WEBPACK_IMPORTED_MODULE_2__.ZoomButtons({
            map: this,
            id: opts?.id || 'gridviz-zoom-buttons',
            class: opts?.class,
            x: opts?.x,
            y: opts?.y,
            onZoom: opts?.onZoom,
            delta: opts?.delta || 0.2
        })

        return this
    }

    /**
     * Adds a fullscreen toggle button to the app
     *
     * @param {object} opts
     * @returns {this}
     */
    addFullscreenButton(opts) {
        // * opts.map - the gridviz map
        // * opts.id
        // * opts.x
        // * opts.y

        this.fullscreenButton = new _button_FullscreenButton_js__WEBPACK_IMPORTED_MODULE_3__.FullscreenButton({
            map: this,
            id: opts?.id || 'gridviz-fullscreen-button',
            class: opts?.class,
            x: opts?.x,
            y: opts?.y
        })

        return this
    }

    /** @returns {this} */
    setViewFromURL() {
        this.geoCanvas.setViewFromURL()
        return this
    }

    /**
     * @description Add a resize event observer to the Apps container and update the canvas accordingly
     * @param {HTMLDivElement} container The App's container element
     * @param {HTMLCanvasElement} canvas The App canvas element
     * @memberof App
     */
    defineResizeObserver(container, canvas) {
        // listen to resize events
        const resizeObserver = new ResizeObserver((entries) => {
            // make sure canvas has been built
            if (container.clientWidth > 0 && container.clientHeight > 0) {
                // make sure we dont exceed loop limit first
                // see: https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
                window.requestAnimationFrame(() => {
                    if (!Array.isArray(entries) || !entries.length) {
                        return
                    }
                    // update the map and canvas size
                    if (this.h !== container.clientHeight || this.w !== container.clientWidth) {
                        this.h = container.clientHeight
                        this.w = container.clientWidth
                        this.geoCanvas.h = container.clientHeight
                        this.geoCanvas.w = container.clientWidth
                        canvas.setAttribute('width', '' + this.w)
                        canvas.setAttribute('height', '' + this.h)
                        this.redraw()

                        //update button positions
                        // if (this.zoomButtons) this.zoomButtons.node.style.left = this.w - 50 + 'px'
                        // if (this.fullscreenButton) this.fullscreenButton.node.style.left = this.w - 50 + 'px'
                    }
                })
            }
        })

        resizeObserver.observe(container)
    }

    /**
     * @description Destroy the map and it's event listeners
     * This should significantly reduce the memory used when creating and destroying gridviz map instances (for example in leaflet-gridviz)
     * @memberof App
     */
    destroy() {
        // clear layers
        this.layers = []
        this.bgLayers = []

        // remove event listeners from container
        this.container.removeEventListener('mouseover', this.mouseOverHandler)
        this.container.removeEventListener('mousemove', this.mouseMoveHandler)
        this.container.removeEventListener('mouseout', this.mouseOutHandler)

        // remove canvas
        this.geoCanvas.canvas.remove()

        // remove legend
        this.legend?.remove()

        // remove tooltip
        this.tooltip.tooltip?.remove()
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/core/MultiResolutionDataset.js":
/*!*****************************************************************!*\
  !*** ./node_modules/gridviz/src/core/MultiResolutionDataset.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiResolutionDataset: () => (/* binding */ MultiResolutionDataset)
/* harmony export */ });
//@ts-check


/**
 * A multi resolution dataset of grid cells.
 * It consists of different {@link Dataset}s for each resolution.
 *
 * @abstract
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class MultiResolutionDataset {
    /**
     * @param {Array.<number>} resolutions The resolutions of the datasets, in CRS geographical unit.
     * @param {Array.<import("./Dataset").Dataset>|function(number):import("./Dataset").Dataset} datasets The datasets list, one per resolution. Or a function that returns a dataset from a resolution value.
     * @param { {preprocess?:function(import("./Dataset").Cell):boolean} } opts Options. preprocess: A function to apply on each dataset cell to prepare its values. Can be used also to select cells to keep.
     */
    constructor(resolutions, datasets, opts = {}) {
        opts = opts || {}

        /** The resolutions of the datasets, in CRS geographical unit.
         * @type {Array.<number>} */
        this.resolutions = resolutions

        /** The datasets. If the list is not explictely defined, build it from the resolution list with the function
         * @type {Array.<import("./Dataset").Dataset>} */
        this.datasets = (typeof datasets === 'function') ? this.resolutions.map(datasets) : datasets

        //there must be as many datasets as resolutions
        if (this.datasets.length > 1 && this.datasets.length != this.resolutions.length)
            throw new Error(
                'Uncompatible number of datasets and resolutions: ' +
                this.datasets.length +
                ' ' +
                this.resolutions.length
            )

        //set dataset preprocesses if specified
        if (opts.preprocess) this.setPrepocesses(opts.preprocess)
    }


    /**
     * Return the relevant dataset for a specified zoom.
     * @param {number} z
     * @param {number} minPixelsPerCell
     * @returns {import("./Dataset").Dataset|undefined}
     * */
    getDataset(z, minPixelsPerCell) {

        //special case whith single dataset
        if (this.datasets.length == 1) return this.datasets[0]

        const rs = this.resolutions
        let i = 0
        let z_ = rs[i] / minPixelsPerCell
        while (z_ < z && i < rs.length) {
            i++
            z_ = rs[i] / minPixelsPerCell
        }
        //if (i == 0) return this.dataset.datasets[0];
        //return this.dataset.datasets[i - 1];
        if (i == rs.length) return this.datasets[rs.length - 1]
        return this.datasets[i]
    }



    /**
     * Set a preprocess function for all datasets.
     * This is a function applied on each cell after it has been loaded.
     *
     * @param {function(import("./Dataset").Cell):boolean} preprocess
     * @returns {this}
     */
    setPrepocesses(preprocess) {
        for (let ds of this.datasets) ds.preprocess = preprocess
        return this
    }

    /**
     * A function to ease the creation of multi resolution datasets.
     *
     * @param {Array.<number>} resolutions The resolutions of the datasets, in CRS geographical unit
     * @param {function(number):import("./Dataset").Dataset} resToDataset Function returning a dataset from a resolution
     * @param { {preprocess?:function(import("./Dataset").Cell):boolean} } opts Options. preprocess: A function to apply on each dataset cell to prepare its values
     * @returns {MultiResolutionDataset}
     */
    /*static make(resolutions, resToDataset, opts) {
        //make datasets
        const dsc = []
        for (const res of resolutions) dsc.push(resToDataset(res))
        //make multi resolution dataset
        return new MultiResolutionDataset(dsc, resolutions, opts)
    }*/
}


/***/ }),

/***/ "./node_modules/gridviz/src/core/Style.js":
/*!************************************************!*\
  !*** ./node_modules/gridviz/src/core/Style.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Style: () => (/* binding */ Style)
/* harmony export */ });
/* harmony import */ var _Drawable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Drawable.js */ "./node_modules/gridviz/src/core/Drawable.js");
//@ts-check


;

/** @typedef {"square"|"circle"|"diamond"|"donut"|"triangle_up"|"triangle_down"|"triangle_left"|"triangle_right"|"none"} Shape */

/**
 * viewScale type
 * Returns an object from a list of cells, 
 * @typedef {function(Array.<import('./Dataset.js').Cell>,number, number):*} ViewScale */

/**
 * A style, to show a grid dataset.
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class Style extends _Drawable_js__WEBPACK_IMPORTED_MODULE_0__.Drawable {
    /**
     * @abstract
     * @param {{filter?:function(import('./Dataset').Cell):boolean, offset?:function(import('./Dataset').Cell, number, number):{dx:number,dy:number}, visible?:function(number):boolean,alpha?:function(number):number,blendOperation?:function(number):GlobalCompositeOperation,drawFun?:function,viewScale?:ViewScale}} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
        * @type {ViewScale|undefined} */
        this.viewScale = opts.viewScale

        /** A filter function to apply to the cell list, to filter out some cells not to be drawn (such as for example the cells with value=0).
        * @protected
        * @type {function(import('./Dataset').Cell):boolean} */
        this.filter = opts.filter || (() => true)

        /** An offset. This is to alter the position of all symbols in a given direction. In geographical unit.
         * @protected
         * @type {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} */
        this.offset = opts.offset || ((c, r, z) => ({ dx: 0, dy: 0 }))

        /** A draw function for the style.
         * @type {function|undefined} */
        this.drawFun = opts.drawFun

        /**
         * @public
         * @type {Array.<import("./Legend").Legend>} */
        this.legends = []
    }

    /**
     * Draw cells.
     *
     * @param {Array.<import('./Dataset').Cell>} cells The cells to draw.
     * @param {import("./GeoCanvas").GeoCanvas} geoCanvas The canvas where to draw them.
     * @param {number} resolution Their resolution (in geographic unit)
     * @abstract
     */
    draw(cells, geoCanvas, resolution) {
        if (this.drawFun) this.drawFun(cells, geoCanvas, resolution)
        else throw new Error('Method draw not implemented.')
    }

    //getters and setters

    /** @returns {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} */
    getOffset() {
        return this.offset
    }
    /** @param {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} val @returns {this} */
    setOffset(val) {
        this.offset = val
        return this
    }

    /** Update legends of the style, if any
     * @param {object} opts
     * @returns {this} */
    updateLegends(opts) {
        Style.updateLegendsRecursive(this.legends, opts)
        return this
    }

    /** @private */
    static updateLegendsRecursive(lg, opts) {
        if (Array.isArray(lg)) for (const lg_ of lg) this.updateLegendsRecursive(lg_, opts)
        else lg.update(opts)
    }

    /**
     * @param {Array.<import("./Legend").Legend>} legends
     * @returns {this} */
    addLegends(legends) {
        for (let legend of legends)
            this.legends.push(legend)
        return this
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/core/Tooltip.js":
/*!**************************************************!*\
  !*** ./node_modules/gridviz/src/core/Tooltip.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tooltip: () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


;
//import { transition } from "d3-transition";

/**
 * A generic class to make a tooltip.
 * It is a div element, which can be moved under the mouse pointer and filled with some information in html.
 * @module core
 */
class Tooltip {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** @type {string} */
        this.div = opts.div || 'tooltip_eurostat'
        /** @type {string} */
        this.maxWidth = opts.maxWidth || '20em'
        /** @type {string} */
        this.fontSize = opts.fontSize || '1.2em'
        /** @type {string} */
        this.background = opts.background || 'white'
        /** @type {string} */
        this.padding = opts.padding || '5px'
        /** @type {string} */
        this.border = opts.border || '0px'
        /** @type {string} */
        this['border-radius'] = opts['border-radius'] || '0px'
        /** @type {string} */
        this['box-shadow'] = opts['box-shadow'] || '5px 5px 5px grey'
        /** @type {string} */
        this['font-family'] = opts['font-family'] || 'Helvetica, Arial, sans-serif'

        /** @type {number} */
        this.transitionDuration = opts.transitionDuration || 100
        /** @type {number} */
        this.xOffset = opts.xOffset || 30
        /** @type {number} */
        this.yOffset = opts.yOffset || 20
        /** @type {number} */ // e.g. to prevent mouse cursor covering cell being highlighted
        this.yMouseOffset = opts.yMouseOffset || 0
        /** @type {number} */
        this.xMouseOffset = opts.xMouseOffset || 0
        /** @type {HTMLElement} */
        this.parentElement = opts.parentElement || document.body

        /**
         * @public
         * @type {import("d3-selection").Selection} */
        this.tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + this.div)

        if (this.tooltip.empty()) {
            //create tooltip DOM node
            // this.tooltip = select(
            //     '#' + this.parentElement.id && this.parentElement.id != ''
            //         ? '#' + this.parentElement.id
            //         : 'body'
            // )
            this.tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('body').append('div').attr('id', this.div)
        }

        //initialise
        this.tooltip.style('max-width', this.maxWidth)
        this.tooltip.style('overflow', 'hidden')
        this.tooltip.style('font-size', this.fontSize)
        this.tooltip.style('background', this.background)
        this.tooltip.style('padding', this.padding)
        this.tooltip.style('border', this.border)
        this.tooltip.style('border-radius', this['border-radius'])
        this.tooltip.style('box-shadow', this['box-shadow'])
        this.tooltip.style('font-family', this['font-family'])
        this.tooltip.style('position', 'absolute')
        this.tooltip.style('pointer-events', 'none')
        this.tooltip.style('opacity', '0')
        this.tooltip.style('text-wrap', 'nowrap')

        // aria-labels (thanks to wahlatlas)
        this.tooltip.attr('role', 'tooltip').attr('aria-live', 'polite')
    }

    /** Show the tooltip */
    show() {
        // @ts-ignore
        this.tooltip.transition().duration(this.transitionDuration).style('opacity', 1)
    }

    /** Hide the tooltip */
    hide() {
        // @ts-ignore
        this.tooltip.transition().duration(this.transitionDuration).style('opacity', 0)
    }

    /**
     * Set the content of the tooltip.
     * @param {string} html
     */
    html(html) {
        this.tooltip.html(html)
    }

    /**
     * Set the position of the tooltip at the mouse event position.
     * @param {MouseEvent} event
     */
    setPosition(event) {
        let parentRect = this.parentElement.getBoundingClientRect()

        let x = event.pageX + this.xOffset
        let y = event.pageY - this.yOffset

        this.tooltip.style('left', x + 'px').style('top', y + 'px')

        this.ensureTooltipInsideContainer(event, parentRect)
    }

    /*
	my.mouseover = function (event, html) {
		if (html) my.html(html);
		my.setPosition(event);
		my.show()
		//this.ensureTooltipInsideContainer();
	};
	
	my.mousemove = function (event) {
		my.setPosition(event);
		//this.ensureTooltipInsideContainer();
	};
	
	my.mouseout = function () {
		my.hide();
	};*/

    style(k, v) {
        if (arguments.length == 1) return this.tooltip.style(k)
        this.tooltip.style(k, v)
        return this
    }

    attr(k, v) {
        if (arguments.length == 1) return this.tooltip.attr(k)
        this.tooltip.attr(k, v)
        return this
    }

    /**
     * @function ensureTooltipInsideContainer
     * @description Prevents the tooltip from overflowing out of the App container (ensures that the tooltip is inside the gridviz container)
     * @param {MouseEvent} event
     * @param {DOMRect} parentRect
     */
    ensureTooltipInsideContainer = function (event, parentRect) {
        let node = this.tooltip.node()
        let parentWidth = parentRect.width
        let parentHeight = parentRect.height

        //too far right
        if (node.offsetLeft > parentRect.left + parentWidth - node.clientWidth) {
            let left = event.x - node.clientWidth - this.xOffset
            node.style.left = left + 'px'
            // check if mouse covers tooltip
            if (node.offsetLeft + node.clientWidth > event.x) {
                //move tooltip left so it doesnt cover mouse
                let left2 = event.x - node.clientWidth - this.xOffset
                node.style.left = left2 + 'px'
            }
            // node.style.top = node.offsetTop + config.yOffset + "px";
        }

        //too far down
        if (node.offsetTop + node.clientHeight > parentRect.top + parentHeight) {
            node.style.top = node.offsetTop - node.clientHeight + 'px'
        }

        //too far up
        if (node.offsetTop < parentRect.top) {
            node.style.top = parentRect.top + this.yOffset + 'px'
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/dataset/CSVGrid.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridviz/src/dataset/CSVGrid.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSVGrid: () => (/* binding */ CSVGrid)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
/* harmony import */ var _core_Dataset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Dataset.js */ "./node_modules/gridviz/src/core/Dataset.js");
//@ts-check


/** @typedef {{ dims: object, crs: string, tileSizeCell: number, originPoint: {x:number,y:number}, resolutionGeo: number, tilingBounds:import("../core/GeoCanvas.js").Envelope }} GridInfo */

;


/**
 * A dataset composed of a single CSV file (not tiled).
 *
 * @module dataset
 * @author Joseph Davies, Julien Gaffuri
 */
class CSVGrid extends _core_Dataset_js__WEBPACK_IMPORTED_MODULE_0__.Dataset {
    /**
     * @param {import("../core/Map.js").Map} map The map.
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {{preprocess?:(function(import("../core/Dataset.js").Cell):boolean)}} opts
     */
    constructor(map, url, resolution, opts = {}) {
        super(map, url, resolution, opts)

        /**
         * @private
         * @type {Array.<import("../core/Dataset.js").Cell>} */
        this.cells = []

        /**
         * @type {string}
         * @private  */
        this.infoLoadingStatus = 'notLoaded'

        //get data
        this.getData(undefined)
    }

    /**
     * Request data within a geographic envelope.
     * @param {import("../core/GeoCanvas.js").Envelope|undefined} e
     */
    getData(e) {
        //check if data already loaded
        if (this.infoLoadingStatus != 'notLoaded') return this

        //load data
        this.infoLoadingStatus = 'loading'
            ; (async () => {
                try {
                    const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_1__.csv)(this.url)

                    //convert coordinates in numbers
                    for (const c of data) {
                        c.x = +c.x
                        c.y = +c.y
                    }

                    //preprocess/filter
                    if (this.preprocess) {
                        this.cells = []
                        for (const c of data) {
                            const b = this.preprocess(c)
                            if (b == false) continue
                            this.cells.push(c)
                        }
                    } else {
                        this.cells = data
                    }

                    //TODO check if redraw is necessary
                    //that is if the dataset belongs to a layer which is visible at the current zoom level

                    //execute the callback, usually a draw function
                    if (this.map) this.map.redraw()

                    this.infoLoadingStatus = 'loaded'
                } catch (error) {
                    //mark as failed
                    this.infoLoadingStatus = 'failed'
                    this.cells = []
                }
            })()

        return this
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     *
     * @param {import("../core/GeoCanvas.js").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //data not loaded yet
        if (!this.cells) return

        this.cellsViewCache = []
        for (const cell of this.cells) {
            if (+cell.x + this.resolution < extGeo.xMin) continue
            if (+cell.x - this.resolution > extGeo.xMax) continue
            if (+cell.y + this.resolution < extGeo.yMin) continue
            if (+cell.y - this.resolution > extGeo.yMax) continue
            this.cellsViewCache.push(cell)
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/dataset/JSGrid.js":
/*!****************************************************!*\
  !*** ./node_modules/gridviz/src/dataset/JSGrid.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JSGrid: () => (/* binding */ JSGrid)
/* harmony export */ });
/* harmony import */ var _core_Dataset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Dataset.js */ "./node_modules/gridviz/src/core/Dataset.js");
//@ts-check


;

/**
 * A dataset composed of cells defined in javascript, or loaded outside of gridviz map.
 *
 * @module dataset
 * @author Joseph Davies, Julien Gaffuri
 */
class JSGrid extends _core_Dataset_js__WEBPACK_IMPORTED_MODULE_0__.Dataset {

    /**
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {Array.<Object>} cells The cells.
     * @param {} opts
     */
    constructor(resolution, cells, opts = {}) {
        super(undefined, "", resolution, opts)

        /**
         * @private
         * @type {Array.<import('../core/Dataset.js').Cell>} */
        this.cells = cells || []
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {import("../core/GeoCanvas.js").Envelope|undefined} e
     */
    getData(e) { return this }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     *
     * @param {import("../core/GeoCanvas.js").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //data not loaded yet
        if (!this.cells) return

        this.cellsViewCache = []
        for (const cell of this.cells) {
            if (+cell.x + this.resolution < extGeo.xMin) continue
            if (+cell.x - this.resolution > extGeo.xMax) continue
            if (+cell.y + this.resolution < extGeo.yMin) continue
            if (+cell.y - this.resolution > extGeo.yMax) continue
            this.cellsViewCache.push(cell)
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/dataset/TiledGrid.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/dataset/TiledGrid.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TiledGrid: () => (/* binding */ TiledGrid)
/* harmony export */ });
/* harmony import */ var _core_Dataset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Dataset.js */ "./node_modules/gridviz/src/core/Dataset.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
//@ts-check


/** @typedef {{ dims: object, crs: string, tileSizeCell: number, originPoint: {x:number,y:number}, resolutionGeo: number, tilingBounds:import("../core/GeoCanvas.js").Envelope }} GridInfo */

// internal
;
//import { monitor, monitorDuration } from '../utils/Utils.js'

// external


/**
 * A tiled dataset, composed of CSV tiles.
 *
 * @module dataset
 * @author Joseph Davies, Julien Gaffuri
 */
class TiledGrid extends _core_Dataset_js__WEBPACK_IMPORTED_MODULE_0__.Dataset {
    /**
     * @param {import("../core/Map.js").Map} map The map.
     * @param {string} url The URL of the dataset.
     * @param {{preprocess?:(function(import("../core/Dataset.js").Cell):boolean) }} opts
     */
    constructor(map, url, opts = {}) {
        super(map, url, 0, opts)

        /**
         * The grid info object, from the info.json file.
         *  @type {GridInfo | undefined}
         * @private
         *  */
        this.info = undefined

        /**
         * @type {string}
         * @private  */
        this.infoLoadingStatus = 'notLoaded'

        /**
         * The cache of the loaded tiles. It is double indexed: by xT and then yT.
         * Example: this.cache[xT][yT] returns the tile at [xT][yT] location.
         *
         * @type {object}
         * */
        this.cache = {}

        //launch loading
        this.loadInfo()
    }

    /**
     * Load the info.json from the url.
     * @returns this
     */
    loadInfo() {
        if (!this.info && this.infoLoadingStatus === 'notLoaded') {
            ; (async () => {
                try {
                    const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_1__["default"])(this.url + 'info.json')
                    this.info = data
                    this.resolution = data.resolutionGeo
                    this.infoLoadingStatus = 'loaded'
                    this.map.redraw()
                } catch (error) {
                    //mark as failed
                    this.infoLoadingStatus = 'failed'
                }
            })()
        } else if ((this.infoLoadingStatus === 'loaded' || this.infoLoadingStatus === 'failed'))
            this.map.redraw()
        return this
    }

    /**
     * Compute a tiling envelope from a geographical envelope.
     * This is the function to use to know which tiles to download for a geographical view.
     *
     * @param {import("../core/GeoCanvas.js").Envelope} e
     * @returns {import("../core/GeoCanvas.js").Envelope|undefined}
     */
    getTilingEnvelope(e) {
        if (!this.info) {
            this.loadInfo()
            return
        }

        const po = this.info.originPoint,
            r = this.info.resolutionGeo,
            s = this.info.tileSizeCell

        return {
            xMin: Math.floor((e.xMin - po.x) / (r * s)),
            xMax: Math.floor((e.xMax - po.x) / (r * s)),
            yMin: Math.floor((e.yMin - po.y) / (r * s)),
            yMax: Math.floor((e.yMax - po.y) / (r * s)),
        }
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {import('../core/GeoCanvas.js').Envelope} extGeo
     * @returns {this}
     */
    getData(extGeo) {
        //TODO empty cache when it gets too big ?

        //check if info has been loaded
        if (!this.info) return this

        //tiles within the scope
        /** @type {import("../core/GeoCanvas.js").Envelope|undefined} */
        const tb = this.getTilingEnvelope(extGeo)
        if (!tb) return this

        //grid bounds
        /** @type {import("../core/GeoCanvas.js").Envelope} */
        const gb = this.info.tilingBounds

        for (let xT = Math.max(tb.xMin, gb.xMin); xT <= Math.min(tb.xMax, gb.xMax); xT++) {
            for (let yT = Math.max(tb.yMin, gb.yMin); yT <= Math.min(tb.yMax, gb.yMax); yT++) {
                //prepare cache
                if (!this.cache[xT]) this.cache[xT] = {}

                //check if tile exists in the cache
                /** @type {object} */
                let tile = this.cache[xT][yT]
                if (tile) continue

                //mark tile as loading
                this.cache[xT][yT] = "loading";
                (async () => {
                    //request tile
                    /** @type {Array.<import("../core/Dataset.js").Cell>}  */
                    let cells

                    try {
                        /** @type {Array.<import("../core/Dataset.js").Cell>}  */
                        // @ts-ignore
                        const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_2__.csv)(this.url + xT + '/' + yT + '.csv')

                        //if (monitor) monitorDuration('*** TiledGrid parse start')

                        //preprocess/filter
                        if (this.preprocess) {
                            cells = []
                            for (const c of data) {
                                const b = this.preprocess(c)
                                if (b == false) continue
                                cells.push(c)
                            }
                        } else {
                            cells = data
                        }

                        //if (monitor) monitorDuration('preprocess / filter')
                    } catch (error) {
                        //mark as failed
                        this.cache[xT][yT] = 'failed'
                        return
                    }

                    //store tile in cache
                    if (!this.info) {
                        console.error('Tile info inknown')
                        return
                    }
                    const tile_ = getGridTile(cells, xT, yT, this.info)
                    this.cache[xT][yT] = tile_

                    //if (monitor) monitorDuration('storage')

                    //if no redraw is specified, then leave
                    this.map.redraw()

                    //check if redraw is really needed, that is if:

                    // 1. the dataset belongs to a layer which is visible at the current zoom level
                    let redraw = false
                    //go through the layers
                    const z = this.map.getZoom()
                    for (const lay of this.map.layers) {
                        if (lay.visible && !lay.visible(z)) continue
                        if (!lay.getDataset) continue
                        if (lay.getDataset(z) != this) continue
                        //found one layer. No need to seek more.
                        redraw = true
                        break
                    }
                    //if (monitor) monitorDuration('check redraw 1')

                    if (!redraw) return

                    // 2. the tile is within the view, that is its geo envelope intersects the viewer geo envelope.
                    const env = this.map.updateExtentGeo()
                    const envT = tile_.extGeo
                    if (env.xMax <= envT.xMin) return
                    if (env.xMin >= envT.xMax) return
                    if (env.yMax <= envT.yMin) return
                    if (env.yMin >= envT.yMax) return

                    //if (monitor) monitorDuration('check redraw 2')
                    //if (monitor) monitorDuration('*** TiledGrid parse end')

                    //redraw
                    this.map.redraw()
                })()
            }
        }
        return this
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     * @abstract
     * @param {import("../core/GeoCanvas.js").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //
        this.cellsViewCache = []

        //check if info has been loaded
        if (!this.info) return

        //tiles within the scope
        /** @type {import("../core/GeoCanvas.js").Envelope|undefined} */
        const tb = this.getTilingEnvelope(extGeo)
        if (!tb) return

        //grid bounds
        /** @type {import("../core/GeoCanvas.js").Envelope} */
        const gb = this.info.tilingBounds

        for (let xT = Math.max(tb.xMin, gb.xMin); xT <= Math.min(tb.xMax, gb.xMax); xT++) {
            if (!this.cache[xT]) continue
            for (let yT = Math.max(tb.yMin, gb.yMin); yT <= Math.min(tb.yMax, gb.yMax); yT++) {
                //get tile
                /** @type {object} */
                const tile = this.cache[xT][yT]
                if (!tile || typeof tile === 'string') continue

                //get cells
                //this.cellsViewCache = this.cellsViewCache.concat(tile.cells)

                for (const cell of tile.cells) {
                    if (+cell.x + this.resolution < extGeo.xMin) continue
                    if (+cell.x - this.resolution > extGeo.xMax) continue
                    if (+cell.y + this.resolution < extGeo.yMin) continue
                    if (+cell.y - this.resolution > extGeo.yMax) continue
                    this.cellsViewCache.push(cell)
                }
            }
        }
    }
}

function getGridTile(cells, xT, yT, gridInfo) {

    const tile = {}

    /** @type {Array.<import("../core/Dataset").Cell>} */
    tile.cells = cells
    /** @type {number} */
    tile.x = xT
    /** @type {number} */
    tile.y = yT

    const r = gridInfo.resolutionGeo
    const s = gridInfo.tileSizeCell

    /** @type {import("../core/GeoCanvas").Envelope} */
    tile.extGeo = {
        xMin: gridInfo.originPoint.x + r * s * tile.x,
        xMax: gridInfo.originPoint.x + r * s * (tile.x + 1),
        yMin: gridInfo.originPoint.y + r * s * tile.y,
        yMax: gridInfo.originPoint.y + r * s * (tile.y + 1),
    }

    //convert cell coordinates into geographical coordinates
    for (let cell of tile.cells) {
        cell.x = tile.extGeo.xMin + cell.x * r
        cell.y = tile.extGeo.yMin + cell.y * r
    }

    return tile
}


/***/ }),

/***/ "./node_modules/gridviz/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/gridviz/src/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundLayer: () => (/* reexport safe */ _layer_BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_28__.BackgroundLayer),
/* harmony export */   BackgroundLayerImage: () => (/* reexport safe */ _layer_BackgroundLayerImage_js__WEBPACK_IMPORTED_MODULE_30__.BackgroundLayerImage),
/* harmony export */   BackgroundLayerWMS: () => (/* reexport safe */ _layer_BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_29__.BackgroundLayerWMS),
/* harmony export */   CSVGrid: () => (/* reexport safe */ _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_6__.CSVGrid),
/* harmony export */   ColorCategoryLegend: () => (/* reexport safe */ _legend_ColorCategoryLegend_js__WEBPACK_IMPORTED_MODULE_35__.ColorCategoryLegend),
/* harmony export */   ColorDiscreteLegend: () => (/* reexport safe */ _legend_ColorDiscreteLegend_js__WEBPACK_IMPORTED_MODULE_34__.ColorDiscreteLegend),
/* harmony export */   ColorLegend: () => (/* reexport safe */ _legend_ColorLegend_js__WEBPACK_IMPORTED_MODULE_33__.ColorLegend),
/* harmony export */   CompositionStyle: () => (/* reexport safe */ _style_CompositionStyle_js__WEBPACK_IMPORTED_MODULE_11__.CompositionStyle),
/* harmony export */   DotDensityStyle: () => (/* reexport safe */ _style_DotDensityStyle_js__WEBPACK_IMPORTED_MODULE_17__.DotDensityStyle),
/* harmony export */   GeoCanvas: () => (/* reexport safe */ _core_GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__.GeoCanvas),
/* harmony export */   GeoJSONLayer: () => (/* reexport safe */ _layer_GeoJSONLayer_js__WEBPACK_IMPORTED_MODULE_32__.GeoJSONLayer),
/* harmony export */   GridLayer: () => (/* reexport safe */ _layer_GridLayer_js__WEBPACK_IMPORTED_MODULE_27__.GridLayer),
/* harmony export */   ImageStyle: () => (/* reexport safe */ _style_ImageStyle_js__WEBPACK_IMPORTED_MODULE_26__.ImageStyle),
/* harmony export */   IsoFenceStyle: () => (/* reexport safe */ _style_IsoFenceStyle_js__WEBPACK_IMPORTED_MODULE_25__.IsoFenceStyle),
/* harmony export */   JSGrid: () => (/* reexport safe */ _dataset_JSGrid_js__WEBPACK_IMPORTED_MODULE_7__.JSGrid),
/* harmony export */   JoyPlotStyle: () => (/* reexport safe */ _style_JoyPlotStyle_js__WEBPACK_IMPORTED_MODULE_10__.JoyPlotStyle),
/* harmony export */   LabelLayer: () => (/* reexport safe */ _layer_LabelLayer_js__WEBPACK_IMPORTED_MODULE_31__.LabelLayer),
/* harmony export */   Layer: () => (/* reexport safe */ _core_Layer_js__WEBPACK_IMPORTED_MODULE_3__.Layer),
/* harmony export */   LegoStyle: () => (/* reexport safe */ _style_LegoStyle_js__WEBPACK_IMPORTED_MODULE_19__.LegoStyle),
/* harmony export */   Map: () => (/* reexport safe */ _core_Map_js__WEBPACK_IMPORTED_MODULE_0__.Map),
/* harmony export */   MosaicStyle: () => (/* reexport safe */ _style_MosaicStyle_js__WEBPACK_IMPORTED_MODULE_22__.MosaicStyle),
/* harmony export */   MultiResolutionDataset: () => (/* reexport safe */ _core_MultiResolutionDataset_js__WEBPACK_IMPORTED_MODULE_4__.MultiResolutionDataset),
/* harmony export */   NinjaStarStyle: () => (/* reexport safe */ _style_NinjaStarStyle_js__WEBPACK_IMPORTED_MODULE_23__.NinjaStarStyle),
/* harmony export */   OrientationLegend: () => (/* reexport safe */ _legend_OrientationLegend_js__WEBPACK_IMPORTED_MODULE_37__.OrientationLegend),
/* harmony export */   PillarStyle: () => (/* reexport safe */ _style_PillarStyle_js__WEBPACK_IMPORTED_MODULE_14__.PillarStyle),
/* harmony export */   SegmentStyle: () => (/* reexport safe */ _style_SegmentStyle_js__WEBPACK_IMPORTED_MODULE_12__.SegmentStyle),
/* harmony export */   ShapeColorSizeStyle: () => (/* reexport safe */ _style_ShapeColorSizeStyle_js__WEBPACK_IMPORTED_MODULE_8__.ShapeColorSizeStyle),
/* harmony export */   SideCategoryStyle: () => (/* reexport safe */ _style_SideCategoryStyle_js__WEBPACK_IMPORTED_MODULE_16__.SideCategoryStyle),
/* harmony export */   SideStyle: () => (/* reexport safe */ _style_SideStyle_js__WEBPACK_IMPORTED_MODULE_15__.SideStyle),
/* harmony export */   SizeLegend: () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_36__.SizeLegend),
/* harmony export */   SquareColorCategoryWebGLStyle: () => (/* reexport safe */ _style_SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_21__.SquareColorCategoryWebGLStyle),
/* harmony export */   SquareColorWebGLStyle: () => (/* reexport safe */ _style_SquareColorWebGLStyle_js__WEBPACK_IMPORTED_MODULE_20__.SquareColorWebGLStyle),
/* harmony export */   StrokeStyle: () => (/* reexport safe */ _style_StrokeStyle_js__WEBPACK_IMPORTED_MODULE_9__.StrokeStyle),
/* harmony export */   Style: () => (/* reexport safe */ _core_Style_js__WEBPACK_IMPORTED_MODULE_2__.Style),
/* harmony export */   TanakaStyle: () => (/* reexport safe */ _style_TanakaStyle_js__WEBPACK_IMPORTED_MODULE_18__.TanakaStyle),
/* harmony export */   TextStyle: () => (/* reexport safe */ _style_TextStyle_js__WEBPACK_IMPORTED_MODULE_13__.TextStyle),
/* harmony export */   TiledGrid: () => (/* reexport safe */ _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_5__.TiledGrid),
/* harmony export */   TimeSeriesStyle: () => (/* reexport safe */ _style_TimeSeriesStyle_js__WEBPACK_IMPORTED_MODULE_24__.TimeSeriesStyle),
/* harmony export */   TrivariateLegend: () => (/* reexport safe */ _legend_TrivariateLegend_js__WEBPACK_IMPORTED_MODULE_38__.TrivariateLegend),
/* harmony export */   circularInverseScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.circularInverseScale),
/* harmony export */   circularScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.circularScale),
/* harmony export */   classifier: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_40__.classifier),
/* harmony export */   colorClassifier: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_40__.colorClassifier),
/* harmony export */   discreteColors: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_40__.discreteColors),
/* harmony export */   exponentialScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.exponentialScale),
/* harmony export */   getParameterByName: () => (/* binding */ getParameterByName),
/* harmony export */   loadChernoffFacesImages: () => (/* reexport safe */ _utils_chernoff_js__WEBPACK_IMPORTED_MODULE_42__.loadChernoffFacesImages),
/* harmony export */   loadImage: () => (/* reexport safe */ _utils_utils_js__WEBPACK_IMPORTED_MODULE_43__.loadImage),
/* harmony export */   logarithmicScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.logarithmicScale),
/* harmony export */   nice: () => (/* reexport safe */ _utils_utils_js__WEBPACK_IMPORTED_MODULE_43__.nice),
/* harmony export */   orientationLegend: () => (/* reexport safe */ _legend_OrientationLegend_js__WEBPACK_IMPORTED_MODULE_37__.orientationLegend),
/* harmony export */   powerInverseScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.powerInverseScale),
/* harmony export */   powerScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.powerScale),
/* harmony export */   sizeDiscreteLegend: () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_36__.sizeDiscreteLegend),
/* harmony export */   sizeDiscreteViewScaleLegend: () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_36__.sizeDiscreteViewScaleLegend),
/* harmony export */   sizeLegend: () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_36__.sizeLegend),
/* harmony export */   sizeLegendViewScale: () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_36__.sizeLegendViewScale),
/* harmony export */   trivariateClassifier: () => (/* reexport safe */ _utils_trivariate_js__WEBPACK_IMPORTED_MODULE_41__.trivariateClassifier),
/* harmony export */   trivariateColorClassifier: () => (/* reexport safe */ _utils_trivariate_js__WEBPACK_IMPORTED_MODULE_41__.trivariateColorClassifier),
/* harmony export */   viewScale: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_40__.viewScale),
/* harmony export */   viewScaleColor: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_40__.viewScaleColor),
/* harmony export */   viewScaleColorQuantile: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_40__.viewScaleColorQuantile),
/* harmony export */   viewScaleCombination: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_40__.viewScaleCombination),
/* harmony export */   viewScaleQuantile: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_40__.viewScaleQuantile)
/* harmony export */ });
/* harmony import */ var _core_Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Map.js */ "./node_modules/gridviz/src/core/Map.js");
/* harmony import */ var _core_GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/GeoCanvas.js */ "./node_modules/gridviz/src/core/GeoCanvas.js");
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/Layer.js */ "./node_modules/gridviz/src/core/Layer.js");
/* harmony import */ var _core_MultiResolutionDataset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/MultiResolutionDataset.js */ "./node_modules/gridviz/src/core/MultiResolutionDataset.js");
/* harmony import */ var _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dataset/TiledGrid.js */ "./node_modules/gridviz/src/dataset/TiledGrid.js");
/* harmony import */ var _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dataset/CSVGrid.js */ "./node_modules/gridviz/src/dataset/CSVGrid.js");
/* harmony import */ var _dataset_JSGrid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataset/JSGrid.js */ "./node_modules/gridviz/src/dataset/JSGrid.js");
/* harmony import */ var _style_ShapeColorSizeStyle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./style/ShapeColorSizeStyle.js */ "./node_modules/gridviz/src/style/ShapeColorSizeStyle.js");
/* harmony import */ var _style_StrokeStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./style/StrokeStyle.js */ "./node_modules/gridviz/src/style/StrokeStyle.js");
/* harmony import */ var _style_JoyPlotStyle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style/JoyPlotStyle.js */ "./node_modules/gridviz/src/style/JoyPlotStyle.js");
/* harmony import */ var _style_CompositionStyle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./style/CompositionStyle.js */ "./node_modules/gridviz/src/style/CompositionStyle.js");
/* harmony import */ var _style_SegmentStyle_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./style/SegmentStyle.js */ "./node_modules/gridviz/src/style/SegmentStyle.js");
/* harmony import */ var _style_TextStyle_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./style/TextStyle.js */ "./node_modules/gridviz/src/style/TextStyle.js");
/* harmony import */ var _style_PillarStyle_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./style/PillarStyle.js */ "./node_modules/gridviz/src/style/PillarStyle.js");
/* harmony import */ var _style_SideStyle_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./style/SideStyle.js */ "./node_modules/gridviz/src/style/SideStyle.js");
/* harmony import */ var _style_SideCategoryStyle_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./style/SideCategoryStyle.js */ "./node_modules/gridviz/src/style/SideCategoryStyle.js");
/* harmony import */ var _style_DotDensityStyle_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./style/DotDensityStyle.js */ "./node_modules/gridviz/src/style/DotDensityStyle.js");
/* harmony import */ var _style_TanakaStyle_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./style/TanakaStyle.js */ "./node_modules/gridviz/src/style/TanakaStyle.js");
/* harmony import */ var _style_LegoStyle_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style/LegoStyle.js */ "./node_modules/gridviz/src/style/LegoStyle.js");
/* harmony import */ var _style_SquareColorWebGLStyle_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./style/SquareColorWebGLStyle.js */ "./node_modules/gridviz/src/style/SquareColorWebGLStyle.js");
/* harmony import */ var _style_SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./style/SquareColorCategoryWebGLStyle.js */ "./node_modules/gridviz/src/style/SquareColorCategoryWebGLStyle.js");
/* harmony import */ var _style_MosaicStyle_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./style/MosaicStyle.js */ "./node_modules/gridviz/src/style/MosaicStyle.js");
/* harmony import */ var _style_NinjaStarStyle_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./style/NinjaStarStyle.js */ "./node_modules/gridviz/src/style/NinjaStarStyle.js");
/* harmony import */ var _style_TimeSeriesStyle_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./style/TimeSeriesStyle.js */ "./node_modules/gridviz/src/style/TimeSeriesStyle.js");
/* harmony import */ var _style_IsoFenceStyle_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./style/IsoFenceStyle.js */ "./node_modules/gridviz/src/style/IsoFenceStyle.js");
/* harmony import */ var _style_ImageStyle_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./style/ImageStyle.js */ "./node_modules/gridviz/src/style/ImageStyle.js");
/* harmony import */ var _layer_GridLayer_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./layer/GridLayer.js */ "./node_modules/gridviz/src/layer/GridLayer.js");
/* harmony import */ var _layer_BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./layer/BackgroundLayer.js */ "./node_modules/gridviz/src/layer/BackgroundLayer.js");
/* harmony import */ var _layer_BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./layer/BackgroundLayerWMS.js */ "./node_modules/gridviz/src/layer/BackgroundLayerWMS.js");
/* harmony import */ var _layer_BackgroundLayerImage_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./layer/BackgroundLayerImage.js */ "./node_modules/gridviz/src/layer/BackgroundLayerImage.js");
/* harmony import */ var _layer_LabelLayer_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./layer/LabelLayer.js */ "./node_modules/gridviz/src/layer/LabelLayer.js");
/* harmony import */ var _layer_GeoJSONLayer_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./layer/GeoJSONLayer.js */ "./node_modules/gridviz/src/layer/GeoJSONLayer.js");
/* harmony import */ var _legend_ColorLegend_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./legend/ColorLegend.js */ "./node_modules/gridviz/src/legend/ColorLegend.js");
/* harmony import */ var _legend_ColorDiscreteLegend_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./legend/ColorDiscreteLegend.js */ "./node_modules/gridviz/src/legend/ColorDiscreteLegend.js");
/* harmony import */ var _legend_ColorCategoryLegend_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./legend/ColorCategoryLegend.js */ "./node_modules/gridviz/src/legend/ColorCategoryLegend.js");
/* harmony import */ var _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./legend/SizeLegend.js */ "./node_modules/gridviz/src/legend/SizeLegend.js");
/* harmony import */ var _legend_OrientationLegend_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./legend/OrientationLegend.js */ "./node_modules/gridviz/src/legend/OrientationLegend.js");
/* harmony import */ var _legend_TrivariateLegend_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./legend/TrivariateLegend.js */ "./node_modules/gridviz/src/legend/TrivariateLegend.js");
/* harmony import */ var _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./utils/stretching.js */ "./node_modules/gridviz/src/utils/stretching.js");
/* harmony import */ var _utils_scale_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./utils/scale.js */ "./node_modules/gridviz/src/utils/scale.js");
/* harmony import */ var _utils_trivariate_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./utils/trivariate.js */ "./node_modules/gridviz/src/utils/trivariate.js");
/* harmony import */ var _utils_chernoff_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./utils/chernoff.js */ "./node_modules/gridviz/src/utils/chernoff.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./utils/utils.js */ "./node_modules/gridviz/src/utils/utils.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
//@ts-check


// the application






// export dataset types




// export styles








//export { ContourStyle } from './style/ContourStyle.js'












// export additional layers







// export legends







// export { goToStraight, zoomTo } from "./utils/zoomUtils"






;
const getParameterByName = _core_GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__.GeoCanvas.getParameterByName

// set default d3 locale
;
(0,d3_format__WEBPACK_IMPORTED_MODULE_44__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})


/***/ }),

/***/ "./node_modules/gridviz/src/layer/BackgroundLayer.js":
/*!***********************************************************!*\
  !*** ./node_modules/gridviz/src/layer/BackgroundLayer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundLayer: () => (/* binding */ BackgroundLayer)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./node_modules/gridviz/src/core/Layer.js");
//@ts-check


;

/**
 *
 * A map background layer in "Slippy map" XYZ standard.
 * See https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames
 * https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/#6/27.88/44.48
 * 
 * @module layer
 * @author Julien Gaffuri
 */
class BackgroundLayer extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The image cache, indexed by z/y/x */
        this.cache = {}

        /**
         * @type {string} */
        this.url = opts.url
        /** @type {function(number,number,number):string} */
        this.urlFun = opts.urlFun || ((x, y, z) => this.url + z + '/' + x + '/' + y + '.png')

        /** @type {Array.<number>} */
        this.resolutions = opts.resolutions
        if (!this.resolutions || this.resolutions.length == 0)
            throw new Error('No resolutions provided for background layer')

        /** @type {number} */
        this.nbPix = opts.nbPix || 256
        /** CRS coordinates of top left corner
         * @type {Array.<number>} */
        this.origin = opts.origin || [0, 0]
        /** @type {number} */
        this.z0 = opts.z0 || 0
    }

    /**
     * Get z/x/y cache data.
     * @param {number} z
     * @param {number} x
     * @param {number} y
     * @returns {HTMLImageElement|string|undefined}
     * @private
     */
    get(z, x, y) {
        let d = this.cache[z]
        if (!d) return
        d = d[x]
        if (!d) return
        return d[y]
    }

    /**
     * Get z/x/y cache data.
     * @param {HTMLImageElement|string} img
     * @param {number} z
     * @param {number} x
     * @param {number} y
     * @returns
     * @private
     */
    put(img, z, x, y) {
        if (!this.cache[z]) this.cache[z] = {}
        if (!this.cache[z][x]) this.cache[z][x] = {}
        this.cache[z][x][y] = img
    }

    /**
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     */
    draw(geoCanvas) {

        if (!this.resolutions || this.resolutions.length == 0) {
            console.error('No resolutions provided for background layer')
            return
        }

        //
        const z = geoCanvas.view.z
        const x0 = this.origin[0],
            y0 = this.origin[1]

        //get zoom level and resolution
        let z_ = 0
        for (z_ = 0; z_ < this.resolutions.length; z_++) if (this.resolutions[z_] < z) break
        z_ -= 1
        z_ = Math.max(0, z_)
        z_ = Math.min(z_, this.resolutions.length - 1)
        //console.log(this.resolutions.length, z)
        const res = this.resolutions[z_]

        z_ += this.z0

        const sizeG = this.nbPix * res
        const size = sizeG / z

        //get tile numbers
        const xGeoToTMS = (x) => Math.ceil((x - x0) / sizeG)
        const yGeoToTMS = (y) => Math.ceil(-(y - y0) / sizeG)
        const xMin = xGeoToTMS(geoCanvas.extGeo.xMin) - 1
        const xMax = xGeoToTMS(geoCanvas.extGeo.xMax)
        const yMax = yGeoToTMS(geoCanvas.extGeo.yMin)
        const yMin = yGeoToTMS(geoCanvas.extGeo.yMax) - 1

        //handle images
        for (let x = xMin; x < xMax; x++) {
            for (let y = yMin; y < yMax; y++) {
                //get image
                let img = this.get(z_, x, y)

                //load image
                if (!img) {
                    const img = new Image()
                    this.put(img, z_, x, y)
                    img.onload = () => {
                        geoCanvas.redraw()
                    }
                    img.onerror = () => {
                        //case when no image
                        this.put('failed', z_, x, y)
                    }
                    img.src = this.urlFun(x, y, z_)
                    continue
                }

                //case when no image
                if (img === 'failed') continue
                if (!(img instanceof HTMLImageElement)) {
                    console.log(img)
                    continue
                }
                if (img.width == 0 || img.height == 0) continue

                //draw image
                const xGeo = x0 + x * sizeG
                const yGeo = y0 - y * sizeG
                try {
                    geoCanvas.initCanvasTransform()
                    geoCanvas.ctx.drawImage(img, geoCanvas.geoToPixX(xGeo), geoCanvas.geoToPixY(yGeo), size, size)
                    //cg.ctx.drawImage(img, xGeo, yGeo, sizeG, -sizeG)
                } catch (error) {
                    console.error(error)
                }
            }
        }

    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/layer/BackgroundLayerImage.js":
/*!****************************************************************!*\
  !*** ./node_modules/gridviz/src/layer/BackgroundLayerImage.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundLayerImage: () => (/* binding */ BackgroundLayerImage)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./node_modules/gridviz/src/core/Layer.js");
//@ts-check


;

/**
 *
 * A map background layer composed of a single image file, geolocated.
 * 
 * @module layer
 * @author Julien Gaffuri
 */
class BackgroundLayerImage extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The image file URL
         * @type {string} */
        this.url = opts.url

        /** The image left coordinate
         * @type {number} */
        this.xMin = opts.xMin || 0;
        /** The image top coordinate
         *  @type {number} */
        this.yMax = opts.yMax || 0;

        /** The image width, in geo unit
         * @type {number} */
        this.width = opts.width || 20000
        /** The image height, in geo unit
         * @type {number} */
        this.height = opts.height || 20000

        /** The image object
         * @type {HTMLImageElement|undefined} */
        this.img = undefined;
    }

    /**
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     */
    draw(geoCanvas) {

        //update map extent
        //geoCanvas.updateExtentGeo(0)

        if (this.img) {
            //the image was already downloaded: draw it

            //compute screen coordinates and size ratio
            const x = geoCanvas.geoToPixX(this.xMin)
            const y = geoCanvas.geoToPixY(this.yMax)
            const z = geoCanvas.getView().z

            //draw image
            geoCanvas.initCanvasTransform()
            geoCanvas.ctx.drawImage(this.img, x, y, this.width / z, this.height / z)

        } else {
            //retrieve image

            if (!this.img) {
                this.img = new Image()
                this.img.onload = () => {
                    geoCanvas.redraw()
                }
                this.img.onerror = () => {
                    //case when no image
                    console.warn("Could not retrieve background image from", this.url)
                }
            }

            //set URL to launch the download
            this.img.src = this.url
        }

    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/layer/BackgroundLayerWMS.js":
/*!**************************************************************!*\
  !*** ./node_modules/gridviz/src/layer/BackgroundLayerWMS.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundLayerWMS: () => (/* binding */ BackgroundLayerWMS)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./node_modules/gridviz/src/core/Layer.js");
//@ts-check


;

/**
 *
 * A map WMS background layer.
 * 
 * @module layer
 * @author Julien Gaffuri
 */
class BackgroundLayerWMS extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * @type {string} */
        this.url = opts.url

        /** @type {HTMLImageElement|undefined} */
        this.img = undefined;

        /** @type {number|undefined} */
        this.xMin = undefined;
        /** @type {number|undefined} */
        this.xMax = undefined;
        /** @type {number|undefined} */
        this.yMin = undefined;
        /** @type {number|undefined} */
        this.yMax = undefined;
    }

    /** Check if the view has moved and a new image needs to be retrieved.
     * @private */
    hasMoved(extGeo) {
        if ((extGeo.xMin) != this.xMin) return true
        else if ((extGeo.xMax) != this.xMax) return true
        else if ((extGeo.yMin) != this.yMin) return true
        else if ((extGeo.yMax) != this.yMax) return true
        else return false
    }


    /**
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     */
    draw(geoCanvas) {

        //update map extent
        geoCanvas.updateExtentGeo(0)

        if (!this.hasMoved(geoCanvas.extGeo) && this.img) {
            //the map did not move and the image was already downloaded: draw the image
            geoCanvas.initCanvasTransform()
            geoCanvas.ctx.drawImage(this.img, 0, 0, geoCanvas.w, geoCanvas.h)

        } else {
            //the map moved: retrieve new image

            //
            this.xMin = geoCanvas.extGeo.xMin
            this.xMax = geoCanvas.extGeo.xMax
            this.yMin = geoCanvas.extGeo.yMin
            this.yMax = geoCanvas.extGeo.yMax

            //build WMS URL
            const url = []
            url.push(this.url)
            url.push("&width=")
            url.push(geoCanvas.w)
            url.push("&height=")
            url.push(geoCanvas.h)
            //bbox: xmin ymin xmax ymax
            url.push("&bbox=")
            url.push(geoCanvas.extGeo.xMin)
            url.push(",")
            url.push(geoCanvas.extGeo.yMin)
            url.push(",")
            url.push(geoCanvas.extGeo.xMax)
            url.push(",")
            url.push(geoCanvas.extGeo.yMax)

            const urlS = url.join("")
            //console.log(urlS)

            if (!this.img) {
                this.img = new Image()
                this.img.onload = () => {
                    geoCanvas.redraw()
                }
                this.img.onerror = () => {
                    //case when no image
                    console.warn("Could not retrieve WMS background image from", urlS)
                }
            }

            //set URL to launch the download
            this.img.src = urlS
        }

    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/layer/GeoJSONLayer.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/layer/GeoJSONLayer.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeoJSONLayer: () => (/* binding */ GeoJSONLayer)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./node_modules/gridviz/src/core/Layer.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
//@ts-check


;


/**
 * @module layer
 * @author Joseph Davies, Julien Gaffuri
 */
class GeoJSONLayer extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * @private
         * @type {string} */
        this.url = opts.url

        /**
         * A preprocess to run on each feature after loading.
         * It can be used to apply some specific treatment before, format the label data, project coordinates, etc.
         * Return false if the label should not be kept.
         * @private
         * @type {function(object):boolean} */
        this.preprocess = opts.preprocess

        /**
         * @private
         * @type {function(object,number):string} */
        this.color = opts.color || ((f, z) => 'gray')
        /**
         * @private
         * @type {function(object,number):number} */
        this.width = opts.width || ((f, z) => 2)
        /**
         * @private
         * @type {function(object,number):Array.<number>|undefined} */
        this.lineDash = opts.lineDash || ((f, z) => undefined)

        /**
         * @private
         * @type {Array.<object> | undefined} */
        this.fs = undefined

        /**
         * @private
         * @type {string} */
        this.loadingStatus = 'notLoaded'
    }

    /**
     * Draw the layer.
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     */
    draw(geoCanvas) {
        //load data, if not done yet.
        if (!this.fs) {
            this.load(geoCanvas.redraw)
            return
        }

        //TODO sort lines by width ?

        //
        const z = geoCanvas.view.z

        for (const f of this.fs) {
            const cs = f.geometry.coordinates
            if (cs.length < 2) continue

            //set color
            const col = this.color(f, z)
            if (!col || col == 'none') continue
            geoCanvas.ctx.strokeStyle = col

            //set linewidth
            const wP = this.width(f, z)
            if (!wP || wP < 0) continue
            geoCanvas.ctx.lineWidth = wP * z

            //set line dash
            const ldP = this.lineDash(f, z)
            if (ldP) geoCanvas.ctx.setLineDash(ldP)

            //draw line
            geoCanvas.ctx.beginPath()
            geoCanvas.ctx.moveTo(cs[0][0], cs[0][1])
            for (let i = 1; i < cs.length; i++) geoCanvas.ctx.lineTo(cs[i][0], cs[i][1])
            geoCanvas.ctx.stroke()
        }

        //...
        geoCanvas.ctx.setLineDash([])
    }

    /**
     * Load data for labels, from URL this.url
     * @param {function():void} callback
     * @private
     */
    async load(callback) {
        if (!this.url) {
            console.log('Failed loading boundaries: No URL specified. ' + this.url)
            this.loadingStatus = 'failed'
            this.labels = []
            return
        }

        //check if data already loaded
        if (this.loadingStatus != 'notLoaded') return

        //load data
        this.loadingStatus = 'loading'

        try {
            const data_ = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_1__["default"])(this.url)

            /** @type { Array.<object> } */
            const data = data_.features

            //preprocess/filter
            if (this.preprocess) {
                this.fs = []
                for (const c of data) {
                    const b = this.preprocess(c)
                    if (b == false) continue
                    this.fs.push(c)
                }
            } else {
                //store labels
                this.fs = data
            }

            this.loadingStatus = 'loaded'

            //redraw
            if (callback) callback()
        } catch (error) {
            console.log('Failed loading boundaries from ' + this.url)
            this.fs = []
            this.loadingStatus = 'failed'
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/layer/GridLayer.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridviz/src/layer/GridLayer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GridLayer: () => (/* binding */ GridLayer)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./node_modules/gridviz/src/core/Layer.js");
//@ts-check


;

/**
 * A layer, which specifies a dataset to be shown with specified styles.
 *
 * @module layer
 * @author Joseph Davies, Julien Gaffuri
 */
class GridLayer extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {import("../core/Dataset").Dataset|import("../core/MultiResolutionDataset").MultiResolutionDataset} dataset The dataset to show.
     * @param {Array.<import("../core/Style").Style>} styles The styles, ordered in drawing order.
     * @param {{visible?:function(number):boolean,alpha?:function(number):number,blendOperation?:function(number):GlobalCompositeOperation,minPixelsPerCell?:number,cellInfoHTML?:function(import("../core/Dataset").Cell):string}} opts
     */
    constructor(dataset, styles, opts = {}) {
        super(opts)
        opts = opts || {}

        /** @type {import("../core/Dataset").Dataset|import("../core/MultiResolutionDataset").MultiResolutionDataset} */
        this.dataset = dataset

        /** @type {Array.<import("../core/Style").Style>} */
        this.styles = styles

        /** 
         * This parameter is used when the dataset is a MultiResolutionDataset.
         * It defines the minimum number of pixels a grid cell should have to select the dataset to display based on its resolution.
         * A low value, means that the map will be more detailled (smaller cells).
         * A high value, means that the map will be less detailled (larger cells).
         * This value should be higher than 1, otherwise it means a grid cell is smaller than the screen resolution.
         * For more complex cell representations that require some more map space, this value should be higher.
         * @type {number} */
        this.minPixelsPerCell = opts.minPixelsPerCell || 3

        /**
         * The function returning cell information as HTML.
         * This is typically used for tooltip information.
         * @type {function(import("../core/Dataset").Cell, number):string} */
        this.cellInfoHTML = opts.cellInfoHTML || GridLayer.defaultCellInfoHTML
    }

    /** */
    draw(geoCanvas, legend) {

        //get zoom level
        const z = geoCanvas.view.z

        //get layer dataset component
        /** @type {import('../core/Dataset.js').Dataset|undefined} */
        const dsc = this.getDataset(z)
        if (!dsc) return

        //launch data download, if necessary
        dsc.getData(geoCanvas.extGeo)

        //update dataset view cache
        dsc.updateViewCache(geoCanvas.extGeo)

        //draw cells, style by style
        for (const s of this.styles) {

            //check if style is visible
            if (s.visible && !s.visible(z)) continue

            //set style alpha and blend mode
            //TODO: multiply by layer alpha ?
            geoCanvas.ctx.globalAlpha = s.alpha ? s.alpha(z) : 1.0
            if (s.blendOperation)
                geoCanvas.ctx.globalCompositeOperation = s.blendOperation(z)

            //set affin transform to draw with geographical coordinates
            geoCanvas.setCanvasTransform()

            //draw with style
            s.draw(dsc.getViewCache(), geoCanvas, dsc.getResolution())

            //draw style filter
            if (s.filterColor)
                s.drawFilter(geoCanvas)
        }

        //add legend element
        if (legend) {
            for (const s of this.styles) {
                //check if style is visible
                if (s.visible && !s.visible(z)) continue
                GridLayer.addLegends(legend, s.legends)

                //case for styles of styles, like kernel smoothing
                //TODO do better
                if (s['styles']) {
                    for (const s2 of s['styles']) {
                        if (s2.visible && !s2.visible(z)) continue
                        GridLayer.addLegends(legend, s2.legends)
                    }
                }
            }
        }

    }

    /** @private */
    static addLegends(legendComp, lg) {
        if (Array.isArray(lg)) for (const lg_ of lg) this.addLegends(legendComp, lg_)
        else legendComp.node().append(lg.div.node())
    }


    /**
     * Return the relevant dataset component for a specified zoom.
     *
     * @param {number} z
     * @returns {import("../core/Dataset").Dataset|undefined}
     * */
    getDataset(z) {
        return this.dataset.getDataset(z, this.minPixelsPerCell);
    }



    /**
     * Set/get style stack.
     * 
     * @param {undefined|import("../core/Style").Style|Array.<import("../core/Style").Style>} styles 
     * @returns { this | Array.<import("../core/Style").Style> }
     */
    styles_(styles) {
        if (arguments.length === 0) return this.styles
        if (arguments.length === 1)
            if (Array.isArray(styles)) this.styles = styles
            else this.styles = [styles]
        else this.styles = arguments
        return this
    }



    /**
     * The default function returning cell information as HTML.
     * This is typically used for tooltip information.
     *
     * @param {import("../core/Dataset").Cell} cell
     * @returns {string}
     */
    static defaultCellInfoHTML(cell) {
        const buf = []
        for (const key of Object.keys(cell)) {
            if (key === 'x') continue
            if (key === 'y') continue
            buf.push('<b>', key, '</b>', ' : ', cell[key], '<br>')
        }
        return buf.join('')
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/layer/LabelLayer.js":
/*!******************************************************!*\
  !*** ./node_modules/gridviz/src/layer/LabelLayer.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LabelLayer: () => (/* binding */ LabelLayer)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./node_modules/gridviz/src/core/Layer.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
//@ts-check


;


/** A label. The name is the text to show. (x,y) are the coordinates in the same CRS as the grid.
 * @typedef {{name: string, x:number, y:number }} Label */

/**
 * A (generic) layer for placename labels, to be shown on top of the grid layers.
 * The input is a CSV file with the position (x, y) of the labels and name + some other info on the label importance.
 * If the label data is not in the expected format or in the same CRS as the grid, it can be corrected with the "preprocess" function.
 * The selection of the label, their style (font, weight, etc.) and color can be specified depending on their importance and the zoom level.
 *
 * @module layer
 * @author Joseph Davies, Julien Gaffuri
 */
class LabelLayer extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The URL of the label data, as CSV file.
         * The file should contain the information for each label such as the text, the position and other information for the display of the label according to the zoom level.
         * If necessary, this data can be reformated with the 'preprocess' parameter.
         * @private
         * @type {string} */
        this.url = opts.url

        /** Specify if and how a label should be drawn, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.style = opts.style || (() => 'bold 1em Arial')

        /** Specify the label color, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.color = opts.color || (opts.dark ? () => '#ddd' : () => '#222')

        /** Specify the label halo color, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.haloColor = opts.haloColor || (opts.dark ? () => '#000000BB' : () => '#FFFFFFBB')

        /** Specify the label halo width, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):number} */
        this.haloWidth = opts.haloWidth || (() => 4)

        /** The anchor where to draw the text, from label position. See HTML-canvas textAlign property.
         * "left" || "right" || "center" || "start" || "end"
         * @private
         * @type {CanvasTextAlign} */
        this.textAlign = opts.textAlign || 'start'

        /**
         * @private
         * @type {Array.<number>} */
        this.offsetPix = opts.offsetPix || [5, 5]

        /**
         * A preprocess to run on each label after loading.
         * It can be used to apply some specific treatment before, format the label data, project coordinates, etc.
         * Return false if the label should not be kept.
         * @private
         * @type {function(Label):boolean} */
        this.preprocess = opts.preprocess

        /**
         * @private
         * @type {Array.<Label> | undefined} */
        this.labels = undefined

        /**
         * @private
         * @type {string} */
        this.loadingStatus = 'notLoaded'
    }

    /**
     * Draw the label layer.
     *
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     */
    draw(geoCanvas) {
        //load labels, if not done yet.
        if (!this.labels) {
            this.load(geoCanvas.redraw)
            return
        }

        //
        const z = geoCanvas.view.z

        //text align
        geoCanvas.ctx.textAlign = this.textAlign || 'start'

        //line join and cap
        geoCanvas.ctx.lineJoin = 'bevel' //|| "round" || "miter";
        geoCanvas.ctx.lineCap = 'butt' //|| "round" || "square";

        //draw in pix coordinates
        geoCanvas.initCanvasTransform()

        //draw labels, one by one
        for (const lb of this.labels) {
            //get label style
            const st = this.style(lb, z)
            if (!st) continue
            geoCanvas.ctx.font = st

            //check label within the view, to be drawn
            if (!geoCanvas.toDraw(lb)) continue

            //position
            const xP = geoCanvas.geoToPixX(lb.x) + this.offsetPix[0]
            const yP = geoCanvas.geoToPixY(lb.y) - this.offsetPix[1]

            //label stroke, for the halo
            if (this.haloColor && this.haloWidth) {
                const hc = this.haloColor(lb, z)
                const hw = this.haloWidth(lb, z)
                if (hc && hw && hw > 0) {
                    geoCanvas.ctx.strokeStyle = hc
                    geoCanvas.ctx.lineWidth = hw
                    geoCanvas.ctx.strokeText(lb.name, xP, yP)
                }
            }

            //label fill
            if (this.color) {
                const col = this.color(lb, z)
                if (col) {
                    geoCanvas.ctx.fillStyle = col
                    geoCanvas.ctx.fillText(lb.name, xP, yP)
                }
            }
        }
    }

    /**
     * Load data for labels, from URL this.url
     * @param {function():void} callback
     * @private
     */
    async load(callback) {
        if (!this.url) {
            console.log('Failed loading labels: No URL specified. ' + this.url)
            this.loadingStatus = 'failed'
            this.labels = []
            return
        }

        //check if data already loaded
        if (this.loadingStatus != 'notLoaded') return

        //load data
        this.loadingStatus = 'loading'

        try {
            /** @type { Array.<Label> } */
            const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_1__.csv)(this.url)

            //preprocess/filter
            if (this.preprocess) {
                this.labels = []
                for (const c of data) {
                    const b = this.preprocess(c)
                    if (b == false) continue
                    this.labels.push(c)
                }
            } else {
                //store labels
                this.labels = data
            }

            this.loadingStatus = 'loaded'

            //redraw
            if (callback) callback()
        } catch (error) {
            console.log('Failed loading labels from ' + this.url)
            this.labels = []
            this.loadingStatus = 'failed'
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/legend/ColorCategoryLegend.js":
/*!****************************************************************!*\
  !*** ./node_modules/gridviz/src/legend/ColorCategoryLegend.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorCategoryLegend: () => (/* binding */ ColorCategoryLegend)
/* harmony export */ });
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Legend.js */ "./node_modules/gridviz/src/core/Legend.js");
//@ts-check


;

/**
 * A legend element for color categrories.
 *
 * @module legend
 * @author Joseph Davies, Julien Gaffuri
 */
class ColorCategoryLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //col/categories array, in display order
        /**
         * @private
         * @type {Array.<[string,string]>} */
        this.colorLabel = opts.colorLabel || [['gray', '-']]

        /**
         * @private
         * @type {import("../core/Style.js").Shape} */
        this.shape = opts.shape || 'circle'
        this.dimension = opts.dimension || { r: 8 }
        this.strokeColor = opts.strokeColor || 'gray'
        this.strokeWidth = opts.strokeWidth || 1
    }

    /**
     */
    update() {

        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        //categories
        const nb = this.colorLabel.length
        if (nb == 0) return

        for (let i = 0; i < nb; i++) {
            const cat = this.colorLabel[i]

            //make div for category
            const d = this.div.append('div')
            //to enable vertical centering
            //.style("position", "relative")

            const sw = this.strokeWidth

            //draw graphic element: box / circle
            if (this.shape === 'square') {
                const h = this.dimension.h || 15
                const w = this.dimension.w || 20
                d.append('div')
                    .style('display', 'inline')

                    .append('svg')
                    .attr('width', w + 2 * sw)
                    .attr('height', h + 2 * sw)

                    .append('rect')
                    .attr('x', sw)
                    .attr('y', sw)
                    .attr('width', w)
                    .attr('height', h)
                    .style('fill', cat[0])
                    .style('stroke', this.strokeColor)
                    .style('stroke-width', this.strokeWidth)
            } else if (this.shape === 'circle') {
                const r = this.dimension.r || 8
                const h = 2 * r + 2 * sw
                d.append('div')
                    .style('display', 'inline')

                    .append('svg')
                    .attr('width', h)
                    .attr('height', h)

                    .append('circle')
                    .attr('cx', r + sw)
                    .attr('cy', r + sw)
                    .attr('r', r)
                    .style('fill', cat[0])
                    .style('stroke', this.strokeColor)
                    .style('stroke-width', this.strokeWidth)
            } else {
                throw new Error('Unexpected shape:' + this.shape)
            }

            //write label text
            d.append('div')
                //show on right of graphic
                .style('display', 'inline')

                //center vertically
                //.style("position", "absolute").style("top", "0").style("bottom", "0")

                .style('padding-left', '5px')
                .style('font-size', this.labelFontSize)
                .text(cat[1])
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/legend/ColorDiscreteLegend.js":
/*!****************************************************************!*\
  !*** ./node_modules/gridviz/src/legend/ColorDiscreteLegend.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorDiscreteLegend: () => (/* binding */ ColorDiscreteLegend)
/* harmony export */ });
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Legend.js */ "./node_modules/gridviz/src/core/Legend.js");
//@ts-check


;

/**
 * A legend element for discrete color style.
 * Inspiration: https://observablehq.com/@d3/color-legend
 *
 * @module legend
 * @author Julien Gaffuri
 */
class ColorDiscreteLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** @private @type {function(import('../core/Style').ViewScale):Array.<string>} */
        this.colors = opts.colors
        /** @private @type {function(import('../core/Style').ViewScale):Array.<number>} */
        this.breaks = opts.breaks

        this.width = opts.width || 300
        this.height = opts.height || 15

        this.tickSize = opts.tickSize || 3

        //label
        this.invert = opts.invert
    }

    /**
     * @param {{viewScale:import('../core/Style').ViewScale} } opts
     */
    update(opts) {

        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        //get colors and breaks
        const colors = this.colors(opts.viewScale)
        const breaks = this.breaks(opts.viewScale)
        if (!breaks) return

        //classes
        const nb = colors.length
        if (nb == 0) return
        const w = this.width / nb

        //make svg element
        const svg = this.div
            .append('svg')
            .attr('width', this.width)
            .attr('height', this.height + this.tickSize + 2 + 10)

        //draw graphic elements
        for (let i = 0; i < nb; i++) {
            svg.append('rect')
                .attr('x', i * w)
                .attr('y', 0)
                .attr('width', w)
                .attr('height', this.height)
                .style('fill', colors[i])
        }

        //tick line
        for (let i = 1; i < nb; i++) {
            svg.append('line')
                .attr('x1', w * i)
                .attr('y1', 0)
                .attr('x2', w * i)
                .attr('y2', this.height + this.tickSize)
                .style('stroke', 'black')
        }

        //labels
        for (let i = 1; i < nb; i++) {

            let label = breaks[i - 1]
            if (isNaN(label) || label == undefined) continue

            //label
            svg.append('text')
                .attr('id', 'ticklabel_' + i)
                .attr('x', w * i)
                .attr('y', this.height + this.tickSize + 2)
                .style('font-size', this.labelFontSize)
                //.style("font-weight", "bold")
                //.style("font-family", "Arial")
                .style('text-anchor', 'middle')
                .style('alignment-baseline', 'top')
                .style('dominant-baseline', 'hanging')
                .style('pointer-events', 'none')
                .text(label)
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/legend/ColorLegend.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/legend/ColorLegend.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorLegend: () => (/* binding */ ColorLegend)
/* harmony export */ });
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Legend.js */ "./node_modules/gridviz/src/core/Legend.js");
//@ts-check


;

/**
 * A legend element for continuous color style.
 * Inspiration: https://observablehq.com/@d3/color-legend
 *
 * @module legend
 * @author Joseph Davies, Julien Gaffuri
 */
class ColorLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //a function [0,1]->color for continuous colors
        //or array of colors for discrete colors
        this.colorScale = opts.colorScale

        //function (t[0,1]) -> value (for label text)
        this.textScale = opts.textScale || (t => t)

        this.margin = opts.margin || 5

        //replace with labels ?
        this.tickSize = opts.tickSize || 6
        this.ticks = opts.ticks || Math.floor(this.width / 50)
        this.tickFormat = opts.tickFormat
        this.tickUnit = opts.tickUnit

        this.fontSize = opts.fontSize || '0.8em'
        this.invert = opts.invert

        this.width = opts.width || 300
        this.height = opts.height || 15
    }

    /**
     * @param {{viewScale:import('../core/Style').ViewScale} } opts
     */
    update(opts) {

        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        const svgW = this.width + 2 * this.margin
        const svgH = this.height + this.margin + this.tickSize + 10
        const svg = this.div.append('svg').attr('width', svgW).attr('height', svgH)
        //  <rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />

        const g = svg
            .append('g')
            .attr('transform', 'translate(' + this.margin + ' ' + 0 + ')')

        //draw color bar
        const w = this.width,
            h = this.height
        const step = 5
        for (let i = 0; i < w; i += step) {
            let t = i / (w - 1)
            if (this.invert) t = 1 - t
            g.append('rect')
                .attr('x', i)
                .attr('y', 0)
                .attr('width', step)
                .attr('height', h)
                .style('fill', this.colorScale(t, opts.viewScale))
        }

        for (let i = 0; i < this.ticks; i++) {
            let t = i / (this.ticks - 1)

            //tick line
            g.append('line')
                .attr('x1', w * t)
                .attr('y1', 0)
                .attr('x2', w * t)
                .attr('y2', h + this.tickSize)
                .style('stroke', 'black')

            //prepare tick label
            g.append('text')
                .attr('id', 'ticklabel_' + i)
                .attr('x', w * t)
                .attr('y', h + this.tickSize + 2)
                .style('font-size', this.fontSize)
                //.style("font-weight", "bold")
                //.style("font-family", "Arial")
                .style('text-anchor', i == 0 ? 'start' : i == this.ticks - 1 ? 'end' : 'middle')
                .style('alignment-baseline', 'top')
                .style('dominant-baseline', 'hanging')
                .style('pointer-events', 'none')
            //.text("-")
        }

        //update tick labels

        //label text format
        const f = this.tickFormat && this.tickFormat != 'text' ? this.tickFormat : (v) => v
        for (let i = 0; i < this.ticks; i++) {
            let t = i / (this.ticks - 1)

            const v = this.textScale(t, opts.viewScale)
            const text = (v ? f(v) : '0') + (this.tickUnit ? this.tickUnit : '')
            if (text == undefined) continue

            //tick label
            this.div.select('#' + 'ticklabel_' + i).text(text)
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/legend/OrientationLegend.js":
/*!**************************************************************!*\
  !*** ./node_modules/gridviz/src/legend/OrientationLegend.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrientationLegend: () => (/* binding */ OrientationLegend),
/* harmony export */   orientationLegend: () => (/* binding */ orientationLegend)
/* harmony export */ });
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Legend.js */ "./node_modules/gridviz/src/core/Legend.js");
//@ts-check


;

/**
 * A legend element for segment orientation.
 *
 * @module legend
 * @author Joseph Davies, Julien Gaffuri
 */
class OrientationLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //orientation
        this.orientation = opts.orientation || 0
        //color
        this.color = opts.color || ((resolution, z, viewScale) => 'gray')
        //width
        this.width = opts.width || ((resolution, z, viewScale) => 3 * z)
        //length
        this.length = opts.length || ((resolution, z, viewScale) => resolution)

        //label
        this.label = opts.label || "-"
    }

    /**
     * @param {{ style: import("../style/SegmentStyle.js").SegmentStyle, resolution: number, z: number, viewScale:object }} opts
     */
    update(opts) {

        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        const d = this.div.append('div')

        //compute segment color, width and length
        const color = this.color(opts.resolution, opts.z, opts.viewScale)
        const widthPix = this.width(opts.resolution, opts.z, opts.viewScale) / opts.z
        const lengthPix = this.length(opts.resolution, opts.z, opts.viewScale) / opts.z

        //draw SVG segment
        const svgS = Math.max(lengthPix, widthPix)
        const svg = d.append('svg').attr('width', svgS).attr('height', svgS).style('', 'inline-block')

        const cos = Math.cos((-this.orientation * Math.PI) / 180)
        const sin = Math.sin((-this.orientation * Math.PI) / 180)
        const dc = svgS * 0.5,
            l2 = lengthPix * 0.5
        svg.append('line')
            .attr('x1', dc - cos * l2)
            .attr('y1', dc - sin * l2)
            .attr('x2', dc + cos * l2)
            .attr('y2', dc + sin * l2)
            .style('stroke', color)
            .style('stroke-width', widthPix)


        //label
        d.append('div')
            .style('display', 'inline')
            .style('padding-left', '5px')
            .style('font-size', this.labelFontSize)
            .text(this.label + (this.labelUnitText ? ' ' : '') + this.labelUnitText)
    }
}

/**
 * 
 * @param {Array.<number>} orientations 
 * @param {Array.<string>} labels 
 * @param {object} opts 
 * @returns  { Array.<OrientationLegend> }
 */
function orientationLegend(orientations, labels, opts = {}) {
    const legends = []
    for (let i = 0; i < orientations.length; i++) {
        opts.title = i == 0 ? opts.title : undefined;
        opts.orientation = orientations[i]
        opts.label = labels[i]
        legends.push(new OrientationLegend(opts))
    }
    return legends
}


/***/ }),

/***/ "./node_modules/gridviz/src/legend/SizeLegend.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/legend/SizeLegend.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SizeLegend: () => (/* binding */ SizeLegend),
/* harmony export */   sizeDiscreteLegend: () => (/* binding */ sizeDiscreteLegend),
/* harmony export */   sizeDiscreteViewScaleLegend: () => (/* binding */ sizeDiscreteViewScaleLegend),
/* harmony export */   sizeLegend: () => (/* binding */ sizeLegend),
/* harmony export */   sizeLegendViewScale: () => (/* binding */ sizeLegendViewScale)
/* harmony export */ });
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Legend.js */ "./node_modules/gridviz/src/core/Legend.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils.js */ "./node_modules/gridviz/src/utils/utils.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
//@ts-check


;



/**
 * A legend element for proportional symbols.
 *
 * @module legend
 * @author Joseph Davies, Julien Gaffuri
 */
class SizeLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the text label, from the view scale and list of cells, resolution and zoom
         *  @type { function(object, Array.<import('../core/Dataset.js').Cell>, number, number):(number|string) } */
        this.label = opts.label || undefined

        /** A function returning the size of the legend symbol, in geo UoM, from the viewscale, resolution and zoom
         *  @type { function(object, number, number):number } */
        this.size = opts.size || undefined

        //symbol
        /**  @type {(import("../core/Style").Shape)|"line"} */
        this.shape = opts.shape || 'circle'

        //general case
        this.fillColor = opts.fillColor || 'none'
        this.strokeColor = opts.strokeColor || 'gray'
        this.strokeWidth = opts.strokeWidth || 1

        //for line shape
        //TODO this.orientation = opts.orientation || 0
        this.color = opts.color || 'gray'
        this.length = opts.length || ((resolution, z, viewScale) => resolution)
    }

    /**
     * @param {{ viewScale:object, resolution: number, z:number, cells:Array.<import('../core/Dataset.js').Cell> }} opts
     */
    update(opts) {

        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        //get label. May not be a number (!)
        let label = this.label(opts.viewScale, opts.cells, opts.resolution, opts.z)

        //compute size of symbol, in pix
        let sizePix
        if (this.size)
            sizePix = this.size(opts.viewScale, opts.resolution, opts.z) / opts.z
        else
            sizePix = opts.viewScale(+label) / opts.z
        if (!sizePix) return

        //format label, if specified and possible
        if (this.labelFormat && !isNaN(+label)) label = this.labelFormat(label)

        const d = this.div.append('div')
        //to enable vertical centering
        //.style("position", "relative")

        //default svg construction, for square and circle
        const svg = () => d
            .append('svg')
            .attr('width', sizePix + this.strokeWidth + 2)
            .attr('height', sizePix + this.strokeWidth + 2)
            .style('', 'inline-block')

        if (this.shape === 'square') {
            svg().append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', sizePix)
                .attr('height', sizePix)
                .style('fill', this.fillColor)
                .style('stroke', this.strokeColor)
                .style('stroke-width', this.strokeWidth)
        } else if (this.shape === 'circle') {
            // <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
            const r = (sizePix + this.strokeWidth) * 0.5
            svg().append('circle')
                .attr('cx', r + 1)
                .attr('cy', r + 1)
                .attr('r', r)
                .style('fill', this.fillColor)
                .style('stroke', this.strokeColor)
                .style('stroke-width', this.strokeWidth)
        } else if (this.shape === 'donut') {
            //TODO
        } else if (this.shape === 'diamond') {
            //TODO
        } else if (this.shape === 'line') {

            //get segment length
            let lengthPix = this.length ? this.length(opts.resolution, opts.z, opts.viewScale) : opts.resolution
            lengthPix /= opts.z

            const svg = d.append('svg').attr('width', lengthPix).attr('height', sizePix).style('', 'inline-block')

            //TODO orientation
            //<line x1="0" y1="0" x2="200" y2="200" style="stroke:rgb(255,0,0);stroke-width:2" />
            svg.append('line')
                .attr('x1', 0)
                .attr('y1', sizePix / 2)
                .attr('x2', lengthPix)
                .attr('y2', sizePix / 2)
                .style('stroke', this.color)
                .style('stroke-width', sizePix)
        } else {
            throw new Error('Unexpected shape:' + this.shape)
        }

        //label
        d.append('div')
            .style('display', 'inline')
            .style('padding-left', '5px')
            .style('font-size', this.labelFontSize)
            .text(label + (this.labelUnitText ? ' ' : '') + this.labelUnitText)
    }
}







/**
 * @param {Array.<number>} values 
 * @param {function(number):number} size 
 * @param { object } opts 
 * @returns {Array.<SizeLegend>}
 */
function sizeLegend(values, size, opts = {}) {
    const legends = []
    for (let value of values) {
        opts.title = value == values[0] ? opts.title : undefined;
        opts.size = () => size(value)
        opts.label = () => value
        legends.push(new SizeLegend(opts))
    }
    return legends
}

/**
 * @param { function(import('../core/Dataset.js').Cell):number } value 
 * @param {*} opts 
 * @returns {Array.<SizeLegend>}
 */
function sizeLegendViewScale(value, opts = {}) {
    const k = opts.k || [0.9, 0.5, 0.2, 0.05]
    const legends = []
    for (let k_ of k) {
        opts.title = k_ == k[0] ? opts.title : undefined
        opts.label = (viewScale, cells) => (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.nice)(k_ * (0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(cells, value))
        legends.push(new SizeLegend(opts))
    }
    return legends
}

/**
 * A function which return a stack of size legends for a discrete classification.
 * 
 * @param { Array.<number> } breaks 
 * @param { Array.<number> } sizes 
 * @param { object } opts 
 * @returns {Array.<SizeLegend>}
 */
function sizeDiscreteLegend(breaks, sizes, opts = {}) {
    const f = opts.labelFormat || (x => x)
    const labelText = opts.labelText || defaultLabelText(f)
    const legends = []
    for (let i = sizes.length - 1; i >= 0; i--) {
        opts.title = i == sizes.length - 1 ? opts.title : undefined
        opts.size = () => sizes[i]
        opts.label = () => labelText(breaks[i - 1], breaks[i])
        legends.push(new SizeLegend(opts))
    }
    return legends
}

/**
 * A function which return a stack of size legends for a discrete classification using a viewscale.
 * @param { number } classNumber 
 * @param { object } opts 
 * @returns {Array.<SizeLegend>}
 */
function sizeDiscreteViewScaleLegend(classNumber, opts = {}) {
    const f = opts.labelFormat || (x => x)
    const labelText = opts.labelText || defaultLabelText(f)
    const legends = []
    const viewScaleFun = opts.viewScaleFun || (t => t) //TODO do it differently? At sizelegend level !
    for (let i = classNumber - 1; i >= 0; i--) {
        opts.title = i == classNumber - 1 ? opts.title : undefined
        opts.size = (viewScale) => viewScaleFun(viewScale).values[i]
        opts.label = (viewScale) => labelText(viewScaleFun(viewScale).breaks[i - 1], viewScaleFun(viewScale).breaks[i])
        legends.push(new SizeLegend(opts))
    }
    return legends
}

/**
 * A function that returns a function to format laberls for discrete scale legends.
 * @param { function(number):string } format 
 * @returns { function(number|undefined, number|undefined): string }
 */
function defaultLabelText(format) {
    return (v0, v1) => {
        if (v0 == undefined && v1 == undefined) return ""
        if (v1 == undefined) return "> " + format(v0)
        if (v0 == undefined) return "< " + format(v1)
        return format(v0) + " - " + format(v1)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/legend/TrivariateLegend.js":
/*!*************************************************************!*\
  !*** ./node_modules/gridviz/src/legend/TrivariateLegend.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TrivariateLegend: () => (/* binding */ TrivariateLegend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Legend.js */ "./node_modules/gridviz/src/core/Legend.js");
//@ts-check


;


/**
 *
 * @module legend
 * @author Julien Gaffuri
 */
class TrivariateLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //classifier
        this.classifier = opts.classifier

        this.width = opts.width || 150
        this.selectionColor = this.selectionColor || "red"
        this.tooltip = opts.tooltip
        this.texts = opts.texts

        this.leftText = opts.leftText || "Category 0"
        this.topText = opts.topText || "Category 1"
        this.rightText = opts.rightText || "Category 2"

        this.centerCoefficient = opts.centerCoefficient || this.classifier.centerCoefficient
    }

    /**
     * @param {{} } opts
     */
    update(opts) {

        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        const sqrt3over2 = 0.866025
        const w = this.width, h = w * sqrt3over2
        const classifier = this.classifier
        const selectionColor = this.selectionColor
        const selectionStrokeWidth = 0
        const tt = this.tooltip
        const texts = this.texts || {}

        const padding = 2
        const fontSize = 12

        //make svg element
        const svg = this.div
            .append('svg')
            .attr('width', w + selectionStrokeWidth)
            .attr('height', h + 4 * padding + 2 * fontSize)

        //top label
        svg.append("text").attr("x", w / 2).attr("y", padding + fontSize).text(this.topText).attr("font-size", fontSize)
            .attr("text-anchor", "middle")
        //left label
        svg.append("text").attr("x", 0).attr("y", 3 * padding + 2 * fontSize + h).text(this.leftText).attr("font-size", fontSize)
            .attr("text-anchor", "start")
        //right label
        svg.append("text").attr("x", w).attr("y", 3 * padding + 2 * fontSize + h).text(this.rightText).attr("font-size", fontSize)
            .attr("text-anchor", "end")



        //triangle group
        const g = svg.append("g").attr("transform", "translate(" + (selectionStrokeWidth / 2) + " " + (selectionStrokeWidth / 2 + (2 * padding + fontSize)) + ")")

        //common function for triangle patches
        const setAttributes = (elt, color, text) => {
            //elt.raise();
            elt.attr('fill', color)
                //.attr("stroke", colorOver)
                //.attr("stroke-width", 0)
                //.attr("stroke-linejoin", "round")
                .on("mouseover", function (e) {
                    /*this.parentNode.appendChild(this); select(this).attr("stroke-width", selectionStrokeWidth);*/
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this).attr('fill', selectionColor);
                    if (!tt || !text) return;
                    tt.html(text);
                    tt.setPosition(e);
                    tt.show()
                })
                .on("mouseout", function () {
                    /*select(this).attr("stroke-width", 0);*/
                    (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this).attr('fill', color);
                    if (tt) tt.hide()
                })
            if (tt && text) elt.on("mousemove", function (e) { tt.setPosition(e) })
        }

        //const [c0, c1, c2] = classifier.center

        //trapezium s0
        const t0 = g.append('polygon')
            .attr('points', "0," + h + " " + w / 3 + "," + h + " " + w / 2 + "," + h * 2 / 3 + " " + w / 6 + "," + h * 2 / 3)
        setAttributes(t0, classifier.colors[0], texts["0"])
        //trapezium s1
        const t1 = g.append('polygon')
            .attr('points', w / 2 + ",0 " + w * 2 / 3 + "," + h / 3 + " " + w / 2 + "," + h * 2 / 3 + " " + w / 3 + "," + h / 3)
        setAttributes(t1, classifier.colors[1], texts["1"])
        //trapezium s2
        const t2 = g.append('polygon')
            .attr('points', w + "," + h + " " + w * 5 / 6 + "," + 2 * h / 3 + " " + w / 2 + "," + h * 2 / 3 + " " + w * 2 / 3 + "," + h)
        setAttributes(t2, classifier.colors[2], texts["2"])
        //triangle s0
        const t0_ = g.append('polygon')
            .attr('points', w / 2 + "," + h * 2 / 3 + " " + w * 5 / 6 + "," + h * 2 / 3 + " " + w * 2 / 3 + "," + h / 3)
        setAttributes(t0_, classifier.mixColors[0], texts["12"])
        //triangle s1
        const t1_ = g.append('polygon')
            .attr('points', w / 2 + "," + h * 2 / 3 + " " + w / 3 + "," + h + " " + w * 2 / 3 + "," + h)
        setAttributes(t1_, classifier.mixColors[1], texts["02"])
        //triangle s2
        const t2_ = g.append('polygon')
            .attr('points', w / 2 + "," + h * 2 / 3 + " " + w / 6 + "," + h * 2 / 3 + " " + w / 3 + "," + h / 3)
        setAttributes(t2_, classifier.mixColors[2], texts["01"])

        //center
        if (this.centerCoefficient) {
            //TODO make it an hexagon !
            const center = g.append('circle')
                .attr('cx', w / 2).attr('cy', h * 2 / 3)
                .attr('r', this.centerCoefficient * h / 3)
            setAttributes(center, classifier.centerColor, texts["center"])
        }


        /*
        let middle, left, top, right, left_, bottom_, right_
        if (!this.real) {

            //0 left triangle
            left = g.append('polygon')
                .attr('points', "0," + h + " " + (w / 3) + "," + h + " " + (w / 6) + "," + (2 * h / 3))
            //1 top triangle
            top = g.append('polygon')
                .attr('points', (w / 3) + "," + (h / 3) + " " + (w * 2 / 3) + "," + (h / 3) + " " + (w / 2) + ",0")
            //2 right triangle
            right = g.append('polygon')
                .attr('points', (w * 2 / 3) + "," + h + " " + w + "," + h + " " + (w * 5 / 6) + "," + (2 * h / 3))
            //middle triangle
            middle = g.append('polygon')
                .attr('points', (w / 2) + "," + (h / 3) + " " + (w / 4) + "," + (h * 5 / 6) + " " + (3 * w / 4) + "," + (h * 5 / 6))
            //01 left trapezium
            left_ = g.append('polygon')
                .attr('points', (w / 6) + "," + (h * 2 / 3) + " " + (w / 4) + "," + (h * 5 / 6) + " " + (w / 2) + "," + (h / 3) + " " + (w / 3) + "," + (h / 3))
            //02 bottom trapezium
            bottom_ = g.append('polygon')
                .attr('points', (w / 3) + "," + (h) + " " + (2 * w / 3) + "," + (h) + " " + (w * 3 / 4) + "," + (h * 5 / 6) + " " + (w / 4) + "," + (h * 5 / 6))
            //12 right trapezium
            right_ = g.append('polygon')
                .attr('points', (w / 2) + "," + (h / 3) + " " + (w * 3 / 4) + "," + (h * 5 / 6) + " " + (w * 5 / 6) + "," + (h * 2 / 3) + " " + (w * 2 / 3) + "," + (h / 3))

        } else {

            //middle triangle
            middle = g.append('polygon')
                .attr('points', (w / 2) + ",0 0," + h + " " + w + "," + h)

            //draw trapezium
            //draw large trapezium first
            for (let i_ = 2; i_ >= 0; i_--) {
                const i = this.classifier.lowIndex[i_]
                const r = this.classifier.lowThreshold[i]
                if (i == 2)
                    //01 left trapezium
                    left_ = g.append('polygon')
                        .attr('points', w / 2 + ",0 0," + h + " " + w * r + "," + h + " " + w * (1 + r) / 2 + "," + r * h)
                else if (i == 1)
                    //02 bottom trapezium
                    bottom_ = g.append('polygon')
                        .attr('points', "0," + h + " " + w + "," + h + " " + w * (1 - r / 2) + "," + h * (1 - r) + " " + r * w / 2 + "," + h * (1 - r))
                else
                    //12 right trapezium
                    right_ = g.append('polygon')
                        .attr('points', w + "," + h + " " + w / 2 + ",0 " + w * (1 - r) / 2 + "," + h * r + " " + w * (1 - r) + "," + h)
            }

            //draw triangles
            //draw large triangles first
            for (let i_ = 2; i_ >= 0; i_--) {
                const i = this.classifier.highIndex[i_]
                const r = this.classifier.highThreshold[i]

                if (i == 2)
                    //2 right triangle
                    right = g.append('polygon')
                        .attr('points', w + "," + h + " " + w * r + "," + h + " " + w * (1 + r) / 2 + "," + h * r)
                else if (i == 1)
                    //1 top triangle
                    top = g.append('polygon')
                        .attr('points', (w / 2) + ",0 " + w * r / 2 + "," + h * (1 - r) + " " + w * (1 - r / 2) + "," + h * (1 - r))
                else
                    //0 left triangle
                    left = g.append('polygon')
                        .attr('points', "0," + h + " " + w * (1 - r) + "," + h + " " + w * (1 - r) / 2 + "," + h * r)
            }

        }*/

    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/CompositionStyle.js":
/*!************************************************************!*\
  !*** ./node_modules/gridviz/src/style/CompositionStyle.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompositionStyle: () => (/* binding */ CompositionStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/** @typedef {"flag"|"piechart"|"ring"|"segment"|"radar"|"agepyramid"|"halftone"} CompositionType */

/**
 * A style showing the composition of a total in different categories, with different color hues.
 * It consists of a symbol with different parts, whose size reflect the proportion of the corresponding category.
 * For a list of supported symbols, @see CompositionType
 * The symbol can be scaled depending on the cell importance.
 *
 * @module style
 * @author Julien Gaffuri
 */
class CompositionStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

        /**
         * A function returning the type of decomposition symbol of a cell, @see CompositionType
         * @type {function(import("../core/Dataset.js").Cell,number, number,object):CompositionType} */
        this.type = opts.type || (() => "flag") //(c,r,z,vs) => {}

        /** A function returning the size of a cell in geographical unit.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.size = opts.size || ((c, r) => r) //(c,r,z,vs) => {}

        /** For style types with stripes (flag, segment), the orientation of the stripes (0 for horizontal, other for vertical).
         * @type {function(import("../core/Dataset.js").Cell,number,number,object):number} */
        this.stripesOrientation = opts.stripesOrientation || (() => 0) //(c,r,z,vs) => ...

        /** The function specifying an offset angle for a radar, halftone or pie chart style.
         * The angle is specified in degree. The rotation is anti-clockwise.
         * @type {function(import("../core/Dataset.js").Cell,number,number,object):number} */
        this.offsetAngle = opts.offsetAngle || (() => 0) //(c,r,z,vs) => ...

        /** The function specifying the height of the age pyramid, in geo unit.
         * @type {function(import("../core/Dataset.js").Cell,number,number,object):number} */
        this.agePyramidHeight = opts.agePyramidHeight || ((c, r) => r) //(c,r,z,vs) => ...

        /** For pie chart, this is parameter for internal radius, so that the pie chart looks like a donut.
         * 0 for normal pie charts, 0.5 to empty half of the radius.
         * @type {number} */
        this.pieChartInternalRadiusFactor = opts.pieChartInternalRadiusFactor || 0
    }

    /**
     * Draw cells as squares depending on their value.
     *
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //nb categories - used for radar and agepyramid
        const nbCat = Object.entries(this.color).length

        //draw calls
        for (let cell of cells) {

            //size
            const sG = this.size ? this.size(cell, resolution, z, viewScale) : resolution
            if (!sG) continue

            //get offset
            const offset = this.offset(cell, resolution, z)

            //get symbol type
            const type_ = this.type ? this.type(cell, resolution, z, viewScale) : 'flag'

            //compute center position
            const xc = cell.x + offset.dx + (type_ === 'agepyramid' ? 0 : resolution * 0.5)
            const yc = cell.y + offset.dy + (type_ === 'agepyramid' ? 0 : resolution * 0.5)

            //compute offset angle, when relevant
            const offAng = this.offsetAngle ? (this.offsetAngle(cell, resolution, z, viewScale) * Math.PI) / 180 : 0

            if (type_ === 'agepyramid' || type_ === 'radar' || type_ === 'halftone') {
                //get cell category max value
                let maxVal = -Infinity
                for (let key of Object.keys(this.color)) {
                    const v = +cell[key]
                    if (v > maxVal) maxVal = v
                }

                //cumul
                let cumul = 0
                if (type_ === 'agepyramid' && this.agePyramidHeight)
                    cumul = (resolution - this.agePyramidHeight(cell, resolution, z, viewScale)) / 2
                if (type_ === 'radar' || type_ === 'halftone') cumul = Math.PI / 2 + offAng

                //compute the increment, which is the value to increment the cumul for each category
                const incr =
                    type_ === 'agepyramid'
                        ? (this.agePyramidHeight ? this.agePyramidHeight(cell, resolution, z, viewScale) : resolution) / nbCat
                        : type_ === 'radar' || type_ === 'halftone'
                            ? (2 * Math.PI) / nbCat
                            : undefined
                if (incr === undefined) throw new Error('Unexpected symbol type:' + type_)

                for (let [column, color] of Object.entries(this.color)) {
                    if (type_ === 'agepyramid') {
                        //set category color
                        geoCanvas.ctx.fillStyle = color

                        //get category value
                        const val = cell[column]

                        //compute category length - in geo
                        /** @type {number} */
                        const wG = (sG * val) / maxVal

                        //draw bar
                        geoCanvas.ctx.fillRect(xc + (resolution - wG) / 2, yc + cumul, wG, incr)

                        //next height
                        cumul += incr
                    } else if (type_ === 'radar') {
                        //set category color
                        geoCanvas.ctx.fillStyle = color

                        //get categroy value
                        const val = cell[column]

                        //compute category radius - in geo
                        /** @type {number} */
                        //const rG = this.radius(val, r, stat, cellStat, z)
                        const rG = (sG / 2) * Math.sqrt(val / maxVal)

                        //draw angular sector
                        geoCanvas.ctx.beginPath()
                        geoCanvas.ctx.moveTo(xc, yc)
                        geoCanvas.ctx.arc(xc, yc, rG, cumul - incr, cumul)
                        geoCanvas.ctx.lineTo(xc, yc)
                        geoCanvas.ctx.fill()

                        //next angular sector
                        cumul += incr
                    } else if (type_ === 'halftone') {
                        //set category color
                        geoCanvas.ctx.fillStyle = color

                        //get categroy value
                        const val = cell[column]

                        //compute category radius - in geo
                        /** @type {number} */
                        const rG = sG * 0.333 * Math.sqrt(val / maxVal)

                        //draw circle
                        geoCanvas.ctx.beginPath()
                        geoCanvas.ctx.arc(
                            xc + resolution * 0.25 * Math.cos(cumul),
                            yc + resolution * 0.25 * Math.sin(cumul),
                            rG,
                            0,
                            2 * Math.PI
                        )
                        geoCanvas.ctx.fill()

                        //next angular sector
                        cumul += incr
                    } else {
                        throw new Error('Unexpected symbol type:' + type_)
                    }
                }
            } else {
                //compute total
                let total = 0
                for (let column of Object.keys(this.color)) {
                    const v = +cell[column]
                    if (!v) continue
                    total += v
                }
                if (!total || isNaN(total)) continue

                //draw decomposition symbol
                let cumul = 0
                const d = resolution * (1 - sG / resolution) * 0.5
                const ori = this.stripesOrientation(cell, resolution, z, viewScale)

                for (let [column, color] of Object.entries(this.color)) {
                    //get share
                    const share = cell[column] / total
                    if (!share || isNaN(share)) continue

                    //set color
                    geoCanvas.ctx.fillStyle = color

                    //draw symbol part
                    if (type_ === 'flag') {
                        //draw flag stripe
                        if (ori == 0) {
                            //horizontal
                            geoCanvas.ctx.fillRect(
                                cell.x + d + offset.dx,
                                cell.y + d + cumul * sG + offset.dy,
                                sG,
                                share * sG
                            )
                        } else {
                            //vertical
                            geoCanvas.ctx.fillRect(
                                cell.x + d + cumul * sG + offset.dx,
                                cell.y + d + offset.dy,
                                share * sG,
                                sG
                            )
                        }
                    } else if (type_ === 'piechart') {
                        //draw pie chart angular sector

                        //compute angles
                        const a1 = cumul * 2 * Math.PI
                        const a2 = (cumul + share) * 2 * Math.PI

                        //draw
                        geoCanvas.ctx.beginPath()
                        geoCanvas.ctx.moveTo(xc, yc)
                        geoCanvas.ctx.arc(xc, yc, sG * 0.5, a1 + offAng, a2 + offAng)
                        if (this.pieChartInternalRadiusFactor)
                            geoCanvas.ctx.arc(
                                xc,
                                yc,
                                sG * 0.5 * this.pieChartInternalRadiusFactor,
                                a1 + offAng,
                                a2 + offAng,
                                true
                            )
                        geoCanvas.ctx.closePath()
                        geoCanvas.ctx.fill()
                    } else if (type_ === 'ring') {
                        //draw ring
                        geoCanvas.ctx.beginPath()
                        geoCanvas.ctx.arc(xc, yc, Math.sqrt(1 - cumul) * sG * 0.5, 0, 2 * Math.PI)
                        geoCanvas.ctx.fill()
                    } else if (type_ === 'segment') {
                        //draw segment sections
                        const wG = (sG * sG) / resolution
                        if (ori == 0) {
                            //horizontal
                            geoCanvas.ctx.fillRect(
                                cell.x + offset.dx,
                                cell.y + (resolution - wG) / 2 + cumul * wG + offset.dy,
                                resolution,
                                share * wG
                            )
                        } else {
                            //vertical
                            geoCanvas.ctx.fillRect(
                                cell.x + cumul * resolution + offset.dx,
                                cell.y + (resolution - wG) / 2 + offset.dy,
                                share * resolution,
                                wG
                            )
                        }
                    } else {
                        throw new Error('Unexpected symbol type:' + type_)
                    }

                    cumul += share
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/DotDensityStyle.js":
/*!***********************************************************!*\
  !*** ./node_modules/gridviz/src/style/DotDensityStyle.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DotDensityStyle: () => (/* binding */ DotDensityStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
/* harmony import */ var d3_random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-random */ "./node_modules/d3-random/src/normal.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoring_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/WebGLSquareColoring.js */ "./node_modules/gridviz/src/utils/WebGLSquareColoring.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;





/**
 *
 * @module style
 * @author Julien Gaffuri
 */
class DotDensityStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the number of dots for a cell value.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.dotNumber = opts.dotNumber || ((cell, resolution) => resolution / 100)//(c,r,z,vs) => {}

        /** The color of the dots. Same color for all dots within a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => '#FF5733') //(c,r,z,vs) => {}

        /** A function returning the size of the dots, in geo unit. Same size for all cells.
         * @type {function(number, number,object):number} */
        this.dotSize = opts.dotSize || ((resolution, z) => 1.5 * z) //(c,r,z,vs) => {}

        /** A function returning the sigma of the dots distribution. Same value for all cells.
         * @type {function(number, number,object):number} */
        this.sigma = opts.sigma || ((resolution, z) => resolution / 2)//(c,r,z,vs) => {}
    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //get size
        const sGeo = this.dotSize ? this.dotSize(resolution, z, viewScale) : z

        //make random function
        const sig = this.sigma ? this.sigma(resolution, z, viewScale) : resolution * 0.4
        const rand = (0,d3_random__WEBPACK_IMPORTED_MODULE_3__["default"])(0, sig)

        if ((0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.checkWebGLSupport)()) {
            //create canvas and webgl renderer
            const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeWebGLCanvas)(geoCanvas.w + '', geoCanvas.h + '')
            if (!cvWGL) {
                console.error('No webGL')
                return
            }

            //create webGL program
            const prog = new _utils_WebGLSquareColoring_js__WEBPACK_IMPORTED_MODULE_2__.WebGLSquareColoring(cvWGL.gl, sGeo / z)

            const r2 = resolution / 2

            for (let cell of cells) {
                //get color
                const col = this.color(cell, resolution, z, viewScale)
                if (!col || col === 'none') continue

                //number of dots
                const dotNumber = this.dotNumber(cell, resolution, z, viewScale)

                //get offset
                const offset = this.offset(cell, resolution, z)

                //cell center
                const cx = cell.x + offset.dx + r2
                const cy = cell.y + offset.dy + r2

                //convert color
                const cc = (0,d3_color__WEBPACK_IMPORTED_MODULE_4__["default"])(col)
                if (!cc) return

                //random points
                for (let i = 0; i <= dotNumber; i++)
                    prog.addPointData2(cx + rand(), cy + rand(), cc.r, cc.g, cc.b, cc.opacity)
            }

            //draw
            prog.draw(geoCanvas.getWebGLTransform())

            //draw in canvas geo
            geoCanvas.initCanvasTransform()
            geoCanvas.ctx.drawImage(cvWGL.canvas, 0, 0)

        } else {
            for (let cell of cells) {

                //get color
                const col = this.color(cell, resolution, z, viewScale)
                if (!col || col === 'none') continue
                //set color
                geoCanvas.ctx.fillStyle = col

                //number of dots
                const dotNumber = this.dotNumber(cell, resolution, z, viewScale)

                //get offset
                const offset = this.offset(cell, resolution, z)

                //draw random dots
                const cx = cell.x + offset.dx + resolution / 2,
                    cy = cell.y + offset.dy + resolution / 2
                for (let i = 0; i <= dotNumber; i++) {
                    geoCanvas.ctx.fillRect(cx + rand(), cy + rand(), sGeo, sGeo)
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/ImageStyle.js":
/*!******************************************************!*\
  !*** ./node_modules/gridviz/src/style/ImageStyle.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImageStyle: () => (/* binding */ ImageStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class ImageStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {

    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the image code of a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.imageCode = opts.imageCode || (() => '') //(c,r,z,vs) => {}

        /** The dictionnary code -> image
         *  @type {object}        */
        this.images = opts.images || {}

        /** The image size in ground meters
         *  @type {function(import('../core/Dataset.js').Cell, number, number, object):number}        */
        this.size = opts.size || ((cell, resolution) => resolution)
    }

    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     * @override
     */
    draw(cells, geoCanvas, resolution) {

        //
        const z = geoCanvas.view.z,
            resolutionPix = resolution / z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //draw in screen coordinates
        geoCanvas.initCanvasTransform()

        //
        for (let cell of cells) {

            //get cell image code
            const code = this.imageCode(cell, resolution, z, viewScale)

            //get image
            const image = this.images[code]
            if (!image) continue

            //size and position values
            let sizePix = this.size(cell, resolution, z, viewScale) / z
            if (!sizePix) continue
            const d = (resolutionPix - sizePix) / 2

            try {
                geoCanvas.ctx.drawImage(image, geoCanvas.geoToPixX(cell.x) + d, geoCanvas.geoToPixY(cell.y) + d -resolutionPix, sizePix, sizePix)

                /*/red color filter
                geoCanvas.ctx.globalCompositeOperation = 'source-in';
                geoCanvas.ctx.fillStyle = 'red';
                geoCanvas.ctx.fillRect(geoCanvas.geoToPixX(cell.x) + d, geoCanvas.geoToPixY(cell.y) + d, sizePix, sizePix);
                geoCanvas.ctx.globalCompositeOperation = 'source-over';*/
            } catch (error) {
                console.error(error)
            }

        }


        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/IsoFenceStyle.js":
/*!*********************************************************!*\
  !*** ./node_modules/gridviz/src/style/IsoFenceStyle.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IsoFenceStyle: () => (/* binding */ IsoFenceStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
/* harmony import */ var _SideStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SideStyle.js */ "./node_modules/gridviz/src/style/SideStyle.js");
//@ts-check


;


/** @typedef {{x:number,y:number,or:"v"|"h",c1:import('../core/Dataset.js').Cell|undefined,c2:import('../core/Dataset.js').Cell|undefined}} Side */

/**
 * @module style
 * @author Julien Gaffuri
 */
class IsoFenceStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {

    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

        /** A function returning the height of a cell in geographical unit.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.height = opts.height || ((cell, resolution, z, viewScale) => resolution * 0.4)

        /** The perspective angle, in degree, within [-180,180], from [O,x] axis.
         * @type {number} */
        this.angle = opts.angle != undefined ? opts.angle : 50

        /** A function returning the corner line stroke style.
         * @type {function(import('../core/Dataset.js').Cell,number,number,number):string} */
        this.cornerLineStrokeColor = opts.cornerLineStrokeColor || ((c, r, z, angle) => "#999")

        /** A function returning the corner line width.
        * @type {function(import('../core/Dataset.js').Cell,number,number,number):number} */
        this.cornerLineWidth = opts.cornerLineWidth || ((c, r, z, angle) => (angle % 90 == 0 ? 0 : 0.8 * z))

        /**
        * Show vertical cross-sections.
        * @type {boolean} */
        this.sVert = opts.sVert != undefined ? opts.sVert : true

        /**
        * Show horizontal cross-sections.
        * @type {boolean} */
        this.sHor = opts.sHor != undefined ? opts.sHor : true
    }

    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     * @override
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //nb categories - used for radar and agepyramid
        const cats = Object.keys(this.color)

        //half resolution
        const r2 = resolution / 2

        //get offset
        // @ts-ignore
        const offset = this.offset(undefined, resolution, z), dx = offset.dx, dy = offset.dy

        //make sides
        /**  @type {Array.<Side>} */
        const sides = _SideStyle_js__WEBPACK_IMPORTED_MODULE_1__.SideStyle.buildSides(cells, resolution, this.angle % 180 != 90 && this.sVert, this.angle % 180 != 0 && this.sHor)

        //
        if (sides.length == 0) return

        //angle in radians
        const aRad = this.angle * Math.PI / 180, cos = Math.cos(aRad), sin = Math.sin(aRad)

        //sort sides so that the back ones are drawn first. This depends on the angle.
        //depending on distance to the reference corner point
        const xCorner = Math.abs(this.angle) < 90 ? geoCanvas.extGeo.xMin : geoCanvas.extGeo.xMax
        const yCorner = this.angle < 0 ? geoCanvas.extGeo.yMax : geoCanvas.extGeo.yMin
        sides.sort((s1, s2) => (Math.hypot(s2.x - xCorner, s2.y - yCorner) - Math.hypot(s1.x - xCorner, s1.y - yCorner)))

        //prepare function to draw corner line for a cell *c*
        const drawCornerLine = (cell) => {

            if (!cell) return
            //line style
            const lw = this.cornerLineWidth ? this.cornerLineWidth(cell, resolution, z, this.angle) : 0.8 * z
            if (lw == 0) return
            geoCanvas.ctx.strokeStyle = this.cornerLineStrokeColor ? this.cornerLineStrokeColor(cell, resolution, z, this.angle) : "#333"
            geoCanvas.ctx.lineWidth = lw

            //height - in geo
            const hG = this.height(cell, resolution, z, viewScale)

            //draw line
            geoCanvas.ctx.beginPath()
            geoCanvas.ctx.moveTo(cell.x + r2 + dx, cell.y + r2 + dy)
            geoCanvas.ctx.lineTo(cell.x + r2 + hG * cos + dx, cell.y + r2 + hG * sin + dy)
            geoCanvas.ctx.stroke()
        }

        //draw sides
        geoCanvas.ctx.lineCap = "round";
        for (let side of sides) {
            const c1 = side.c1, c2 = side.c2, x = side.x, y = side.y

            //heights - in geo
            const hG1 = c1 ? this.height(c1, resolution, z, viewScale) : 0,
                hG2 = c2 ? this.height(c2, resolution, z, viewScale) : 0

            //compute totals for both cells
            const total1 = computeTotal(c1, cats),
                total2 = computeTotal(c2, cats)
            if (total1 == 0 && total2 == 0) continue

            let cumul1 = 0, cumul2 = 0
            for (let [column, color] of Object.entries(this.color)) {
                //draw stripe of side s and category column

                //get values for both cells
                let v1 = c1 ? +c1[column] : 0
                let v2 = c2 ? +c2[column] : 0
                if (v1 == 0 && v2 == 0) continue

                //compute heights
                const h1 = hG1 * cumul1 / total1 || 0
                const h1n = hG1 * (cumul1 + v1) / total1 || 0
                const h2 = hG2 * cumul2 / total2 || 0
                const h2n = hG2 * (cumul2 + v2) / total2 || 0

                //make path
                geoCanvas.ctx.beginPath()
                if (side.or == "h") {
                    //horizontal side - vertical section
                    //bottom left
                    geoCanvas.ctx.moveTo(x + h1 * cos + dx, y - r2 + h1 * sin + dy)
                    //top left
                    geoCanvas.ctx.lineTo(x + h2 * cos + dx, y + r2 + h2 * sin + dy)
                    //top right
                    geoCanvas.ctx.lineTo(x + h2n * cos + dx, y + r2 + h2n * sin + dy)
                    //bottom right
                    geoCanvas.ctx.lineTo(x + h1n * cos + dx, y - r2 + h1n * sin + dy)
                } else {
                    //vertical side - horizontal section
                    //bottom left
                    geoCanvas.ctx.moveTo(x - r2 + h1 * cos + dx, y + h1 * sin + dy)
                    //bottom right
                    geoCanvas.ctx.lineTo(x + r2 + h2 * cos + dx, y + h2 * sin + dy)
                    //top right
                    geoCanvas.ctx.lineTo(x + r2 + h2n * cos + dx, y + h2n * sin + dy)
                    //top left
                    geoCanvas.ctx.lineTo(x - r2 + h1n * cos + dx, y + h1n * sin + dy)
                }
                //cg.ctx.closePath()

                //fill
                geoCanvas.ctx.fillStyle = color
                geoCanvas.ctx.fill()

                cumul1 += v1
                cumul2 += v2

                //TODO draw only one line
                //draw corner line
                //if (side.or == "h") {
                drawCornerLine(c1)
                drawCornerLine(c2)
                //if (this.angle > 0 && side.or == "h") drawCornerLine(c2)
                //else drawCornerLine(c2)
                //}
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}



const computeTotal = (cell, categories) => {
    if (!cell) return 0
    let total = 0
    for (let column of categories) {
        const v = cell[column]
        if (!v) continue
        total += +v
    }
    return total || 0
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/JoyPlotStyle.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/style/JoyPlotStyle.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JoyPlotStyle: () => (/* binding */ JoyPlotStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class JoyPlotStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the height of a cell in geographical unit.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.height = opts.height || ((c, r) => r * Math.random()) //(c,r,z,vs) => {}

        /**
         * @type {function(number,{min:number, max:number},number,number):string} */
        this.lineColor = opts.lineColor || ((y, ys, r, z) => '#BBB')
        /**
         * @type {function(number,{min:number, max:number},number,number):number} */
        this.lineWidth = opts.lineWidth || ((y, ys, r, z) => z)
        /**
         * @type {function(number,{min:number, max:number},number,number):string} */
        this.fillColor = opts.fillColor || ((y, ys, r, z) => '#c08c5968')
    }


    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     * @override
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //index cells by y and x
        /**  @type {object} */
        const ind = {}
        for (const cell of cells) {
            let row = ind[cell.y]
            if (!row) {
                row = {}
                ind[cell.y] = row
            }
            row[cell.x] = this.height(cell, resolution, z, viewScale)
        }

        //compute extent
        const e = geoCanvas.extGeo
        if (!e) return
        const xMin = Math.floor(e.xMin / resolution) * resolution
        const xMax = Math.floor(e.xMax / resolution) * resolution
        const yMin = Math.floor(e.yMin / resolution) * resolution
        const yMax = Math.floor(e.yMax / resolution) * resolution

        /**  @type {{min:number, max:number}} */
        const ys = { min: yMin, max: yMax }

        //draw lines, row by row, stating from the top
        geoCanvas.ctx.lineJoin = 'round'
        for (let y = yMax; y >= yMin; y -= resolution) {
            //get row
            const row = ind[y]

            //no row
            if (!row) continue

            //place first point
            geoCanvas.ctx.beginPath()
            geoCanvas.ctx.moveTo(xMin - resolution / 2, y)

            //store the previous height
            /** @type {number|undefined} */
            let hG_

            //go through the line cells
            for (let x = xMin; x <= xMax; x += resolution) {
                //get column value
                /** @type {number} */
                let hG = row[x]
                if (!hG) hG = 0

                if (hG || hG_) {
                    //draw line only when at least one of both values is non-null
                    //TODO test bezierCurveTo
                    geoCanvas.ctx.lineTo(x + resolution / 2, y + hG)
                } else {
                    //else move the point
                    geoCanvas.ctx.moveTo(x + resolution / 2, y)
                }
                //store the previous value
                hG_ = hG
            }

            //last point
            if (hG_) geoCanvas.ctx.lineTo(xMax + resolution / 2, y)

            //draw fill
            const fc = this.fillColor(y, ys, resolution, z)
            if (fc && fc != 'none') {
                geoCanvas.ctx.fillStyle = fc
                geoCanvas.ctx.fill()
            }

            //draw line
            const lc = this.lineColor(y, ys, resolution, z)
            const lw = this.lineWidth(y, ys, resolution, z)
            if (lc && lc != 'none' && lw > 0) {
                geoCanvas.ctx.strokeStyle = lc
                geoCanvas.ctx.lineWidth = lw
                geoCanvas.ctx.stroke()
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/LegoStyle.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridviz/src/style/LegoStyle.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LegoStyle: () => (/* binding */ LegoStyle)
/* harmony export */ });
/* harmony import */ var _TanakaStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TanakaStyle.js */ "./node_modules/gridviz/src/style/TanakaStyle.js");
/* harmony import */ var _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StrokeStyle.js */ "./node_modules/gridviz/src/style/StrokeStyle.js");
/* harmony import */ var _SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SquareColorCategoryWebGLStyle.js */ "./node_modules/gridviz/src/style/SquareColorCategoryWebGLStyle.js");
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;




/**
 * @module style
 * @author Julien Gaffuri
 */
class LegoStyle {

    static get(value, breaks, colors, opts = {}) {
        opts = opts || {}

        //the colors
        //http://www.jennyscrayoncollection.com/2021/06/all-current-lego-colors.html
        //https://leonawicz.github.io/legocolors/reference/figures/README-plot-1.png
        /*opts.colors = opts.colors || [
            '#00852b', //darker green
            '#afd246', //light green
            '#fac80a', //dark yellow
            '#bb805a', //brown
            '#d67923', //mostard
            '#cb4e29', //redish
            '#b40000', //red
            '#720012', //dark red
            //"purple",
            //"#eee" //whithe
        ]*/

        opts.colDark = opts.colDark || '#333'
        opts.colBright = opts.colBright || '#aaa'
        opts.widthFactor = opts.widthFactor || 0.12

        //reuse tanaka as basis
        const ts = _TanakaStyle_js__WEBPACK_IMPORTED_MODULE_0__.TanakaStyle.get(value, breaks, colors, opts)
        //style to show limits between pieces
        const sst = new _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__.StrokeStyle({
            strokeColor: () => '#666',
            strokeWidth: (c, r, z) => 0.2 * z,
            filter: opts.filter,
        })

        return [
            ts[0],
            sst,
            ts[1],
            new LegoTopStyle({ colDark: opts.colDark, colBright: opts.colBright, filter: opts.filter }),
        ]
    }

    /**
     * @param {function(import('../core/Dataset.js').Cell):string} code
     * @param {object} color
     * @param {object} opts
     * @returns {Array.<Style>}
     */
    static getCategory(code, color, opts) {
        opts = opts || {}

        opts.colDark = opts.colDark || '#333'
        opts.colBright = opts.colBright || '#aaa'

        //
        const s = new _SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_2__.SquareColorCategoryWebGLStyle({ code: code, color: color })
        //style to show limits between pieces
        const sst = new _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__.StrokeStyle({ strokeColor: () => '#666', strokeWidth: (c, r, z) => 0.2 * z })

        return [s, sst, new LegoTopStyle({ colDark: opts.colDark, colBright: opts.colBright })]
    }
}

/**
 * A style to draw top circle of lego bricks.
 */
class LegoTopStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_3__.Style {
    /** @param {object|undefined} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}
        this.colDark = opts.colDark || '#333'
        this.colBright = opts.colBright || '#aaa'
    }

    draw(cells, geoCanvas, r) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        geoCanvas.ctx.lineWidth = 0.6 * geoCanvas.view.z

        //dark part
        geoCanvas.ctx.strokeStyle = this.colDark
        for (let c of cells) {
            geoCanvas.ctx.beginPath()
            geoCanvas.ctx.arc(c.x + r * 0.5, c.y + r * 0.5, r * 0.55 * 0.5, Math.PI / 4, -Math.PI * (3 / 4), true)
            geoCanvas.ctx.stroke()
        }

        //bright part
        geoCanvas.ctx.strokeStyle = this.colBright
        for (let c of cells) {
            geoCanvas.ctx.beginPath()
            geoCanvas.ctx.arc(c.x + r * 0.5, c.y + r * 0.5, r * 0.55 * 0.5, Math.PI / 4, -Math.PI * (3 / 4), false)
            geoCanvas.ctx.stroke()
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/MosaicStyle.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/style/MosaicStyle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MosaicStyle: () => (/* binding */ MosaicStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class MosaicStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the color of the cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => "#EA6BAC") //(c,r,z,vs) => {}

        /** The mosaic factor, within [0,0.5]. Set to 0 for no mosaic effect. Set to 0.5 for strong mosaic effect.
         * @type {number} */
        this.mosaicFactor = opts.mosaicFactor || 0.15

        /** The mosaic shadow factor, within [0,0.5]. Set to 0 for no mosaic shadow. Set to 0.5 for strong mosaic shadow.
         * @type {number} */
        this.shadowFactor = opts.shadowFactor || 0.2

        /** The mosaic shadow color.
         * @type {string} */
        this.shadowColor = opts.shadowColor || '#555'
    }

    /**
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //set stroke style, for shadow
        geoCanvas.ctx.strokeStyle = this.shadowColor
        geoCanvas.ctx.lineWidth = this.shadowFactor * resolution
        geoCanvas.ctx.lineJoin = 'round'
        geoCanvas.ctx.lineCap = 'butt'

        //function to compute position mosaic effect
        const d = resolution * this.mosaicFactor
        const mosaic = () => {
            return { x: Math.random() * d, y: Math.random() * d }
        }

        for (let cell of cells) {
            //set fill color
            const col = this.color ? this.color(cell, resolution, z, viewScale) : undefined
            if (!col || col === 'none') continue
            geoCanvas.ctx.fillStyle = col

            //get offset
            const offset = this.offset(cell, resolution, z)

            //compute position mosaic effect
            const ll = mosaic(),
                ul = mosaic(),
                lr = mosaic(),
                ur = mosaic()

            //stroke
            if (this.shadowFactor > 0) {
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(cell.x + offset.dx + ll.x, cell.y + offset.dy + ll.y)
                geoCanvas.ctx.lineTo(cell.x + offset.dx + resolution - lr.x, cell.y + offset.dy + lr.y)
                geoCanvas.ctx.lineTo(cell.x + offset.dx + resolution - ur.x, cell.y + offset.dy + resolution - ur.y)
                geoCanvas.ctx.stroke()
            }

            //fill

            geoCanvas.ctx.beginPath()
            geoCanvas.ctx.moveTo(cell.x + offset.dx + ll.x, cell.y + offset.dy + ll.y)
            geoCanvas.ctx.lineTo(cell.x + offset.dx + resolution - lr.x, cell.y + offset.dy + lr.y)
            geoCanvas.ctx.lineTo(cell.x + offset.dx + resolution - ur.x, cell.y + offset.dy + resolution - ur.y)
            geoCanvas.ctx.lineTo(cell.x + offset.dx + ul.x, cell.y + offset.dy + resolution - ul.y)
            geoCanvas.ctx.fill()
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/NinjaStarStyle.js":
/*!**********************************************************!*\
  !*** ./node_modules/gridviz/src/style/NinjaStarStyle.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NinjaStarStyle: () => (/* binding */ NinjaStarStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Joseph Davies, Julien Gaffuri
 */
class NinjaStarStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the color of the cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => "#EA6BAC") //(c,r,z,vs) => {}

        /** A function returning the size of a cell, within [0,1]:
         *  - 0, nothing shown
         *  - 1, entire square
          * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.size = opts.size || ((cell, resolution) => resolution) //(c,r,z,vs) => {}

        /** A function returning the shape.
         * @type {function(import("../core/Dataset").Cell):string} */
        this.shape = opts.shape || (() => 'o')
    }

    /**
     *
     * @param {Array.<import('../core/Dataset.js').Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        const r2 = resolution * 0.5
        for (let cell of cells) {
            //color
            const col = this.color ? this.color(cell, resolution, z, viewScale) : undefined
            if (!col || col === 'none') continue
            geoCanvas.ctx.fillStyle = col

            //size - in geo unit
            let k = this.size(cell, resolution, z, viewScale)
            k = k < 0 ? 0 : k > 1 ? 1 : k
            const sG2 = k * r2

            //shape
            const shape = this.shape ? this.shape(cell) : 'o'
            if (shape === 'none') continue

            //get offset
            //TODO use
            //const offset = this.offset(cell, r, z)

            //center position
            const cx = cell.x + r2
            const cy = cell.y + r2

            if (shape === 'p') {
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(cx, cy + r2)
                geoCanvas.ctx.lineTo(cx + sG2, cy + sG2)
                geoCanvas.ctx.lineTo(cx + r2, cy)
                geoCanvas.ctx.lineTo(cx + sG2, cy - sG2)
                geoCanvas.ctx.lineTo(cx, cy - r2)
                geoCanvas.ctx.lineTo(cx - sG2, cy - sG2)
                geoCanvas.ctx.lineTo(cx - r2, cy)
                geoCanvas.ctx.lineTo(cx - sG2, cy + sG2)
                geoCanvas.ctx.fill()
            } else if (shape === 'o') {
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(cx, cy + sG2)
                geoCanvas.ctx.lineTo(cx + r2, cy + r2)
                geoCanvas.ctx.lineTo(cx + sG2, cy)
                geoCanvas.ctx.lineTo(cx + r2, cy - r2)
                geoCanvas.ctx.lineTo(cx, cy - sG2)
                geoCanvas.ctx.lineTo(cx - r2, cy - r2)
                geoCanvas.ctx.lineTo(cx - sG2, cy)
                geoCanvas.ctx.lineTo(cx - r2, cy + r2)
                geoCanvas.ctx.fill()
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/PillarStyle.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/style/PillarStyle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PillarStyle: () => (/* binding */ PillarStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class PillarStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {

    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the height of the line representing a cell, in geo unit
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.height = opts.height

        /** A function returning the color of the line representing a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => "#c08c59") //(c,r,z,vs) => {}

        /** A function returning the width of the line representing a cell, in geo unit
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.width = opts.width || ((cell, resolution) => 0.5 * resolution)

        /** A function returning the width of the line representing a cell, in geo unit
         * @type {function(number, number,object):boolean} */
        this.simple = opts.simple || (() => false)

        /** @type {number} */
        this.viewHeightFactor = opts.viewHeightFactor || 1.5
        //0,0 is the center
        /** @type {number} */
        this.viewSX = opts.viewSX == undefined ? 0 : opts.viewSX
        /** @type {number} */
        this.viewSY = opts.viewSY == undefined ? -0.5 : opts.viewSY

        //TODO replace with sun location ?
        /** @type {number} */
        this.shadowDirection =
            opts.shadowDirection == undefined ? (-40.3 * Math.PI) / 180.0 : opts.shadowDirection
        /** @type {number} */
        this.shadowFactor = opts.shadowFactor || 0.3
        /** @type {string} */
        this.shadowColor = opts.shadowColor || '#00000033'

        /** @type {string} */
        this.outlineCol = opts.outlineCol || '#FFFFFF'
        /** @type {number} */
        this.outlineWidthPix = opts.outlineWidthPix == undefined ? 0.5 : opts.outlineWidthPix
    }

    /**
     * Draw cells as segments.
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //get view center geo position
        const cvx = geoCanvas.view.x + this.viewSX * geoCanvas.w * z
        const cvy = geoCanvas.view.y + this.viewSY * geoCanvas.h * z
        //get view height
        const H = this.viewHeightFactor * (geoCanvas.w + geoCanvas.h) * 0.5 * z

        //sort cells by y and x
        //const distToViewCenter = (c) => { const dx = cvx - c.x, dy = cvy - c.y; return Math.sqrt(dx * dx + dy * dy) }
        cells.sort((c1, c2) => 100000000 * (c2.y - c1.y) + c1.x - c2.x)

        //get simple information
        const simple = this.simple(resolution, z, viewScale)

        geoCanvas.ctx.lineCap = simple ? 'butt' : 'round'

        //draw shadows
        geoCanvas.ctx.strokeStyle = this.shadowColor
        geoCanvas.ctx.fillStyle = this.shadowColor
        for (let cell of cells) {
            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(cell, resolution, z, viewScale) : undefined
            if (!wG || wG < 0) continue

            //height
            /** @type {number|undefined} */
            const hG = this.height ? this.height(cell, resolution, z, viewScale) : undefined
            if (!hG || hG < 0) continue

            //get offset
            //TODO use that
            //const offset = this.offset(c, resolution, z)

            //set width
            geoCanvas.ctx.lineWidth = wG

            //compute cell center postition
            const cx = cell.x + resolution / 2
            const cy = cell.y + resolution / 2
            const ls = hG * this.shadowFactor

            //draw segment
            geoCanvas.ctx.beginPath()
            geoCanvas.ctx.moveTo(cx, cy)
            geoCanvas.ctx.lineTo(cx + ls * Math.cos(this.shadowDirection), cy + ls * Math.sin(this.shadowDirection))
            geoCanvas.ctx.stroke()

            /*
            if (this.simple) {
                //draw base circle
                cg.ctx.beginPath();
                cg.ctx.arc(
                    cx, cy,
                    wG * 0.5,
                    0, 2 * Math.PI, false);
                //cg.ctx.stroke();
                cg.ctx.fill();
            }*/
        }

        //draw pillars
        for (let cell of cells) {
            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(cell, resolution, z, viewScale) : undefined
            if (!col) continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(cell, resolution, z, viewScale) : undefined
            if (!wG || wG < 0) continue

            //height
            /** @type {number|undefined} */
            const hG = this.height ? this.height(cell, resolution, z, viewScale) : undefined
            if (!hG || hG < 0) continue

            //get offset
            //TODO use that
            //const offset = this.offset(c, resolution, z)

            //compute cell center postition
            const cx = cell.x + resolution / 2
            const cy = cell.y + resolution / 2

            //compute angle
            const dx = cx - cvx,
                dy = cy - cvy
            const a = Math.atan2(dy, dx)
            const D = Math.sqrt(dx * dx + dy * dy)
            const d = (D * hG) / (H - hG)

            if (simple) {
                //draw segment
                geoCanvas.ctx.strokeStyle = col
                geoCanvas.ctx.lineWidth = wG
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(cx, cy)
                geoCanvas.ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                geoCanvas.ctx.stroke()
            } else {
                //draw background segment
                geoCanvas.ctx.strokeStyle = this.outlineCol
                geoCanvas.ctx.lineWidth = wG + 2 * this.outlineWidthPix * z
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(cx, cy)
                geoCanvas.ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                geoCanvas.ctx.stroke()

                //draw segment
                geoCanvas.ctx.strokeStyle = col
                geoCanvas.ctx.lineWidth = wG
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(cx, cy)
                geoCanvas.ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                geoCanvas.ctx.stroke()

                //draw top circle
                geoCanvas.ctx.strokeStyle = this.outlineCol
                //cg.ctx.fillStyle = "#c08c59"
                geoCanvas.ctx.lineWidth = this.outlineWidthPix * z
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.arc(cx + d * Math.cos(a), cy + d * Math.sin(a), wG * 0.5, 0, 2 * Math.PI, false)
                geoCanvas.ctx.stroke()
                //cg.ctx.fill();
            }
        }

        //in case...
        geoCanvas.ctx.lineCap = 'butt'

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/SegmentStyle.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/style/SegmentStyle.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SegmentStyle: () => (/* binding */ SegmentStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/**
 * A style where each cell is represented by a segment whose length, width, color and orientation can vary according to statistical values.
 *
 * @module style
 * @author Julien Gaffuri
 */
class SegmentStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the color of the cell segment.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => "#EA6BAC") //(c,r,z,vs) => {}

        /** A function returning the width of the segment representing a cell, in geo unit
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.width = opts.width || ((cell, resolution) => resolution * 0.1)  //(c,r,z,vs) => {}

        /** A function returning the length of the segment representing a cell, in geo unit
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.length = opts.length || ((cell, resolution) => resolution * 0.9)  //(c,r,z,vs) => {}

        /** A function returning the orientation (in degrees) of the segment representing a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.orientation = opts.orientation || (() => 180 * Math.random()) //(c,r,z,vs) => {}
    }

    /**
     * Draw cells as segments.
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //
        geoCanvas.ctx.lineCap = 'butt'

        //conversion factor degree -> radian
        const f = Math.PI / 180

        for (let cell of cells) {
            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(cell, resolution, z, viewScale) : undefined
            if (!col) continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(cell, resolution, z, viewScale) : undefined
            if (!wG || wG < 0) continue

            //length
            /** @type {number|undefined} */
            const lG = this.length ? this.length(cell, resolution, z, viewScale) : undefined
            if (!lG || lG < 0) continue

            //orientation (in radian)
            /** @type {number} */
            const or = this.orientation(cell, resolution, z, viewScale) * f
            if (or === undefined || isNaN(or)) continue

            //get offset
            const offset = this.offset(cell, resolution, z)

            //set color and width
            geoCanvas.ctx.strokeStyle = col
            geoCanvas.ctx.lineWidth = wG

            //compute segment center postition
            const cx = cell.x + resolution / 2 + offset.dx
            const cy = cell.y + resolution / 2 + offset.dy

            //compute segment direction
            const dx = 0.5 * Math.cos(or) * lG
            const dy = 0.5 * Math.sin(or) * lG

            //draw segment
            geoCanvas.ctx.beginPath()
            geoCanvas.ctx.moveTo(cx - dx, cy - dy)
            geoCanvas.ctx.lineTo(cx + dx, cy + dy)
            geoCanvas.ctx.stroke()
        }

        //update legends
        this.updateLegends({ viewScale: viewScale, resolution: resolution, z: z, cells: cells })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/ShapeColorSizeStyle.js":
/*!***************************************************************!*\
  !*** ./node_modules/gridviz/src/style/ShapeColorSizeStyle.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShapeColorSizeStyle: () => (/* binding */ ShapeColorSizeStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/**
 * A very generic style that shows grid cells with specific color, size and shape.
 * It can be used to show variables as cell colors, cell size, cell shape, or any combination of the three visual variables.
 *
 * @module style
 * @author Joseph Davies, Julien Gaffuri
 */
class ShapeColorSizeStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the color of the cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => "#EA6BAC") //(c,r,z,vs) => {}

        /** A function returning the size of a cell in geographical unit.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.size = opts.size || ((cell, resolution) => resolution) //(c,r,z,vs) => {}

        /** A function returning the shape of a cell.
         * @type {function(import("../core/Dataset.js").Cell,number, number,object):import("../core/Style.js").Shape} */
        this.shape = opts.shape || (() => "square") //(c,r,z,vs) => {}
    }

    /**
     * Draw cells as squares, with various colors and sizes.
     * 
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     * @override
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        const r2 = resolution * 0.5
        for (let c of cells) {
            //color
            let col = this.color ? this.color(c, resolution, z, viewScale) : "black"
            if (!col || col === 'none') continue

            //size
            const size = this.size ? this.size(c, resolution, z, viewScale) : resolution
            if (!size) continue

            //shape
            const shape = this.shape ? this.shape(c, resolution, z, viewScale) : 'square'
            if (shape === 'none') continue

            //get offset
            const offset = this.offset(c, resolution, z)

            geoCanvas.ctx.fillStyle = col
            if (shape === 'square') {
                //draw square
                const d = resolution * (1 - size / resolution) * 0.5
                geoCanvas.ctx.fillRect(c.x + d + offset.dx, c.y + d + offset.dy, size, size)
            } else if (shape === 'circle') {
                //draw circle
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.arc(c.x + r2 + offset.dx, c.y + r2 + offset.dy, size * 0.5, 0, 2 * Math.PI, false)
                geoCanvas.ctx.fill()
            } else if (shape === 'donut') {
                //draw donut
                const xc = c.x + r2 + offset.dx,
                    yc = c.y + r2 + offset.dy
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(xc, yc)
                geoCanvas.ctx.arc(xc, yc, r2, 0, 2 * Math.PI)
                geoCanvas.ctx.arc(xc, yc, (1 - size / resolution) * r2, 0, 2 * Math.PI, true)
                geoCanvas.ctx.closePath()
                geoCanvas.ctx.fill()
            } else if (shape === 'diamond') {
                const s2 = size * 0.5
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(c.x + r2 - s2, c.y + r2)
                geoCanvas.ctx.lineTo(c.x + r2, c.y + r2 + s2)
                geoCanvas.ctx.lineTo(c.x + r2 + s2, c.y + r2)
                geoCanvas.ctx.lineTo(c.x + r2, c.y + r2 - s2)
                geoCanvas.ctx.fill()
            } else if (shape === 'triangle_up') {
                const dr2 = (size - resolution) / 2
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(c.x - dr2, c.y - dr2)
                geoCanvas.ctx.lineTo(c.x + r2, c.y + resolution + dr2)
                geoCanvas.ctx.lineTo(c.x + resolution + dr2, c.y - dr2)
                geoCanvas.ctx.fill()
            } else if (shape === 'triangle_down') {
                const dr2 = (size - resolution) / 2
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(c.x - dr2, c.y + resolution + dr2)
                geoCanvas.ctx.lineTo(c.x + r2, c.y - dr2)
                geoCanvas.ctx.lineTo(c.x + resolution + dr2, c.y + resolution + dr2)
                geoCanvas.ctx.fill()
            } else if (shape === 'triangle_left') {
                const dr2 = (size - resolution) / 2
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(c.x + resolution + dr2, c.y + resolution + dr2)
                geoCanvas.ctx.lineTo(c.x - dr2, c.y + r2)
                geoCanvas.ctx.lineTo(c.x + resolution + dr2, c.y - dr2)
                geoCanvas.ctx.fill()
            } else if (shape === 'triangle_right') {
                const dr2 = (size - resolution) / 2
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(c.x - dr2, c.y - dr2)
                geoCanvas.ctx.lineTo(c.x + resolution + dr2, c.y + r2)
                geoCanvas.ctx.lineTo(c.x - dr2, c.y + resolution + dr2)
                geoCanvas.ctx.fill()
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        this.updateLegends({ viewScale: viewScale, resolution: resolution, z: z, cells: cells })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/SideCategoryStyle.js":
/*!*************************************************************!*\
  !*** ./node_modules/gridviz/src/style/SideCategoryStyle.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SideCategoryStyle: () => (/* binding */ SideCategoryStyle)
/* harmony export */ });
/* harmony import */ var _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SideStyle.js */ "./node_modules/gridviz/src/style/SideStyle.js");
//@ts-check


;

/**
 * A style to show the sides of grid cells based on their different categories.
 *
 * @module style
 * @author Julien Gaffuri
 */
class SideCategoryStyle extends _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__.SideStyle {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the category code of a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number):string} */
        this.code = opts.code

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

    }

    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //build sides

        /**  @type {Array.<import('./SideStyle.js').Side>} */
        const sides = _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__.SideStyle.buildSides(cells, resolution)
        if (sides.length == 0) return

        //get side view scale
        const viewScale = this.viewScale ? this.viewScale(sides, resolution, z) : undefined

        //draw sides

        geoCanvas.ctx.lineCap = 'butt'
        for (let side of sides) {

            //get category codes for both cells
            const code1 = side.c1 ? this.code(side.c1, resolution, z) : undefined
            const code2 = side.c2 ? this.code(side.c2, resolution, z) : undefined
            if (code1 == code2) continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(side, resolution, z, viewScale) : undefined
            if (!wG || wG <= 0) continue
            const w2 = wG * 0.5

            //set width
            geoCanvas.ctx.lineWidth = wG

            //draw segment with correct orientation
            if (side.or === 'h') {
                //top line
                if (code2) {
                    geoCanvas.ctx.beginPath()
                    geoCanvas.ctx.strokeStyle = this.color[code2]
                    geoCanvas.ctx.moveTo(side.x, side.y + w2)
                    geoCanvas.ctx.lineTo(side.x + resolution, side.y + w2)
                    geoCanvas.ctx.stroke()
                }

                //bottom line
                if (code1) {
                    geoCanvas.ctx.beginPath()
                    geoCanvas.ctx.strokeStyle = this.color[code1]
                    geoCanvas.ctx.moveTo(side.x, side.y - w2)
                    geoCanvas.ctx.lineTo(side.x + resolution, side.y - w2)
                    geoCanvas.ctx.stroke()
                }
            } else {
                //right line
                if (code2) {
                    geoCanvas.ctx.beginPath()
                    geoCanvas.ctx.strokeStyle = this.color[code2]
                    geoCanvas.ctx.moveTo(side.x + w2, side.y)
                    geoCanvas.ctx.lineTo(side.x + w2, side.y + resolution)
                    geoCanvas.ctx.stroke()
                }

                //left line
                if (code1) {
                    geoCanvas.ctx.beginPath()
                    geoCanvas.ctx.strokeStyle = this.color[code1]
                    geoCanvas.ctx.moveTo(side.x - w2, side.y)
                    geoCanvas.ctx.lineTo(side.x - w2, side.y + resolution)
                    geoCanvas.ctx.stroke()
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/SideStyle.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridviz/src/style/SideStyle.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SideStyle: () => (/* binding */ SideStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/** @typedef {{ x:number, y:number, or:"v"|"h", c1:(import('../core/Dataset').Cell)|undefined, c2:(import('../core/Dataset').Cell)|undefined }} Side */

/**
 * @typedef {function(Array.<Side>,number, number):*} SideViewScale */

/**
 * @module style
 * @author Julien Gaffuri
 */
class SideStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts = {}) {
        super(opts)

        /** A function returning the color of a cell side.
         * @type {function(Side, number, number, object):string} */
        this.color = opts.color || ((side, resolution, z, sideViewScale) => '#EA6BAC')

        /** A function returning the width of a cell side, in geo unit
         * @type {function(Side, number, number, object):number} */
        this.width = opts.width || ((side, resolution, z, sideViewScale) => resolution / 5)

        /** A function returning the length of a cell side, in geo unit
         * @type {function(Side, number, number, object):number} */
        this.length = opts.length || ((side, resolution, z, sideViewScale) => resolution)

        /** Set to A or true so that the side is drawn as a diamond */
        this.diamond = opts.diamond
    }

    /**
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {number} resolution
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //build sides

        /**  @type {Array.<Side>} */
        const sides = SideStyle.buildSides(cells, resolution)
        if (sides.length == 0) return

        //get side view scale
        const viewScale = this.viewScale ? this.viewScale(sides, resolution, z) : undefined

        //draw sides

        geoCanvas.ctx.lineCap = 'butt'
        const r2 = resolution * 0.5
        for (let side of sides) {

            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(side, resolution, z, viewScale) : undefined
            if (!col || col == 'none') continue

            if (this.diamond) {

                //set color
                geoCanvas.ctx.fillStyle = col

                //draw diamond
                const x = side.x, y = side.y
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(x - r2, y)
                geoCanvas.ctx.lineTo(x, y + r2)
                geoCanvas.ctx.lineTo(x + r2, y)
                geoCanvas.ctx.lineTo(x, y - r2)
                geoCanvas.ctx.closePath()
                geoCanvas.ctx.fill()

            } else {

                //width
                /** @type {number|undefined} */
                const wG = this.width ? this.width(side, resolution, z, viewScale) : undefined
                if (!wG || wG <= 0) continue

                //length
                /** @type {number|undefined} */
                const lG = this.length ? this.length(side, resolution, z, viewScale) : undefined
                if (!lG || lG <= 0) continue
                const lG2 = lG * 0.5

                //set width
                geoCanvas.ctx.lineWidth = wG
                //set color
                geoCanvas.ctx.strokeStyle = col

                //draw segment with correct orientation
                const x = side.x, y = side.y
                geoCanvas.ctx.beginPath()
                if (side.or === "v") {
                    geoCanvas.ctx.moveTo(x, y - lG2)
                    geoCanvas.ctx.lineTo(x, y + lG2)
                } else {
                    geoCanvas.ctx.moveTo(x - lG2, y)
                    geoCanvas.ctx.lineTo(x + lG2, y)
                }
                geoCanvas.ctx.stroke()
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }



    /**
     * 
     * @param {Array.<import('../core/Dataset').Cell>} cells The cells to use to build the sides.
     * @param {number} resolution The cells resolution
     * @param {boolean} withHorizontal Set to true to build horizontal sides, false otherwise.
     * @param {boolean} withVertical Set to true to build vertical sides, false otherwise.
     * @param {boolean} center Set to true so that the side coordinate are those of its center point rather than its left/bottom point (the side x,y coordinates are those of the left point for horizontal sides, and of the bottom point for vertical sides)
     * @returns { Array.<Side> }
     */
    static buildSides(cells, resolution, withHorizontal = true, withVertical = true, center = true) {
        /** @type { Array.<Side> } */
        const sides = []

        const r2 = center ? resolution / 2 : 0

        //make horizontal sides
        //sort cells by x and y
        cells.sort((c1, c2) => (c2.x == c1.x ? c1.y - c2.y : c1.x - c2.x))
        let c1 = cells[0]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]

            if ((c1.y + resolution == c2.y) && (c1.x == c2.x))
                //cells in same column and touch along horizontal side
                //make shared side
                sides.push({
                    or: 'h',
                    x: c1.x + r2, y: c2.y,
                    c1: c1, c2: c2
                })
            else {
                //cells do not touch along horizontal side
                //make two sides: top one for c1, bottom for c2
                sides.push({
                    or: 'h',
                    x: c1.x + r2, y: c1.y + resolution,
                    c1: c1, c2: undefined
                })
                sides.push({
                    or: 'h',
                    x: c2.x + r2, y: c2.y,
                    c1: undefined, c2: c2
                })
            }

            c1 = c2
        }

        //make vertical sides
        //sort cells by y and x
        cells.sort((c1, c2) => (c2.y == c1.y ? c1.x - c2.x : c1.y - c2.y))
        c1 = cells[0]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]

            if ((c1.x + resolution == c2.x) && (c1.y == c2.y))
                //cells in same row and touch along vertical side
                //make shared side
                sides.push({
                    or: 'v',
                    x: c1.x + resolution, y: c1.y + r2,
                    c1: c1, c2: c2
                })
            else {
                //cells do not touch along vertical side
                //make two sides: right one for c1, left for c2
                sides.push({
                    or: 'v',
                    x: c1.x + resolution, y: c1.y + r2,
                    c1: c1, c2: undefined
                })
                sides.push({
                    or: 'v',
                    x: c2.x, y: c2.y + r2,
                    c1: undefined, c2: c2
                })
            }

            c1 = c2
        }
        return sides
    }

}


/***/ }),

/***/ "./node_modules/gridviz/src/style/SquareColorCategoryWebGLStyle.js":
/*!*************************************************************************!*\
  !*** ./node_modules/gridviz/src/style/SquareColorCategoryWebGLStyle.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SquareColorCategoryWebGLStyle: () => (/* binding */ SquareColorCategoryWebGLStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoringCatAdvanced_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/WebGLSquareColoringCatAdvanced.js */ "./node_modules/gridviz/src/utils/WebGLSquareColoringCatAdvanced.js");
//@ts-check


;



/**
 * Style based on webGL
 * To show cells as colored squares, from categories.
 * All cells are drawn as squares, with the same size
 *
 * @module style
 * @author Julien Gaffuri
 */
class SquareColorCategoryWebGLStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * A function returning the category code of the cell, for coloring.
         * @type {function(import('../core/Dataset.js').Cell):string} */
        this.code = opts.code

        /**
         * The dictionary (code -> color) which gives the color of each category code.
         * @type {object} */
        opts.color = opts.color || undefined

        /** @type { Array.<string> } */
        const codes = Object.keys(opts.color)

        /** @type { object } @private */
        this.catToI = {}
        for (let i = 0; i < codes.length; i++) this.catToI[codes[i]] = i + ''

        /** @type { Array.<string> } @private */
        this.colors = []
        for (const code of codes)
            this.colors.push(opts.color['' + code])

        /**
         * A function returning the size of the cells, in geographical unit. All cells have the same size.
         * @type {function(number,number):number} */
        this.size = opts.size // (resolution, z) => ...

        /**
         * @private
         * @type { WebGLSquareColoringCatAdvanced } */
        this.wgp = new _utils_WebGLSquareColoringCatAdvanced_js__WEBPACK_IMPORTED_MODULE_2__.WebGLSquareColoringCatAdvanced(this.colors)
    }

    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //add vertice and fragment data
        const r2 = resolution / 2
        let c, nb = cells.length
        const verticesBuffer = []
        const iBuffer = []
        for (let i = 0; i < nb; i++) {
            c = cells[i]
            const cat = this.code(c)
            if (cat == undefined) {
                console.log('Unexpected category: ' + cat)
                continue
            }
            /** @type {number} */
            const i_ = this.catToI[cat]
            if (isNaN(+i_)) {
                console.log('Unexpected category index: ' + cat + ' ' + i_)
                continue
            }
            verticesBuffer.push(c.x + r2, c.y + r2)
            iBuffer.push(+i_)
        }

        //create canvas and webgl renderer
        const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeWebGLCanvas)(geoCanvas.w + '', geoCanvas.h + '')
        if (!cvWGL) {
            console.error('No webGL')
            return
        }

        //draw
        const sizeGeo = this.size ? this.size(resolution, z) : resolution + 0.2 * z
        this.wgp.draw(cvWGL.gl, verticesBuffer, iBuffer, geoCanvas.getWebGLTransform(), sizeGeo / z)

        //draw in canvas geo
        geoCanvas.initCanvasTransform()
        geoCanvas.ctx.drawImage(cvWGL.canvas, 0, 0)

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z })
    }
}

/***/ }),

/***/ "./node_modules/gridviz/src/style/SquareColorWebGLStyle.js":
/*!*****************************************************************!*\
  !*** ./node_modules/gridviz/src/style/SquareColorWebGLStyle.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SquareColorWebGLStyle: () => (/* binding */ SquareColorWebGLStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoringAdvanced_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/WebGLSquareColoringAdvanced.js */ "./node_modules/gridviz/src/utils/WebGLSquareColoringAdvanced.js");
//@ts-check


;



/**
 * Style based on webGL
 * To show cells as colored squares, with computation of the colors on GPU side (faster than JavaScript side).
 * Alls squares with the same size
 *
 * @module style
 * @author Julien Gaffuri
 */
class SquareColorWebGLStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * A function returning a t value (within [0,1]) for a cell.
         * @type {function(import('../core/Dataset.js').Cell,number,number,object):number} */
        this.tFun = opts.tFun //(c,r,z,vs) => {}

        /**
         * Distribution stretching method.
         * The stretching is performed on GPU side (fragment shader).
         * @type {{ fun:string, alpha:number }} */
        this.stretching = opts.stretching

        /**
         * The sample of the color ramp.
         * The color is computed on GPU side (fragment shader) based on those values (linear interpolation).
         * @type {Array.<string>} */
        this.colors =
            opts.colors ||
            [
                'rgb(158, 1, 66)',
                'rgb(248, 142, 83)',
                'rgb(251, 248, 176)',
                'rgb(137, 207, 165)',
                'rgb(94, 79, 162)',
            ].reverse()
        if (opts.color)
            this.colors = [
                opts.color(0),
                opts.color(0.2),
                opts.color(0.4),
                opts.color(0.6),
                opts.color(0.8),
                opts.color(1),
            ]

        /**
         * Define the opacity of the style, within [0,1].
         * If this opacity is defined, the individual color opacity will be ignored.
         * @type {function(number,number):number} */
        this.opacity = opts.opacity // (r,z) => ...

        /**
         * A function returning the size of the cells, in geographical unit. All cells have the same size.
         * @type {function(number,number):number} */
        this.size = opts.size // (resolution, z) => ...
    }

    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //create canvas and webgl renderer
        //for opacity control, see: https://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html
        const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeWebGLCanvas)(
            geoCanvas.w + '',
            geoCanvas.h + '',
            this.opacity != undefined ? { premultipliedAlpha: false } : undefined
        )
        if (!cvWGL) {
            console.error('No webGL')
            return
        }

        //add vertice and fragment data
        const r2 = resolution / 2
        const verticesBuffer = []
        const tBuffer = []
        for (let cell of cells) {
            const t = this.tFun(cell, resolution, z, viewScale)
            if (t == null || t == undefined) continue
            verticesBuffer.push(cell.x + r2, cell.y + r2)
            tBuffer.push(t > 1 ? 1 : t < 0 ? 0 : t)
        }

        //compute pixel size
        const sizeGeo = this.size ? this.size(resolution, z) : resolution + 0.2 * z

        //compute opacity
        const op = this.opacity ? this.opacity(resolution, z) : undefined

        //
        const wgp = new _utils_WebGLSquareColoringAdvanced_js__WEBPACK_IMPORTED_MODULE_2__.WebGLSquareColoringAdvanced(cvWGL.gl, this.colors, this.stretching, sizeGeo / z, op)

        //draw
        wgp.draw(verticesBuffer, tBuffer, geoCanvas.getWebGLTransform())

        //draw in canvas geo
        geoCanvas.initCanvasTransform()
        geoCanvas.ctx.drawImage(cvWGL.canvas, 0, 0)

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/StrokeStyle.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/style/StrokeStyle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StrokeStyle: () => (/* binding */ StrokeStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class StrokeStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the color of the cell.
         * @type {function(import('../core/Dataset.js').Cell,number,number,object):string} */
        this.strokeColor = opts.strokeColor || (() => "#666") //(c,r,z,vs) => {}

        /** A function returning the size of a cell in geographical unit.
         * @type {function(import('../core/Dataset.js').Cell,number,number,object):number} */
        this.size = opts.size || ((cell, resolution) => resolution) //(c,r,z,vs) => {}

        /** The stroke line width in geographical unit.
         * @type {function(import('../core/Dataset.js').Cell,number,number,object):number} */
        this.strokeWidth = opts.strokeWidth || ((cell, resolution, z) => z * 1.5) //(c,r,z,vs) => {}

        /** A function returning the shape of a cell.
        * @type {function(import("../core/Dataset.js").Cell,number,number,object):import("../core/Style.js").Shape} */
        this.shape = opts.shape || (() => "square") //(c,r,z,vs) => {}
    }

    /**
     * Draw cells as squares, with various colors and size.
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        const r2 = resolution * 0.5
        for (let c of cells) {

            //color
            const col = this.strokeColor ? this.strokeColor(c, resolution, z, viewScale) : undefined
            if (!col || col === 'none') continue
            geoCanvas.ctx.strokeStyle = col

            //size - in geo unit
            const size = this.size ? this.size(c, resolution, z, viewScale) : resolution

            //width
            const wi = this.strokeWidth ? this.strokeWidth(c, resolution, z, viewScale) : 1 * z
            if (!wi || wi <= 0) continue
            geoCanvas.ctx.lineWidth = wi

            //shape
            const shape = this.shape ? this.shape(c, resolution, z, viewScale) : 'square'
            if (shape === 'none') continue

            //get offset
            const offset = this.offset(c, resolution, z)

            if (shape === 'square') {
                //draw square
                const d = resolution * (1 - size / resolution) * 0.5
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.rect(c.x + d + offset.dx, c.y + d + offset.dy, size, size)
                geoCanvas.ctx.stroke()
            } else if (shape === 'circle') {
                //draw circle
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.arc(c.x + r2 + offset.dx, c.y + r2 + offset.dy, size * 0.5, 0, 2 * Math.PI, false)
                geoCanvas.ctx.stroke()
            } else if (shape === 'diamond') {
                const s2 = size * 0.5
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(c.x + r2 - s2, c.y + r2)
                geoCanvas.ctx.lineTo(c.x + r2, c.y + r2 + s2)
                geoCanvas.ctx.lineTo(c.x + r2 + s2, c.y + r2)
                geoCanvas.ctx.lineTo(c.x + r2, c.y + r2 - s2)
                geoCanvas.ctx.lineTo(c.x + r2 - s2, c.y + r2)
                geoCanvas.ctx.stroke()
            } else if (shape === 'donut') {
                console.error('Not implemented')
            } else if (shape === 'triangle_up') {
                const dr2 = (size - resolution) / 2
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(c.x - dr2, c.y - dr2)
                geoCanvas.ctx.lineTo(c.x + r2, c.y + resolution + dr2)
                geoCanvas.ctx.lineTo(c.x + resolution + dr2, c.y - dr2)
                geoCanvas.ctx.closePath()
                geoCanvas.ctx.stroke()
            } else if (shape === 'triangle_down') {
                const dr2 = (size - resolution) / 2
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(c.x - dr2, c.y + resolution + dr2)
                geoCanvas.ctx.lineTo(c.x + r2, c.y - dr2)
                geoCanvas.ctx.lineTo(c.x + resolution + dr2, c.y + resolution + dr2)
                geoCanvas.ctx.closePath()
                geoCanvas.ctx.stroke()
            } else if (shape === 'triangle_left') {
                const dr2 = (size - resolution) / 2
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(c.x + resolution + dr2, c.y + resolution + dr2)
                geoCanvas.ctx.lineTo(c.x - dr2, c.y + r2)
                geoCanvas.ctx.lineTo(c.x + resolution + dr2, c.y - dr2)
                geoCanvas.ctx.closePath()
                geoCanvas.ctx.stroke()
            } else if (shape === 'triangle_right') {
                const dr2 = (size - resolution) / 2
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(c.x - dr2, c.y - dr2)
                geoCanvas.ctx.lineTo(c.x + resolution + dr2, c.y + r2)
                geoCanvas.ctx.lineTo(c.x - dr2, c.y + resolution + dr2)
                geoCanvas.ctx.closePath()
                geoCanvas.ctx.stroke()
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/TanakaStyle.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/style/TanakaStyle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TanakaStyle: () => (/* binding */ TanakaStyle)
/* harmony export */ });
/* harmony import */ var _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SideStyle.js */ "./node_modules/gridviz/src/style/SideStyle.js");
/* harmony import */ var _SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SquareColorCategoryWebGLStyle.js */ "./node_modules/gridviz/src/style/SquareColorCategoryWebGLStyle.js");
/* harmony import */ var _utils_scale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/scale.js */ "./node_modules/gridviz/src/utils/scale.js");
//@ts-check


;



/**
 * @see https://manifold.net/doc/mfd9/example__tanaka_contours.htm
 *
 * @module style
 * @author Julien Gaffuri
 */
class TanakaStyle {
    /**
     * @param {function(import('../core/Dataset.js').Cell):number} value Function that returns the value of a cell
     * @param {Array.<number>} breaks The break values
     * @param {Array.<string>} colors The colors, one more than the break values
     * @param {object} opts
     * @returns {Array.<import("../core/Style").Style>}
     */
    static get(value, breaks, colors, opts = {}) {

        //shadow colors
        opts.colorDark = opts.colorDark || '#111'
        opts.colorBright = opts.colorBright || '#ddd'

        /** @type { function(number, number):number } */
        opts.width = opts.width || ((sideValue, resolution, z) => {
            const minWG = 1 * z
            const maxWG = 4 * z
            const step = (maxWG - minWG) / 3
            return Math.min(minWG + (sideValue - 1) * step, maxWG)
        })

        //make classifier
        const classifier = (0,_utils_scale_js__WEBPACK_IMPORTED_MODULE_2__.classifier)(breaks)
        //make colors table
        const colorsDict = {};
        for (let i = 0; i < colors.length; i++) colorsDict[i + ""] = colors[i]

        const cellStyle = new _SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_1__.SquareColorCategoryWebGLStyle({
            code: cell => classifier(value(cell)),
            color: colorsDict
        })

        const getSideValue = (side) => {
            const cl1 = side.c1 ? classifier(value(side.c1)) : -1
            const cl2 = side.c2 ? classifier(value(side.c2)) : -1
            return cl1 - cl2
        }

        /** The side style, for the shadow effect */
        const sideStyle = new _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__.SideStyle({
            //white or black, depending on orientation and value
            color: (side) => {
                const v = getSideValue(side)
                if (v === 0) return
                if (side.or === 'v') return v < 0 ? opts.colorBright : opts.colorDark
                return v < 0 ? opts.colorDark : opts.colorBright
            },
            //width depends on the value, that is the number of classes of difference
            width: (side, resolution, z) => opts.width(Math.abs(getSideValue(side)), resolution, z)
        })

        return [cellStyle, sideStyle]
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/TextStyle.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridviz/src/style/TextStyle.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextStyle: () => (/* binding */ TextStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class TextStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the text of a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.text = opts.text || (() => 'X') //(c,r,z,vs) => {}

        /** A function returning the color of the cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => "black") //(c,r,z,vs) => {}

        /** A function returning the font size of a cell in geo unit.
         * @type {function(import('../core/Dataset.js').Cell, number, number,object):number} */
        this.fontSize = opts.fontSize || ((cell, resolution) => resolution) //(c,r,z,vs) => {}

        /** The text font family.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.fontFamily = opts.fontFamily || (() => 'Arial')

        /** The text font weight.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.fontWeight = opts.fontWeight || (() => 'bold')
    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //draw with HTML canvas
        //in screen coordinates
        geoCanvas.initCanvasTransform()

        for (let cell of cells) {
            //get cell text
            const text = this.text ? this.text(cell, resolution, z, viewScale) : undefined
            if (text == undefined || text == null || text + '' === '') continue

            //color
            const col = this.color ? this.color(cell, resolution, z, viewScale) : undefined
            if (!col) continue
            geoCanvas.ctx.fillStyle = col

            //font size
            //size - in pixel unit
            const fontSizePix = this.fontSize(cell, resolution, z, viewScale) / z
            if (!fontSizePix) continue

            //set font
            const fontFamily = this.fontFamily ? this.fontFamily(cell, resolution, z, viewScale) : 'Arial'
            const fontWeight = this.fontWeight ? this.fontWeight(cell, resolution, z, viewScale) : 'bold'
            geoCanvas.ctx.font = fontWeight + ' ' + fontSizePix + 'px ' + fontFamily

            //get offset
            const offset = this.offset(cell, resolution, z)

            //text position
            geoCanvas.ctx.textAlign = 'center'
            const tx = geoCanvas.geoToPixX(cell.x + resolution * 0.5 + offset.dx)
            const ty = geoCanvas.geoToPixY(cell.y + resolution * 0.5 + offset.dy) + fontSizePix * 0.3 //it should be 0.5 but 0.3 seems to work better

            //draw the text
            geoCanvas.ctx.fillText(text, tx, ty)
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }

    /**
     * Build a function [0,1]->string for characters legend
     *
     * @param {Array.<string>} chars
     * @param {(function(number):number)|undefined} scale
     * @returns {function(number):string}
     */
    static textScale(chars, scale = undefined) {
        const nb = chars.length
        return (t) => {
            if (scale) t = scale(t)
            if (t == 0) return ""
            if (t >= 1) return chars[nb - 1]
            return chars[Math.floor(t * nb)]
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/TimeSeriesStyle.js":
/*!***********************************************************!*\
  !*** ./node_modules/gridviz/src/style/TimeSeriesStyle.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TimeSeriesStyle: () => (/* binding */ TimeSeriesStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./node_modules/gridviz/src/core/Style.js");
//@ts-check


;

/** @typedef {"first"|"bottom"|"center"|"top"|"last"} AnchorModeYEnum */

/**
 * Show cell as timeseries chart
 * Can be used for sparkline map of https://datagistips.hypotheses.org/488
 *
 * @module style
 * @author Julien Gaffuri
 */
class TimeSeriesStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The columns of the time series, ordered in chronological order.
         * @type {Array.<string>} */
        this.ts = opts.ts

        /** A function specifying when a value should be considered as "no data" and thus not ignored. The line will have a break at these values.
         * @type {function(string):boolean} */
        this.noData = opts.noData || ((v) => v === undefined || v == "" || v === null || isNaN(+v))

        //x
        /** in geo unit
         * @type {function(import("../core/Dataset.js").Cell,number,number):number} */
        this.offsetX = opts.offsetX || ((c, r, z) => 0)
        /** @type {function(import("../core/Dataset.js").Cell,number,number):number} */
        this.width = opts.width || ((c, r, z) => r)

        //y
        /** in geo unit
         * @type {function(import("../core/Dataset.js").Cell,number,number):number} */
        this.offsetY = opts.offsetY || ((c, r, z) => 0)
        /** @type {function(import("../core/Dataset.js").Cell,number,number):number} */
        this.height = opts.height || ((c, r, z) => r)
        /** @type {function(import("../core/Dataset.js").Cell,number,number):AnchorModeYEnum} */
        this.anchorModeY = opts.anchorModeY || ((c, r, z) => "center")

        /** A function returning the width of the line, in geo unit
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.lineWidth = opts.lineWidth || ((v, r, s, z) => 1.5 * z)

        /** A function returning the color of the chart.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => "black") //(c,r,z,vs) => {}
    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //compute cell amplitude
        const getAmplitude = c => {
            let min, max
            for (let t of this.ts) {
                const val = c[t];
                if (val == undefined) continue
                if (min == undefined || val < min) min = val
                if (max == undefined || val > max) max = val
            }
            if (min == undefined) return undefined
            return max - min
        }

        //compute max amplitude
        let ampMax
        for (let c of cells) {
            const amp = getAmplitude(c)
            if (amp == undefined) continue
            if (ampMax == undefined || amp > ampMax) ampMax = amp
        }
        if (!ampMax) return

        const nb = this.ts.length

        geoCanvas.ctx.lineCap = "butt"
        for (let c of cells) {

            //line width
            /** @type {number|undefined} */
            const wG = this.lineWidth ? this.lineWidth(c, resolution, z, viewScale) : undefined
            if (!wG || wG < 0) continue

            //line color
            /** @type {string|undefined} */
            const col = this.color ? this.color(c, resolution, z, viewScale) : undefined
            if (!col) continue


            //x
            const offX = this.offsetX ? this.offsetX(c, resolution, z) : 0
            if (offX == undefined || isNaN(offX)) continue
            const w = this.width ? this.width(c, resolution, z) : resolution
            if (w == undefined || isNaN(w)) continue

            //y
            const offY = this.offsetY ? this.offsetY(c, resolution, z) : 0
            if (offY == undefined || isNaN(offY)) continue
            const h = this.height ? this.height(c, resolution, z) : resolution
            if (h == undefined || isNaN(h)) continue
            const anchY = this.anchorModeY ? this.anchorModeY(c, resolution, z) : "center"
            if (!anchY) continue

            geoCanvas.ctx.lineWidth = wG
            geoCanvas.ctx.strokeStyle = col

            //compute anchor Y figures
            let val0, y0
            if (anchY === "first") {
                //get first value
                val0 = c[this.ts[0]]
                y0 = 0
            } else if (anchY === "last") {
                //get last value
                val0 = c[this.ts[this.ts.length - 1]]
                y0 = 0
            } else if (anchY === "bottom") {
                //get min
                for (let t of this.ts) {
                    const val = +c[t];
                    if (val == undefined) continue
                    if (val0 == undefined || val < val0) val0 = val
                }
                y0 = 0
            } else if (anchY === "top") {
                //get max
                for (let t of this.ts) {
                    const val = +c[t];
                    if (val == undefined) continue
                    if (val0 == undefined || val > val0) val0 = val
                }
                y0 = resolution
            } else if (anchY === "center") {
                //get min and max
                let min, max
                for (let t of this.ts) {
                    const val = c[t];
                    if (val == undefined) continue
                    if (min == undefined || val < min) min = val
                    if (max == undefined || val > max) max = val
                }
                val0 = (+max + +min) * 0.5
                y0 = resolution / 2
            } else {
                console.log("Unexpected anchorModeY: " + anchY)
                continue;
            }

            /*/draw line
            if (val0 == undefined || isNaN(val0)) continue
            cg.ctx.beginPath()
            const sX = w / (nb - 1)
            for (let i = 0; i < nb; i++) {
                const val = c[this.ts[i]]
                if (val == undefined || isNaN(val)) break
                if (i == 0)
                    cg.ctx.moveTo(c.x + i * sX + offX, c.y + y0 + (val - val0) * h / ampMax + offY)
                else
                    cg.ctx.lineTo(c.x + i * sX + offX, c.y + y0 + (val - val0) * h / ampMax + offY)
            }
            cg.ctx.stroke()*/


            //draw line, segment by segment
            const sX = w / (nb - 1)

            //handle first point
            let v0 = c[this.ts[0]]
            if (!this.noData(v0)) {
                geoCanvas.ctx.beginPath()
                geoCanvas.ctx.moveTo(c.x + offX, c.y + y0 + (v0 - val0) * h / ampMax + offY)
            }
            //console.log(v0, isNaN(v0))

            let v1
            for (let i = 1; i < nb; i++) {
                v1 = c[this.ts[i]]

                //draw segment from v0 to v1

                //both points 'no data'
                if (this.noData(v0) && this.noData(v1)) {

                    //second point 'no data'
                } else if (!this.noData(v0) && this.noData(v1)) {
                    geoCanvas.ctx.stroke()

                    //first point 'no data'
                } else if (this.noData(v0) && !this.noData(v1)) {
                    geoCanvas.ctx.beginPath()
                    geoCanvas.ctx.moveTo(c.x + i * sX + offX, c.y + y0 + (v1 - val0) * h / ampMax + offY)

                    //both points have data: trace line
                } else {
                    geoCanvas.ctx.lineTo(c.x + i * sX + offX, c.y + y0 + (v1 - val0) * h / ampMax + offY)
                    //if it is the last point, stroke
                    if (i == nb - 1) geoCanvas.ctx.stroke()
                }
                v0 = v1
            }

        }

        //update legend, if any
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }

}



/***/ }),

/***/ "./node_modules/gridviz/src/utils/WebGLSquareColoring.js":
/*!***************************************************************!*\
  !*** ./node_modules/gridviz/src/utils/WebGLSquareColoring.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLSquareColoring: () => (/* binding */ WebGLSquareColoring)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 */
class WebGLSquareColoring {
    /**
     *
     * @param {WebGLRenderingContext} gl
     */
    constructor(gl, sizePix) {
        this.gl = gl
        this.sizePix = sizePix || 10.0

        this.program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(
            gl,
            (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
                gl,
                gl.VERTEX_SHADER,
                `
            attribute vec2 pos;
            uniform float sizePix;
            uniform mat3 mat;
            attribute vec4 color;
            varying vec4 vColor;
            void main() {
              gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
              gl_PointSize = sizePix;
              vColor = color;
            }
          `
            ),
            (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
                gl,
                gl.FRAGMENT_SHADER,
                `
            precision mediump float;
            varying vec4 vColor;
            void main(void) {
                vec4 vColor_ = vColor / 255.0;
                vColor_[3] = 255.0 * vColor_[3];
                gl_FragColor = vColor_;
            }`
            )
        )
        gl.useProgram(this.program)

        //buffer data
        this.verticesBuffer = []
        this.colorsBuffer = []
    }

    /** Add data to vertices/size/color buffers for color squares drawing */
    addPointData(xC, yC, col) {
        //convert color
        const cc = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(col)
        //const cc = {r:45,g:87,b:98,opacity:0.9}
        if (!cc) return

        //vertices
        this.verticesBuffer.push(xC, yC)
        //color
        this.colorsBuffer.push(cc.r, cc.g, cc.b, cc.opacity)
    }

    addPointData2(xC, yC, r, g, b, opacity) {
        //vertices
        this.verticesBuffer.push(xC, yC)
        //color
        this.colorsBuffer.push(r, g, b, opacity)
    }

    /**  */
    draw(transfoMat) {
        const gl = this.gl

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(this.program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //color data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.colorsBuffer), gl.STATIC_DRAW)
        var color = gl.getAttribLocation(this.program, 'color')
        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(color)

        //sizePix
        gl.uniform1f(gl.getUniformLocation(this.program, 'sizePix'), 1.0 * this.sizePix)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(this.program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, this.verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/utils/WebGLSquareColoringAdvanced.js":
/*!***********************************************************************!*\
  !*** ./node_modules/gridviz/src/utils/WebGLSquareColoringAdvanced.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLSquareColoringAdvanced: () => (/* binding */ WebGLSquareColoringAdvanced)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 * The color interpolation is computed in the fragment shader program, by the GPU, thus it is less flexible but faster.
 */
class WebGLSquareColoringAdvanced {
    //see:
    //https://webglfundamentals.org/webgl/lessons/fr/webgl-shaders-and-glsl.html#les-uniforms-dans-les-shaders-de-vertex
    //https://thebookofshaders.com/glossary/?search=mix
    //https://thebookofshaders.com/06/
    //https://thebookofshaders.com/glossary/

    /**
     *
     * @param {*} gl
     * @param {Array.<String>} colors
     * @param {{fun:string,alpha:number}} stretching
     * @param {number} sizePix
     * @param {number|undefined} globalOpacity
     */
    constructor(gl, colors, stretching, sizePix = 10, globalOpacity = undefined) {
        /** @type {WebGLRenderingContext} */
        this.gl = gl
        //gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        /** @type {WebGLShader} */
        const vShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
            gl,
            gl.VERTEX_SHADER,
            `
        attribute vec2 pos;
        uniform float sizePix;
        uniform mat3 mat;

        attribute float t;
        varying float vt;

        void main() {
          gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
          gl_PointSize = sizePix;
          vt = t;
        }
      `
        )

        //prepare fragment shader code
        //declare the uniform and other variables
        let fshString =
            '' +
            'precision mediump float;\n' +
            'varying float vt;\n' +
            'uniform float alpha;\n' +
            (() => {
                const out = []
                for (let i = 0; i < colors.length; i++) out.push('uniform vec4 c' + i + ';\n')
                return out.join('')
            })() +
            //start the main function, apply the stretching of t
            'void main(void) {\n'

        if (stretching) {
            if (stretching.fun == 'pow')
                //sPow = (t, alpha = 3) => Math.pow(t, alpha);
                fshString += '   float t = pow(vt, alpha);\n'
            else if (stretching.fun == 'powInv')
                //sPowRev = (t, alpha = 3) => 1 - Math.pow(1 - t, 1 / alpha);
                fshString += '   float t = 1.0-pow(1.0-vt, 1.0/alpha);\n'
            else if (stretching.fun == 'exp')
                //sExp = (t, alpha = 3) => alpha == 0 ? t : (Math.exp(t * alpha) - 1) / (Math.exp(alpha) - 1);
                fshString +=
                    stretching.alpha == 0
                        ? `float t = vt;`
                        : '   float t = (exp(vt * alpha) - 1.0) / (exp(alpha) - 1.0);\n'
            else if (stretching.fun == 'log')
                //sExpRev = (t, alpha = 3) => alpha == 0 ? t : 1 - (1 / alpha) * Math.log(Math.exp(alpha) * (1 - t) + t);
                fshString +=
                    stretching.alpha == 0
                        ? `float t = vt;`
                        : '   float t = 1.0 - (1.0 / alpha) * log(exp(alpha) * (1.0 - vt) + vt);\n'
            else if (stretching.fun == 'circle') {
                if (stretching.alpha == 0)
                    //if (alpha == 0) return t;
                    fshString += '   float t = vt;\n'
                else if (stretching.alpha == 1)
                    // if (alpha == 1) return Math.sqrt(2 * t - t * t);
                    fshString += '   float t = sqrt(vt * (2.0 - vt));\n'
                else {
                    //const a = alpha / (1 - alpha);
                    //return Math.sqrt(1 / (a * a) + t * (2 / a + 2 - t)) - 1 / a;
                    fshString +=
                        '   float a = alpha / (1.0 - alpha);\n' +
                        '   float t = sqrt(1.0 / (a * a) + vt * ( 2.0/a + 2.0 - vt )) - 1.0 / a;\n'
                }
            } else if (stretching.fun == 'circleInv') {
                // 1 - sCircleLow(1 - t, alpha)
                if (stretching.alpha == 0)
                    //if (alpha == 0) return t;
                    fshString += '   float t = vt;\n'
                else if (stretching.alpha == 1)
                    // if (alpha == 1) return Math.sqrt(2 * t - t * t);
                    fshString += '   float t = 1.0 - sqrt((1.0 - vt) * (1.0 + vt));\n'
                else {
                    //const a = alpha / (1 - alpha);
                    //return Math.sqrt(1 / (a * a) + (2 * t) / a + 2 * t - t * t) - 1 / a;
                    fshString +=
                        '   float a = alpha / (1.0 - alpha);\n' +
                        '   float t = 1.0 - sqrt(1.0 / (a * a) + (1.0-vt) * ( 2.0/a + 1.0 + vt )) + 1.0 / a;\n'
                }
            } else {
                console.error('Unexpected stretching function code: ' + stretching.fun)
                fshString += '   float t = vt;\n'
            }
        } else {
            fshString += '   float t = vt;\n'
        }

        //choose initial and final colors, and adjust t value
        if (colors.length == 1) fshString += '   vec4 cI=c0;\n   vec4 cF=c0;\n'
        else if (colors.length == 2) fshString += '   vec4 cI=c0;\n   vec4 cF=c1;\n'
        else {
            const nb = colors.length - 1
            const nbs = nb + '.0'
            fshString += '   vec4 cI;\n'
            fshString += '   vec4 cF;\n'
            fshString += '   if(t<1.0/' + nbs + ') { cI=c0; cF=c1; t=t*' + nbs + '; }\n'
            for (let i = 2; i < nb; i++)
                fshString +=
                    '   else if(t<' +
                    i +
                    '.0/' +
                    nbs +
                    ') { cI=c' +
                    (i - 1) +
                    '; cF=c' +
                    i +
                    '; t=' +
                    nbs +
                    '*t-' +
                    (i - 1) +
                    '.0; }\n'
            fshString +=
                '   else { cI=c' + (nb - 1) + '; cF=c' + nb + '; t=' + nbs + '*t-' + (nb - 1) + '.0; }\n'
        }

        //one single color
        if (colors.length == 1) fshString += '   gl_FragColor = vec4(c0[0], c0[1], c0[2], c0[3]);}\n'
        //set interpolated color, between initial and final one
        else fshString += '   gl_FragColor = mix(cI, cF, t);}\n'

        //console.log(fshString)

        /** @type {WebGLShader} */
        const fShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.FRAGMENT_SHADER, fshString)

        /** @type {WebGLProgram} */
        this.program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(gl, vShader, fShader)
        gl.useProgram(this.program)

        //set uniforms

        //sizePix
        //TODO: bug here. Seems to be limited to some threshold value (around 250).
        gl.uniform1f(gl.getUniformLocation(this.program, 'sizePix'), 1.0 * sizePix)

        //stretching alpha factor
        gl.uniform1f(gl.getUniformLocation(this.program, 'alpha'), stretching ? 1.0 * stretching.alpha : 0.0)

        //colors
        for (let i = 0; i < colors.length; i++) {
            const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(colors[i])

            let opacity = c.opacity
            if (c.opacity == 1 && globalOpacity != undefined) opacity = globalOpacity

            gl.uniform4fv(gl.getUniformLocation(this.program, 'c' + i), [
                +c.r / 255.0,
                +c.g / 255.0,
                +c.b / 255.0,
                +opacity,
            ])
        }
    }

    /**  */
    draw(verticesBuffer, tBuffer, transfoMat) {
        const gl = this.gl
        const program = this.program

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //t data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tBuffer), gl.STATIC_DRAW)
        const t = gl.getAttribLocation(program, 't')
        gl.vertexAttribPointer(t, 1, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(t)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/utils/WebGLSquareColoringCatAdvanced.js":
/*!**************************************************************************!*\
  !*** ./node_modules/gridviz/src/utils/WebGLSquareColoringCatAdvanced.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLSquareColoringCatAdvanced: () => (/* binding */ WebGLSquareColoringCatAdvanced)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 * Color based on categories.
 */
class WebGLSquareColoringCatAdvanced {
    /**
     * @param {Array.<string>} colors
     */
    constructor(colors) {
        /**
         * @type {Array.<string>} */
        this.colors = colors

        /** Vector shader program
         * @type {string} */
        this.vshString = `
        attribute vec2 pos;
        uniform float sizePix;
        uniform mat3 mat;

        attribute float i;
        varying float vi;

        void main() {
          gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
          gl_PointSize = sizePix;
          vi = i;
        }
        `

        //prepare fragment shader code
        //declare the uniform and other variables
        const out = []
        out.push('precision mediump float;\nvarying float vi;\n')
        //add color uniforms
        out.push('uniform vec4')
        for (let i = 0; i < colors.length; i++) {
            if (i > 0) out.push(',')
            out.push(' c' + i)
        }
        out.push(';\n')
        //start the main function
        out.push('void main(void) {\n')
        //choose color i
        for (let i = 0; i < colors.length; i++) {
            if (i > 0) out.push('else ')
            out.push('if(vi==')
            out.push(i)
            out.push('.0) gl_FragColor = vec4(c')
            out.push(i)
            out.push('[0], c')
            out.push(i)
            out.push('[1], c')
            out.push(i)
            out.push('[2], c')
            out.push(i)
            out.push('[3]);\n')
        }
        out.push('else gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}')
        /** Fragment shader program
         * @type {string} */
        this.fshString = out.join('')
    }

    /**  */
    draw(gl, verticesBuffer, iBuffer, transfoMat, sizePix = 10) {
        /** @type {WebGLShader} */
        const vShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.VERTEX_SHADER, this.vshString)

        /** @type {WebGLShader} */
        const fShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.FRAGMENT_SHADER, this.fshString)

        /** @type {WebGLProgram} */
        const program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(gl, vShader, fShader)
        gl.useProgram(program)

        //set uniforms

        //sizePix
        gl.uniform1f(gl.getUniformLocation(program, 'sizePix'), 1.0 * sizePix)

        //colors
        for (let i = 0; i < this.colors.length; i++) {
            const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(this.colors[i])
            gl.uniform4fv(gl.getUniformLocation(program, 'c' + i), [
                +c.r / 255.0,
                +c.g / 255.0,
                +c.b / 255.0,
                +c.opacity,
            ])
        }

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //i data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(iBuffer), gl.STATIC_DRAW)
        const i = gl.getAttribLocation(program, 'i')
        gl.vertexAttribPointer(i, 1, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(i)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/utils/chernoff.js":
/*!****************************************************!*\
  !*** ./node_modules/gridviz/src/utils/chernoff.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadChernoffFacesImages: () => (/* binding */ loadChernoffFacesImages)
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils.js */ "./node_modules/gridviz/src/utils/utils.js");
//@ts-check


;

//

/**
 * Load chernoff images
 * See for example: https://github.com/jgaffuri/chernoff-faces
 * @param {object} out 
 * @param {string} baseURL 
 * @param {function|undefined} callback 
 * @returns 
 */
async function loadChernoffFacesImages(out, baseURL, callback = undefined) {
    out = out || {}
    for (let s of ["f", "m"])
        for (let a of ["y", "m", "o"])
            for (let i = 0; i <= 2; i++)
                out[s + a + i] = await (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.loadImage)(baseURL + (s + a + i) + ".png")
    if (callback) callback()
    return out
}


/***/ }),

/***/ "./node_modules/gridviz/src/utils/scale.js":
/*!*************************************************!*\
  !*** ./node_modules/gridviz/src/utils/scale.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   classifier: () => (/* binding */ classifier),
/* harmony export */   colorClassifier: () => (/* binding */ colorClassifier),
/* harmony export */   discreteColors: () => (/* binding */ discreteColors),
/* harmony export */   viewScale: () => (/* binding */ viewScale),
/* harmony export */   viewScaleColor: () => (/* binding */ viewScaleColor),
/* harmony export */   viewScaleColorQuantile: () => (/* binding */ viewScaleColorQuantile),
/* harmony export */   viewScaleCombination: () => (/* binding */ viewScaleCombination),
/* harmony export */   viewScaleQuantile: () => (/* binding */ viewScaleQuantile)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
//@ts-check


;


/**
 * A scale is simply a function that map a domain to a range.
 * @typedef {function(number):number} Scale */

/**
 * A scale whose range is a color (string).
* @typedef {function(number):string} ColorScale */


/**
 * @module utils
 */


/**
 * Generic function for view scale - continuous or discrete
 * 
 * @param {{ valueFunction:function(import("../core/Dataset").Cell):number, minValue?:number, minSizePix?:number, maxSizeFactor?:number, range?:[number, number], domain?:[number, number], stretching?:function(number):number, classNumber?:number}} opts 
 * @returns {function(Array.<import("../core/Dataset").Cell>):Scale}
 */
const viewScale = (opts) => {
    const valueFunction = opts.valueFunction
    const minValue = opts.minValue || 0
    const minSizePix = opts.minSizePix || 0
    const maxSizeFactor = opts.maxSizeFactor || 1
    const stretching = opts.stretching
    const range_ = opts.range
    const domain_ = opts.domain
    const classNumber = opts.classNumber
    return (cells, resolution, z) => {
        const domain = domain_ || [minValue, (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(cells, valueFunction)]
        const range = range_ || [minSizePix * z, resolution * maxSizeFactor]
        const domainSize = domain[1] - domain[0], domainMin = domain[0]
        const rangeSize = range[1] - range[0], rangeMin = range[0]
        return t => {
            //scale to [0,1]
            t = (t - domainMin) / domainSize
            //stretch
            if (stretching) t = stretching(t)
            //classify
            if (classNumber) t = t == 1 ? 1 : Math.floor(t * (classNumber)) / (classNumber - 1)
            //scale to range
            return rangeMin + t * rangeSize
        }
    }
}



/**
 * Generic function for view scale - quantile
 * 
 * @param {{ valueFunction:function(import("../core/Dataset").Cell):number, classNumber?:number, minSizePix?:number, maxSizeFactor?:number }} opts 
 * @returns {function(Array.<import("../core/Dataset").Cell>):Scale}
 */
const viewScaleQuantile = (opts) => {
    const valueFunction = opts.valueFunction
    const classNumber = opts.classNumber || 12
    const minSizePix = opts.minSizePix || 1
    const maxSizeFactor = opts.maxSizeFactor || 1
    const scale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__["default"])()
    return (cells, resolution, z) => {
        scale.domain(cells.map(valueFunction))
        const minSizeGeo = minSizePix * z, maxSizeGeo = resolution * maxSizeFactor
        scale.range(Array.from({ length: classNumber }, (_, i) => minSizeGeo + i * (maxSizeGeo - minSizeGeo) / (classNumber - 1)))
        scale.breaks = scale.quantiles()
        scale.values = scale.range()
        return scale;
    }
}






/**
 * Generic function for color view scale - continuous or discrete
 * 
 * @param {{ valueFunction:function(import("../core/Dataset").Cell):number, colorScale?:function(number):string, colors?:Array.<string>, stretching?:function(number):number }} opts 
 * @returns {function(Array.<import("../core/Dataset").Cell>):ColorScale}
 */
const viewScaleColor = (opts) => {
    const valueFunction = opts.valueFunction
    const stretching = opts.stretching
    let colorScale = opts.colorScale || (() => "purple")

    //discrete colors case: build continuous color scale from discrete ones.
    const nbClass = opts.colors?.length
    if (opts.colors && nbClass)
        colorScale = t => opts.colors[t == 1 ? nbClass - 1 : Math.floor(t * nbClass)]

    return (cells) => {
        if (cells.length == 0 || !cells) return
        /** @type {[undefined, undefined] | [number, number]} */
        const domain = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(cells, valueFunction)
        if (domain[0] == undefined) return
        const domainSize = domain[1] - domain[0]
        const scale = t => {
            //scale to [0,1]
            t = (t - domain[0]) / domainSize
            //stretch
            if (stretching) t = stretching(t)
            return colorScale(t)
        }
        //function that return the domain value from the [0,1] range.
        scale.invert = t => {
            if (stretching) t = stretching.invert(t)
            return domain[0] + t * domainSize
        }
        //discrete colors: return the breaks
        if (opts.colors && nbClass) {
            scale.breaks = []
            for (let i = 1; i < nbClass; i++)
                scale.breaks.push(scale.invert(i / nbClass))
        }

        return scale;
    }
}





/**
 * Generic function for color view scale - quantile
 * 
 * @param {{ valueFunction:function(import("../core/Dataset").Cell):number, classNumber?:number, colors?:Array.<string>, colorScale?:function(number):string }} opts 
 * @returns {function(Array.<import("../core/Dataset").Cell>):ColorScale}
 */
const viewScaleColorQuantile = (opts) => {
    const valueFunction = opts.valueFunction
    const classNumber = opts.classNumber || 12

    let colors = opts.colors
    if (opts.colorScale) colors = discreteColors(opts.colorScale, classNumber)
    colors = colors || Array.from({ length: classNumber }, (_, i) => "rgb(" + Math.floor(255 * i / (classNumber - 1)) + ",150,150)")

    const scale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__["default"])().range(colors)
    return (cells) => {
        scale.domain(cells.map(valueFunction));
        scale.breaks = scale.quantiles()
        scale.colors = colors
        return scale;
    }
}




/**
 * Combine view scale functions
 * 
 * @param {*} obj 
 * @returns {function}
 */
const viewScaleCombination = (obj) => {
    //obj: prop and a function to call
    return (cells, resolution, z) => {
        const out = {}
        for (const p in obj) { out[p] = obj[p](cells, resolution, z) }
        return out
    }
}






/**
 * Return a classifier function from break values.
 * The classifier function returns the class id (from 0 to breaks.length) from a value to classifiy.
 * @param {Array.<number>} breaks the breaks
 */
function classifier(breaks) {
    const bl = breaks.length
    const classifier = value => {
        let i = 0
        while (i < bl) {
            const break_ = breaks[i]
            if (value <= break_) return i
            i++
        }
        return i
    }
    classifier.breaks = breaks
    return classifier
}



/**
 * Return a color classifier function from break values.
 * The classifier function returns the color from a value to classifiy.
 * There should be one color more than break values.
 * @param {Array.<number>} breaks the breaks
 * @param {Array.<string>} colors the colors
 */
function colorClassifier(breaks, colors) {
    const classifier_ = classifier(breaks)
    const colorClassifier = value => colors[classifier_(value)]
    colorClassifier.breaks = breaks
    colorClassifier.colors = colors
    return colorClassifier
}

/**
 * Make array of colors from a colorScale.
 * It is a kind of sampling, or un-interpolation
 * 
 * @param {function(number):string} colorScale 
 * @param {number} nb 
 */
function discreteColors(colorScale, nb) {
    if (nb == 1) return [colorScale(0.5)]
    const out = []
    for (let i = 0; i < nb; i++)
        out.push(colorScale(i / (nb - 1)))
    return out
}


/***/ }),

/***/ "./node_modules/gridviz/src/utils/stretching.js":
/*!******************************************************!*\
  !*** ./node_modules/gridviz/src/utils/stretching.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circularInverseScale: () => (/* binding */ circularInverseScale),
/* harmony export */   circularScale: () => (/* binding */ circularScale),
/* harmony export */   exponentialScale: () => (/* binding */ exponentialScale),
/* harmony export */   logarithmicScale: () => (/* binding */ logarithmicScale),
/* harmony export */   powerInverseScale: () => (/* binding */ powerInverseScale),
/* harmony export */   powerScale: () => (/* binding */ powerScale)
/* harmony export */ });
//@ts-check


/**
 * @module utils
 */


//TODO invert for circular
//TODO use Math.sqrt
//TODO validate


/**
 * Some function [0,1]->[0,1] to stretch range of values.
 * @see https://github.com/eurostat/gridviz/blob/master/docs/reference.md#stretching
 * @see https://observablehq.com/@jgaffuri/stretching
 */

//identity function
const identity = t => t
identity.invert = identity


/**
 * @param {number} base 
 * @returns {function(number):number}
 */
const exponentialScale = (base = 3) => {
    if (base == 0) return identity
    const a = (Math.exp(base) - 1)
    const f = t => (Math.exp(t * base) - 1) / a
    f.invert = t => Math.log(a * t + 1) / base
    return f
}

/**
 * @param {number} base 
 * @returns {function(number):number}
 */
const logarithmicScale = (base = 3) => {
    if (base == 0) return identity
    const a = Math.exp(base), b = 1 - a
    const f = t => 1 - Math.log(a + t * b) / base
    f.invert = t => (Math.exp((1 - t) * base) - a) / b
    return f
}





/**
 * @param {number} exponent 
 * @returns {function(number):number}
 */
const powerScale = (exponent = 3) => {
    if (exponent == 1) return identity
    //TODO if (exponent == 0.5) return Math.sqrt
    const f = t => Math.pow(t, exponent)
    const a = 1 / exponent
    f.invert = t => Math.pow(t, a)
    return f
}

/**
 * @param {number} exponent 
 * @returns {function(number):number}
 */
const powerInverseScale = (exponent = 3) => {
    if (exponent == 1) return identity
    //TODO if (exponent == 2) return t => 1 - Math.sqrt(1 - t)
    const a = 1 / exponent
    const f = t => 1 - Math.pow(1 - t, a)
    f.invert = t => 1 - Math.pow(1 - t, exponent)
    return f
}




/**
 * @param {number} circularity 
 * @returns {function(number):number}
 */
const circularScale = (circularity = 0.8) => {
    if (circularity == 0) return identity
    if (circularity == 1) return t => Math.sqrt(t * (2 - t))
    else {
        const a = circularity / (1 - circularity)
        return t => Math.sqrt(1 / (a * a) + t * (2 / a + 2 - t)) - 1 / a
    }
}

/**
 * @param {number} circularity 
 * @returns {function(number):number}
 */
const circularInverseScale = (circularity = 0.8) => {
    if (circularity == 0) return identity
    const f = circularScale(circularity)
    return t => 1 - f(1 - t)
}





//test
/*
const test = (f, fun, a, err = 1e-12) => {
    for (let t = 0; t <= 1; t += 1 / 50) {
        const er = t - f.invert(f(t))
        if (Math.abs(er) < err) continue
        console.log(fun, a, er)
    }
}

for (let fun of [powerScale, powerInverseScale])
    for (let exp = -30; exp <= 50; exp += 1) {
        if (exp == 0) continue
        const f = fun(exp)
        test(f, fun, exp)
    }


for (let fun of [exponentialScale, logarithmicScale])
    for (let base = -20; base <= 20; base += 1) {
        //if (exp == 0) continue
        const f = fun(base)
        test(f, fun, base, 1e-10)
    }
*/

/***/ }),

/***/ "./node_modules/gridviz/src/utils/trivariate.js":
/*!******************************************************!*\
  !*** ./node_modules/gridviz/src/utils/trivariate.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   trivariateClassifier: () => (/* binding */ trivariateClassifier),
/* harmony export */   trivariateColorClassifier: () => (/* binding */ trivariateColorClassifier)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/lab.js");
//@ts-check


;



const trivariateClassifier = (properties, totalFunction, opts = {}) => {

    //the three properties
    const p0 = properties[0], p1 = properties[1], p2 = properties[2]

    //the classifier center point. sum must be equal to 1
    const [c0, c1, c2] = opts.center || [1 / 3, 1 / 3, 1 / 3]

    //parameter to decide wether to use mixed classes m0, m1, m2.
    const withMixedClasses = opts.withMixedClasses != undefined ? opts.withMixedClasses : true

    //paramerter decide wether to use a central class, and the size of this central class.
    //set to 0 or undefined for not showing any central class. Set to 1 for a central class that contains the mix classes
    const cc = opts.centerCoefficient ? 1 - opts.centerCoefficient : undefined

    //the output classifier method
    const fun = c => {
        //get total
        const tot = totalFunction(c)
        if (!tot) return undefined
        //compute shares
        const [s0, s1, s2] = [+c[p0] / tot, +c[p1] / tot, +c[p2] / tot]

        //class 0
        if (s0 >= c0 && s1 <= c1 && s2 <= c2) {
            //central class near class 0
            if (cc != undefined && (s2 - c2) * (c1 - cc * c1) >= (s1 - cc * c1) * (cc * c2 - c2))
                return "center"
            return "0"
        }
        //class 1
        if (s0 <= c0 && s1 >= c1 && s2 <= c2) {
            //central class near class 1
            if (cc != undefined && (s2 - c2) * (c0 - cc * c0) >= (s0 - cc * c0) * (cc * c2 - c2))
                return "center"
            return "1"
        }
        //class 2
        if (s0 <= c0 && s1 <= c1 && s2 >= c2) {
            //central class near class 2
            if (cc != undefined && (s1 - c1) * (c0 - cc * c0) >= (s0 - cc * c0) * (cc * c1 - c1))
                return "center"
            return "2"
        }
        //middle class 0 - intersection class 1 and 2
        if (s0 <= c0 && s1 >= c1 && s2 >= c2) {
            //central class
            if (cc != undefined && s0 > cc * c0) return "center"
            if (withMixedClasses) return "m0"
            return s1 > s2 ? "1" : "2"
        }
        //middle class 1 - intersection class 0 and 1
        if (s0 >= c0 && s1 <= c1 && s2 >= c2) {
            //central class
            if (cc != undefined && s1 > cc * c1) return "center"
            if (withMixedClasses) return "m1"
            return s0 > s2 ? "0" : "2"
        }
        //middle class 2 - intersection class 0 and 1
        if (s0 >= c0 && s1 >= c1 && s2 <= c2) {
            //central class
            if (cc != undefined && s2 > cc * c2) return "center"
            if (withMixedClasses) return "m2"
            return s1 > s0 ? "1" : "0"
        }
        //should not happen
        return "unknown"
    }

    //attach information to output function
    fun.center = [c0, c1, c2]
    fun.centerCoefficient = opts.centerCoefficient

    return fun
}



const trivariateColorClassifier = (properties, totalFunction, colors, opts = {}) => {

    //the three colors
    const [color0, color1, color2] = colors || ["red", "green", "blue"]

    //the color interpolation function
    const colorInterpolation = opts.colorInterpolation || d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["default"]

    //parameter to decide wether to use mixed classes.
    const withMixedClasses = opts.withMixedClasses != undefined ? opts.withMixedClasses : true
    //https://d3js.org/d3-interpolate/color
    const mixColorFunction = (color1, color2) => colorInterpolation(color1, color2)(0.5)
    //the colors corresponding to the mixed classes
    const [mixColor0, mixColor1, mixColor2] = opts.mixedColors || withMixedClasses ? [mixColorFunction(color1, color2), mixColorFunction(color0, color2), mixColorFunction(color0, color1)] : []

    //the central color, used for the central class, if any. The central class is the class of relatively balanced values, around the center point
    const centerColor = opts.centerColor || colorInterpolation(mixColorFunction(color0, color1), color2)(0.333)

    //make classifier
    const classifier = trivariateClassifier(properties, totalFunction, opts)

    //the output color classifier method
    const fun = c => {
        const cla = classifier(c)
        if (cla == "0") return color0
        if (cla == "1") return color1
        if (cla == "2") return color2
        if (cla == "m0") return mixColor0
        if (cla == "m1") return mixColor1
        if (cla == "m2") return mixColor2
        if (cla == "center") return centerColor
        return opts.defaultColor || "black"
    }
    fun.center = classifier.center
    fun.centerCoefficient = opts.centerCoefficient
    fun.colors = [color0, color1, color2]
    fun.mixColors = [mixColor0, mixColor1, mixColor2]
    fun.centerColor = centerColor

    return fun
}






/*
const orderedIndexesDec = arr => [...arr.keys()].sort((a, b) => arr[b] - arr[a]);
const orderedIndexesInc = arr => [...arr.keys()].sort((a, b) => arr[a] - arr[b]);

export const trivariateClassifier = (properties, totalFunction, opts = {}) => {
    const lowThreshold = opts.lowThreshold || [1 / 3, 1 / 3, 1 / 3]
    const highThreshold = opts.highThreshold || [2 / 3, 2 / 3, 2 / 3]
    const colors = opts.colors || ["red", "green", "blue"]
    const colorInterpolation = opts.colorInterpolation || interpolateLab

    //https://d3js.org/d3-interpolate/color
    const middleColorFunction = (color1, color2) => colorInterpolation(color1, color2)(0.5)
    const middleColors = opts.middleColors || [middleColorFunction(colors[1], colors[2]), middleColorFunction(colors[0], colors[2]), middleColorFunction(colors[0], colors[1])]
    const centerColor = opts.centerColor || colorInterpolation(middleColors[2], colors[2])(0.333)

    const high_ = orderedIndexesDec(highThreshold)
    const low_ = orderedIndexesInc(lowThreshold)

    const p0 = properties[0], p1 = properties[1], p2 = properties[2]
    const fun = c => {
        //get total
        const tot = totalFunction(c)
        if (!tot) return undefined
        //compute shares
        const shares = [+c[p0] / tot, +c[p1] / tot, +c[p2] / tot]
        //return colors
        //start first with the extreme high (triangles): from the larger value (small triangle) to the lower value (large triangle)
        for (let i of high_) if (shares[i] > highThreshold[i]) return colors[i]
        //then draw the extreme low (trapeziums): from the lower value (small trapeziums) to the larger values (large trapezium)
        for (let i of low_) if (shares[i] < lowThreshold[i]) return middleColors[i]
        //else central color
        return centerColor
    }
    fun.lowThreshold = lowThreshold
    fun.highThreshold = highThreshold
    fun.colors = colors
    fun.middleColors = middleColors
    fun.centerColor = centerColor
    fun.lowIndex = low_
    fun.highIndex = high_
    return fun
}
*/

/*
export const trivariateClassifier3 = (properties, totalFunction, opts = {}) => {
    const [a01, a12, a20] = opts.thresholds || [1/3, 1/3, 1/3]
    const [c0, c1, c2] = opts.colors || ["red", "green", "blue"]
    const centerColor = opts.centerColor || "gray"

    const fff = a => a == 1 ? Infinity : a / (1 - a)
    const c01 = fff(a01), c12 = fff(a12), c20 = fff(a20)

    const p0 = properties[0], p1 = properties[1], p2 = properties[2]
    const fun = c => {
        //get total
        const tot = totalFunction(c)
        if (!tot) return undefined
        //compute shares
        const [s0, s1, s2] = [+c[p0] / tot, +c[p1] / tot, +c[p2] / tot]
        //return colors
        if (s0 * c01 > s1 && s0 > s2 * c20) return c0
        else if (s1 > s0 * c01 && s1 * c12 > s2) return c1
        else if (s2 * c20 > s0 && s2 > s1 * c12) return c2
        else return centerColor
    }
    fun.colors = [c0, c1, c2]
    fun.centerColor = centerColor
    return fun
}
*/


/***/ }),

/***/ "./node_modules/gridviz/src/utils/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/gridviz/src/utils/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getClass: () => (/* binding */ getClass),
/* harmony export */   loadImage: () => (/* binding */ loadImage),
/* harmony export */   nice: () => (/* binding */ nice)
/* harmony export */ });
//@ts-check


/**
 * Get the class id from a value and class break values
 *
 * @param {number} v the value
 * @param {Array.<number>} breaks the breaks
 * @returns The class id, from 0 to breaks.length
 * @deprecated use getClassifier instead
 */
function getClass(v, breaks) {
    if (!breaks) return
    if (breaks.length == 0) return 0
    if (v <= breaks[0]) return 0
    for (let i = 1; i < breaks.length; i++) if (breaks[i - 1] < v && v <= breaks[i]) return i
    return breaks.length
}



//take 'nice' value (power of ten, or multiple)
function nice(v, multiples = [8, 6, 5, 4, 2.5, 2]) {
    //compute bigger power of ten below
    const v_ = Math.pow(10, Math.floor(Math.log10(v)))
    for (let multiple of multiples)
        if (v_ * multiple <= v) return v_ * multiple
    return v_
}


function loadImage(src) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function () { resolve(img); };
        img.onerror = function () { reject(new Error('Error loading image')); };
        img.src = src;
    });
}



/*
export let monitor = false

let previousDate
export function monitorDuration(message) {
    const nowDate = Date.now()

    //first call
    if (!previousDate) {
        previousDate = nowDate
        console.log(previousDate, message)
        return
    }

    const d = nowDate - previousDate
    previousDate = nowDate
    console.log(d, message)
}
*/


/***/ }),

/***/ "./node_modules/gridviz/src/utils/webGLUtils.js":
/*!******************************************************!*\
  !*** ./node_modules/gridviz/src/utils/webGLUtils.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkWebGLSupport: () => (/* binding */ checkWebGLSupport),
/* harmony export */   createShader: () => (/* binding */ createShader),
/* harmony export */   initShaderProgram: () => (/* binding */ initShaderProgram),
/* harmony export */   makeWebGLCanvas: () => (/* binding */ makeWebGLCanvas)
/* harmony export */ });
//@ts-check


/**
 * @param {string} width
 * @param {string} height
 * @param {object} opts
 * @returns {{canvas:HTMLCanvasElement, gl:WebGLRenderingContext}}
 */
function makeWebGLCanvas(width, height, opts={}) {
    const canvas = document.createElement('canvas')
    canvas.setAttribute('width', width)
    canvas.setAttribute('height', height)
    /** @type {WebGLRenderingContext} */
    const gl = canvas.getContext('webgl', opts)
    if (!gl) {
        throw new Error('Unable to initialize WebGL. Your browser or machine may not support it.')
    }
    return { canvas: canvas, gl: gl }
}

/**
 * Initialize a shader program, so WebGL knows how to draw our data
 *
 * @param {WebGLRenderingContext} gl
 * @param  {...WebGLShader} shaders
 * @returns {WebGLProgram}
 */
function initShaderProgram(gl, ...shaders) {
    /** @type {WebGLProgram|null} */
    const program = gl.createProgram()
    if (program == null) throw new Error('Cannot create webGL program')
    for (const shader of shaders) gl.attachShader(program, shader)
    gl.linkProgram(program)
    if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program
    throw new Error(gl.getProgramInfoLog(program) || 'Cannot create webGL program (2)')
}

/**
 * Creates a shader of the given type, uploads the source and compiles it.
 *
 * @param {WebGLRenderingContext} gl
 * @param {number} type
 * @param  {...string} sources
 * @returns {WebGLShader}
 */
function createShader(gl, type, ...sources) {
    /** @type {WebGLShader|null} */
    const shader = gl.createShader(type)
    if (shader == null) throw new Error('Cannot create webGL shader')
    gl.shaderSource(shader, sources.join('\n'))
    gl.compileShader(shader)
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader
    throw new Error(gl.getShaderInfoLog(shader) || 'Cannot create webGL shader (2)')
}

/**
 * Check if webGL is supported
 *
 * @returns {boolean}
 */
function checkWebGLSupport() {
    try {
        const canvas = document.createElement('canvas')
        return !!(!!window.WebGLRenderingContext &&
            (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')))
    } catch (err) {
        return false
    }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/assemble.js":
/*!************************************************!*\
  !*** ./node_modules/hyparquet/src/assemble.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assembleLists: () => (/* binding */ assembleLists),
/* harmony export */   assembleNested: () => (/* binding */ assembleNested)
/* harmony export */ });
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");


/**
 * Dremel-assembly of arrays of values into lists
 *
 * Reconstructs a complex nested structure from flat arrays of definition and repetition levels,
 * according to Dremel encoding.
 *
 * @typedef {import('./types.d.ts').DecodedArray} DecodedArray
 * @typedef {import('./types.d.ts').FieldRepetitionType} FieldRepetitionType
 * @param {number[] | undefined} definitionLevels
 * @param {number[]} repetitionLevels
 * @param {DecodedArray} values
 * @param {(FieldRepetitionType | undefined)[]} repetitionPath
 * @param {number} maxDefinitionLevel definition level that corresponds to non-null
 * @param {number} maxRepetitionLevel repetition level that corresponds to a new row
 * @returns {DecodedArray} array of values
 */
function assembleLists(
  definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel, maxRepetitionLevel
) {
  const n = definitionLevels?.length || repetitionLevels.length
  let valueIndex = 0
  /** @type {any[]} */
  const output = []

  // Track state of nested structures
  const containerStack = [output]
  let currentContainer = output
  let currentDepth = 0 // schema depth
  let currentDefLevel = 0 // list depth
  let currentRepLevel = 0

  for (let i = 0; i < n; i++) {
    // assert(currentDefLevel === containerStack.length - 1)
    const def = definitionLevels?.length ? definitionLevels[i] : maxDefinitionLevel
    const rep = repetitionLevels[i]

    // Pop up to start of rep level
    while (currentDepth && (rep < currentRepLevel || repetitionPath[currentDepth] !== 'REPEATED')) {
      if (repetitionPath[currentDepth] !== 'REQUIRED') {
        containerStack.pop()
        currentDefLevel--
      }
      if (repetitionPath[currentDepth] === 'REPEATED') currentRepLevel--
      currentDepth--
    }
    // @ts-expect-error won't be empty
    currentContainer = containerStack.at(-1)

    // Go deeper to end of definition level
    while (
      (currentDepth < repetitionPath.length - 2 || repetitionPath[currentDepth + 1] === 'REPEATED') &&
      (currentDefLevel < def || repetitionPath[currentDepth + 1] === 'REQUIRED')
    ) {
      currentDepth++
      if (repetitionPath[currentDepth] !== 'REQUIRED') {
        /** @type {any[]} */
        const newList = []
        currentContainer.push(newList)
        currentContainer = newList
        containerStack.push(newList)
        currentDefLevel++
      }
      if (repetitionPath[currentDepth] === 'REPEATED') currentRepLevel++
    }

    // Add value or null based on definition level
    if (def === maxDefinitionLevel) {
      // assert(currentDepth === maxDefinitionLevel || currentDepth === repetitionPath.length - 2)
      currentContainer.push(values[valueIndex++])
    } else if (currentDepth === repetitionPath.length - 2) {
      currentContainer.push(null)
    } else {
      currentContainer.push([])
    }
  }

  // Handle edge cases for empty inputs or single-level data
  if (output.length === 0) {
    if (values.length > 0 && maxRepetitionLevel === 0) {
      return values // flat list
    }
    // return max definition level of nested lists
    for (let i = 0; i < maxDefinitionLevel; i++) {
      /** @type {any[]} */
      const newList = []
      currentContainer.push(newList)
      currentContainer = newList
    }
  }

  return output
}

/**
 * Assemble a nested structure from subcolumn data.
 * https://github.com/apache/parquet-format/blob/apache-parquet-format-2.10.0/LogicalTypes.md#nested-types
 *
 * @typedef {import('./types.d.ts').SchemaTree} SchemaTree
 * @param {Map<string, any[]>} subcolumnData
 * @param {SchemaTree} schema top-level schema element
 * @param {number} [depth] depth of nested structure
 */
function assembleNested(subcolumnData, schema, depth = 0) {
  const path = schema.path.join('.')
  const optional = schema.element.repetition_type === 'OPTIONAL'
  const nextDepth = optional ? depth + 1 : depth

  if ((0,_schema_js__WEBPACK_IMPORTED_MODULE_0__.isListLike)(schema)) {
    let sublist = schema.children[0]
    let subDepth = nextDepth
    if (sublist.children.length === 1) {
      sublist = sublist.children[0]
      subDepth++
    }
    assembleNested(subcolumnData, sublist, subDepth)

    const subcolumn = sublist.path.join('.')
    const values = subcolumnData.get(subcolumn)
    if (!values) throw new Error('parquet list-like column missing values')
    if (optional) flattenAtDepth(values, depth)
    subcolumnData.set(path, values)
    subcolumnData.delete(subcolumn)
    return
  }

  if ((0,_schema_js__WEBPACK_IMPORTED_MODULE_0__.isMapLike)(schema)) {
    const mapName = schema.children[0].element.name

    // Assemble keys and values
    assembleNested(subcolumnData, schema.children[0].children[0], nextDepth + 1)
    assembleNested(subcolumnData, schema.children[0].children[1], nextDepth + 1)

    const keys = subcolumnData.get(`${path}.${mapName}.key`)
    const values = subcolumnData.get(`${path}.${mapName}.value`)

    if (!keys) throw new Error('parquet map-like column missing keys')
    if (!values) throw new Error('parquet map-like column missing values')
    if (keys.length !== values.length) {
      throw new Error('parquet map-like column key/value length mismatch')
    }

    const out = assembleMaps(keys, values, nextDepth)
    if (optional) flattenAtDepth(out, depth)

    subcolumnData.delete(`${path}.${mapName}.key`)
    subcolumnData.delete(`${path}.${mapName}.value`)
    subcolumnData.set(path, out)
    return
  }

  // Struct-like column
  if (schema.children.length) {
    // construct a meta struct and then invert
    /** @type {Record<string, any>} */
    const struct = {}
    for (const child of schema.children) {
      assembleNested(subcolumnData, child, nextDepth)
      const childData = subcolumnData.get(child.path.join('.'))
      if (!childData) throw new Error('parquet struct-like column missing child data')
      struct[child.element.name] = childData
    }
    // remove children
    for (const child of schema.children) {
      subcolumnData.delete(child.path.join('.'))
    }
    // invert struct by depth
    const invertDepth = schema.element.repetition_type === 'REQUIRED' ? depth : depth + 1
    const inverted = invertStruct(struct, invertDepth)
    if (optional) flattenAtDepth(inverted, depth)
    subcolumnData.set(path, inverted)
  }
  // assert(schema.element.repetition_type !== 'REPEATED')
}

/**
 * @param {any[]} arr
 * @param {number} depth
 */
function flattenAtDepth(arr, depth) {
  for (let i = 0; i < arr.length; i++) {
    if (depth) {
      flattenAtDepth(arr[i], depth - 1)
    } else {
      arr[i] = arr[i][0]
    }
  }
}

/**
 * @param {any[]} keys
 * @param {any[]} values
 * @param {number} depth
 * @returns {any[]}
 */
function assembleMaps(keys, values, depth) {
  const out = []
  for (let i = 0; i < keys.length; i++) {
    if (depth) {
      out.push(assembleMaps(keys[i], values[i], depth - 1)) // go deeper
    } else {
      if (keys[i]) {
        /** @type {Record<string, any>} */
        const obj = {}
        for (let j = 0; j < keys[i].length; j++) {
          const value = values[i][j]
          obj[keys[i][j]] = value === undefined ? null : value
        }
        out.push(obj)
      } else {
        out.push(undefined)
      }
    }
  }
  return out
}

/**
 * Invert a struct-like object by depth.
 *
 * @param {Record<string, any[]>} struct
 * @param {number} depth
 * @returns {any[]}
 */
function invertStruct(struct, depth) {
  const keys = Object.keys(struct)
  const length = struct[keys[0]]?.length
  const out = []
  for (let i = 0; i < length; i++) {
    /** @type {Record<string, any>} */
    const obj = {}
    for (const key of keys) {
      obj[key] = struct[key][i]
    }
    if (depth) {
      out.push(invertStruct(obj, depth - 1)) // deeper
    } else {
      out.push(obj)
    }
  }
  return out
}


/***/ }),

/***/ "./node_modules/hyparquet/src/column.js":
/*!**********************************************!*\
  !*** ./node_modules/hyparquet/src/column.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decompressPage: () => (/* binding */ decompressPage),
/* harmony export */   getColumnOffset: () => (/* binding */ getColumnOffset),
/* harmony export */   readColumn: () => (/* binding */ readColumn)
/* harmony export */ });
/* harmony import */ var _assemble_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assemble.js */ "./node_modules/hyparquet/src/assemble.js");
/* harmony import */ var _convert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./convert.js */ "./node_modules/hyparquet/src/convert.js");
/* harmony import */ var _datapage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./datapage.js */ "./node_modules/hyparquet/src/datapage.js");
/* harmony import */ var _datapageV2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./datapageV2.js */ "./node_modules/hyparquet/src/datapageV2.js");
/* harmony import */ var _header_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./header.js */ "./node_modules/hyparquet/src/header.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");
/* harmony import */ var _snappy_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./snappy.js */ "./node_modules/hyparquet/src/snappy.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./node_modules/hyparquet/src/utils.js");









/**
 * Parse column data from a buffer.
 *
 * @typedef {import('./types.js').ColumnMetaData} ColumnMetaData
 * @typedef {import('./types.js').DecodedArray} DecodedArray
 * @param {import('./types.js').DataReader} reader
 * @param {import('./types.js').RowGroup} rowGroup row group metadata
 * @param {ColumnMetaData} columnMetadata column metadata
 * @param {import('./types.js').SchemaTree[]} schemaPath schema path for the column
 * @param {import('./hyparquet.js').ParquetReadOptions} options read options
 * @returns {any[]} array of values
 */
function readColumn(reader, rowGroup, columnMetadata, schemaPath, { compressors, utf8 }) {
  const { element } = schemaPath[schemaPath.length - 1]
  /** @type {DecodedArray | undefined} */
  let dictionary = undefined
  let seen = 0
  /** @type {any[]} */
  const rowData = []

  while (seen < rowGroup.num_rows) {
    // parse column header
    const header = (0,_header_js__WEBPACK_IMPORTED_MODULE_4__.parquetHeader)(reader)
    // assert(header.compressed_page_size !== undefined)

    // read compressed_page_size bytes starting at offset
    const compressedBytes = new Uint8Array(
      reader.view.buffer, reader.view.byteOffset + reader.offset, header.compressed_page_size
    )

    // parse page data by type
    /** @type {DecodedArray} */
    let values
    if (header.type === 'DATA_PAGE') {
      const daph = header.data_page_header
      if (!daph) throw new Error('parquet data page header is undefined')

      const page = decompressPage(compressedBytes, Number(header.uncompressed_page_size), columnMetadata.codec, compressors)
      const { definitionLevels, repetitionLevels, dataPage } = (0,_datapage_js__WEBPACK_IMPORTED_MODULE_2__.readDataPage)(page, daph, schemaPath, columnMetadata)
      seen += daph.num_values
      // assert(!daph.statistics || daph.statistics.null_count === BigInt(daph.num_values - dataPage.length))

      // construct output values: skip nulls and construct lists
      values = (0,_convert_js__WEBPACK_IMPORTED_MODULE_1__.dereferenceDictionary)(dictionary, dataPage)
      values = (0,_convert_js__WEBPACK_IMPORTED_MODULE_1__.convert)(values, element, utf8)
      if (repetitionLevels.length || definitionLevels?.length) {
        // Use repetition levels to construct lists
        const maxDefinitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_5__.getMaxDefinitionLevel)(schemaPath)
        const maxRepetitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_5__.getMaxRepetitionLevel)(schemaPath)
        const repetitionPath = schemaPath.map(({ element }) => element.repetition_type)
        values = (0,_assemble_js__WEBPACK_IMPORTED_MODULE_0__.assembleLists)(
          definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel, maxRepetitionLevel
        )
      } else {
        // wrap nested flat data by depth
        for (let i = 2; i < schemaPath.length; i++) {
          if (schemaPath[i].element.repetition_type !== 'REQUIRED') {
            values = Array.from(values, e => [e])
          }
        }
      }
      // assert(BigInt(values.length) === rowGroup.num_rows)
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.concat)(rowData, values)
    } else if (header.type === 'DATA_PAGE_V2') {
      const daph2 = header.data_page_header_v2
      if (!daph2) throw new Error('parquet data page header v2 is undefined')

      const { definitionLevels, repetitionLevels, dataPage } = (0,_datapageV2_js__WEBPACK_IMPORTED_MODULE_3__.readDataPageV2)(
        compressedBytes, header, schemaPath, columnMetadata, compressors
      )
      seen += daph2.num_values

      values = (0,_convert_js__WEBPACK_IMPORTED_MODULE_1__.dereferenceDictionary)(dictionary, dataPage)
      values = (0,_convert_js__WEBPACK_IMPORTED_MODULE_1__.convert)(values, element, utf8)
      if (repetitionLevels.length || definitionLevels?.length) {
        // Use repetition levels to construct lists
        const maxDefinitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_5__.getMaxDefinitionLevel)(schemaPath)
        const maxRepetitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_5__.getMaxRepetitionLevel)(schemaPath)
        const repetitionPath = schemaPath.map(({ element }) => element.repetition_type)
        values = (0,_assemble_js__WEBPACK_IMPORTED_MODULE_0__.assembleLists)(
          definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel, maxRepetitionLevel
        )
      }
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.concat)(rowData, values)
    } else if (header.type === 'DICTIONARY_PAGE') {
      const diph = header.dictionary_page_header
      if (!diph) throw new Error('parquet dictionary page header is undefined')

      const page = decompressPage(
        compressedBytes, Number(header.uncompressed_page_size), columnMetadata.codec, compressors
      )
      dictionary = (0,_datapage_js__WEBPACK_IMPORTED_MODULE_2__.readDictionaryPage)(page, diph, columnMetadata, element.type_length)
    } else {
      throw new Error(`parquet unsupported page type: ${header.type}`)
    }
    reader.offset += header.compressed_page_size
  }
  if (rowData.length !== Number(rowGroup.num_rows)) {
    throw new Error(`parquet row data length ${rowData.length} does not match row group length ${rowGroup.num_rows}}`)
  }
  return rowData
}

/**
 * Find the start byte offset for a column chunk.
 *
 * @param {ColumnMetaData} columnMetadata
 * @returns {number} byte offset
 */
function getColumnOffset({ dictionary_page_offset, data_page_offset }) {
  let columnOffset = dictionary_page_offset
  if (!dictionary_page_offset || data_page_offset < dictionary_page_offset) {
    columnOffset = data_page_offset
  }
  return Number(columnOffset)
}

/**
 * @param {Uint8Array} compressedBytes
 * @param {number} uncompressed_page_size
 * @param {import('./types.js').CompressionCodec} codec
 * @param {import('./types.js').Compressors | undefined} compressors
 * @returns {Uint8Array}
 */
function decompressPage(compressedBytes, uncompressed_page_size, codec, compressors) {
  /** @type {Uint8Array} */
  let page
  const customDecompressor = compressors?.[codec]
  if (codec === 'UNCOMPRESSED') {
    page = compressedBytes
  } else if (customDecompressor) {
    page = customDecompressor(compressedBytes, uncompressed_page_size)
  } else if (codec === 'SNAPPY') {
    page = new Uint8Array(uncompressed_page_size)
    ;(0,_snappy_js__WEBPACK_IMPORTED_MODULE_6__.snappyUncompress)(compressedBytes, page)
  } else {
    throw new Error(`parquet unsupported compression codec: ${codec}`)
  }
  if (page?.length !== uncompressed_page_size) {
    throw new Error(`parquet decompressed page length ${page?.length} does not match header ${uncompressed_page_size}`)
  }
  return page
}


/***/ }),

/***/ "./node_modules/hyparquet/src/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/hyparquet/src/constants.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompressionCodec: () => (/* binding */ CompressionCodec),
/* harmony export */   ConvertedType: () => (/* binding */ ConvertedType),
/* harmony export */   Encoding: () => (/* binding */ Encoding),
/* harmony export */   FieldRepetitionType: () => (/* binding */ FieldRepetitionType),
/* harmony export */   PageType: () => (/* binding */ PageType),
/* harmony export */   ParquetType: () => (/* binding */ ParquetType),
/* harmony export */   logicalTypeType: () => (/* binding */ logicalTypeType)
/* harmony export */ });
/**
 * @type {import('./types.js').ParquetType[]}
 */
const ParquetType = [
  'BOOLEAN',
  'INT32',
  'INT64',
  'INT96', // deprecated
  'FLOAT',
  'DOUBLE',
  'BYTE_ARRAY',
  'FIXED_LEN_BYTE_ARRAY',
]

const Encoding = [
  'PLAIN',
  undefined,
  'PLAIN_DICTIONARY',
  'RLE',
  'BIT_PACKED', // deprecated
  'DELTA_BINARY_PACKED',
  'DELTA_LENGTH_BYTE_ARRAY',
  'DELTA_BYTE_ARRAY',
  'RLE_DICTIONARY',
  'BYTE_STREAM_SPLIT',
]

const FieldRepetitionType = [
  'REQUIRED',
  'OPTIONAL',
  'REPEATED',
]

/**
 * @type {import('./types.js').ConvertedType[]}
 */
const ConvertedType = [
  'UTF8',
  'MAP',
  'MAP_KEY_VALUE',
  'LIST',
  'ENUM',
  'DECIMAL',
  'DATE',
  'TIME_MILLIS',
  'TIME_MICROS',
  'TIMESTAMP_MILLIS',
  'TIMESTAMP_MICROS',
  'UINT_8',
  'UINT_16',
  'UINT_32',
  'UINT_64',
  'INT_8',
  'INT_16',
  'INT_32',
  'INT_64',
  'JSON',
  'BSON',
  'INTERVAL',
]

/**
 * @type {import('./types.js').LogicalTypeType[]}
 */
const logicalTypeType = [
  'NULL',
  'STRING',
  'MAP',
  'LIST',
  'ENUM',
  'DECIMAL',
  'DATE',
  'TIME',
  'TIMESTAMP',
  'INTERVAL',
  'INTEGER',
  'NULL',
  'JSON',
  'BSON',
  'UUID',
]

const CompressionCodec = [
  'UNCOMPRESSED',
  'SNAPPY',
  'GZIP',
  'LZO',
  'BROTLI',
  'LZ4',
  'ZSTD',
  'LZ4_RAW',
]

/**
 * @type {import('./types.js').PageType[]}
 */
const PageType = [
  'DATA_PAGE',
  'INDEX_PAGE',
  'DICTIONARY_PAGE',
  'DATA_PAGE_V2',
]


/***/ }),

/***/ "./node_modules/hyparquet/src/convert.js":
/*!***********************************************!*\
  !*** ./node_modules/hyparquet/src/convert.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convert: () => (/* binding */ convert),
/* harmony export */   dereferenceDictionary: () => (/* binding */ dereferenceDictionary),
/* harmony export */   parseFloat16: () => (/* binding */ parseFloat16)
/* harmony export */ });
const dayMillis = 86400000 // 1 day in milliseconds

/**
 * Convert known types from primitive to rich.
 *
 * @typedef {import('./types.js').DecodedArray} DecodedArray
 * @param {DecodedArray} data series of primitive types
 * @param {import('./types.js').SchemaElement} schemaElement schema element for the data
 * @param {boolean | undefined} utf8 decode bytes as utf8?
 * @returns {DecodedArray} series of rich types
 */
function convert(data, schemaElement, utf8 = true) {
  const ctype = schemaElement.converted_type
  if (ctype === 'DECIMAL') {
    const scale = schemaElement.scale || 0
    const factor = Math.pow(10, -scale)
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      if (data[0] instanceof Uint8Array) {
        arr[i] = parseDecimal(data[i]) * factor
      } else {
        arr[i] = Number(data[i]) * factor
      }
    }
    return arr
  }
  if (ctype === undefined && schemaElement.type === 'INT96') {
    return Array.from(data).map(parseInt96Date)
  }
  if (ctype === 'DATE') {
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = new Date(data[i] * dayMillis)
    }
    return arr
  }
  if (ctype === 'TIMESTAMP_MILLIS') {
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = new Date(Number(data[i]))
    }
    return arr
  }
  if (ctype === 'TIMESTAMP_MICROS') {
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = new Date(Number(data[i] / 1000n))
    }
    return arr
  }
  if (ctype === 'JSON') {
    const decoder = new TextDecoder()
    return data.map(v => JSON.parse(decoder.decode(v)))
  }
  if (ctype === 'BSON') {
    throw new Error('parquet bson not supported')
  }
  if (ctype === 'INTERVAL') {
    throw new Error('parquet interval not supported')
  }
  if (ctype === 'UTF8' || utf8 && schemaElement.type === 'BYTE_ARRAY') {
    const decoder = new TextDecoder()
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = data[i] && decoder.decode(data[i])
    }
    return arr
  }
  if (ctype === 'UINT_64') {
    const arr = new BigUint64Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = BigInt(data[i])
    }
    return arr
  }
  const logicalType = schemaElement.logical_type?.type
  if (logicalType === 'FLOAT16') {
    return Array.from(data).map(parseFloat16)
  }
  if (logicalType === 'TIMESTAMP') {
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = new Date(Number(data[i]))
    }
    return arr
  }
  return data
}

/**
 * @param {Uint8Array} bytes
 * @returns {number}
 */
function parseDecimal(bytes) {
  // TODO: handle signed
  let value = 0
  for (const byte of bytes) {
    value = value << 8 | byte
  }
  return value
}

/**
 * @param {bigint} value
 * @returns {Date}
 */
function parseInt96Date(value) {
  const days = Number((value >> 64n) - 2440588n)
  const nano = Number((value & 0xffffffffffffffffn) / 1000000n)
  const millis = days * dayMillis + nano
  return new Date(millis)
}

/**
 * @param {Uint8Array | undefined} bytes
 * @returns {number | undefined}
 */
function parseFloat16(bytes) {
  if (!bytes) return undefined
  const int16 = bytes[1] << 8 | bytes[0]
  const sign = int16 >> 15 ? -1 : 1
  const exp = int16 >> 10 & 0x1f
  const frac = int16 & 0x3ff
  if (exp === 0) return sign * Math.pow(2, -14) * (frac / 1024) // subnormals
  if (exp === 0x1f) return frac ? NaN : sign * Infinity
  return sign * Math.pow(2, exp - 15) * (1 + frac / 1024)
}

/**
 * Map data to dictionary values in place.
 *
 * @param {DecodedArray | undefined} dictionary
 * @param {DecodedArray} dataPage
 * @returns {DecodedArray}
 */
function dereferenceDictionary(dictionary, dataPage) {
  let output = dataPage
  if (dictionary) {
    if (dataPage instanceof Uint8Array && !(dictionary instanceof Uint8Array)) {
      // upgrade dataPage to match dictionary type
      // @ts-expect-error not my fault typescript doesn't understand constructors
      output = new dictionary.constructor(dataPage.length)
    }
    for (let i = 0; i < dataPage.length; i++) {
      output[i] = dictionary[dataPage[i]]
    }
  }
  return output
}


/***/ }),

/***/ "./node_modules/hyparquet/src/datapage.js":
/*!************************************************!*\
  !*** ./node_modules/hyparquet/src/datapage.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readDataPage: () => (/* binding */ readDataPage),
/* harmony export */   readDictionaryPage: () => (/* binding */ readDictionaryPage)
/* harmony export */ });
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encoding.js */ "./node_modules/hyparquet/src/encoding.js");
/* harmony import */ var _plain_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plain.js */ "./node_modules/hyparquet/src/plain.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");




/**
 * Read a data page from uncompressed reader.
 *
 * @typedef {import("./types.d.ts").DataPage} DataPage
 * @typedef {import("./types.d.ts").ColumnMetaData} ColumnMetaData
 * @typedef {import("./types.d.ts").DataPageHeader} DataPageHeader
 * @typedef {import("./types.d.ts").SchemaTree} SchemaTree
 * @typedef {import("./types.d.ts").DecodedArray} DecodedArray
 * @param {Uint8Array} bytes raw page data (should already be decompressed)
 * @param {DataPageHeader} daph data page header
 * @param {SchemaTree[]} schemaPath
 * @param {ColumnMetaData} columnMetadata
 * @returns {DataPage} definition levels, repetition levels, and array of values
 */
function readDataPage(bytes, daph, schemaPath, { type }) {
  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)
  const reader = { view, offset: 0 }
  /** @type {DecodedArray} */
  let dataPage

  // repetition and definition levels
  const repetitionLevels = readRepetitionLevels(reader, daph, schemaPath)
  const { definitionLevels, numNulls } = readDefinitionLevels(reader, daph, schemaPath)

  // read values based on encoding
  const nValues = daph.num_values - numNulls
  if (daph.encoding === 'PLAIN') {
    const { type_length } = schemaPath[schemaPath.length - 1].element
    dataPage = (0,_plain_js__WEBPACK_IMPORTED_MODULE_1__.readPlain)(reader, type, nValues, type_length)
  } else if (
    daph.encoding === 'PLAIN_DICTIONARY' ||
    daph.encoding === 'RLE_DICTIONARY' ||
    daph.encoding === 'RLE'
  ) {
    const bitWidth = type === 'BOOLEAN' ? 1 : view.getUint8(reader.offset++)
    if (bitWidth) {
      dataPage = new Array(nValues)
      ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.readRleBitPackedHybrid)(reader, bitWidth, view.byteLength - reader.offset, dataPage)
    } else {
      dataPage = new Uint8Array(nValues) // nValue zeroes
    }
  } else if (daph.encoding === 'BYTE_STREAM_SPLIT') {
    const { type_length } = schemaPath[schemaPath.length - 1].element
    dataPage = (0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.byteStreamSplit)(reader, nValues, type, type_length)
  } else {
    throw new Error(`parquet unsupported encoding: ${daph.encoding}`)
  }

  return { definitionLevels, repetitionLevels, dataPage }
}

/**
 * @param {Uint8Array} bytes raw page data
 * @param {import("./types.d.ts").DictionaryPageHeader} diph dictionary page header
 * @param {ColumnMetaData} columnMetadata
 * @param {number | undefined} typeLength - type_length from schema
 * @returns {DecodedArray}
 */
function readDictionaryPage(bytes, diph, columnMetadata, typeLength) {
  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)
  const reader = { view, offset: 0 }
  return (0,_plain_js__WEBPACK_IMPORTED_MODULE_1__.readPlain)(reader, columnMetadata.type, diph.num_values, typeLength)
}

/**
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @param {DataReader} reader data view for the page
 * @param {DataPageHeader} daph data page header
 * @param {SchemaTree[]} schemaPath
 * @returns {any[]} repetition levels and number of bytes read
 */
function readRepetitionLevels(reader, daph, schemaPath) {
  if (schemaPath.length > 1) {
    const maxRepetitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_2__.getMaxRepetitionLevel)(schemaPath)
    if (maxRepetitionLevel) {
      const values = new Array(daph.num_values)
      ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.readRleBitPackedHybrid)(reader, (0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.bitWidth)(maxRepetitionLevel), 0, values)
      return values
    }
  }
  return []
}

/**
 * @param {DataReader} reader data view for the page
 * @param {DataPageHeader} daph data page header
 * @param {SchemaTree[]} schemaPath
 * @returns {{ definitionLevels: number[], numNulls: number }} definition levels
 */
function readDefinitionLevels(reader, daph, schemaPath) {
  const maxDefinitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_2__.getMaxDefinitionLevel)(schemaPath)
  if (!maxDefinitionLevel) return { definitionLevels: [], numNulls: 0 }

  const definitionLevels = new Array(daph.num_values)
  ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.readRleBitPackedHybrid)(reader, (0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.bitWidth)(maxDefinitionLevel), 0, definitionLevels)

  // count nulls
  let numNulls = daph.num_values
  for (const def of definitionLevels) {
    if (def === maxDefinitionLevel) numNulls--
  }
  if (numNulls === 0) definitionLevels.length = 0

  return { definitionLevels, numNulls }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/datapageV2.js":
/*!**************************************************!*\
  !*** ./node_modules/hyparquet/src/datapageV2.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readDataPageV2: () => (/* binding */ readDataPageV2),
/* harmony export */   readRepetitionLevelsV2: () => (/* binding */ readRepetitionLevelsV2)
/* harmony export */ });
/* harmony import */ var _column_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./column.js */ "./node_modules/hyparquet/src/column.js");
/* harmony import */ var _delta_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./delta.js */ "./node_modules/hyparquet/src/delta.js");
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ "./node_modules/hyparquet/src/encoding.js");
/* harmony import */ var _plain_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plain.js */ "./node_modules/hyparquet/src/plain.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");






/**
 * Read a data page from the given Uint8Array.
 *
 * @typedef {import("./types.d.ts").DataPage} DataPage
 * @typedef {import("./types.d.ts").ColumnMetaData} ColumnMetaData
 * @typedef {import("./types.d.ts").Compressors} Compressors
 * @typedef {import("./types.d.ts").DataPageHeaderV2} DataPageHeaderV2
 * @typedef {import("./types.d.ts").SchemaTree} SchemaTree
 * @param {Uint8Array} compressedBytes raw page data
 * @param {import("./types.d.ts").PageHeader} ph page header
 * @param {SchemaTree[]} schemaPath
 * @param {ColumnMetaData} columnMetadata
 * @param {Compressors | undefined} compressors
 * @returns {DataPage} definition levels, repetition levels, and array of values
 */
function readDataPageV2(compressedBytes, ph, schemaPath, columnMetadata, compressors) {
  const view = new DataView(compressedBytes.buffer, compressedBytes.byteOffset, compressedBytes.byteLength)
  const reader = { view, offset: 0 }
  const { codec, type } = columnMetadata
  const daph2 = ph.data_page_header_v2
  if (!daph2) throw new Error('parquet data page header v2 is undefined')

  // repetition levels
  const repetitionLevels = readRepetitionLevelsV2(reader, daph2, schemaPath)
  reader.offset = daph2.repetition_levels_byte_length // readVarInt() => len for boolean v2?

  // definition levels
  const definitionLevels = readDefinitionLevelsV2(reader, daph2, schemaPath)
  // assert(reader.offset === daph2.repetition_levels_byte_length + daph2.definition_levels_byte_length)

  const uncompressedPageSize = ph.uncompressed_page_size - daph2.definition_levels_byte_length - daph2.repetition_levels_byte_length

  let page = compressedBytes.subarray(reader.offset)
  if (daph2.is_compressed !== false) {
    page = (0,_column_js__WEBPACK_IMPORTED_MODULE_0__.decompressPage)(page, uncompressedPageSize, codec, compressors)
  }
  const pageView = new DataView(page.buffer, page.byteOffset, page.byteLength)
  const pageReader = { view: pageView, offset: 0 }

  // read values based on encoding
  /** @type {import('./types.d.ts').DecodedArray} */
  let dataPage
  const nValues = daph2.num_values - daph2.num_nulls
  if (daph2.encoding === 'PLAIN') {
    const { type_length } = schemaPath[schemaPath.length - 1].element
    dataPage = (0,_plain_js__WEBPACK_IMPORTED_MODULE_3__.readPlain)(pageReader, type, nValues, type_length)
  } else if (daph2.encoding === 'RLE') {
    // assert(columnMetadata.type === 'BOOLEAN')
    dataPage = new Array(nValues)
    ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.readRleBitPackedHybrid)(pageReader, 1, 0, dataPage)
    dataPage = dataPage.map(x => !!x)
  } else if (
    daph2.encoding === 'PLAIN_DICTIONARY' ||
    daph2.encoding === 'RLE_DICTIONARY'
  ) {
    const bitWidth = pageView.getUint8(pageReader.offset++)
    dataPage = new Array(nValues)
    ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.readRleBitPackedHybrid)(pageReader, bitWidth, uncompressedPageSize - 1, dataPage)
  } else if (daph2.encoding === 'DELTA_BINARY_PACKED') {
    const int32 = type === 'INT32'
    dataPage = int32 ? new Int32Array(nValues) : new BigInt64Array(nValues)
    ;(0,_delta_js__WEBPACK_IMPORTED_MODULE_1__.deltaBinaryUnpack)(pageReader, nValues, dataPage)
  } else if (daph2.encoding === 'DELTA_LENGTH_BYTE_ARRAY') {
    dataPage = new Array(nValues)
    ;(0,_delta_js__WEBPACK_IMPORTED_MODULE_1__.deltaLengthByteArray)(pageReader, nValues, dataPage)
  } else if (daph2.encoding === 'DELTA_BYTE_ARRAY') {
    dataPage = new Array(nValues)
    ;(0,_delta_js__WEBPACK_IMPORTED_MODULE_1__.deltaByteArray)(pageReader, nValues, dataPage)
  } else if (daph2.encoding === 'BYTE_STREAM_SPLIT') {
    const { type_length } = schemaPath[schemaPath.length - 1].element
    dataPage = (0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.byteStreamSplit)(reader, nValues, type, type_length)
  } else {
    throw new Error(`parquet unsupported encoding: ${daph2.encoding}`)
  }

  return { definitionLevels, repetitionLevels, dataPage }
}

/**
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @param {DataReader} reader
 * @param {DataPageHeaderV2} daph2 data page header v2
 * @param {SchemaTree[]} schemaPath
 * @returns {any[]} repetition levels
 */
function readRepetitionLevelsV2(reader, daph2, schemaPath) {
  const maxRepetitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_4__.getMaxRepetitionLevel)(schemaPath)
  if (!maxRepetitionLevel) return []

  const values = new Array(daph2.num_values)
  ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.readRleBitPackedHybrid)(
    reader, (0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.bitWidth)(maxRepetitionLevel), daph2.repetition_levels_byte_length, values
  )
  return values
}

/**
 * @param {DataReader} reader
 * @param {DataPageHeaderV2} daph2 data page header v2
 * @param {SchemaTree[]} schemaPath
 * @returns {number[] | undefined} definition levels
 */
function readDefinitionLevelsV2(reader, daph2, schemaPath) {
  const maxDefinitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_4__.getMaxDefinitionLevel)(schemaPath)
  if (maxDefinitionLevel) {
    // V2 we know the length
    const values = new Array(daph2.num_values)
    ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.readRleBitPackedHybrid)(reader, (0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.bitWidth)(maxDefinitionLevel), daph2.definition_levels_byte_length, values)
    return values
  }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/delta.js":
/*!*********************************************!*\
  !*** ./node_modules/hyparquet/src/delta.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deltaBinaryUnpack: () => (/* binding */ deltaBinaryUnpack),
/* harmony export */   deltaByteArray: () => (/* binding */ deltaByteArray),
/* harmony export */   deltaLengthByteArray: () => (/* binding */ deltaLengthByteArray)
/* harmony export */ });
/* harmony import */ var _thrift_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thrift.js */ "./node_modules/hyparquet/src/thrift.js");


/**
 * @typedef {import('./types.d.ts').DataReader} DataReader
 * @param {DataReader} reader
 * @param {number} count number of values to read
 * @param {Int32Array | BigInt64Array} output
 */
function deltaBinaryUnpack(reader, count, output) {
  const int32 = output instanceof Int32Array
  const blockSize = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readVarInt)(reader)
  const miniblockPerBlock = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readVarInt)(reader)
  ;(0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readVarInt)(reader) // assert(=== count)
  let value = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readZigZagBigInt)(reader) // first value
  let outputIndex = 0
  output[outputIndex++] = int32 ? Number(value) : value

  const valuesPerMiniblock = blockSize / miniblockPerBlock

  while (outputIndex < count) {
    // new block
    const minDelta = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readZigZagBigInt)(reader)
    const bitWidths = new Uint8Array(miniblockPerBlock)
    for (let i = 0; i < miniblockPerBlock; i++) {
      bitWidths[i] = reader.view.getUint8(reader.offset++)
    }

    for (let i = 0; i < miniblockPerBlock && outputIndex < count; i++) {
      // new miniblock
      const bitWidth = BigInt(bitWidths[i])
      if (bitWidth) {
        let bitpackPos = 0n
        let miniblockCount = valuesPerMiniblock
        const mask = (1n << bitWidth) - 1n
        while (miniblockCount && outputIndex < count) {
          let bits = BigInt(reader.view.getUint8(reader.offset)) >> bitpackPos & mask // TODO: don't re-read value every time
          bitpackPos += bitWidth
          while (bitpackPos >= 8) {
            bitpackPos -= 8n
            reader.offset++
            if (bitpackPos) {
              bits |= BigInt(reader.view.getUint8(reader.offset)) << bitWidth - bitpackPos & mask
            }
          }
          const delta = minDelta + bits
          value += delta
          output[outputIndex++] = int32 ? Number(value) : value
          miniblockCount--
        }
        if (miniblockCount) {
          // consume leftover miniblock
          reader.offset += Math.ceil((miniblockCount * Number(bitWidth) + Number(bitpackPos)) / 8)
        }
      } else {
        for (let j = 0; j < valuesPerMiniblock && outputIndex < count; j++) {
          value += minDelta
          output[outputIndex++] = int32 ? Number(value) : value
        }
      }
    }
  }
}

/**
 * @param {DataReader} reader
 * @param {number} count
 * @param {Uint8Array[]} output
 */
function deltaLengthByteArray(reader, count, output) {
  const lengths = new Int32Array(count)
  deltaBinaryUnpack(reader, count, lengths)
  for (let i = 0; i < count; i++) {
    output[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, lengths[i])
    reader.offset += lengths[i]
  }
}

/**
 * @param {DataReader} reader
 * @param {number} count
 * @param {Uint8Array[]} output
 */
function deltaByteArray(reader, count, output) {
  const prefixData = new Int32Array(count)
  deltaBinaryUnpack(reader, count, prefixData)
  const suffixData = new Int32Array(count)
  deltaBinaryUnpack(reader, count, suffixData)

  for (let i = 0; i < count; i++) {
    const suffix = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, suffixData[i])
    if (prefixData[i]) {
      // copy from previous value
      output[i] = new Uint8Array(prefixData[i] + suffixData[i])
      output[i].set(output[i - 1].subarray(0, prefixData[i]))
      output[i].set(suffix, prefixData[i])
    } else {
      output[i] = suffix
    }
    reader.offset += suffixData[i]
  }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/encoding.js":
/*!************************************************!*\
  !*** ./node_modules/hyparquet/src/encoding.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bitWidth: () => (/* binding */ bitWidth),
/* harmony export */   byteStreamSplit: () => (/* binding */ byteStreamSplit),
/* harmony export */   readRleBitPackedHybrid: () => (/* binding */ readRleBitPackedHybrid)
/* harmony export */ });
/* harmony import */ var _thrift_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thrift.js */ "./node_modules/hyparquet/src/thrift.js");


/**
 * Minimum bits needed to store value.
 *
 * @param {number} value
 * @returns {number}
 */
function bitWidth(value) {
  return 32 - Math.clz32(value)
}

/**
 * Read values from a run-length encoded/bit-packed hybrid encoding.
 *
 * If length is zero, then read int32 length at the start.
 *
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @typedef {import("./types.d.ts").DecodedArray} DecodedArray
 * @param {DataReader} reader
 * @param {number} width - width of each bit-packed group
 * @param {number} length - length of the encoded data
 * @param {DecodedArray} output
 */
function readRleBitPackedHybrid(reader, width, length, output) {
  if (!length) {
    // length = reader.view.getUint32(reader.offset, true)
    reader.offset += 4
  }
  let seen = 0
  while (seen < output.length) {
    const header = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readVarInt)(reader)
    if (header & 1) {
      // bit-packed
      seen = readBitPacked(reader, header, width, output, seen)
    } else {
      // rle
      const count = header >>> 1
      readRle(reader, count, width, output, seen)
      seen += count
    }
  }
  // assert(reader.offset - startOffset === length)
}

/**
 * Run-length encoding: read value with bitWidth and repeat it count times.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @param {number} bitWidth
 * @param {DecodedArray} output
 * @param {number} seen
 */
function readRle(reader, count, bitWidth, output, seen) {
  const width = bitWidth + 7 >> 3
  let value = 0
  if (width === 1) {
    value = reader.view.getUint8(reader.offset)
    // assert(value < 1 << bitWidth)
  } else if (width === 2) {
    value = reader.view.getUint16(reader.offset, true)
  } else if (width === 4) {
    value = reader.view.getUint32(reader.offset, true)
  } else if (width) {
    throw new Error(`parquet invalid rle width ${width}`)
  }
  reader.offset += width

  // repeat value count times
  for (let i = 0; i < count; i++) {
    output[seen + i] = value
  }
}

/**
 * Read a bit-packed run of the rle/bitpack hybrid.
 * Supports width > 8 (crossing bytes).
 *
 * @param {DataReader} reader
 * @param {number} header - bit-pack header
 * @param {number} bitWidth
 * @param {DecodedArray} output
 * @param {number} seen
 * @returns {number} total output values so far
 */
function readBitPacked(reader, header, bitWidth, output, seen) {
  let count = header >> 1 << 3 // values to read
  const mask = (1 << bitWidth) - 1

  let data = 0
  if (reader.offset < reader.view.byteLength) {
    data = reader.view.getUint8(reader.offset++)
  } else if (mask) {
    // sometimes out-of-bounds reads are masked out
    throw new Error(`parquet bitpack offset ${reader.offset} out of range`)
  }
  let left = 8
  let right = 0

  // read values
  while (count) {
    // if we have crossed a byte boundary, shift the data
    if (right > 8) {
      right -= 8
      left -= 8
      data >>= 8
    } else if (left - right < bitWidth) {
      // if we don't have bitWidth number of bits to read, read next byte
      data |= reader.view.getUint8(reader.offset) << left
      reader.offset++
      left += 8
    } else {
      if (seen < output.length) {
        // emit value
        output[seen++] = data >> right & mask
      }
      count--
      right += bitWidth
    }
  }

  return seen
}

/**
 * @typedef {import("./types.d.ts").ParquetType} ParquetType
 * @param {DataReader} reader
 * @param {number} count
 * @param {ParquetType} type
 * @param {number | undefined} typeLength
 * @returns {DecodedArray}
 */
function byteStreamSplit(reader, count, type, typeLength) {
  const width = byteWidth(type, typeLength)
  const bytes = new Uint8Array(count * width)
  for (let b = 0; b < width; b++) {
    for (let i = 0; i < count; i++) {
      bytes[i * width + b] = reader.view.getUint8(reader.offset++)
    }
  }
  // interpret bytes as typed array
  if (type === 'FLOAT') return new Float32Array(bytes.buffer)
  else if (type === 'DOUBLE') return new Float64Array(bytes.buffer)
  else if (type === 'INT32') return new Int32Array(bytes.buffer)
  else if (type === 'INT64') return new BigInt64Array(bytes.buffer)
  else if (type === 'FIXED_LEN_BYTE_ARRAY') {
    // split into arrays of typeLength
    const split = new Array(count)
    for (let i = 0; i < count; i++) {
      split[i] = bytes.subarray(i * width, (i + 1) * width)
    }
    return split
  }
  throw new Error(`parquet byte_stream_split unsupported type: ${type}`)
}

/**
 * @param {ParquetType} type
 * @param {number | undefined} typeLength
 * @returns {number}
 */
function byteWidth(type, typeLength) {
  switch (type) {
  case 'INT32':
  case 'FLOAT':
    return 4
  case 'INT64':
  case 'DOUBLE':
    return 8
  case 'FIXED_LEN_BYTE_ARRAY':
    if (!typeLength) throw new Error('parquet byteWidth missing type_length')
    return typeLength
  default:
    throw new Error(`parquet unsupported type: ${type}`)
  }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/header.js":
/*!**********************************************!*\
  !*** ./node_modules/hyparquet/src/header.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parquetHeader: () => (/* binding */ parquetHeader)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/hyparquet/src/constants.js");
/* harmony import */ var _thrift_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./thrift.js */ "./node_modules/hyparquet/src/thrift.js");



/**
 * Read parquet header from a buffer.
 *
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @typedef {import("./types.d.ts").PageHeader} PageHeader
 * @param {DataReader} reader - parquet file reader
 * @returns {PageHeader} metadata object and bytes read
 */
function parquetHeader(reader) {
  const header = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_1__.deserializeTCompactProtocol)(reader)

  // Parse parquet header from thrift data
  const type = _constants_js__WEBPACK_IMPORTED_MODULE_0__.PageType[header.field_1]
  const uncompressed_page_size = header.field_2
  const compressed_page_size = header.field_3
  const crc = header.field_4
  const data_page_header = header.field_5 && {
    num_values: header.field_5.field_1,
    encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[header.field_5.field_2],
    definition_level_encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[header.field_5.field_3],
    repetition_level_encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[header.field_5.field_4],
    statistics: header.field_5.field_5 && {
      max: header.field_5.field_5.field_1,
      min: header.field_5.field_5.field_2,
      null_count: header.field_5.field_5.field_3,
      distinct_count: header.field_5.field_5.field_4,
      max_value: header.field_5.field_5.field_5,
      min_value: header.field_5.field_5.field_6,
    },
  }
  const index_page_header = header.field_6
  const dictionary_page_header = header.field_7 && {
    num_values: header.field_7.field_1,
    encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[header.field_7.field_2],
    is_sorted: header.field_7.field_3,
  }
  const data_page_header_v2 = header.field_8 && {
    num_values: header.field_8.field_1,
    num_nulls: header.field_8.field_2,
    num_rows: header.field_8.field_3,
    encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[header.field_8.field_4],
    definition_levels_byte_length: header.field_8.field_5,
    repetition_levels_byte_length: header.field_8.field_6,
    is_compressed: header.field_8.field_7 === undefined ? true : header.field_8.field_7, // default true
    statistics: header.field_8.field_8,
  }

  return {
    type,
    uncompressed_page_size,
    compressed_page_size,
    crc,
    data_page_header,
    index_page_header,
    dictionary_page_header,
    data_page_header_v2,
  }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/hyparquet.js":
/*!*************************************************!*\
  !*** ./node_modules/hyparquet/src/hyparquet.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parquetMetadata: () => (/* reexport safe */ _metadata_js__WEBPACK_IMPORTED_MODULE_0__.parquetMetadata),
/* harmony export */   parquetMetadataAsync: () => (/* reexport safe */ _metadata_js__WEBPACK_IMPORTED_MODULE_0__.parquetMetadataAsync),
/* harmony export */   parquetRead: () => (/* reexport safe */ _read_js__WEBPACK_IMPORTED_MODULE_1__.parquetRead),
/* harmony export */   parquetSchema: () => (/* reexport safe */ _metadata_js__WEBPACK_IMPORTED_MODULE_0__.parquetSchema),
/* harmony export */   snappyUncompress: () => (/* reexport safe */ _snappy_js__WEBPACK_IMPORTED_MODULE_2__.snappyUncompress),
/* harmony export */   toJson: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_3__.toJson)
/* harmony export */ });
/* harmony import */ var _metadata_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metadata.js */ "./node_modules/hyparquet/src/metadata.js");
/* harmony import */ var _read_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./read.js */ "./node_modules/hyparquet/src/read.js");
/* harmony import */ var _snappy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./snappy.js */ "./node_modules/hyparquet/src/snappy.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ "./node_modules/hyparquet/src/utils.js");



;


;


;



/***/ }),

/***/ "./node_modules/hyparquet/src/metadata.js":
/*!************************************************!*\
  !*** ./node_modules/hyparquet/src/metadata.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parquetMetadata: () => (/* binding */ parquetMetadata),
/* harmony export */   parquetMetadataAsync: () => (/* binding */ parquetMetadataAsync),
/* harmony export */   parquetSchema: () => (/* binding */ parquetSchema)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/hyparquet/src/constants.js");
/* harmony import */ var _convert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./convert.js */ "./node_modules/hyparquet/src/convert.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");
/* harmony import */ var _thrift_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./thrift.js */ "./node_modules/hyparquet/src/thrift.js");





/**
 * Read parquet metadata from an async buffer.
 *
 * An AsyncBuffer is like an ArrayBuffer, but the slices are loaded
 * asynchronously, possibly over the network.
 *
 * You must provide the byteLength of the buffer, typically from a HEAD request.
 *
 * In theory, you could use suffix-range requests to fetch the end of the file,
 * and save a round trip. But in practice, this doesn't work because chrome
 * deems suffix-range requests as a not-safe-listed header, and will require
 * a pre-flight. So the byteLength is required.
 *
 * To make this efficient, we initially request the last 512kb of the file,
 * which is likely to contain the metadata. If the metadata length exceeds the
 * initial fetch, 512kb, we request the rest of the metadata from the AsyncBuffer.
 *
 * This ensures that we either make one 512kb initial request for the metadata,
 * or a second request for up to the metadata size.
 *
 * @typedef {import("./types.d.ts").AsyncBuffer} AsyncBuffer
 * @typedef {import("./types.d.ts").FileMetaData} FileMetaData
 * @typedef {import("./types.d.ts").SchemaElement} SchemaElement
 * @param {AsyncBuffer} asyncBuffer parquet file contents
 * @param {number} initialFetchSize initial fetch size in bytes
 * @returns {Promise<FileMetaData>} parquet metadata object
 */
async function parquetMetadataAsync(asyncBuffer, initialFetchSize = 1 << 19 /* 512kb */) {
  if (!asyncBuffer) throw new Error('parquet file is required')
  if (!(asyncBuffer.byteLength >= 0)) throw new Error('parquet file byteLength is required')

  // fetch last bytes (footer) of the file
  const footerOffset = Math.max(0, asyncBuffer.byteLength - initialFetchSize)
  const footerBuffer = await asyncBuffer.slice(footerOffset, asyncBuffer.byteLength)

  // Check for parquet magic number "PAR1"
  const footerView = new DataView(footerBuffer)
  if (footerView.getUint32(footerBuffer.byteLength - 4, true) !== 0x31524150) {
    throw new Error('parquet file invalid (footer != PAR1)')
  }

  // Parquet files store metadata at the end of the file
  // Metadata length is 4 bytes before the last PAR1
  const metadataLength = footerView.getUint32(footerBuffer.byteLength - 8, true)
  if (metadataLength > asyncBuffer.byteLength - 8) {
    throw new Error(`parquet metadata length ${metadataLength} exceeds available buffer ${asyncBuffer.byteLength - 8}`)
  }

  // check if metadata size fits inside the initial fetch
  if (metadataLength + 8 > initialFetchSize) {
    // fetch the rest of the metadata
    const metadataOffset = asyncBuffer.byteLength - metadataLength - 8
    const metadataBuffer = await asyncBuffer.slice(metadataOffset, footerOffset)
    // combine initial fetch with the new slice
    const combinedBuffer = new ArrayBuffer(metadataLength + 8)
    const combinedView = new Uint8Array(combinedBuffer)
    combinedView.set(new Uint8Array(metadataBuffer))
    combinedView.set(new Uint8Array(footerBuffer), footerOffset - metadataOffset)
    return parquetMetadata(combinedBuffer)
  } else {
    // parse metadata from the footer
    return parquetMetadata(footerBuffer)
  }
}

/**
 * Read parquet metadata from a buffer synchronously.
 *
 * @param {ArrayBuffer} arrayBuffer parquet file contents
 * @returns {FileMetaData} parquet metadata object
 */
function parquetMetadata(arrayBuffer) {
  if (!arrayBuffer) throw new Error('parquet file is required')
  const view = new DataView(arrayBuffer)

  // Validate footer magic number "PAR1"
  if (view.byteLength < 8) {
    throw new Error('parquet file is too short')
  }
  if (view.getUint32(view.byteLength - 4, true) !== 0x31524150) {
    throw new Error('parquet file invalid (footer != PAR1)')
  }

  // Parquet files store metadata at the end of the file
  // Metadata length is 4 bytes before the last PAR1
  const metadataLengthOffset = view.byteLength - 8
  const metadataLength = view.getUint32(metadataLengthOffset, true)
  if (metadataLength > view.byteLength - 8) {
    // {metadata}, metadata_length, PAR1
    throw new Error(`parquet metadata length ${metadataLength} exceeds available buffer ${view.byteLength - 8}`)
  }

  const metadataOffset = metadataLengthOffset - metadataLength
  const reader = { view, offset: metadataOffset }
  const metadata = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_3__.deserializeTCompactProtocol)(reader)
  const decoder = new TextDecoder()
  function decode(/** @type {Uint8Array} */ value) {
    return value && decoder.decode(value)
  }

  // Parse metadata from thrift data
  const version = metadata.field_1
  /** @type {SchemaElement[]} */
  const schema = metadata.field_2.map((/** @type {any} */ field) => ({
    type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ParquetType[field.field_1],
    type_length: field.field_2,
    repetition_type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.FieldRepetitionType[field.field_3],
    name: decode(field.field_4),
    num_children: field.field_5,
    converted_type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ConvertedType[field.field_6],
    scale: field.field_7,
    precision: field.field_8,
    field_id: field.field_9,
    logical_type: logicalType(field.field_10),
  }))
  // schema element per column index
  const columnSchema = schema.filter(e => e.type)
  const num_rows = metadata.field_3
  const row_groups = metadata.field_4.map((/** @type {any} */ rowGroup) => ({
    columns: rowGroup.field_1.map((/** @type {any} */ column, /** @type {number} */ columnIndex) => ({
      file_path: decode(column.field_1),
      file_offset: column.field_2,
      meta_data: column.field_3 && {
        type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ParquetType[column.field_3.field_1],
        encodings: column.field_3.field_2?.map((/** @type {number} */ e) => _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[e]),
        path_in_schema: column.field_3.field_3.map(decode),
        codec: _constants_js__WEBPACK_IMPORTED_MODULE_0__.CompressionCodec[column.field_3.field_4],
        num_values: column.field_3.field_5,
        total_uncompressed_size: column.field_3.field_6,
        total_compressed_size: column.field_3.field_7,
        key_value_metadata: column.field_3.field_8,
        data_page_offset: column.field_3.field_9,
        index_page_offset: column.field_3.field_10,
        dictionary_page_offset: column.field_3.field_11,
        statistics: columnStats(column.field_3.field_12, columnSchema[columnIndex]),
        encoding_stats: column.field_3.field_13?.map((/** @type {any} */ encodingStat) => ({
          page_type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.PageType[encodingStat.field_1],
          encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[encodingStat.field_2],
          count: encodingStat.field_3,
        })),
        bloom_filter_offset: column.field_3.field_14,
        bloom_filter_length: column.field_3.field_15,
        size_statistics: column.field_3.field_16 && {
          unencoded_byte_array_data_bytes: column.field_3.field_16.field_1,
          repetition_level_histogram: column.field_3.field_16.field_2,
          definition_level_histogram: column.field_3.field_16.field_3,
        },
      },
      offset_index_offset: column.field_4,
      offset_index_length: column.field_5,
      column_index_offset: column.field_6,
      column_index_length: column.field_7,
      crypto_metadata: column.field_7,
      encrypted_column_metadata: column.field_8,
    })),
    total_byte_size: rowGroup.field_2,
    num_rows: rowGroup.field_3,
    sorting_columns: rowGroup.field_4?.map((/** @type {any} */ sortingColumn) => ({
      column_idx: sortingColumn.field_1,
      descending: sortingColumn.field_2,
      nulls_first: sortingColumn.field_3,
    })),
    file_offset: rowGroup.field_5,
    total_compressed_size: rowGroup.field_6,
    ordinal: rowGroup.field_7,
  }))
  const key_value_metadata = metadata.field_5?.map((/** @type {any} */ keyValue) => ({
    key: decode(keyValue.field_1),
    value: decode(keyValue.field_2),
  }))
  const created_by = decode(metadata.field_6)

  return {
    version,
    schema,
    num_rows,
    row_groups,
    key_value_metadata,
    created_by,
    metadata_length: metadataLength,
  }
}

/**
 * Return a tree of schema elements from parquet metadata.
 *
 * @param {FileMetaData} metadata parquet metadata object
 * @returns {import("./types.d.ts").SchemaTree} tree of schema elements
 */
function parquetSchema(metadata) {
  return (0,_schema_js__WEBPACK_IMPORTED_MODULE_2__.getSchemaPath)(metadata.schema, [])[0]
}

/**
 * @param {any} logicalType
 * @returns {import("./types.d.ts").LogicalType | undefined}
 */
function logicalType(logicalType) {
  if (logicalType?.field_1) return { type: 'STRING' }
  if (logicalType?.field_2) return { type: 'MAP' }
  if (logicalType?.field_3) return { type: 'LIST' }
  if (logicalType?.field_4) return { type: 'ENUM' }
  if (logicalType?.field_5) return {
    type: 'DECIMAL',
    scale: logicalType.field_5.field_1,
    precision: logicalType.field_5.field_2,
  }
  if (logicalType?.field_6) return { type: 'DATE' }
  if (logicalType?.field_7) return {
    type: 'TIME',
    isAdjustedToUTC: logicalType.field_7.field_1,
    unit: logicalType.field_7.field_2,
  }
  if (logicalType?.field_8) return {
    type: 'TIMESTAMP',
    isAdjustedToUTC: logicalType.field_8.field_1,
    unit: logicalType.field_8.field_2,
  }
  if (logicalType?.field_10) return {
    type: 'INTEGER',
    bitWidth: logicalType.field_10.field_1,
    isSigned: logicalType.field_10.field_2,
  }
  if (logicalType?.field_11) return { type: 'NULL' }
  if (logicalType?.field_12) return { type: 'JSON' }
  if (logicalType?.field_13) return { type: 'BSON' }
  if (logicalType?.field_14) return { type: 'UUID' }
  if (logicalType?.field_15) return { type: 'FLOAT16' }
  return logicalType
}

/**
 * Convert column statistics based on column type.
 *
 * @param {any} stats
 * @param {SchemaElement} schema
 * @returns {import("./types.d.ts").Statistics}
 */
function columnStats(stats, schema) {
  const { type, logical_type } = schema
  function convert(/** @type {Uint8Array} */ value) {
    if (value === undefined) return value
    if (type === 'BOOLEAN') return value[0] === 1
    if (type === 'BYTE_ARRAY') return new TextDecoder().decode(value)
    if (type === 'INT32') {
      const view = new DataView(value.buffer, value.byteOffset, value.byteLength)
      return view.getInt32(0, true)
    }
    if (type === 'INT64') {
      const view = new DataView(value.buffer, value.byteOffset, value.byteLength)
      return view.getBigInt64(0, true)
    }
    if (type === 'FLOAT') {
      const view = new DataView(value.buffer, value.byteOffset, value.byteLength)
      return view.getFloat32(0, true)
    }
    if (type === 'DOUBLE') {
      const view = new DataView(value.buffer, value.byteOffset, value.byteLength)
      return view.getFloat64(0, true)
    }
    if (logical_type?.type === 'FLOAT16') {
      return (0,_convert_js__WEBPACK_IMPORTED_MODULE_1__.parseFloat16)(value)
    }
    return value
  }
  return stats && {
    max: convert(stats.field_1),
    min: convert(stats.field_2),
    null_count: stats.field_3,
    distinct_count: stats.field_4,
    max_value: convert(stats.field_5),
    min_value: convert(stats.field_6),
    is_max_value_exact: stats.field_7,
    is_min_value_exact: stats.field_8,
  }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/plain.js":
/*!*********************************************!*\
  !*** ./node_modules/hyparquet/src/plain.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readPlain: () => (/* binding */ readPlain)
/* harmony export */ });
/**
 * Read `count` values of the given type from the reader.view.
 *
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @typedef {import("./types.d.ts").DecodedArray} DecodedArray
 * @typedef {import("./types.d.ts").ParquetType} ParquetType
 * @param {DataReader} reader - buffer to read data from
 * @param {ParquetType} type - parquet type of the data
 * @param {number} count - number of values to read
 * @param {number | undefined} fixedLength - length of each fixed length byte array
 * @returns {DecodedArray} array of values
 */
function readPlain(reader, type, count, fixedLength) {
  if (count === 0) return []
  if (type === 'BOOLEAN') {
    return readPlainBoolean(reader, count)
  } else if (type === 'INT32') {
    return readPlainInt32(reader, count)
  } else if (type === 'INT64') {
    return readPlainInt64(reader, count)
  } else if (type === 'INT96') {
    return readPlainInt96(reader, count)
  } else if (type === 'FLOAT') {
    return readPlainFloat(reader, count)
  } else if (type === 'DOUBLE') {
    return readPlainDouble(reader, count)
  } else if (type === 'BYTE_ARRAY') {
    return readPlainByteArray(reader, count)
  } else if (type === 'FIXED_LEN_BYTE_ARRAY') {
    if (!fixedLength) throw new Error('parquet missing fixed length')
    return readPlainByteArrayFixed(reader, count, fixedLength)
  } else {
    throw new Error(`parquet unhandled type: ${type}`)
  }
}

/**
 * Read `count` boolean values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {boolean[]}
 */
function readPlainBoolean(reader, count) {
  const values = new Array(count)
  for (let i = 0; i < count; i++) {
    const byteOffset = reader.offset + (i / 8 | 0)
    const bitOffset = i % 8
    const byte = reader.view.getUint8(byteOffset)
    values[i] = (byte & 1 << bitOffset) !== 0
  }
  reader.offset += Math.ceil(count / 8)
  return values
}

/**
 * Read `count` int32 values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {Int32Array}
 */
function readPlainInt32(reader, count) {
  const values = (reader.view.byteOffset + reader.offset) % 4
    ? new Int32Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 4))
    : new Int32Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)
  reader.offset += count * 4
  return values
}

/**
 * Read `count` int64 values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {BigInt64Array}
 */
function readPlainInt64(reader, count) {
  const values = (reader.view.byteOffset + reader.offset) % 8
    ? new BigInt64Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 8))
    : new BigInt64Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)
  reader.offset += count * 8
  return values
}

/**
 * Read `count` int96 values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {bigint[]}
 */
function readPlainInt96(reader, count) {
  const values = new Array(count)
  for (let i = 0; i < count; i++) {
    const low = reader.view.getBigInt64(reader.offset + i * 12, true)
    const high = reader.view.getInt32(reader.offset + i * 12 + 8, true)
    values[i] = BigInt(high) << 64n | low
  }
  reader.offset += count * 12
  return values
}

/**
 * Read `count` float values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {Float32Array}
 */
function readPlainFloat(reader, count) {
  const values = (reader.view.byteOffset + reader.offset) % 4
    ? new Float32Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 4))
    : new Float32Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)
  reader.offset += count * 4
  return values
}

/**
 * Read `count` double values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {Float64Array}
 */
function readPlainDouble(reader, count) {
  const values = (reader.view.byteOffset + reader.offset) % 8
    ? new Float64Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 8))
    : new Float64Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)
  reader.offset += count * 8
  return values
}

/**
 * Read `count` byte array values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {Uint8Array[]}
 */
function readPlainByteArray(reader, count) {
  const values = new Array(count)
  for (let i = 0; i < count; i++) {
    const length = reader.view.getInt32(reader.offset, true)
    reader.offset += 4
    values[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, length)
    reader.offset += length
  }
  return values
}

/**
 * Read a fixed length byte array.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @param {number} fixedLength
 * @returns {Uint8Array[]}
 */
function readPlainByteArrayFixed(reader, count, fixedLength) {
  // assert(reader.view.byteLength - reader.offset >= count * fixedLength)
  const values = new Array(count)
  for (let i = 0; i < count; i++) {
    values[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, fixedLength)
    reader.offset += fixedLength
  }
  return values
}

/**
 * Create a new buffer with the offset and size.
 *
 * @param {ArrayBuffer} buffer
 * @param {number} offset
 * @param {number} size
 * @returns {ArrayBuffer}
 */
function align(buffer, offset, size) {
  const aligned = new ArrayBuffer(size)
  new Uint8Array(aligned).set(new Uint8Array(buffer, offset, size))
  return aligned
}


/***/ }),

/***/ "./node_modules/hyparquet/src/read.js":
/*!********************************************!*\
  !*** ./node_modules/hyparquet/src/read.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parquetRead: () => (/* binding */ parquetRead)
/* harmony export */ });
/* harmony import */ var _assemble_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assemble.js */ "./node_modules/hyparquet/src/assemble.js");
/* harmony import */ var _column_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./column.js */ "./node_modules/hyparquet/src/column.js");
/* harmony import */ var _metadata_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metadata.js */ "./node_modules/hyparquet/src/metadata.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ "./node_modules/hyparquet/src/utils.js");







/**
 * Read parquet data rows from a file-like object.
 * Reads the minimal number of row groups and columns to satisfy the request.
 *
 * Returns a void promise when complete, and to throw errors.
 * Data is returned in onComplete, not the return promise, because
 * if onComplete is undefined, we parse the data, and emit chunks, but skip
 * computing the row view directly. This saves on allocation if the caller
 * wants to cache the full chunks, and make their own view of the data from
 * the chunks.
 *
 * @typedef {import('./hyparquet.js').ColumnData} ColumnData
 * @typedef {import('./types.js').Compressors} Compressors
 * @typedef {import('./types.js').AsyncBuffer} AsyncBuffer
 * @typedef {import('./types.js').FileMetaData} FileMetaData
 * @param {object} options read options
 * @param {AsyncBuffer} options.file file-like object containing parquet data
 * @param {FileMetaData} [options.metadata] parquet file metadata
 * @param {string[]} [options.columns] columns to read, all columns if undefined
 * @param {number} [options.rowStart] first requested row index (inclusive)
 * @param {number} [options.rowEnd] last requested row index (exclusive)
 * @param {(chunk: ColumnData) => void} [options.onChunk] called when a column chunk is parsed. chunks may include row data outside the requested range.
 * @param {(rows: any[][]) => void} [options.onComplete] called when all requested rows and columns are parsed
 * @param {Compressors} [options.compressors] custom decompressors
 * @returns {Promise<void>} resolves when all requested rows and columns are parsed
 */
async function parquetRead(options) {
  if (!options.file) throw new Error('parquet file is required')

  // load metadata if not provided
  options.metadata ||= await (0,_metadata_js__WEBPACK_IMPORTED_MODULE_2__.parquetMetadataAsync)(options.file)
  if (!options.metadata) throw new Error('parquet metadata not found')

  const { metadata, onComplete, rowEnd } = options
  const rowStart = options.rowStart || 0
  /** @type {any[][]} */
  const rowData = []

  // find which row groups to read
  let groupStart = 0 // first row index of the current group
  for (const rowGroup of metadata.row_groups) {
    // number of rows in this row group
    const groupRows = Number(rowGroup.num_rows)
    // if row group overlaps with row range, read it
    if (groupStart + groupRows >= rowStart && (rowEnd === undefined || groupStart < rowEnd)) {
      // read row group
      const groupData = await readRowGroup(options, rowGroup, groupStart)
      if (onComplete) {
        // filter to rows in range
        const start = Math.max(rowStart - groupStart, 0)
        const end = rowEnd === undefined ? undefined : rowEnd - groupStart
        ;(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.concat)(rowData, groupData.slice(start, end))
      }
    }
    groupStart += groupRows
  }

  if (onComplete) onComplete(rowData)
}

/**
 * Read a row group from a file-like object.
 *
 * @typedef {import('./types.js').RowGroup} RowGroup
 * @param {object} options read options
 * @param {AsyncBuffer} options.file file-like object containing parquet data
 * @param {FileMetaData} [options.metadata] parquet file metadata
 * @param {string[]} [options.columns] columns to read, all columns if undefined
 * @param {(chunk: ColumnData) => void} [options.onChunk] called when a column chunk is parsed. chunks may include row data outside the requested range.
 * @param {(rows: any[][]) => void} [options.onComplete] called when all requested rows and columns are parsed
 * @param {Compressors} [options.compressors]
 * @param {RowGroup} rowGroup row group to read
 * @param {number} groupStart row index of the first row in the group
 * @returns {Promise<any[][]>} resolves to row data
 */
async function readRowGroup(options, rowGroup, groupStart) {
  const { file, metadata, columns } = options
  if (!metadata) throw new Error('parquet metadata not found')

  // loop through metadata to find min/max bytes to read
  let [groupStartByte, groupEndByte] = [file.byteLength, 0]
  rowGroup.columns.forEach(({ meta_data: columnMetadata }) => {
    if (!columnMetadata) throw new Error('parquet column metadata is undefined')
    // skip columns that are not requested
    if (columns && !columns.includes(columnMetadata.path_in_schema[0])) return

    const startByte = (0,_column_js__WEBPACK_IMPORTED_MODULE_1__.getColumnOffset)(columnMetadata)
    const endByte = startByte + Number(columnMetadata.total_compressed_size)
    groupStartByte = Math.min(groupStartByte, startByte)
    groupEndByte = Math.max(groupEndByte, endByte)
  })
  if (groupStartByte >= groupEndByte && columns?.length) {
    // TODO: should throw if any column is missing
    throw new Error(`parquet columns not found: ${columns.join(', ')}`)
  }
  // if row group size is less than 32mb, pre-load in one read
  let groupBuffer
  if (groupEndByte - groupStartByte <= 1 << 25) {
    // pre-load row group byte data in one big read,
    // otherwise read column data individually
    groupBuffer = await file.slice(groupStartByte, groupEndByte)
  }

  /** @type {any[][]} */
  const groupColumnData = []
  const promises = []
  // Top-level columns to assemble
  const { children } = (0,_schema_js__WEBPACK_IMPORTED_MODULE_3__.getSchemaPath)(metadata.schema, [])[0]
  const subcolumnNames = new Map(children.map(child => [child.element.name, getSubcolumns(child)]))
  const subcolumnData = new Map() // columns to assemble as maps
  // read column data
  for (let columnIndex = 0; columnIndex < rowGroup.columns.length; columnIndex++) {
    const columnMetadata = rowGroup.columns[columnIndex].meta_data
    if (!columnMetadata) throw new Error('parquet column metadata is undefined')

    // skip columns that are not requested
    const columnName = columnMetadata.path_in_schema[0]
    if (columns && !columns.includes(columnName)) continue

    const columnStartByte = (0,_column_js__WEBPACK_IMPORTED_MODULE_1__.getColumnOffset)(columnMetadata)
    const columnEndByte = columnStartByte + Number(columnMetadata.total_compressed_size)
    const columnBytes = columnEndByte - columnStartByte

    // skip columns larger than 1gb
    // TODO: stream process the data, returning only the requested rows
    if (columnBytes > 1 << 30) {
      console.warn(`parquet skipping huge column "${columnMetadata.path_in_schema}" ${columnBytes.toLocaleString()} bytes`)
      // TODO: set column to new Error('parquet column too large')
      continue
    }

    // use pre-loaded row group byte data if available, else read column data
    /** @type {Promise<ArrayBuffer>} */
    let buffer
    let bufferOffset = 0
    if (groupBuffer) {
      buffer = Promise.resolve(groupBuffer)
      bufferOffset = columnStartByte - groupStartByte
    } else {
      // wrap awaitable to ensure it's a promise
      buffer = Promise.resolve(file.slice(columnStartByte, columnEndByte))
    }

    // read column data async
    promises.push(buffer.then(arrayBuffer => {
      const schemaPath = (0,_schema_js__WEBPACK_IMPORTED_MODULE_3__.getSchemaPath)(metadata.schema, columnMetadata.path_in_schema)
      const reader = { view: new DataView(arrayBuffer), offset: bufferOffset }
      /** @type {any[] | undefined} */
      let columnData = (0,_column_js__WEBPACK_IMPORTED_MODULE_1__.readColumn)(reader, rowGroup, columnMetadata, schemaPath, options)
      // assert(columnData.length === Number(rowGroup.num_rows)

      // TODO: fast path for non-nested columns
      // Save column data for assembly
      const subcolumn = columnMetadata.path_in_schema.join('.')
      subcolumnData.set(subcolumn, columnData)
      columnData = undefined

      const subcolumns = subcolumnNames.get(columnName)
      if (subcolumns?.every(name => subcolumnData.has(name))) {
        // We have all data needed to assemble a top level column
        (0,_assemble_js__WEBPACK_IMPORTED_MODULE_0__.assembleNested)(subcolumnData, schemaPath[1])
        columnData = subcolumnData.get(columnName)
        if (!columnData) {
          throw new Error(`parquet column data not assembled: ${columnName}`)
        }
      }

      // do not emit column data until structs are fully parsed
      if (!columnData) return
      // notify caller of column data
      options.onChunk?.({
        columnName,
        columnData,
        rowStart: groupStart,
        rowEnd: groupStart + columnData.length,
      })
      // save column data only if onComplete is defined
      if (options.onComplete) groupColumnData.push(columnData)
    }))
  }
  await Promise.all(promises)
  if (options.onComplete) {
    // transpose columns into rows
    return groupColumnData[0].map((_, row) => groupColumnData.map(col => col[row]))
  }
  return []
}


/**
 * Return a list of sub-columns needed to construct a top-level column.
 *
 * @param {import('./types.js').SchemaTree} schema
 * @param {string[]} output
 * @returns {string[]}
 */
function getSubcolumns(schema, output = []) {
  if (schema.children.length) {
    for (const child of schema.children) {
      getSubcolumns(child, output)
    }
  } else {
    output.push(schema.path.join('.'))
  }
  return output
}


/***/ }),

/***/ "./node_modules/hyparquet/src/schema.js":
/*!**********************************************!*\
  !*** ./node_modules/hyparquet/src/schema.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMaxDefinitionLevel: () => (/* binding */ getMaxDefinitionLevel),
/* harmony export */   getMaxRepetitionLevel: () => (/* binding */ getMaxRepetitionLevel),
/* harmony export */   getSchemaPath: () => (/* binding */ getSchemaPath),
/* harmony export */   isListLike: () => (/* binding */ isListLike),
/* harmony export */   isMapLike: () => (/* binding */ isMapLike)
/* harmony export */ });
/**
 * Build a tree from the schema elements.
 *
 * @typedef {import('./types.js').SchemaElement} SchemaElement
 * @typedef {import('./types.js').SchemaTree} SchemaTree
 * @param {SchemaElement[]} schema
 * @param {number} rootIndex index of the root element
 * @param {string[]} path path to the element
 * @returns {SchemaTree} tree of schema elements
 */
function schemaTree(schema, rootIndex, path) {
  const element = schema[rootIndex]
  const children = []
  let count = 1

  // Read the specified number of children
  if (element.num_children) {
    while (children.length < element.num_children) {
      const childElement = schema[rootIndex + count]
      const child = schemaTree(schema, rootIndex + count, [...path, childElement.name])
      count += child.count
      children.push(child)
    }
  }

  return { count, element, children, path }
}

/**
 * Get schema elements from the root to the given element name.
 *
 * @param {SchemaElement[]} schema
 * @param {string[]} name path to the element
 * @returns {SchemaTree[]} list of schema elements
 */
function getSchemaPath(schema, name) {
  let tree = schemaTree(schema, 0, [])
  const path = [tree]
  for (const part of name) {
    const child = tree.children.find(child => child.element.name === part)
    if (!child) throw new Error(`parquet schema element not found: ${name}`)
    path.push(child)
    tree = child
  }
  return path
}

/**
 * Get the max repetition level for a given schema path.
 *
 * @param {SchemaTree[]} schemaPath
 * @returns {number} max repetition level
 */
function getMaxRepetitionLevel(schemaPath) {
  let maxLevel = 0
  for (const { element } of schemaPath) {
    if (element.repetition_type === 'REPEATED') {
      maxLevel++
    }
  }
  return maxLevel
}

/**
 * Get the max definition level for a given schema path.
 *
 * @param {SchemaTree[]} schemaPath
 * @returns {number} max definition level
 */
function getMaxDefinitionLevel(schemaPath) {
  let maxLevel = 0
  for (const { element } of schemaPath.slice(1)) {
    if (element.repetition_type !== 'REQUIRED') {
      maxLevel++
    }
  }
  return maxLevel
}

/**
 * Check if a column is list-like.
 *
 * @param {SchemaTree} schema
 * @returns {boolean} true if list-like
 */
function isListLike(schema) {
  if (!schema) return false
  if (schema.element.converted_type !== 'LIST') return false
  if (schema.children.length > 1) return false

  const firstChild = schema.children[0]
  if (firstChild.children.length > 1) return false
  if (firstChild.element.repetition_type !== 'REPEATED') return false

  return true
}

/**
 * Check if a column is map-like.
 *
 * @param {SchemaTree} schema
 * @returns {boolean} true if map-like
 */
function isMapLike(schema) {
  if (!schema) return false
  if (schema.element.converted_type !== 'MAP') return false
  if (schema.children.length > 1) return false

  const firstChild = schema.children[0]
  if (firstChild.children.length !== 2) return false
  if (firstChild.element.repetition_type !== 'REPEATED') return false

  const keyChild = firstChild.children.find(child => child.element.name === 'key')
  if (keyChild?.element.repetition_type === 'REPEATED') return false

  const valueChild = firstChild.children.find(child => child.element.name === 'value')
  if (valueChild?.element.repetition_type === 'REPEATED') return false

  return true
}


/***/ }),

/***/ "./node_modules/hyparquet/src/snappy.js":
/*!**********************************************!*\
  !*** ./node_modules/hyparquet/src/snappy.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   snappyUncompress: () => (/* binding */ snappyUncompress)
/* harmony export */ });
/**
 * The MIT License (MIT)
 * Copyright (c) 2016 Zhipeng Jia
 * https://github.com/zhipeng-jia/snappyjs
 */

const WORD_MASK = [0, 0xff, 0xffff, 0xffffff, 0xffffffff]

/**
 * Copy bytes from one array to another
 *
 * @param {Uint8Array} fromArray source array
 * @param {number} fromPos source position
 * @param {Uint8Array} toArray destination array
 * @param {number} toPos destination position
 * @param {number} length number of bytes to copy
 * @returns {void}
 */
function copyBytes(fromArray, fromPos, toArray, toPos, length) {
  for (let i = 0; i < length; i++) {
    toArray[toPos + i] = fromArray[fromPos + i]
  }
}

/**
 * Copy bytes within an array
 *
 * @param {Uint8Array} array source and destination array
 * @param {number} pos source position
 * @param {number} offset offset back from current position to read
 * @param {number} length number of bytes to copy
 * @returns {void}
 */
function selfCopyBytes(array, pos, offset, length) {
  for (let i = 0; i < length; i++) {
    array[pos + i] = array[pos - offset + i]
  }
}

/**
 * Decompress snappy data.
 * Accepts an output buffer to avoid allocating a new buffer for each call.
 *
 * @param {Uint8Array} input compressed data
 * @param {Uint8Array} output output buffer
 * @returns {void}
 */
function snappyUncompress(input, output) {
  const inputLength = input.byteLength
  const outputLength = output.byteLength
  let pos = 0
  let outPos = 0

  // skip preamble (contains uncompressed length as varint)
  while (pos < inputLength) {
    const c = input[pos]
    pos++
    if (c < 128) {
      break
    }
  }
  if (outputLength && pos >= inputLength) {
    throw new Error('invalid snappy length header')
  }

  while (pos < inputLength) {
    const c = input[pos]
    let len = 0
    pos++

    if (pos >= inputLength) {
      throw new Error('missing eof marker')
    }

    // There are two types of elements, literals and copies (back references)
    if ((c & 0x3) === 0) {
      // Literals are uncompressed data stored directly in the byte stream
      let len = (c >>> 2) + 1
      // Longer literal length is encoded in multiple bytes
      if (len > 60) {
        if (pos + 3 >= inputLength) {
          throw new Error('snappy error literal pos + 3 >= inputLength')
        }
        const lengthSize = len - 60 // length bytes - 1
        len = input[pos]
          + (input[pos + 1] << 8)
          + (input[pos + 2] << 16)
          + (input[pos + 3] << 24)
        len = (len & WORD_MASK[lengthSize]) + 1
        pos += lengthSize
      }
      if (pos + len > inputLength) {
        throw new Error('snappy error literal exceeds input length')
      }
      copyBytes(input, pos, output, outPos, len)
      pos += len
      outPos += len
    } else {
      // Copy elements
      let offset = 0 // offset back from current position to read
      switch (c & 0x3) {
      case 1:
        // Copy with 1-byte offset
        len = (c >>> 2 & 0x7) + 4
        offset = input[pos] + (c >>> 5 << 8)
        pos++
        break
      case 2:
        // Copy with 2-byte offset
        if (inputLength <= pos + 1) {
          throw new Error('snappy error end of input')
        }
        len = (c >>> 2) + 1
        offset = input[pos] + (input[pos + 1] << 8)
        pos += 2
        break
      case 3:
        // Copy with 4-byte offset
        if (inputLength <= pos + 3) {
          throw new Error('snappy error end of input')
        }
        len = (c >>> 2) + 1
        offset = input[pos]
          + (input[pos + 1] << 8)
          + (input[pos + 2] << 16)
          + (input[pos + 3] << 24)
        pos += 4
        break
      default:
        break
      }
      if (offset === 0 || isNaN(offset)) {
        throw new Error(`invalid offset ${offset} pos ${pos} inputLength ${inputLength}`)
      }
      if (offset > outPos) {
        throw new Error('cannot copy from before start of buffer')
      }
      selfCopyBytes(output, outPos, offset, len)
      outPos += len
    }
  }

  if (outPos !== outputLength) throw new Error('premature end of input')
}


/***/ }),

/***/ "./node_modules/hyparquet/src/thrift.js":
/*!**********************************************!*\
  !*** ./node_modules/hyparquet/src/thrift.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deserializeTCompactProtocol: () => (/* binding */ deserializeTCompactProtocol),
/* harmony export */   readVarInt: () => (/* binding */ readVarInt),
/* harmony export */   readZigZagBigInt: () => (/* binding */ readZigZagBigInt),
/* harmony export */   toVarInt: () => (/* binding */ toVarInt)
/* harmony export */ });
// TCompactProtocol types
const CompactType = {
  STOP: 0,
  TRUE: 1,
  FALSE: 2,
  BYTE: 3,
  I16: 4,
  I32: 5,
  I64: 6,
  DOUBLE: 7,
  BINARY: 8,
  LIST: 9,
  SET: 10,
  MAP: 11,
  STRUCT: 12,
  UUID: 13,
}

/**
 * Parse TCompactProtocol
 *
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @param {DataReader} reader
 * @returns {Record<string, any>}
 */
function deserializeTCompactProtocol(reader) {
  let lastFid = 0
  /** @type {Record<string, any>} */
  const value = {}

  while (reader.offset < reader.view.byteLength) {
    // Parse each field based on its type and add to the result object
    const [type, fid, newLastFid] = readFieldBegin(reader, lastFid)
    lastFid = newLastFid

    if (type === CompactType.STOP) {
      break
    }

    // Handle the field based on its type
    value[`field_${fid}`] = readElement(reader, type)
  }

  return value
}

/**
 * Read a single element based on its type
 *
 * @param {DataReader} reader
 * @param {number} type
 * @returns {any} value
 */
function readElement(reader, type) {
  switch (type) {
  case CompactType.TRUE:
    return true
  case CompactType.FALSE:
    return false
  case CompactType.BYTE:
    // read byte directly
    return reader.view.getInt8(reader.offset++)
  case CompactType.I16:
  case CompactType.I32:
    return readZigZag(reader)
  case CompactType.I64:
    return readZigZagBigInt(reader)
  case CompactType.DOUBLE: {
    const value = reader.view.getFloat64(reader.offset, true)
    reader.offset += 8
    return value
  }
  case CompactType.BINARY: {
    const stringLength = readVarInt(reader)
    const strBytes = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, stringLength)
    reader.offset += stringLength
    return strBytes
  }
  case CompactType.LIST: {
    const [elemType, listSize] = readCollectionBegin(reader)
    const values = new Array(listSize)
    for (let i = 0; i < listSize; i++) {
      values[i] = readElement(reader, elemType)
    }
    return values
  }
  case CompactType.STRUCT: {
    /** @type {Record<string, any>} */
    const structValues = {}
    let structLastFid = 0
    while (true) {
      let structFieldType, structFid
      [structFieldType, structFid, structLastFid] = readFieldBegin(reader, structLastFid)
      if (structFieldType === CompactType.STOP) {
        break
      }
      structValues[`field_${structFid}`] = readElement(reader, structFieldType)
    }
    return structValues
  }
  // TODO: MAP and SET
  case CompactType.UUID: {
    // Read 16 bytes to uuid string
    let uuid = ''
    for (let i = 0; i < 16; i++) {
      uuid += reader.view.getUint8(reader.offset++).toString(16).padStart(2, '0')
    }
    return uuid
  }
  default:
    throw new Error(`thrift unhandled type: ${type}`)
  }
}

/**
 * Var int, also known as Unsigned LEB128.
 * Var ints take 1 to 5 bytes (int32) or 1 to 10 bytes (int64).
 * Takes a Big Endian unsigned integer, left-pads the bit-string to make it a
 * multiple of 7 bits, splits it into 7-bit groups, prefix the most-significant
 * 7-bit group with the 0 bit, prefixing the remaining 7-bit groups with the
 * 1 bit and encode the resulting bit-string as Little Endian.
 *
 * @param {DataReader} reader
 * @returns {number} value
 */
function readVarInt(reader) {
  let result = 0
  let shift = 0
  while (true) {
    const byte = reader.view.getUint8(reader.offset++)
    result |= (byte & 0x7f) << shift
    if (!(byte & 0x80)) {
      return result
    }
    shift += 7
  }
}

/**
 * Read a varint as a bigint.
 *
 * @param {DataReader} reader
 * @returns {bigint} value
 */
function readVarBigInt(reader) {
  let result = 0n
  let shift = 0n
  while (true) {
    const byte = reader.view.getUint8(reader.offset++)
    result |= BigInt(byte & 0x7f) << shift
    if (!(byte & 0x80)) {
      return result
    }
    shift += 7n
  }
}

/**
 * Values of type int32 and int64 are transformed to a zigzag int.
 * A zigzag int folds positive and negative numbers into the positive number space.
 *
 * @param {DataReader} reader
 * @returns {number} value
 */
function readZigZag(reader) {
  const zigzag = readVarInt(reader)
  // convert zigzag to int
  return zigzag >>> 1 ^ -(zigzag & 1)
}

/**
 * A zigzag int folds positive and negative numbers into the positive number space.
 * This version returns a BigInt.
 *
 * @param {DataReader} reader
 * @returns {bigint} value
 */
function readZigZagBigInt(reader) {
  const zigzag = readVarBigInt(reader)
  // convert zigzag to int
  return zigzag >> BigInt(1) ^ -(zigzag & BigInt(1))
}

/**
 * Get thrift type from half a byte
 *
 * @param {number} byte
 * @returns {number}
 */
function getCompactType(byte) {
  return byte & 0x0f
}

/**
 * Read field type and field id
 *
 * @param {DataReader} reader
 * @param {number} lastFid
 * @returns {[number, number, number]} [type, fid, newLastFid]
 */
function readFieldBegin(reader, lastFid) {
  const type = reader.view.getUint8(reader.offset++)
  if ((type & 0x0f) === CompactType.STOP) {
    // STOP also ends a struct
    return [0, 0, lastFid]
  }
  const delta = type >> 4
  let fid // field id
  if (delta === 0) {
    // not a delta, read zigzag varint field id
    fid = readZigZag(reader)
  } else {
    // add delta to last field id
    fid = lastFid + delta
  }
  return [getCompactType(type), fid, fid]
}

/**
 * Read collection type and size
 *
 * @param {DataReader} reader
 * @returns {[number, number]} [type, size]
 */
function readCollectionBegin(reader) {
  const sizeType = reader.view.getUint8(reader.offset++)
  const size = sizeType >> 4
  const type = getCompactType(sizeType)
  if (size === 15) {
    const newSize = readVarInt(reader)
    return [type, newSize]
  }
  return [type, size]
}

/**
 * Convert int to varint. Outputs 1-5 bytes for int32.
 *
 * @param {number} n
 * @returns {number[]}
 */
function toVarInt(n) {
  let idx = 0
  const varInt = []
  while (true) {
    if ((n & ~0x7f) === 0) {
      varInt[idx++] = n
      break
    } else {
      varInt[idx++] = n & 0x7f | 0x80
      n >>>= 7
    }
  }
  return varInt
}


/***/ }),

/***/ "./node_modules/hyparquet/src/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/hyparquet/src/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concat: () => (/* binding */ concat),
/* harmony export */   toJson: () => (/* binding */ toJson)
/* harmony export */ });
/**
 * Replace bigints with numbers.
 * When parsing parquet files, bigints are used to represent 64-bit integers.
 * However, JSON does not support bigints, so it's helpful to convert to numbers.
 *
 * @param {any} obj object to convert
 * @returns {unknown} converted object
 */
function toJson(obj) {
  if (obj === undefined) return null
  if (typeof obj === 'bigint') return Number(obj)
  if (Array.isArray(obj)) return obj.map(toJson)
  if (obj instanceof Uint8Array) return Array.from(obj)
  if (obj instanceof Date) return obj.toISOString()
  if (obj instanceof Object) {
    /** @type {Record<string, unknown>} */
    const newObj = {}
    for (const key of Object.keys(obj)) {
      if (obj[key] === undefined) continue
      newObj[key] = toJson(obj[key])
    }
    return newObj
  }
  return obj
}

/**
 * Concatenate two arrays fast.
 *
 * @typedef {import('./types.js').DecodedArray} DecodedArray
 * @param {any[]} aaa first array
 * @param {DecodedArray} bbb second array
 */
function concat(aaa, bbb) {
  const chunk = 10000
  for (let i = 0; i < bbb.length; i += chunk) {
    aaa.push(...bbb.slice(i, i + chunk))
  }
}


/***/ }),

/***/ "./src/ParquetGrid.js":
/*!****************************!*\
  !*** ./src/ParquetGrid.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParquetGrid: () => (/* binding */ ParquetGrid)
/* harmony export */ });
/* harmony import */ var gridviz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gridviz */ "./node_modules/gridviz/src/index.js");
/* harmony import */ var hyparquet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hyparquet */ "./node_modules/hyparquet/src/hyparquet.js");
//@ts-check


;

//import { tableFromIPC } from 'apache-arrow'
//import { readParquet } from "parquet-wasm"
//import { readParquet } from "parquet-wasm/bundler/arrow1.js";
//import { readParquet } from "parquet-wasm/node2";

//see https://www.npmjs.com/package/parquet-wasm

//see https://observablehq.com/@bmschmidt/hello-parquet-wasm
/*
pq = {
  const pq = await import('https://unpkg.com/parquet-wasm@0.1.1/web.js')
  // default seems to need to resolve first?
  await pq.default()
  return pq
}
*/

/**
 * A dataset composed of a single parquet file (not tiled).
 *
 * @author Julien Gaffuri
 */
class ParquetGrid extends gridviz__WEBPACK_IMPORTED_MODULE_0__.Dataset {

    constructor(map, url, resolution, opts = {}) {
        super(map, url, resolution, opts)

        /**
         * @private
         * @type {Array.<object>} */
        this.cells = []

        /**
         * @type {string}
         * @private  */
        this.infoLoadingStatus = 'notLoaded'

        //console.log(readParquet)
        //const pq = await import('https://unpkg.com/parquet-wasm@0.1.1/web.js')
        //await pq.default()

        if (!opts.readParquetFun) throw new Error('readParquet function needed for parquet dataset')

        /**
         * @type {Function}
         * @private  */
        //this.readParquetFun = opts.readParquetFun
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {object|undefined} e
     * @param {function():void} redraw
     */
    getData(e, redraw) {
        //check if data already loaded
        if (this.infoLoadingStatus != 'notLoaded') return this

        //load data
        this.infoLoadingStatus = 'loading'

        const res = fetch(this.url)
        const arrayBuffer = res.arrayBuffer()
        const metadata = (0,hyparquet__WEBPACK_IMPORTED_MODULE_1__.parquetMetadata)(arrayBuffer)
        console.log(metadata)

        /*;(async () => {
            try {
                const resp = await fetch(this.url)
                const parquetUint8Array = new Uint8Array(await resp.arrayBuffer())
                const arrowUint8Array = this.readParquetFun(parquetUint8Array)

                const t = tableFromIPC(arrowUint8Array)
                //see https://arrow.apache.org/docs/js/
                //https://loaders.gl/arrowjs/docs/developer-guide/tables#record-tojson-and-toarray

                this.cells = []
                for (const e of t) {
                    //get cell
                    const c = e.toJSON()

                    //preprocess/filter
                    if (this.preprocess) {
                        const b = this.preprocess(c)
                        if (b == false) continue
                        this.cells.push(c)
                    } else {
                        this.cells.push(c)
                    }
                }

                //TODO check if redraw is necessary
                //that is if the dataset belongs to a layer which is visible at the current zoom level

                //execute the callback, usually a draw function
                if (redraw) redraw()

                this.infoLoadingStatus = 'loaded'
            } catch (error) {
                //mark as failed
                this.infoLoadingStatus = 'failed'
                this.cells = []
            }
        })()*/

        return this
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     *
     * @param {object} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //data not loaded yet
        if (!this.cells) return

        this.cellsViewCache = []
        for (const cell of this.cells) {
            if (+cell.x + this.resolution < extGeo.xMin) continue
            if (+cell.x - this.resolution > extGeo.xMax) continue
            if (+cell.y + this.resolution < extGeo.yMin) continue
            if (+cell.y - this.resolution > extGeo.yMax) continue
            this.cellsViewCache.push(cell)
        }
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParquetGrid: () => (/* reexport safe */ _ParquetGrid_js__WEBPACK_IMPORTED_MODULE_0__.ParquetGrid)
/* harmony export */ });
/* harmony import */ var _ParquetGrid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ParquetGrid.js */ "./src/ParquetGrid.js");
//@ts-check



//export { TiledParquetGrid } from "./TiledParquetGrid.js"
/*
import { Dataset } from 'gridviz'
import { ParquetGrid } from "./ParquetGrid.js"
import { TiledParquetGrid } from "./TiledParquetGrid.js"

//import { readParquet } from "parquet-wasm"
//import { readParquet } from "parquet-wasm/bundler/arrow1.js";
//import { readParquet } from "parquet-wasm/node2";



/*
export const makeParquetGridDataset = function (app, url, resolution, opts) {
    return new Dataset([new ParquetGrid(url, resolution, opts).getData(undefined, () => { app.cg.redraw(); })], [], opts)
}

/**
* Add a layer from a parquet grid dataset.
*
* @param {object} app The gridviz application.
* @param {string} url The URL of the dataset.
* @param {number} resolution The dataset resolution in geographical unit.
* @param {Array.<object>} styles The styles, ordered in drawing order.
* @param {object=} opts The parameters of the dataset and layer.
* @returns {object}
*/
/*export const addParquetGridLayer = function (app, url, resolution, styles, opts) {
    const ds = makeParquetGridDataset(app, url, resolution, opts)
    return app.addLayerFromDataset(ds, styles, opts);
}*/






/*
export const makeMultiScaleParquetGridDataset = function (app, resolutions, resToURL, opts) {
    return Dataset.make(
        resolutions,
        (res) => new ParquetGrid(resToURL(res), res, opts).getData(undefined, () => { app.cg.redraw() }),
        opts
    )
}

/**
* @param {object} app The gridviz application.
 * @param {Array.<number>} resolutions
 * @param {function(number):string} resToURL
* @param {Array.<object>} styles The styles, ordered in drawing order.
 * @param {object=} opts The parameters of the dataset and layer.
 * @returns {object}
 */
/*export const addMultiScaleParquetGridLayer = function (app, resolutions, resToURL, styles, opts) {
    const ds = makeMultiScaleParquetGridDataset(app, resolutions, resToURL, opts)
    return app.addLayerFromDataset(ds, styles, opts)
}






export const makeTiledParquetGridDataset = function (app, url, opts) {
    return new Dataset(
        [new TiledParquetGrid(url, app, opts).loadInfo(() => { app.cg.redraw() }),],
        [],
        opts
    )
}

/**
* @param {object} app The gridviz application.
 * @param {string} url
* @param {Array.<object>} styles The styles, ordered in drawing order.
 * @param {{visible?:boolean,minZoom?:number,maxZoom?:number,pixNb?:number,cellInfoHTML?:function(object):string, preprocess?:function(object):boolean}} opts
 * @returns {object}
 */
/*export const addTiledParquetGridLayer = function (app, url, styles, opts) {
    const ds = makeTiledParquetGridDataset(app, url, opts)
    return app.addLayerFromDataset(ds, styles, opts)
}






export const makeMultiScaleTiledParquetGridDataset = function (app, resolutions, resToURL, opts) {
    return Dataset.make(
        resolutions,
        (res) => new TiledParquetGrid(resToURL(res), app, opts).loadInfo(() => { app.cg.redraw() }),
        opts
    )
}

/**
* @param {object} app The gridviz application.
 * @param {Array.<number>} resolutions
 * @param {function(number):string} resToURL
* @param {Array.<object>} styles The styles, ordered in drawing order.
 * @param {object=} opts The parameters of the dataset and layer.
 * @returns {object}
 */
/*export const addMultiScaleTiledParquetGridLayer = function (app, resolutions, resToURL, styles, opts) {
    const ds = makeMultiScaleTiledParquetGridDataset(app, resolutions, resToURL, opts)
    return app.addLayerFromDataset(ds, styles, opts)
}



//test utilisation of that:
//<script src="https://unpkg.com/parquet-wasm@0.4.0-beta.5/esm/arrow2.js"></script>
/*export const loadWasmParquetReader = async () => {
    const parquetModule = await import("parquet-wasm")
    return parquetModule.readParquet
    //await parquetModule.default()
    //return parquetModule.readParquet
}*/


/**
 * Retrieve parquet wasm decoder
 */
/*
const getReadParquetP = ()=> async () => {
    const parquetModule = await import("https://unpkg.com/parquet-wasm@0.4.0-beta.5/esm/arrow2.js");
    await parquetModule.default();
    return parquetModule.readParquet;
}
*/

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EseUJBQXlCLElBQUk7QUFDN0Isd0NBQXdDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSTtBQUMxRCx3Q0FBd0MsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQzFELDBDQUEwQyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQ25FLDBDQUEwQyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQ25FLHdDQUF3QyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDMUQsMENBQTBDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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ZUFBZSxZQUFZLFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4SG9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsOENBQU07QUFDdkM7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJTywrRUFBK0U7O0FBRXRGO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsc0RBQWM7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOztBQUVBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxTUE7QUFDWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxX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LFVBQVUsZ0JBQWdCO0FBQzFCLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ndml6X3Bhci93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9iaXNlY3Rvci5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZGVzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZXh0ZW50LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9ncmVhdGVzdC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWF4LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tYXhJbmRleC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWluLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9taW5JbmRleC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9wZXJtdXRlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9xdWFudGlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcXVpY2tzZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3NvcnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2NvbG9yLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2xhYi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9zcmMvZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9kcmFnLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL25vZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZHN2L3NyYy9jc3YuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZHN2L3NyYy9kc3YuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZHN2L3NyYy90c3YuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvY3ViaWMuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZmV0Y2gvc3JjL2Rzdi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mZXRjaC9zcmMvanNvbi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mZXRjaC9zcmMvdGV4dC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2RlZmF1bHRMb2NhbGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9leHBvbmVudC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdERlY2ltYWwuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRHcm91cC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdE51bWVyYWxzLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0UHJlZml4QXV0by5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFJvdW5kZWQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRTcGVjaWZpZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRUcmltLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHlwZXMuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2xvY2FsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYmFzaXMuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2xhYi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9yZ2IuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2RlY29tcG9zZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2luZGV4LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vcGFyc2UuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3pvb20uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtcmFuZG9tL3NyYy9kZWZhdWx0U291cmNlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXJhbmRvbS9zcmMvbm9ybWFsLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pbml0LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2FycmF5LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdG9yLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbWF0Y2hlci5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9wb2ludGVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2FwcGVuZC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hdHRyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NhbGwuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vY2xhc3NlZC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbG9uZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXRhLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2RhdHVtLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VhY2guanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW1wdHkuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW50ZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZXhpdC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaHRtbC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbnNlcnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vam9pbi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9sb3dlci5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9ub2RlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGVzLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29uLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29yZGVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3Byb3BlcnR5LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JhaXNlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdENoaWxkLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdENoaWxkcmVuLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NpemUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc29ydC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zcGFyc2UuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vdGV4dC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdG9yLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3JBbGwuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zb3VyY2VFdmVudC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3dpbmRvdy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvdGltZW91dC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvdGltZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvYWN0aXZlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL2luZGV4LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL2ludGVycnVwdC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvc2VsZWN0aW9uL2ludGVycnVwdC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vdHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9hdHRyVHdlZW4uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9kZWxheS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2R1cmF0aW9uLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZWFzZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2VWYXJ5aW5nLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZW5kLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZmlsdGVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL21lcmdlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vb24uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zY2hlZHVsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3N0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGVUd2Vlbi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90ZXh0VHdlZW4uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vdHdlZW4uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvbm9ldmVudC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9idXR0b24vQnV0dG9uLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2J1dHRvbi9GdWxsc2NyZWVuQnV0dG9uLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2J1dHRvbi9ab29tQnV0dG9ucy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9jb3JlL0RhdGFzZXQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvY29yZS9EcmF3YWJsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9jb3JlL0dlb0NhbnZhcy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9jb3JlL0xheWVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2NvcmUvTGVnZW5kLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2NvcmUvTWFwLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2NvcmUvTXVsdGlSZXNvbHV0aW9uRGF0YXNldC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9jb3JlL1N0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2NvcmUvVG9vbHRpcC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9kYXRhc2V0L0NTVkdyaWQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvZGF0YXNldC9KU0dyaWQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvZGF0YXNldC9UaWxlZEdyaWQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvbGF5ZXIvQmFja2dyb3VuZExheWVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2xheWVyL0JhY2tncm91bmRMYXllckltYWdlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2xheWVyL0JhY2tncm91bmRMYXllcldNUy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9sYXllci9HZW9KU09OTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvbGF5ZXIvR3JpZExheWVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2xheWVyL0xhYmVsTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvbGVnZW5kL0NvbG9yQ2F0ZWdvcnlMZWdlbmQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvbGVnZW5kL0NvbG9yRGlzY3JldGVMZWdlbmQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvbGVnZW5kL0NvbG9yTGVnZW5kLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2xlZ2VuZC9PcmllbnRhdGlvbkxlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9sZWdlbmQvU2l6ZUxlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9sZWdlbmQvVHJpdmFyaWF0ZUxlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9Db21wb3NpdGlvblN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL0RvdERlbnNpdHlTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9JbWFnZVN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL0lzb0ZlbmNlU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvc3R5bGUvSm95UGxvdFN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL0xlZ29TdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9Nb3NhaWNTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9OaW5qYVN0YXJTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9QaWxsYXJTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9TZWdtZW50U3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvc3R5bGUvU2hhcGVDb2xvclNpemVTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9TaWRlQ2F0ZWdvcnlTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9TaWRlU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvc3R5bGUvU3F1YXJlQ29sb3JDYXRlZ29yeVdlYkdMU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvc3R5bGUvU3F1YXJlQ29sb3JXZWJHTFN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL1N0cm9rZVN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL1RhbmFrYVN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL1RleHRTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9UaW1lU2VyaWVzU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvdXRpbHMvV2ViR0xTcXVhcmVDb2xvcmluZy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy91dGlscy9XZWJHTFNxdWFyZUNvbG9yaW5nQWR2YW5jZWQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvdXRpbHMvV2ViR0xTcXVhcmVDb2xvcmluZ0NhdEFkdmFuY2VkLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3V0aWxzL2NoZXJub2ZmLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3V0aWxzL3NjYWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3V0aWxzL3N0cmV0Y2hpbmcuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvdXRpbHMvdHJpdmFyaWF0ZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy91dGlscy91dGlscy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy91dGlscy93ZWJHTFV0aWxzLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvYXNzZW1ibGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvaHlwYXJxdWV0L3NyYy9jb2x1bW4uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvaHlwYXJxdWV0L3NyYy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvaHlwYXJxdWV0L3NyYy9jb252ZXJ0LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvZGF0YXBhZ2UuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvaHlwYXJxdWV0L3NyYy9kYXRhcGFnZVYyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvZGVsdGEuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvaHlwYXJxdWV0L3NyYy9lbmNvZGluZy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9oeXBhcnF1ZXQvc3JjL2hlYWRlci5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9oeXBhcnF1ZXQvc3JjL2h5cGFycXVldC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9oeXBhcnF1ZXQvc3JjL21ldGFkYXRhLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvcGxhaW4uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvaHlwYXJxdWV0L3NyYy9yZWFkLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvc2NoZW1hLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvc25hcHB5LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvdGhyaWZ0LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9zcmMvUGFycXVldEdyaWQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2d2aXpfcGFyL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJndml6X3BhclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJndml6X3BhclwiXSA9IGZhY3RvcnkoKTtcbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA9PSBudWxsIHx8IGIgPT0gbnVsbCA/IE5hTiA6IGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcbmltcG9ydCBiaXNlY3RvciBmcm9tIFwiLi9iaXNlY3Rvci5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxuY29uc3QgYXNjZW5kaW5nQmlzZWN0ID0gYmlzZWN0b3IoYXNjZW5kaW5nKTtcbmV4cG9ydCBjb25zdCBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbmV4cG9ydCBjb25zdCBiaXNlY3RMZWZ0ID0gYXNjZW5kaW5nQmlzZWN0LmxlZnQ7XG5leHBvcnQgY29uc3QgYmlzZWN0Q2VudGVyID0gYmlzZWN0b3IobnVtYmVyKS5jZW50ZXI7XG5leHBvcnQgZGVmYXVsdCBiaXNlY3RSaWdodDtcbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5pbXBvcnQgZGVzY2VuZGluZyBmcm9tIFwiLi9kZXNjZW5kaW5nLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpc2VjdG9yKGYpIHtcbiAgbGV0IGNvbXBhcmUxLCBjb21wYXJlMiwgZGVsdGE7XG5cbiAgLy8gSWYgYW4gYWNjZXNzb3IgaXMgc3BlY2lmaWVkLCBwcm9tb3RlIGl0IHRvIGEgY29tcGFyYXRvci4gSW4gdGhpcyBjYXNlIHdlXG4gIC8vIGNhbiB0ZXN0IHdoZXRoZXIgdGhlIHNlYXJjaCB2YWx1ZSBpcyAoc2VsZi0pIGNvbXBhcmFibGUuIFdlIGNhbuKAmXQgZG8gdGhpc1xuICAvLyBmb3IgYSBjb21wYXJhdG9yIChleGNlcHQgZm9yIHNwZWNpZmljLCBrbm93biBjb21wYXJhdG9ycykgYmVjYXVzZSB3ZSBjYW7igJl0XG4gIC8vIHRlbGwgaWYgdGhlIGNvbXBhcmF0b3IgaXMgc3ltbWV0cmljLCBhbmQgYW4gYXN5bW1ldHJpYyBjb21wYXJhdG9yIGNhbuKAmXQgYmVcbiAgLy8gdXNlZCB0byB0ZXN0IHdoZXRoZXIgYSBzaW5nbGUgdmFsdWUgaXMgY29tcGFyYWJsZS5cbiAgaWYgKGYubGVuZ3RoICE9PSAyKSB7XG4gICAgY29tcGFyZTEgPSBhc2NlbmRpbmc7XG4gICAgY29tcGFyZTIgPSAoZCwgeCkgPT4gYXNjZW5kaW5nKGYoZCksIHgpO1xuICAgIGRlbHRhID0gKGQsIHgpID0+IGYoZCkgLSB4O1xuICB9IGVsc2Uge1xuICAgIGNvbXBhcmUxID0gZiA9PT0gYXNjZW5kaW5nIHx8IGYgPT09IGRlc2NlbmRpbmcgPyBmIDogemVybztcbiAgICBjb21wYXJlMiA9IGY7XG4gICAgZGVsdGEgPSBmO1xuICB9XG5cbiAgZnVuY3Rpb24gbGVmdChhLCB4LCBsbyA9IDAsIGhpID0gYS5sZW5ndGgpIHtcbiAgICBpZiAobG8gPCBoaSkge1xuICAgICAgaWYgKGNvbXBhcmUxKHgsIHgpICE9PSAwKSByZXR1cm4gaGk7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IG1pZCA9IChsbyArIGhpKSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUyKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgICB9IHdoaWxlIChsbyA8IGhpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvO1xuICB9XG5cbiAgZnVuY3Rpb24gcmlnaHQoYSwgeCwgbG8gPSAwLCBoaSA9IGEubGVuZ3RoKSB7XG4gICAgaWYgKGxvIDwgaGkpIHtcbiAgICAgIGlmIChjb21wYXJlMSh4LCB4KSAhPT0gMCkgcmV0dXJuIGhpO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCBtaWQgPSAobG8gKyBoaSkgPj4+IDE7XG4gICAgICAgIGlmIChjb21wYXJlMihhW21pZF0sIHgpIDw9IDApIGxvID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgIH0gd2hpbGUgKGxvIDwgaGkpO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBmdW5jdGlvbiBjZW50ZXIoYSwgeCwgbG8gPSAwLCBoaSA9IGEubGVuZ3RoKSB7XG4gICAgY29uc3QgaSA9IGxlZnQoYSwgeCwgbG8sIGhpIC0gMSk7XG4gICAgcmV0dXJuIGkgPiBsbyAmJiBkZWx0YShhW2kgLSAxXSwgeCkgPiAtZGVsdGEoYVtpXSwgeCkgPyBpIC0gMSA6IGk7XG4gIH1cblxuICByZXR1cm4ge2xlZnQsIGNlbnRlciwgcmlnaHR9O1xufVxuXG5mdW5jdGlvbiB6ZXJvKCkge1xuICByZXR1cm4gMDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA9PSBudWxsIHx8IGIgPT0gbnVsbCA/IE5hTlxuICAgIDogYiA8IGEgPyAtMVxuICAgIDogYiA+IGEgPyAxXG4gICAgOiBiID49IGEgPyAwXG4gICAgOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHRlbnQodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtaW47XG4gIGxldCBtYXg7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID49IHZhbHVlKSBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPj0gdmFsdWUpIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gW21pbiwgbWF4XTtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdyZWF0ZXN0KHZhbHVlcywgY29tcGFyZSA9IGFzY2VuZGluZykge1xuICBsZXQgbWF4O1xuICBsZXQgZGVmaW5lZCA9IGZhbHNlO1xuICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpIHtcbiAgICBsZXQgbWF4VmFsdWU7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHZhbHVlcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBjb21wYXJlKGVsZW1lbnQpO1xuICAgICAgaWYgKGRlZmluZWRcbiAgICAgICAgICA/IGFzY2VuZGluZyh2YWx1ZSwgbWF4VmFsdWUpID4gMFxuICAgICAgICAgIDogYXNjZW5kaW5nKHZhbHVlLCB2YWx1ZSkgPT09IDApIHtcbiAgICAgICAgbWF4ID0gZWxlbWVudDtcbiAgICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZGVmaW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoZGVmaW5lZFxuICAgICAgICAgID8gY29tcGFyZSh2YWx1ZSwgbWF4KSA+IDBcbiAgICAgICAgICA6IGNvbXBhcmUodmFsdWUsIHZhbHVlKSA9PT0gMCkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgZGVmaW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXgodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtYXg7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXhJbmRleCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1heDtcbiAgbGV0IG1heEluZGV4ID0gLTE7XG4gIGxldCBpbmRleCA9IC0xO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICsraW5kZXg7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbFxuICAgICAgICAgICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtYXggPSB2YWx1ZSwgbWF4SW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbFxuICAgICAgICAgICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtYXggPSB2YWx1ZSwgbWF4SW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heEluZGV4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWluKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWluO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWluO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWluSW5kZXgodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtaW47XG4gIGxldCBtaW5JbmRleCA9IC0xO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICArK2luZGV4O1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWUsIG1pbkluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWUsIG1pbkluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5JbmRleDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG51bWJlcih4KSB7XG4gIHJldHVybiB4ID09PSBudWxsID8gTmFOIDogK3g7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogbnVtYmVycyh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGVybXV0ZShzb3VyY2UsIGtleXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oa2V5cywga2V5ID0+IHNvdXJjZVtrZXldKTtcbn1cbiIsImltcG9ydCBtYXggZnJvbSBcIi4vbWF4LmpzXCI7XG5pbXBvcnQgbWF4SW5kZXggZnJvbSBcIi4vbWF4SW5kZXguanNcIjtcbmltcG9ydCBtaW4gZnJvbSBcIi4vbWluLmpzXCI7XG5pbXBvcnQgbWluSW5kZXggZnJvbSBcIi4vbWluSW5kZXguanNcIjtcbmltcG9ydCBxdWlja3NlbGVjdCBmcm9tIFwiLi9xdWlja3NlbGVjdC5qc1wiO1xuaW1wb3J0IG51bWJlciwge251bWJlcnN9IGZyb20gXCIuL251bWJlci5qc1wiO1xuaW1wb3J0IHthc2NlbmRpbmdEZWZpbmVkfSBmcm9tIFwiLi9zb3J0LmpzXCI7XG5pbXBvcnQgZ3JlYXRlc3QgZnJvbSBcIi4vZ3JlYXRlc3QuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpbGUodmFsdWVzLCBwLCB2YWx1ZW9mKSB7XG4gIHZhbHVlcyA9IEZsb2F0NjRBcnJheS5mcm9tKG51bWJlcnModmFsdWVzLCB2YWx1ZW9mKSk7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSB8fCBpc05hTihwID0gK3ApKSByZXR1cm47XG4gIGlmIChwIDw9IDAgfHwgbiA8IDIpIHJldHVybiBtaW4odmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuIG1heCh2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9IG1heChxdWlja3NlbGVjdCh2YWx1ZXMsIGkwKS5zdWJhcnJheSgwLCBpMCArIDEpKSxcbiAgICAgIHZhbHVlMSA9IG1pbih2YWx1ZXMuc3ViYXJyYXkoaTAgKyAxKSk7XG4gIHJldHVybiB2YWx1ZTAgKyAodmFsdWUxIC0gdmFsdWUwKSAqIChpIC0gaTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpbGVTb3J0ZWQodmFsdWVzLCBwLCB2YWx1ZW9mID0gbnVtYmVyKSB7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSB8fCBpc05hTihwID0gK3ApKSByZXR1cm47XG4gIGlmIChwIDw9IDAgfHwgbiA8IDIpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbMF0sIDAsIHZhbHVlcyk7XG4gIGlmIChwID49IDEpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbbiAtIDFdLCBuIC0gMSwgdmFsdWVzKTtcbiAgdmFyIG4sXG4gICAgICBpID0gKG4gLSAxKSAqIHAsXG4gICAgICBpMCA9IE1hdGguZmxvb3IoaSksXG4gICAgICB2YWx1ZTAgPSArdmFsdWVvZih2YWx1ZXNbaTBdLCBpMCwgdmFsdWVzKSxcbiAgICAgIHZhbHVlMSA9ICt2YWx1ZW9mKHZhbHVlc1tpMCArIDFdLCBpMCArIDEsIHZhbHVlcyk7XG4gIHJldHVybiB2YWx1ZTAgKyAodmFsdWUxIC0gdmFsdWUwKSAqIChpIC0gaTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpbGVJbmRleCh2YWx1ZXMsIHAsIHZhbHVlb2YgPSBudW1iZXIpIHtcbiAgaWYgKGlzTmFOKHAgPSArcCkpIHJldHVybjtcbiAgbnVtYmVycyA9IEZsb2F0NjRBcnJheS5mcm9tKHZhbHVlcywgKF8sIGkpID0+IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpO1xuICBpZiAocCA8PSAwKSByZXR1cm4gbWluSW5kZXgobnVtYmVycyk7XG4gIGlmIChwID49IDEpIHJldHVybiBtYXhJbmRleChudW1iZXJzKTtcbiAgdmFyIG51bWJlcnMsXG4gICAgICBpbmRleCA9IFVpbnQzMkFycmF5LmZyb20odmFsdWVzLCAoXywgaSkgPT4gaSksXG4gICAgICBqID0gbnVtYmVycy5sZW5ndGggLSAxLFxuICAgICAgaSA9IE1hdGguZmxvb3IoaiAqIHApO1xuICBxdWlja3NlbGVjdChpbmRleCwgaSwgMCwgaiwgKGksIGopID0+IGFzY2VuZGluZ0RlZmluZWQobnVtYmVyc1tpXSwgbnVtYmVyc1tqXSkpO1xuICBpID0gZ3JlYXRlc3QoaW5kZXguc3ViYXJyYXkoMCwgaSArIDEpLCAoaSkgPT4gbnVtYmVyc1tpXSk7XG4gIHJldHVybiBpID49IDAgPyBpIDogLTE7XG59XG4iLCJpbXBvcnQge2FzY2VuZGluZ0RlZmluZWQsIGNvbXBhcmVEZWZpbmVkfSBmcm9tIFwiLi9zb3J0LmpzXCI7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3F1aWNrc2VsZWN0XG4vLyBJU0MgbGljZW5zZSwgQ29weXJpZ2h0IDIwMTggVmxhZGltaXIgQWdhZm9ua2luLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyYXksIGssIGxlZnQgPSAwLCByaWdodCA9IEluZmluaXR5LCBjb21wYXJlKSB7XG4gIGsgPSBNYXRoLmZsb29yKGspO1xuICBsZWZ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBsZWZ0KSk7XG4gIHJpZ2h0ID0gTWF0aC5mbG9vcihNYXRoLm1pbihhcnJheS5sZW5ndGggLSAxLCByaWdodCkpO1xuXG4gIGlmICghKGxlZnQgPD0gayAmJiBrIDw9IHJpZ2h0KSkgcmV0dXJuIGFycmF5O1xuXG4gIGNvbXBhcmUgPSBjb21wYXJlID09PSB1bmRlZmluZWQgPyBhc2NlbmRpbmdEZWZpbmVkIDogY29tcGFyZURlZmluZWQoY29tcGFyZSk7XG5cbiAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgIGNvbnN0IG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgY29uc3QgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgIGNvbnN0IHogPSBNYXRoLmxvZyhuKTtcbiAgICAgIGNvbnN0IHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgY29uc3Qgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICBjb25zdCBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgIGNvbnN0IG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICBxdWlja3NlbGVjdChhcnJheSwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xuICAgIH1cblxuICAgIGNvbnN0IHQgPSBhcnJheVtrXTtcbiAgICBsZXQgaSA9IGxlZnQ7XG4gICAgbGV0IGogPSByaWdodDtcblxuICAgIHN3YXAoYXJyYXksIGxlZnQsIGspO1xuICAgIGlmIChjb21wYXJlKGFycmF5W3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFycmF5LCBsZWZ0LCByaWdodCk7XG5cbiAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgIHN3YXAoYXJyYXksIGksIGopLCArK2ksIC0tajtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2ldLCB0KSA8IDApICsraTtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2pdLCB0KSA+IDApIC0tajtcbiAgICB9XG5cbiAgICBpZiAoY29tcGFyZShhcnJheVtsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyYXksIGxlZnQsIGopO1xuICAgIGVsc2UgKytqLCBzd2FwKGFycmF5LCBqLCByaWdodCk7XG5cbiAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gc3dhcChhcnJheSwgaSwgaikge1xuICBjb25zdCB0ID0gYXJyYXlbaV07XG4gIGFycmF5W2ldID0gYXJyYXlbal07XG4gIGFycmF5W2pdID0gdDtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5pbXBvcnQgcGVybXV0ZSBmcm9tIFwiLi9wZXJtdXRlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNvcnQodmFsdWVzLCAuLi5GKSB7XG4gIGlmICh0eXBlb2YgdmFsdWVzW1N5bWJvbC5pdGVyYXRvcl0gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbHVlcyBpcyBub3QgaXRlcmFibGVcIik7XG4gIHZhbHVlcyA9IEFycmF5LmZyb20odmFsdWVzKTtcbiAgbGV0IFtmXSA9IEY7XG4gIGlmICgoZiAmJiBmLmxlbmd0aCAhPT0gMikgfHwgRi5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgaW5kZXggPSBVaW50MzJBcnJheS5mcm9tKHZhbHVlcywgKGQsIGkpID0+IGkpO1xuICAgIGlmIChGLmxlbmd0aCA+IDEpIHtcbiAgICAgIEYgPSBGLm1hcChmID0+IHZhbHVlcy5tYXAoZikpO1xuICAgICAgaW5kZXguc29ydCgoaSwgaikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgRikge1xuICAgICAgICAgIGNvbnN0IGMgPSBhc2NlbmRpbmdEZWZpbmVkKGZbaV0sIGZbal0pO1xuICAgICAgICAgIGlmIChjKSByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGYgPSB2YWx1ZXMubWFwKGYpO1xuICAgICAgaW5kZXguc29ydCgoaSwgaikgPT4gYXNjZW5kaW5nRGVmaW5lZChmW2ldLCBmW2pdKSk7XG4gICAgfVxuICAgIHJldHVybiBwZXJtdXRlKHZhbHVlcywgaW5kZXgpO1xuICB9XG4gIHJldHVybiB2YWx1ZXMuc29ydChjb21wYXJlRGVmaW5lZChmKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlRGVmaW5lZChjb21wYXJlID0gYXNjZW5kaW5nKSB7XG4gIGlmIChjb21wYXJlID09PSBhc2NlbmRpbmcpIHJldHVybiBhc2NlbmRpbmdEZWZpbmVkO1xuICBpZiAodHlwZW9mIGNvbXBhcmUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvbXBhcmUgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gIHJldHVybiAoYSwgYikgPT4ge1xuICAgIGNvbnN0IHggPSBjb21wYXJlKGEsIGIpO1xuICAgIGlmICh4IHx8IHggPT09IDApIHJldHVybiB4O1xuICAgIHJldHVybiAoY29tcGFyZShiLCBiKSA9PT0gMCkgLSAoY29tcGFyZShhLCBhKSA9PT0gMCk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2NlbmRpbmdEZWZpbmVkKGEsIGIpIHtcbiAgcmV0dXJuIChhID09IG51bGwgfHwgIShhID49IGEpKSAtIChiID09IG51bGwgfHwgIShiID49IGIpKSB8fCAoYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDApO1xufVxuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2xvcigpIHt9XG5cbmV4cG9ydCB2YXIgZGFya2VyID0gMC43O1xuZXhwb3J0IHZhciBicmlnaHRlciA9IDEgLyBkYXJrZXI7XG5cbnZhciByZUkgPSBcIlxcXFxzKihbKy1dP1xcXFxkKylcXFxccypcIixcbiAgICByZU4gPSBcIlxcXFxzKihbKy1dPyg/OlxcXFxkKlxcXFwuKT9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPylcXFxccypcIixcbiAgICByZVAgPSBcIlxcXFxzKihbKy1dPyg/OlxcXFxkKlxcXFwuKT9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCIsXG4gICAgcmVIZXggPSAvXiMoWzAtOWEtZl17Myw4fSkkLyxcbiAgICByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKGBecmdiXFxcXCgke3JlSX0sJHtyZUl9LCR7cmVJfVxcXFwpJGApLFxuICAgIHJlUmdiUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5yZ2JcXFxcKCR7cmVQfSwke3JlUH0sJHtyZVB9XFxcXCkkYCksXG4gICAgcmVSZ2JhSW50ZWdlciA9IG5ldyBSZWdFeHAoYF5yZ2JhXFxcXCgke3JlSX0sJHtyZUl9LCR7cmVJfSwke3JlTn1cXFxcKSRgKSxcbiAgICByZVJnYmFQZXJjZW50ID0gbmV3IFJlZ0V4cChgXnJnYmFcXFxcKCR7cmVQfSwke3JlUH0sJHtyZVB9LCR7cmVOfVxcXFwpJGApLFxuICAgIHJlSHNsUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5oc2xcXFxcKCR7cmVOfSwke3JlUH0sJHtyZVB9XFxcXCkkYCksXG4gICAgcmVIc2xhUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5oc2xhXFxcXCgke3JlTn0sJHtyZVB9LCR7cmVQfSwke3JlTn1cXFxcKSRgKTtcblxudmFyIG5hbWVkID0ge1xuICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICBhcXVhOiAweDAwZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXG4gIGF6dXJlOiAweGYwZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjLFxuICBiaXNxdWU6IDB4ZmZlNGM0LFxuICBibGFjazogMHgwMDAwMDAsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgYmx1ZTogMHgwMDAwZmYsXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICBicm93bjogMHhhNTJhMmEsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODcsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxuICBjb3JhbDogMHhmZjdmNTAsXG4gIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgY29ybnNpbGs6IDB4ZmZmOGRjLFxuICBjcmltc29uOiAweGRjMTQzYyxcbiAgY3lhbjogMHgwMGZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YixcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxuICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgZGFya2dyYXk6IDB4YTlhOWE5LFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICBkYXJrZ3JleTogMHhhOWE5YTksXG4gIGRhcmtraGFraTogMHhiZGI3NmIsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxuICBkZWVwcGluazogMHhmZjE0OTMsXG4gIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjksXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxuICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgZ29sZDogMHhmZmQ3MDAsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gIGdyYXk6IDB4ODA4MDgwLFxuICBncmVlbjogMHgwMDgwMDAsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgZ3JleTogMHg4MDgwODAsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMCxcbiAgaG90cGluazogMHhmZjY5YjQsXG4gIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gIGluZGlnbzogMHg0YjAwODIsXG4gIGl2b3J5OiAweGZmZmZmMCxcbiAga2hha2k6IDB4ZjBlNjhjLFxuICBsYXZlbmRlcjogMHhlNmU2ZmEsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgbGlnaHRjeWFuOiAweGUwZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MCxcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxuICBsaW1lOiAweDAwZmYwMCxcbiAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgbGluZW46IDB4ZmFmMGU2LFxuICBtYWdlbnRhOiAweGZmMDBmZixcbiAgbWFyb29uOiAweDgwMDAwMCxcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgbW9jY2FzaW46IDB4ZmZlNGI1LFxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gIG5hdnk6IDB4MDAwMDgwLFxuICBvbGRsYWNlOiAweGZkZjVlNixcbiAgb2xpdmU6IDB4ODA4MDAwLFxuICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICBvcmFuZ2U6IDB4ZmZhNTAwLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgcGVydTogMHhjZDg1M2YsXG4gIHBpbms6IDB4ZmZjMGNiLFxuICBwbHVtOiAweGRkYTBkZCxcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXG4gIHB1cnBsZTogMHg4MDAwODAsXG4gIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICByZWQ6IDB4ZmYwMDAwLFxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXG4gIHNhbG1vbjogMHhmYTgwNzIsXG4gIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICBzZWFncmVlbjogMHgyZThiNTcsXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgc2llbm5hOiAweGEwNTIyZCxcbiAgc2lsdmVyOiAweGMwYzBjMCxcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTAsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gIHNub3c6IDB4ZmZmYWZhLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gIHRhbjogMHhkMmI0OGMsXG4gIHRlYWw6IDB4MDA4MDgwLFxuICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgdG9tYXRvOiAweGZmNjM0NyxcbiAgdHVycXVvaXNlOiAweDQwZTBkMCxcbiAgdmlvbGV0OiAweGVlODJlZSxcbiAgd2hlYXQ6IDB4ZjVkZWIzLFxuICB3aGl0ZTogMHhmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcbn07XG5cbmRlZmluZShDb2xvciwgY29sb3IsIHtcbiAgY29weShjaGFubmVscykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLCBjaGFubmVscyk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpLmRpc3BsYXlhYmxlKCk7XG4gIH0sXG4gIGhleDogY29sb3JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IGNvbG9yX2Zvcm1hdEhleCxcbiAgZm9ybWF0SGV4ODogY29sb3JfZm9ybWF0SGV4OCxcbiAgZm9ybWF0SHNsOiBjb2xvcl9mb3JtYXRIc2wsXG4gIGZvcm1hdFJnYjogY29sb3JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogY29sb3JfZm9ybWF0UmdiXG59KTtcblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRIZXgoKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SGV4OCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4OCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIc2woKSB7XG4gIHJldHVybiBoc2xDb252ZXJ0KHRoaXMpLmZvcm1hdEhzbCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRSZ2IoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdFJnYigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG0sIGw7XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXguZXhlYyhmb3JtYXQpKSA/IChsID0gbVsxXS5sZW5ndGgsIG0gPSBwYXJzZUludChtWzFdLCAxNiksIGwgPT09IDYgPyByZ2JuKG0pIC8vICNmZjAwMDBcbiAgICAgIDogbCA9PT0gMyA/IG5ldyBSZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSwgMSkgLy8gI2YwMFxuICAgICAgOiBsID09PSA4ID8gcmdiYShtID4+IDI0ICYgMHhmZiwgbSA+PiAxNiAmIDB4ZmYsIG0gPj4gOCAmIDB4ZmYsIChtICYgMHhmZikgLyAweGZmKSAvLyAjZmYwMDAwMDBcbiAgICAgIDogbCA9PT0gNCA/IHJnYmEoKG0gPj4gMTIgJiAweGYpIHwgKG0gPj4gOCAmIDB4ZjApLCAobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSkgLyAweGZmKSAvLyAjZjAwMFxuICAgICAgOiBudWxsKSAvLyBpbnZhbGlkIGhleFxuICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdLCBtWzJdLCBtWzNdLCAxKSAvLyByZ2IoMjU1LCAwLCAwKVxuICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxuICAgICAgOiAobSA9IHJlUmdiYUludGVnZXIuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSwgbVsyXSwgbVszXSwgbVs0XSkgLy8gcmdiYSgyNTUsIDAsIDAsIDEpXG4gICAgICA6IChtID0gcmVSZ2JhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCBtWzRdKSAvLyByZ2IoMTAwJSwgMCUsIDAlLCAxKVxuICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcbiAgICAgIDogKG0gPSByZUhzbGFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIG1bNF0pIC8vIGhzbGEoMTIwLCA1MCUsIDUwJSwgMSlcbiAgICAgIDogbmFtZWQuaGFzT3duUHJvcGVydHkoZm9ybWF0KSA/IHJnYm4obmFtZWRbZm9ybWF0XSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApXG4gICAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJnYm4obikge1xuICByZXR1cm4gbmV3IFJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYsIDEpO1xufVxuXG5mdW5jdGlvbiByZ2JhKHIsIGcsIGIsIGEpIHtcbiAgaWYgKGEgPD0gMCkgciA9IGcgPSBiID0gTmFOO1xuICByZXR1cm4gbmV3IFJnYihyLCBnLCBiLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYkNvbnZlcnQobykge1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBSZ2I7XG4gIG8gPSBvLnJnYigpO1xuICByZXR1cm4gbmV3IFJnYihvLnIsIG8uZywgby5iLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICB0aGlzLnIgPSArcjtcbiAgdGhpcy5nID0gK2c7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKFJnYiwgcmdiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY2xhbXAoKSB7XG4gICAgcmV0dXJuIG5ldyBSZ2IoY2xhbXBpKHRoaXMuciksIGNsYW1waSh0aGlzLmcpLCBjbGFtcGkodGhpcy5iKSwgY2xhbXBhKHRoaXMub3BhY2l0eSkpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gKC0wLjUgPD0gdGhpcy5yICYmIHRoaXMuciA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmcgJiYgdGhpcy5nIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuYiAmJiB0aGlzLmIgPCAyNTUuNSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgaGV4OiByZ2JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IHJnYl9mb3JtYXRIZXgsXG4gIGZvcm1hdEhleDg6IHJnYl9mb3JtYXRIZXg4LFxuICBmb3JtYXRSZ2I6IHJnYl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiByZ2JfZm9ybWF0UmdiXG59KSk7XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiBgIyR7aGV4KHRoaXMucil9JHtoZXgodGhpcy5nKX0ke2hleCh0aGlzLmIpfWA7XG59XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRIZXg4KCkge1xuICByZXR1cm4gYCMke2hleCh0aGlzLnIpfSR7aGV4KHRoaXMuZyl9JHtoZXgodGhpcy5iKX0ke2hleCgoaXNOYU4odGhpcy5vcGFjaXR5KSA/IDEgOiB0aGlzLm9wYWNpdHkpICogMjU1KX1gO1xufVxuXG5mdW5jdGlvbiByZ2JfZm9ybWF0UmdiKCkge1xuICBjb25zdCBhID0gY2xhbXBhKHRoaXMub3BhY2l0eSk7XG4gIHJldHVybiBgJHthID09PSAxID8gXCJyZ2IoXCIgOiBcInJnYmEoXCJ9JHtjbGFtcGkodGhpcy5yKX0sICR7Y2xhbXBpKHRoaXMuZyl9LCAke2NsYW1waSh0aGlzLmIpfSR7YSA9PT0gMSA/IFwiKVwiIDogYCwgJHthfSlgfWA7XG59XG5cbmZ1bmN0aW9uIGNsYW1wYShvcGFjaXR5KSB7XG4gIHJldHVybiBpc05hTihvcGFjaXR5KSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBvcGFjaXR5KSk7XG59XG5cbmZ1bmN0aW9uIGNsYW1waSh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHZhbHVlKSB8fCAwKSk7XG59XG5cbmZ1bmN0aW9uIGhleCh2YWx1ZSkge1xuICB2YWx1ZSA9IGNsYW1waSh2YWx1ZSk7XG4gIHJldHVybiAodmFsdWUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyB2YWx1ZS50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIGhzbGEoaCwgcywgbCwgYSkge1xuICBpZiAoYSA8PSAwKSBoID0gcyA9IGwgPSBOYU47XG4gIGVsc2UgaWYgKGwgPD0gMCB8fCBsID49IDEpIGggPSBzID0gTmFOO1xuICBlbHNlIGlmIChzIDw9IDApIGggPSBOYU47XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbmV3IEhzbChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBIc2w7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcbiAgbyA9IG8ucmdiKCk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgaCA9IE5hTixcbiAgICAgIHMgPSBtYXggLSBtaW4sXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAocykge1xuICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcyArIChnIDwgYikgKiA2O1xuICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyBzICsgMjtcbiAgICBlbHNlIGggPSAociAtIGcpIC8gcyArIDQ7XG4gICAgcyAvPSBsIDwgMC41ID8gbWF4ICsgbWluIDogMiAtIG1heCAtIG1pbjtcbiAgICBoICo9IDYwO1xuICB9IGVsc2Uge1xuICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICB9XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhzbENvbnZlcnQoaCkgOiBuZXcgSHNsKGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gSHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShIc2wsIGhzbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYigpIHtcbiAgICB2YXIgaCA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCxcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxuICAgICAgICBsID0gdGhpcy5sLFxuICAgICAgICBtMiA9IGwgKyAobCA8IDAuNSA/IGwgOiAxIC0gbCkgKiBzLFxuICAgICAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBoc2wycmdiKGggPj0gMjQwID8gaCAtIDI0MCA6IGggKyAxMjAsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGgsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGggPCAxMjAgPyBoICsgMjQwIDogaCAtIDEyMCwgbTEsIG0yKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH0sXG4gIGNsYW1wKCkge1xuICAgIHJldHVybiBuZXcgSHNsKGNsYW1waCh0aGlzLmgpLCBjbGFtcHQodGhpcy5zKSwgY2xhbXB0KHRoaXMubCksIGNsYW1wYSh0aGlzLm9wYWNpdHkpKTtcbiAgfSxcbiAgZGlzcGxheWFibGUoKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGZvcm1hdEhzbCgpIHtcbiAgICBjb25zdCBhID0gY2xhbXBhKHRoaXMub3BhY2l0eSk7XG4gICAgcmV0dXJuIGAke2EgPT09IDEgPyBcImhzbChcIiA6IFwiaHNsYShcIn0ke2NsYW1waCh0aGlzLmgpfSwgJHtjbGFtcHQodGhpcy5zKSAqIDEwMH0lLCAke2NsYW1wdCh0aGlzLmwpICogMTAwfSUke2EgPT09IDEgPyBcIilcIiA6IGAsICR7YX0pYH1gO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIGNsYW1waCh2YWx1ZSkge1xuICB2YWx1ZSA9ICh2YWx1ZSB8fCAwKSAlIDM2MDtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IHZhbHVlICsgMzYwIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNsYW1wdCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUgfHwgMCkpO1xufVxuXG4vKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXG5mdW5jdGlvbiBoc2wycmdiKGgsIG0xLCBtMikge1xuICByZXR1cm4gKGggPCA2MCA/IG0xICsgKG0yIC0gbTEpICogaCAvIDYwXG4gICAgICA6IGggPCAxODAgPyBtMlxuICAgICAgOiBoIDwgMjQwID8gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MFxuICAgICAgOiBtMSkgKiAyNTU7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIGRlZmluaXRpb24pIHtcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSBwcm90b3R5cGVba2V5XSA9IGRlZmluaXRpb25ba2V5XTtcbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuaW1wb3J0IHtDb2xvciwgcmdiQ29udmVydCwgUmdifSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuaW1wb3J0IHtkZWdyZWVzLCByYWRpYW5zfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbi8vIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AbWJvc3RvY2svbGFiLWFuZC1yZ2JcbmNvbnN0IEsgPSAxOCxcbiAgICBYbiA9IDAuOTY0MjIsXG4gICAgWW4gPSAxLFxuICAgIFpuID0gMC44MjUyMSxcbiAgICB0MCA9IDQgLyAyOSxcbiAgICB0MSA9IDYgLyAyOSxcbiAgICB0MiA9IDMgKiB0MSAqIHQxLFxuICAgIHQzID0gdDEgKiB0MSAqIHQxO1xuXG5mdW5jdGlvbiBsYWJDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBMYWIpIHJldHVybiBuZXcgTGFiKG8ubCwgby5hLCBvLmIsIG8ub3BhY2l0eSk7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gaGNsMmxhYihvKTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IHJnYjJscmdiKG8uciksXG4gICAgICBnID0gcmdiMmxyZ2Ioby5nKSxcbiAgICAgIGIgPSByZ2IybHJnYihvLmIpLFxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjIyNTA0NSAqIHIgKyAwLjcxNjg3ODYgKiBnICsgMC4wNjA2MTY5ICogYikgLyBZbiksIHgsIHo7XG4gIGlmIChyID09PSBnICYmIGcgPT09IGIpIHggPSB6ID0geTsgZWxzZSB7XG4gICAgeCA9IHh5ejJsYWIoKDAuNDM2MDc0NyAqIHIgKyAwLjM4NTA2NDkgKiBnICsgMC4xNDMwODA0ICogYikgLyBYbik7XG4gICAgeiA9IHh5ejJsYWIoKDAuMDEzOTMyMiAqIHIgKyAwLjA5NzEwNDUgKiBnICsgMC43MTQxNzMzICogYikgLyBabik7XG4gIH1cbiAgcmV0dXJuIG5ldyBMYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheShsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBuZXcgTGFiKGwsIDAsIDAsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBsYWJDb252ZXJ0KGwpIDogbmV3IExhYihsLCBhLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBMYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5hID0gK2E7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKExhYiwgbGFiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXIoaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYigpIHtcbiAgICB2YXIgeSA9ICh0aGlzLmwgKyAxNikgLyAxMTYsXG4gICAgICAgIHggPSBpc05hTih0aGlzLmEpID8geSA6IHkgKyB0aGlzLmEgLyA1MDAsXG4gICAgICAgIHogPSBpc05hTih0aGlzLmIpID8geSA6IHkgLSB0aGlzLmIgLyAyMDA7XG4gICAgeCA9IFhuICogbGFiMnh5eih4KTtcbiAgICB5ID0gWW4gKiBsYWIyeHl6KHkpO1xuICAgIHogPSBabiAqIGxhYjJ4eXooeik7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBscmdiMnJnYiggMy4xMzM4NTYxICogeCAtIDEuNjE2ODY2NyAqIHkgLSAwLjQ5MDYxNDYgKiB6KSxcbiAgICAgIGxyZ2IycmdiKC0wLjk3ODc2ODQgKiB4ICsgMS45MTYxNDE1ICogeSArIDAuMDMzNDU0MCAqIHopLFxuICAgICAgbHJnYjJyZ2IoIDAuMDcxOTQ1MyAqIHggLSAwLjIyODk5MTQgKiB5ICsgMS40MDUyNDI3ICogeiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIHh5ejJsYWIodCkge1xuICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG59XG5cbmZ1bmN0aW9uIGxhYjJ4eXoodCkge1xuICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbn1cblxuZnVuY3Rpb24gbHJnYjJyZ2IoeCkge1xuICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcbn1cblxuZnVuY3Rpb24gcmdiMmxyZ2IoeCkge1xuICByZXR1cm4gKHggLz0gMjU1KSA8PSAwLjA0MDQ1ID8geCAvIDEyLjkyIDogTWF0aC5wb3coKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn1cblxuZnVuY3Rpb24gaGNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gbmV3IEhjbChvLmgsIG8uYywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgTGFiKSkgbyA9IGxhYkNvbnZlcnQobyk7XG4gIGlmIChvLmEgPT09IDAgJiYgby5iID09PSAwKSByZXR1cm4gbmV3IEhjbChOYU4sIDAgPCBvLmwgJiYgby5sIDwgMTAwID8gMCA6IE5hTiwgby5sLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IE1hdGguYXRhbjIoby5iLCBvLmEpICogZGVncmVlcztcbiAgcmV0dXJuIG5ldyBIY2woaCA8IDAgPyBoICsgMzYwIDogaCwgTWF0aC5zcXJ0KG8uYSAqIG8uYSArIG8uYiAqIG8uYiksIG8ubCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxjaChsLCBjLCBoLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChsKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGgpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5jID0gK2M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZnVuY3Rpb24gaGNsMmxhYihvKSB7XG4gIGlmIChpc05hTihvLmgpKSByZXR1cm4gbmV3IExhYihvLmwsIDAsIDAsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gby5oICogcmFkaWFucztcbiAgcmV0dXJuIG5ldyBMYWIoby5sLCBNYXRoLmNvcyhoKSAqIG8uYywgTWF0aC5zaW4oaCkgKiBvLmMsIG8ub3BhY2l0eSk7XG59XG5cbmRlZmluZShIY2wsIGhjbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2IoKSB7XG4gICAgcmV0dXJuIGhjbDJsYWIodGhpcykucmdiKCk7XG4gIH1cbn0pKTtcbiIsImV4cG9ydCBjb25zdCByYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcbiIsInZhciBub29wID0ge3ZhbHVlOiAoKSA9PiB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSB8fCAvW1xccy5dLy50ZXN0KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgX1t0XSA9IFtdO1xuICB9XG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICB0LFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgfSxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRpc3BhdGNoO1xuIiwiaW1wb3J0IHtzZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2V2ZW50LCB7bm9ucGFzc2l2ZWNhcHR1cmV9IGZyb20gXCIuL25vZXZlbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmlldykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuX19ub3NlbGVjdCA9IHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdDtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24geWVzZHJhZyh2aWV3LCBub2NsaWNrKSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgaWYgKG5vY2xpY2spIHtcbiAgICBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG51bGwpOyB9LCAwKTtcbiAgfVxuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gcm9vdC5fX25vc2VsZWN0O1xuICAgIGRlbGV0ZSByb290Ll9fbm9zZWxlY3Q7XG4gIH1cbn1cbiIsIi8vIFRoZXNlIGFyZSB0eXBpY2FsbHkgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIG5vZXZlbnQgdG8gZW5zdXJlIHRoYXQgd2UgY2FuXG4vLyBwcmV2ZW50RGVmYXVsdCBvbiB0aGUgZXZlbnQuXG5leHBvcnQgY29uc3Qgbm9ucGFzc2l2ZSA9IHtwYXNzaXZlOiBmYWxzZX07XG5leHBvcnQgY29uc3Qgbm9ucGFzc2l2ZWNhcHR1cmUgPSB7Y2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogZmFsc2V9O1xuXG5leHBvcnQgZnVuY3Rpb24gbm9wcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJpbXBvcnQgZHN2IGZyb20gXCIuL2Rzdi5qc1wiO1xuXG52YXIgY3N2ID0gZHN2KFwiLFwiKTtcblxuZXhwb3J0IHZhciBjc3ZQYXJzZSA9IGNzdi5wYXJzZTtcbmV4cG9ydCB2YXIgY3N2UGFyc2VSb3dzID0gY3N2LnBhcnNlUm93cztcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0ID0gY3N2LmZvcm1hdDtcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0Qm9keSA9IGNzdi5mb3JtYXRCb2R5O1xuZXhwb3J0IHZhciBjc3ZGb3JtYXRSb3dzID0gY3N2LmZvcm1hdFJvd3M7XG5leHBvcnQgdmFyIGNzdkZvcm1hdFJvdyA9IGNzdi5mb3JtYXRSb3c7XG5leHBvcnQgdmFyIGNzdkZvcm1hdFZhbHVlID0gY3N2LmZvcm1hdFZhbHVlO1xuIiwidmFyIEVPTCA9IHt9LFxuICAgIEVPRiA9IHt9LFxuICAgIFFVT1RFID0gMzQsXG4gICAgTkVXTElORSA9IDEwLFxuICAgIFJFVFVSTiA9IDEzO1xuXG5mdW5jdGlvbiBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucykge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyBjb2x1bW5zLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdIHx8IFxcXCJcXFwiXCI7XG4gIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xufVxuXG5mdW5jdGlvbiBjdXN0b21Db252ZXJ0ZXIoY29sdW1ucywgZikge1xuICB2YXIgb2JqZWN0ID0gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpO1xuICByZXR1cm4gZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgcmV0dXJuIGYob2JqZWN0KHJvdyksIGksIGNvbHVtbnMpO1xuICB9O1xufVxuXG4vLyBDb21wdXRlIHVuaXF1ZSBjb2x1bW5zIGluIG9yZGVyIG9mIGRpc2NvdmVyeS5cbmZ1bmN0aW9uIGluZmVyQ29sdW1ucyhyb3dzKSB7XG4gIHZhciBjb2x1bW5TZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgY29sdW1ucyA9IFtdO1xuXG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICBmb3IgKHZhciBjb2x1bW4gaW4gcm93KSB7XG4gICAgICBpZiAoIShjb2x1bW4gaW4gY29sdW1uU2V0KSkge1xuICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uU2V0W2NvbHVtbl0gPSBjb2x1bW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbHVtbnM7XG59XG5cbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgd2lkdGgpIHtcbiAgdmFyIHMgPSB2YWx1ZSArIFwiXCIsIGxlbmd0aCA9IHMubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKDApICsgcyA6IHM7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXIoeWVhcikge1xuICByZXR1cm4geWVhciA8IDAgPyBcIi1cIiArIHBhZCgteWVhciwgNilcbiAgICA6IHllYXIgPiA5OTk5ID8gXCIrXCIgKyBwYWQoeWVhciwgNilcbiAgICA6IHBhZCh5ZWFyLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgIG1pbnV0ZXMgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgIHNlY29uZHMgPSBkYXRlLmdldFVUQ1NlY29uZHMoKSxcbiAgICAgIG1pbGxpc2Vjb25kcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHJldHVybiBpc05hTihkYXRlKSA/IFwiSW52YWxpZCBEYXRlXCJcbiAgICAgIDogZm9ybWF0WWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIDQpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENNb250aCgpICsgMSwgMikgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ0RhdGUoKSwgMilcbiAgICAgICsgKG1pbGxpc2Vjb25kcyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCI6XCIgKyBwYWQoc2Vjb25kcywgMikgKyBcIi5cIiArIHBhZChtaWxsaXNlY29uZHMsIDMpICsgXCJaXCJcbiAgICAgIDogc2Vjb25kcyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCI6XCIgKyBwYWQoc2Vjb25kcywgMikgKyBcIlpcIlxuICAgICAgOiBtaW51dGVzIHx8IGhvdXJzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIlpcIlxuICAgICAgOiBcIlwiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGVsaW1pdGVyKSB7XG4gIHZhciByZUZvcm1hdCA9IG5ldyBSZWdFeHAoXCJbXFxcIlwiICsgZGVsaW1pdGVyICsgXCJcXG5cXHJdXCIpLFxuICAgICAgREVMSU1JVEVSID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG5cbiAgZnVuY3Rpb24gcGFyc2UodGV4dCwgZikge1xuICAgIHZhciBjb252ZXJ0LCBjb2x1bW5zLCByb3dzID0gcGFyc2VSb3dzKHRleHQsIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgaWYgKGNvbnZlcnQpIHJldHVybiBjb252ZXJ0KHJvdywgaSAtIDEpO1xuICAgICAgY29sdW1ucyA9IHJvdywgY29udmVydCA9IGYgPyBjdXN0b21Db252ZXJ0ZXIocm93LCBmKSA6IG9iamVjdENvbnZlcnRlcihyb3cpO1xuICAgIH0pO1xuICAgIHJvd3MuY29sdW1ucyA9IGNvbHVtbnMgfHwgW107XG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVJvd3ModGV4dCwgZikge1xuICAgIHZhciByb3dzID0gW10sIC8vIG91dHB1dCByb3dzXG4gICAgICAgIE4gPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgSSA9IDAsIC8vIGN1cnJlbnQgY2hhcmFjdGVyIGluZGV4XG4gICAgICAgIG4gPSAwLCAvLyBjdXJyZW50IGxpbmUgbnVtYmVyXG4gICAgICAgIHQsIC8vIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgZW9mID0gTiA8PSAwLCAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPRj9cbiAgICAgICAgZW9sID0gZmFsc2U7IC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9MP1xuXG4gICAgLy8gU3RyaXAgdGhlIHRyYWlsaW5nIG5ld2xpbmUuXG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IE5FV0xJTkUpIC0tTjtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gUkVUVVJOKSAtLU47XG5cbiAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgIGlmIChlb2YpIHJldHVybiBFT0Y7XG4gICAgICBpZiAoZW9sKSByZXR1cm4gZW9sID0gZmFsc2UsIEVPTDtcblxuICAgICAgLy8gVW5lc2NhcGUgcXVvdGVzLlxuICAgICAgdmFyIGksIGogPSBJLCBjO1xuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA9PT0gUVVPVEUpIHtcbiAgICAgICAgd2hpbGUgKEkrKyA8IE4gJiYgdGV4dC5jaGFyQ29kZUF0KEkpICE9PSBRVU9URSB8fCB0ZXh0LmNoYXJDb2RlQXQoKytJKSA9PT0gUVVPVEUpO1xuICAgICAgICBpZiAoKGkgPSBJKSA+PSBOKSBlb2YgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChJKyspKSA9PT0gTkVXTElORSkgZW9sID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gUkVUVVJOKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpICsrSTsgfVxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqICsgMSwgaSAtIDEpLnJlcGxhY2UoL1wiXCIvZywgXCJcXFwiXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgZGVsaW1pdGVyIG9yIG5ld2xpbmUuXG4gICAgICB3aGlsZSAoSSA8IE4pIHtcbiAgICAgICAgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KGkgPSBJKyspKSA9PT0gTkVXTElORSkgZW9sID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gUkVUVVJOKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpICsrSTsgfVxuICAgICAgICBlbHNlIGlmIChjICE9PSBERUxJTUlURVIpIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqLCBpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGxhc3QgdG9rZW4gYmVmb3JlIEVPRi5cbiAgICAgIHJldHVybiBlb2YgPSB0cnVlLCB0ZXh0LnNsaWNlKGosIE4pO1xuICAgIH1cblxuICAgIHdoaWxlICgodCA9IHRva2VuKCkpICE9PSBFT0YpIHtcbiAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgIHdoaWxlICh0ICE9PSBFT0wgJiYgdCAhPT0gRU9GKSByb3cucHVzaCh0KSwgdCA9IHRva2VuKCk7XG4gICAgICBpZiAoZiAmJiAocm93ID0gZihyb3csIG4rKykpID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gcm93cy5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbY29sdW1uXSk7XG4gICAgICB9KS5qb2luKGRlbGltaXRlcik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQocm93cywgY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgcmV0dXJuIFtjb2x1bW5zLm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpXS5jb25jYXQocHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEJvZHkocm93cywgY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgcmV0dXJuIHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvd3Mocm93cykge1xuICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgcmV0dXJuIHJvdy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiXG4gICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZm9ybWF0RGF0ZSh2YWx1ZSlcbiAgICAgICAgOiByZUZvcm1hdC50ZXN0KHZhbHVlICs9IFwiXCIpID8gXCJcXFwiXCIgKyB2YWx1ZS5yZXBsYWNlKC9cIi9nLCBcIlxcXCJcXFwiXCIpICsgXCJcXFwiXCJcbiAgICAgICAgOiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHBhcnNlUm93czogcGFyc2VSb3dzLFxuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGZvcm1hdEJvZHk6IGZvcm1hdEJvZHksXG4gICAgZm9ybWF0Um93czogZm9ybWF0Um93cyxcbiAgICBmb3JtYXRSb3c6IGZvcm1hdFJvdyxcbiAgICBmb3JtYXRWYWx1ZTogZm9ybWF0VmFsdWVcbiAgfTtcbn1cbiIsImltcG9ydCBkc3YgZnJvbSBcIi4vZHN2LmpzXCI7XG5cbnZhciB0c3YgPSBkc3YoXCJcXHRcIik7XG5cbmV4cG9ydCB2YXIgdHN2UGFyc2UgPSB0c3YucGFyc2U7XG5leHBvcnQgdmFyIHRzdlBhcnNlUm93cyA9IHRzdi5wYXJzZVJvd3M7XG5leHBvcnQgdmFyIHRzdkZvcm1hdCA9IHRzdi5mb3JtYXQ7XG5leHBvcnQgdmFyIHRzdkZvcm1hdEJvZHkgPSB0c3YuZm9ybWF0Qm9keTtcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0Um93cyA9IHRzdi5mb3JtYXRSb3dzO1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRSb3cgPSB0c3YuZm9ybWF0Um93O1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRWYWx1ZSA9IHRzdi5mb3JtYXRWYWx1ZTtcbiIsImV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCAqIHQgOiAodCAtPSAyKSAqIHQgKiB0ICsgMikgLyAyO1xufVxuIiwiaW1wb3J0IHtjc3ZQYXJzZSwgZHN2Rm9ybWF0LCB0c3ZQYXJzZX0gZnJvbSBcImQzLWRzdlwiO1xuaW1wb3J0IHRleHQgZnJvbSBcIi4vdGV4dC5qc1wiO1xuXG5mdW5jdGlvbiBkc3ZQYXJzZShwYXJzZSkge1xuICByZXR1cm4gZnVuY3Rpb24oaW5wdXQsIGluaXQsIHJvdykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBpbml0ID09PSBcImZ1bmN0aW9uXCIpIHJvdyA9IGluaXQsIGluaXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRleHQoaW5wdXQsIGluaXQpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBwYXJzZShyZXNwb25zZSwgcm93KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZHN2KGRlbGltaXRlciwgaW5wdXQsIGluaXQsIHJvdykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgaW5pdCA9PT0gXCJmdW5jdGlvblwiKSByb3cgPSBpbml0LCBpbml0ID0gdW5kZWZpbmVkO1xuICB2YXIgZm9ybWF0ID0gZHN2Rm9ybWF0KGRlbGltaXRlcik7XG4gIHJldHVybiB0ZXh0KGlucHV0LCBpbml0KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGZvcm1hdC5wYXJzZShyZXNwb25zZSwgcm93KTtcbiAgfSk7XG59XG5cbmV4cG9ydCB2YXIgY3N2ID0gZHN2UGFyc2UoY3N2UGFyc2UpO1xuZXhwb3J0IHZhciB0c3YgPSBkc3ZQYXJzZSh0c3ZQYXJzZSk7XG4iLCJmdW5jdGlvbiByZXNwb25zZUpzb24ocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNSkgcmV0dXJuO1xuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VKc29uKTtcbn1cbiIsImZ1bmN0aW9uIHJlc3BvbnNlVGV4dChyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlVGV4dCk7XG59XG4iLCJpbXBvcnQgZm9ybWF0TG9jYWxlIGZyb20gXCIuL2xvY2FsZS5qc1wiO1xuXG52YXIgbG9jYWxlO1xuZXhwb3J0IHZhciBmb3JtYXQ7XG5leHBvcnQgdmFyIGZvcm1hdFByZWZpeDtcblxuZGVmYXVsdExvY2FsZSh7XG4gIHRob3VzYW5kczogXCIsXCIsXG4gIGdyb3VwaW5nOiBbM10sXG4gIGN1cnJlbmN5OiBbXCIkXCIsIFwiXCJdXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIGxvY2FsZSA9IGZvcm1hdExvY2FsZShkZWZpbml0aW9uKTtcbiAgZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgZm9ybWF0UHJlZml4ID0gbG9jYWxlLmZvcm1hdFByZWZpeDtcbiAgcmV0dXJuIGxvY2FsZTtcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPSBmb3JtYXREZWNpbWFsUGFydHMoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggPSBNYXRoLnJvdW5kKHgpKSA+PSAxZTIxXG4gICAgICA/IHgudG9Mb2NhbGVTdHJpbmcoXCJlblwiKS5yZXBsYWNlKC8sL2csIFwiXCIpXG4gICAgICA6IHgudG9TdHJpbmcoMTApO1xufVxuXG4vLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4vLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbi8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsUGFydHMoMS4yMykgcmV0dXJucyBbXCIxMjNcIiwgMF0uXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApIHtcbiAgaWYgKChpID0gKHggPSBwID8geC50b0V4cG9uZW50aWFsKHAgLSAxKSA6IHgudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSkgPCAwKSByZXR1cm4gbnVsbDsgLy8gTmFOLCDCsUluZmluaXR5XG4gIHZhciBpLCBjb2VmZmljaWVudCA9IHguc2xpY2UoMCwgaSk7XG5cbiAgLy8gVGhlIHN0cmluZyByZXR1cm5lZCBieSB0b0V4cG9uZW50aWFsIGVpdGhlciBoYXMgdGhlIGZvcm0gXFxkXFwuXFxkK2VbLStdXFxkK1xuICAvLyAoZS5nLiwgMS4yZSszKSBvciB0aGUgZm9ybSBcXGRlWy0rXVxcZCsgKGUuZy4sIDFlKzMpLlxuICByZXR1cm4gW1xuICAgIGNvZWZmaWNpZW50Lmxlbmd0aCA+IDEgPyBjb2VmZmljaWVudFswXSArIGNvZWZmaWNpZW50LnNsaWNlKDIpIDogY29lZmZpY2llbnQsXG4gICAgK3guc2xpY2UoaSArIDEpXG4gIF07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihncm91cGluZywgdGhvdXNhbmRzKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgdCA9IFtdLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgZyA9IGdyb3VwaW5nWzBdLFxuICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgZyA9IGdyb3VwaW5nW2ogPSAoaiArIDEpICUgZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obnVtZXJhbHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1swLTldL2csIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBudW1lcmFsc1sraV07XG4gICAgfSk7XG4gIH07XG59XG4iLCJpbXBvcnQge2Zvcm1hdERlY2ltYWxQYXJ0c30gZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuXG5leHBvcnQgdmFyIHByZWZpeEV4cG9uZW50O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXSxcbiAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgIG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gIHJldHVybiBpID09PSBuID8gY29lZmZpY2llbnRcbiAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICA6IGkgPiAwID8gY29lZmZpY2llbnQuc2xpY2UoMCwgaSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGkpXG4gICAgICA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gaSkuam9pbihcIjBcIikgKyBmb3JtYXREZWNpbWFsUGFydHMoeCwgTWF0aC5tYXgoMCwgcCArIGkgLSAxKSlbMF07IC8vIGxlc3MgdGhhbiAxeSFcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICByZXR1cm4gZXhwb25lbnQgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1leHBvbmVudCkuam9pbihcIjBcIikgKyBjb2VmZmljaWVudFxuICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG59XG4iLCIvLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW35dW3R5cGVdXG52YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyh+KT8oW2EteiVdKT8kL2k7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgaWYgKCEobWF0Y2ggPSByZS5leGVjKHNwZWNpZmllcikpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBzcGVjaWZpZXIpO1xuICB2YXIgbWF0Y2g7XG4gIHJldHVybiBuZXcgRm9ybWF0U3BlY2lmaWVyKHtcbiAgICBmaWxsOiBtYXRjaFsxXSxcbiAgICBhbGlnbjogbWF0Y2hbMl0sXG4gICAgc2lnbjogbWF0Y2hbM10sXG4gICAgc3ltYm9sOiBtYXRjaFs0XSxcbiAgICB6ZXJvOiBtYXRjaFs1XSxcbiAgICB3aWR0aDogbWF0Y2hbNl0sXG4gICAgY29tbWE6IG1hdGNoWzddLFxuICAgIHByZWNpc2lvbjogbWF0Y2hbOF0gJiYgbWF0Y2hbOF0uc2xpY2UoMSksXG4gICAgdHJpbTogbWF0Y2hbOV0sXG4gICAgdHlwZTogbWF0Y2hbMTBdXG4gIH0pO1xufVxuXG5mb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlID0gRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZTsgLy8gaW5zdGFuY2VvZlxuXG5leHBvcnQgZnVuY3Rpb24gRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICB0aGlzLmZpbGwgPSBzcGVjaWZpZXIuZmlsbCA9PT0gdW5kZWZpbmVkID8gXCIgXCIgOiBzcGVjaWZpZXIuZmlsbCArIFwiXCI7XG4gIHRoaXMuYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24gPT09IHVuZGVmaW5lZCA/IFwiPlwiIDogc3BlY2lmaWVyLmFsaWduICsgXCJcIjtcbiAgdGhpcy5zaWduID0gc3BlY2lmaWVyLnNpZ24gPT09IHVuZGVmaW5lZCA/IFwiLVwiIDogc3BlY2lmaWVyLnNpZ24gKyBcIlwiO1xuICB0aGlzLnN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBzcGVjaWZpZXIuc3ltYm9sICsgXCJcIjtcbiAgdGhpcy56ZXJvID0gISFzcGVjaWZpZXIuemVybztcbiAgdGhpcy53aWR0aCA9IHNwZWNpZmllci53aWR0aCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogK3NwZWNpZmllci53aWR0aDtcbiAgdGhpcy5jb21tYSA9ICEhc3BlY2lmaWVyLmNvbW1hO1xuICB0aGlzLnByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICtzcGVjaWZpZXIucHJlY2lzaW9uO1xuICB0aGlzLnRyaW0gPSAhIXNwZWNpZmllci50cmltO1xuICB0aGlzLnR5cGUgPSBzcGVjaWZpZXIudHlwZSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHNwZWNpZmllci50eXBlICsgXCJcIjtcbn1cblxuRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWxsXG4gICAgICArIHRoaXMuYWxpZ25cbiAgICAgICsgdGhpcy5zaWduXG4gICAgICArIHRoaXMuc3ltYm9sXG4gICAgICArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKVxuICAgICAgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMucHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCB0aGlzLnByZWNpc2lvbiB8IDApKVxuICAgICAgKyAodGhpcy50cmltID8gXCJ+XCIgOiBcIlwiKVxuICAgICAgKyB0aGlzLnR5cGU7XG59O1xuIiwiLy8gVHJpbXMgaW5zaWduaWZpY2FudCB6ZXJvcywgZS5nLiwgcmVwbGFjZXMgMS4yMDAwayB3aXRoIDEuMmsuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzKSB7XG4gIG91dDogZm9yICh2YXIgbiA9IHMubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICBzd2l0Y2ggKHNbaV0pIHtcbiAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogaWYgKCErc1tpXSkgYnJlYWsgb3V0OyBpZiAoaTAgPiAwKSBpMCA9IDA7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTAgPiAwID8gcy5zbGljZSgwLCBpMCkgKyBzLnNsaWNlKGkxICsgMSkgOiBzO1xufVxuIiwiaW1wb3J0IGZvcm1hdERlY2ltYWwgZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuaW1wb3J0IGZvcm1hdFByZWZpeEF1dG8gZnJvbSBcIi4vZm9ybWF0UHJlZml4QXV0by5qc1wiO1xuaW1wb3J0IGZvcm1hdFJvdW5kZWQgZnJvbSBcIi4vZm9ybWF0Um91bmRlZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFwiJVwiOiAoeCwgcCkgPT4gKHggKiAxMDApLnRvRml4ZWQocCksXG4gIFwiYlwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKSxcbiAgXCJjXCI6ICh4KSA9PiB4ICsgXCJcIixcbiAgXCJkXCI6IGZvcm1hdERlY2ltYWwsXG4gIFwiZVwiOiAoeCwgcCkgPT4geC50b0V4cG9uZW50aWFsKHApLFxuICBcImZcIjogKHgsIHApID0+IHgudG9GaXhlZChwKSxcbiAgXCJnXCI6ICh4LCBwKSA9PiB4LnRvUHJlY2lzaW9uKHApLFxuICBcIm9cIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCksXG4gIFwicFwiOiAoeCwgcCkgPT4gZm9ybWF0Um91bmRlZCh4ICogMTAwLCBwKSxcbiAgXCJyXCI6IGZvcm1hdFJvdW5kZWQsXG4gIFwic1wiOiBmb3JtYXRQcmVmaXhBdXRvLFxuICBcIlhcIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksXG4gIFwieFwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNilcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5pbXBvcnQgZm9ybWF0R3JvdXAgZnJvbSBcIi4vZm9ybWF0R3JvdXAuanNcIjtcbmltcG9ydCBmb3JtYXROdW1lcmFscyBmcm9tIFwiLi9mb3JtYXROdW1lcmFscy5qc1wiO1xuaW1wb3J0IGZvcm1hdFNwZWNpZmllciBmcm9tIFwiLi9mb3JtYXRTcGVjaWZpZXIuanNcIjtcbmltcG9ydCBmb3JtYXRUcmltIGZyb20gXCIuL2Zvcm1hdFRyaW0uanNcIjtcbmltcG9ydCBmb3JtYXRUeXBlcyBmcm9tIFwiLi9mb3JtYXRUeXBlcy5qc1wiO1xuaW1wb3J0IHtwcmVmaXhFeHBvbmVudH0gZnJvbSBcIi4vZm9ybWF0UHJlZml4QXV0by5qc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuL2lkZW50aXR5LmpzXCI7XG5cbnZhciBtYXAgPSBBcnJheS5wcm90b3R5cGUubWFwLFxuICAgIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obG9jYWxlKSB7XG4gIHZhciBncm91cCA9IGxvY2FsZS5ncm91cGluZyA9PT0gdW5kZWZpbmVkIHx8IGxvY2FsZS50aG91c2FuZHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0R3JvdXAobWFwLmNhbGwobG9jYWxlLmdyb3VwaW5nLCBOdW1iZXIpLCBsb2NhbGUudGhvdXNhbmRzICsgXCJcIiksXG4gICAgICBjdXJyZW5jeVByZWZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVswXSArIFwiXCIsXG4gICAgICBjdXJyZW5jeVN1ZmZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVsxXSArIFwiXCIsXG4gICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWwgPT09IHVuZGVmaW5lZCA/IFwiLlwiIDogbG9jYWxlLmRlY2ltYWwgKyBcIlwiLFxuICAgICAgbnVtZXJhbHMgPSBsb2NhbGUubnVtZXJhbHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0TnVtZXJhbHMobWFwLmNhbGwobG9jYWxlLm51bWVyYWxzLCBTdHJpbmcpKSxcbiAgICAgIHBlcmNlbnQgPSBsb2NhbGUucGVyY2VudCA9PT0gdW5kZWZpbmVkID8gXCIlXCIgOiBsb2NhbGUucGVyY2VudCArIFwiXCIsXG4gICAgICBtaW51cyA9IGxvY2FsZS5taW51cyA9PT0gdW5kZWZpbmVkID8gXCLiiJJcIiA6IGxvY2FsZS5taW51cyArIFwiXCIsXG4gICAgICBuYW4gPSBsb2NhbGUubmFuID09PSB1bmRlZmluZWQgPyBcIk5hTlwiIDogbG9jYWxlLm5hbiArIFwiXCI7XG5cbiAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllcikge1xuICAgIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuXG4gICAgdmFyIGZpbGwgPSBzcGVjaWZpZXIuZmlsbCxcbiAgICAgICAgYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24sXG4gICAgICAgIHNpZ24gPSBzcGVjaWZpZXIuc2lnbixcbiAgICAgICAgc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCxcbiAgICAgICAgemVybyA9IHNwZWNpZmllci56ZXJvLFxuICAgICAgICB3aWR0aCA9IHNwZWNpZmllci53aWR0aCxcbiAgICAgICAgY29tbWEgPSBzcGVjaWZpZXIuY29tbWEsXG4gICAgICAgIHByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24sXG4gICAgICAgIHRyaW0gPSBzcGVjaWZpZXIudHJpbSxcbiAgICAgICAgdHlwZSA9IHNwZWNpZmllci50eXBlO1xuXG4gICAgLy8gVGhlIFwiblwiIHR5cGUgaXMgYW4gYWxpYXMgZm9yIFwiLGdcIi5cbiAgICBpZiAodHlwZSA9PT0gXCJuXCIpIGNvbW1hID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gVGhlIFwiXCIgdHlwZSwgYW5kIGFueSBpbnZhbGlkIHR5cGUsIGlzIGFuIGFsaWFzIGZvciBcIi4xMn5nXCIuXG4gICAgZWxzZSBpZiAoIWZvcm1hdFR5cGVzW3R5cGVdKSBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCAmJiAocHJlY2lzaW9uID0gMTIpLCB0cmltID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gSWYgemVybyBmaWxsIGlzIHNwZWNpZmllZCwgcGFkZGluZyBnb2VzIGFmdGVyIHNpZ24gYW5kIGJlZm9yZSBkaWdpdHMuXG4gICAgaWYgKHplcm8gfHwgKGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikpIHplcm8gPSB0cnVlLCBmaWxsID0gXCIwXCIsIGFsaWduID0gXCI9XCI7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAvLyBGb3IgU0ktcHJlZml4LCB0aGUgc3VmZml4IGlzIGxhemlseSBjb21wdXRlZC5cbiAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5UHJlZml4IDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuICAgICAgICBzdWZmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lTdWZmaXggOiAvWyVwXS8udGVzdCh0eXBlKSA/IHBlcmNlbnQgOiBcIlwiO1xuXG4gICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cbiAgICAvLyBJcyB0aGlzIGFuIGludGVnZXIgdHlwZT9cbiAgICAvLyBDYW4gdGhpcyB0eXBlIGdlbmVyYXRlIGV4cG9uZW50aWFsIG5vdGF0aW9uP1xuICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXG4gICAgICAgIG1heWJlU3VmZml4ID0gL1tkZWZncHJzJV0vLnRlc3QodHlwZSk7XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXG4gICAgLy8gb3IgY2xhbXAgdGhlIHNwZWNpZmllZCBwcmVjaXNpb24gdG8gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAvLyBGb3Igc2lnbmlmaWNhbnQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFsxLCAyMV0uXG4gICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gNlxuICAgICAgICA6IC9bZ3Byc10vLnRlc3QodHlwZSkgPyBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSlcbiAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHN1ZmZpeCxcbiAgICAgICAgICBpLCBuLCBjO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgdmFsdWVTdWZmaXggPSBmb3JtYXRUeXBlKHZhbHVlKSArIHZhbHVlU3VmZml4O1xuICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNpZ24uIC0wIGlzIG5vdCBsZXNzIHRoYW4gMCwgYnV0IDEgLyAtMCBpcyFcbiAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSB2YWx1ZSA8IDAgfHwgMSAvIHZhbHVlIDwgMDtcblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIGZvcm1hdHRpbmcuXG4gICAgICAgIHZhbHVlID0gaXNOYU4odmFsdWUpID8gbmFuIDogZm9ybWF0VHlwZShNYXRoLmFicyh2YWx1ZSksIHByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gVHJpbSBpbnNpZ25pZmljYW50IHplcm9zLlxuICAgICAgICBpZiAodHJpbSkgdmFsdWUgPSBmb3JtYXRUcmltKHZhbHVlKTtcblxuICAgICAgICAvLyBJZiBhIG5lZ2F0aXZlIHZhbHVlIHJvdW5kcyB0byB6ZXJvIGFmdGVyIGZvcm1hdHRpbmcsIGFuZCBubyBleHBsaWNpdCBwb3NpdGl2ZSBzaWduIGlzIHJlcXVlc3RlZCwgaGlkZSB0aGUgc2lnbi5cbiAgICAgICAgaWYgKHZhbHVlTmVnYXRpdmUgJiYgK3ZhbHVlID09PSAwICYmIHNpZ24gIT09IFwiK1wiKSB2YWx1ZU5lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogbWludXMpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcbiAgICAgICAgdmFsdWVTdWZmaXggPSAodHlwZSA9PT0gXCJzXCIgPyBwcmVmaXhlc1s4ICsgcHJlZml4RXhwb25lbnQgLyAzXSA6IFwiXCIpICsgdmFsdWVTdWZmaXggKyAodmFsdWVOZWdhdGl2ZSAmJiBzaWduID09PSBcIihcIiA/IFwiKVwiIDogXCJcIik7XG5cbiAgICAgICAgLy8gQnJlYWsgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpbnRvIHRoZSBpbnRlZ2VyIOKAnHZhbHVl4oCdIHBhcnQgdGhhdCBjYW4gYmVcbiAgICAgICAgLy8gZ3JvdXBlZCwgYW5kIGZyYWN0aW9uYWwgb3IgZXhwb25lbnRpYWwg4oCcc3VmZml44oCdIHBhcnQgdGhhdCBpcyBub3QuXG4gICAgICAgIGlmIChtYXliZVN1ZmZpeCkge1xuICAgICAgICAgIGkgPSAtMSwgbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgaWYgKGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpLCA0OCA+IGMgfHwgYyA+IDU3KSB7XG4gICAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gKGMgPT09IDQ2ID8gZGVjaW1hbCArIHZhbHVlLnNsaWNlKGkgKyAxKSA6IHZhbHVlLnNsaWNlKGkpKSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIG5vdCBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBiZWZvcmUgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiAhemVybykgdmFsdWUgPSBncm91cCh2YWx1ZSwgSW5maW5pdHkpO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBwYWRkaW5nLlxuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlUHJlZml4Lmxlbmd0aCArIHZhbHVlLmxlbmd0aCArIHZhbHVlU3VmZml4Lmxlbmd0aCxcbiAgICAgICAgICBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcblxuICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGFmdGVyIHBhZGRpbmcuXG4gICAgICBpZiAoY29tbWEgJiYgemVybykgdmFsdWUgPSBncm91cChwYWRkaW5nICsgdmFsdWUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSB2YWx1ZVN1ZmZpeC5sZW5ndGggOiBJbmZpbml0eSksIHBhZGRpbmcgPSBcIlwiO1xuXG4gICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgZmluYWwgb3V0cHV0IGJhc2VkIG9uIHRoZSBkZXNpcmVkIGFsaWdubWVudC5cbiAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgY2FzZSBcIjxcIjogdmFsdWUgPSB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nOyBicmVhaztcbiAgICAgICAgY2FzZSBcIj1cIjogdmFsdWUgPSB2YWx1ZVByZWZpeCArIHBhZGRpbmcgKyB2YWx1ZSArIHZhbHVlU3VmZml4OyBicmVhaztcbiAgICAgICAgY2FzZSBcIl5cIjogdmFsdWUgPSBwYWRkaW5nLnNsaWNlKDAsIGxlbmd0aCA9IHBhZGRpbmcubGVuZ3RoID4+IDEpICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZy5zbGljZShsZW5ndGgpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdmFsdWUgPSBwYWRkaW5nICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4OyBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bWVyYWxzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3JtYXQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcGVjaWZpZXIgKyBcIlwiO1xuICAgIH07XG5cbiAgICByZXR1cm4gZm9ybWF0O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpIHtcbiAgICB2YXIgZiA9IG5ld0Zvcm1hdCgoc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciksIHNwZWNpZmllci50eXBlID0gXCJmXCIsIHNwZWNpZmllcikpLFxuICAgICAgICBlID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMsXG4gICAgICAgIGsgPSBNYXRoLnBvdygxMCwgLWUpLFxuICAgICAgICBwcmVmaXggPSBwcmVmaXhlc1s4ICsgZSAvIDNdO1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGYoayAqIHZhbHVlKSArIHByZWZpeDtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IG5ld0Zvcm1hdCxcbiAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGJhc2lzKHQxLCB2MCwgdjEsIHYyLCB2Mykge1xuICB2YXIgdDIgPSB0MSAqIHQxLCB0MyA9IHQyICogdDE7XG4gIHJldHVybiAoKDEgLSAzICogdDEgKyAzICogdDIgLSB0MykgKiB2MFxuICAgICAgKyAoNCAtIDYgKiB0MiArIDMgKiB0MykgKiB2MVxuICAgICAgKyAoMSArIDMgKiB0MSArIDMgKiB0MiAtIDMgKiB0MykgKiB2MlxuICAgICAgKyB0MyAqIHYzKSAvIDY7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdCA8PSAwID8gKHQgPSAwKSA6IHQgPj0gMSA/ICh0ID0gMSwgbiAtIDEpIDogTWF0aC5mbG9vcih0ICogbiksXG4gICAgICAgIHYxID0gdmFsdWVzW2ldLFxuICAgICAgICB2MiA9IHZhbHVlc1tpICsgMV0sXG4gICAgICAgIHYwID0gaSA+IDAgPyB2YWx1ZXNbaSAtIDFdIDogMiAqIHYxIC0gdjIsXG4gICAgICAgIHYzID0gaSA8IG4gLSAxID8gdmFsdWVzW2kgKyAyXSA6IDIgKiB2MiAtIHYxO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7YmFzaXN9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKCgodCAlPSAxKSA8IDAgPyArK3QgOiB0KSAqIG4pLFxuICAgICAgICB2MCA9IHZhbHVlc1soaSArIG4gLSAxKSAlIG5dLFxuICAgICAgICB2MSA9IHZhbHVlc1tpICUgbl0sXG4gICAgICAgIHYyID0gdmFsdWVzWyhpICsgMSkgJSBuXSxcbiAgICAgICAgdjMgPSB2YWx1ZXNbKGkgKyAyKSAlIG5dO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBsaW5lYXIoYSwgZCkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICsgdCAqIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9uZW50aWFsKGEsIGIsIHkpIHtcbiAgcmV0dXJuIGEgPSBNYXRoLnBvdyhhLCB5KSwgYiA9IE1hdGgucG93KGIsIHkpIC0gYSwgeSA9IDEgLyB5LCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGEgKyB0ICogYiwgeSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBodWUoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkID4gMTgwIHx8IGQgPCAtMTgwID8gZCAtIDM2MCAqIE1hdGgucm91bmQoZCAvIDM2MCkgOiBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2FtbWEoeSkge1xuICByZXR1cm4gKHkgPSAreSkgPT09IDEgPyBub2dhbW1hIDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYSA/IGV4cG9uZW50aWFsKGEsIGIsIHkpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vZ2FtbWEoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiaW1wb3J0IHtsYWIgYXMgY29sb3JMYWJ9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yIGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhYihzdGFydCwgZW5kKSB7XG4gIHZhciBsID0gY29sb3IoKHN0YXJ0ID0gY29sb3JMYWIoc3RhcnQpKS5sLCAoZW5kID0gY29sb3JMYWIoZW5kKSkubCksXG4gICAgICBhID0gY29sb3Ioc3RhcnQuYSwgZW5kLmEpLFxuICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgc3RhcnQubCA9IGwodCk7XG4gICAgc3RhcnQuYSA9IGEodCk7XG4gICAgc3RhcnQuYiA9IGIodCk7XG4gICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKiAoMSAtIHQpICsgYiAqIHQ7XG4gIH07XG59XG4iLCJpbXBvcnQge3JnYiBhcyBjb2xvclJnYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgYmFzaXMgZnJvbSBcIi4vYmFzaXMuanNcIjtcbmltcG9ydCBiYXNpc0Nsb3NlZCBmcm9tIFwiLi9iYXNpc0Nsb3NlZC5qc1wiO1xuaW1wb3J0IG5vZ2FtbWEsIHtnYW1tYX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHJnYkdhbW1hKHkpIHtcbiAgdmFyIGNvbG9yID0gZ2FtbWEoeSk7XG5cbiAgZnVuY3Rpb24gcmdiKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IGNvbG9yKChzdGFydCA9IGNvbG9yUmdiKHN0YXJ0KSkuciwgKGVuZCA9IGNvbG9yUmdiKGVuZCkpLnIpLFxuICAgICAgICBnID0gY29sb3Ioc3RhcnQuZywgZW5kLmcpLFxuICAgICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LnIgPSByKHQpO1xuICAgICAgc3RhcnQuZyA9IGcodCk7XG4gICAgICBzdGFydC5iID0gYih0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgcmdiLmdhbW1hID0gcmdiR2FtbWE7XG5cbiAgcmV0dXJuIHJnYjtcbn0pKDEpO1xuXG5mdW5jdGlvbiByZ2JTcGxpbmUoc3BsaW5lKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xvcnMpIHtcbiAgICB2YXIgbiA9IGNvbG9ycy5sZW5ndGgsXG4gICAgICAgIHIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGcgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGksIGNvbG9yO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbG9yID0gY29sb3JSZ2IoY29sb3JzW2ldKTtcbiAgICAgIHJbaV0gPSBjb2xvci5yIHx8IDA7XG4gICAgICBnW2ldID0gY29sb3IuZyB8fCAwO1xuICAgICAgYltpXSA9IGNvbG9yLmIgfHwgMDtcbiAgICB9XG4gICAgciA9IHNwbGluZShyKTtcbiAgICBnID0gc3BsaW5lKGcpO1xuICAgIGIgPSBzcGxpbmUoYik7XG4gICAgY29sb3Iub3BhY2l0eSA9IDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGNvbG9yLnIgPSByKHQpO1xuICAgICAgY29sb3IuZyA9IGcodCk7XG4gICAgICBjb2xvci5iID0gYih0KTtcbiAgICAgIHJldHVybiBjb2xvciArIFwiXCI7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciByZ2JCYXNpcyA9IHJnYlNwbGluZShiYXNpcyk7XG5leHBvcnQgdmFyIHJnYkJhc2lzQ2xvc2VkID0gcmdiU3BsaW5lKGJhc2lzQ2xvc2VkKTtcbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5cbnZhciByZUEgPSAvWy0rXT8oPzpcXGQrXFwuP1xcZCp8XFwuP1xcZCspKD86W2VFXVstK10/XFxkKyk/L2csXG4gICAgcmVCID0gbmV3IFJlZ0V4cChyZUEuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIHplcm8oYikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uZShiKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGIodCkgKyBcIlwiO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBiaSA9IHJlQS5sYXN0SW5kZXggPSByZUIubGFzdEluZGV4ID0gMCwgLy8gc2NhbiBpbmRleCBmb3IgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYW0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYVxuICAgICAgYm0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYlxuICAgICAgYnMsIC8vIHN0cmluZyBwcmVjZWRpbmcgY3VycmVudCBudW1iZXIgaW4gYiwgaWYgYW55XG4gICAgICBpID0gLTEsIC8vIGluZGV4IGluIHNcbiAgICAgIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG5cbiAgLy8gQ29lcmNlIGlucHV0cyB0byBzdHJpbmdzLlxuICBhID0gYSArIFwiXCIsIGIgPSBiICsgXCJcIjtcblxuICAvLyBJbnRlcnBvbGF0ZSBwYWlycyBvZiBudW1iZXJzIGluIGEgJiBiLlxuICB3aGlsZSAoKGFtID0gcmVBLmV4ZWMoYSkpXG4gICAgICAmJiAoYm0gPSByZUIuZXhlYyhiKSkpIHtcbiAgICBpZiAoKGJzID0gYm0uaW5kZXgpID4gYmkpIHsgLy8gYSBzdHJpbmcgcHJlY2VkZXMgdGhlIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGJzID0gYi5zbGljZShiaSwgYnMpO1xuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJzO1xuICAgIH1cbiAgICBpZiAoKGFtID0gYW1bMF0pID09PSAoYm0gPSBibVswXSkpIHsgLy8gbnVtYmVycyBpbiBhICYgYiBtYXRjaFxuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJtO1xuICAgIH0gZWxzZSB7IC8vIGludGVycG9sYXRlIG5vbi1tYXRjaGluZyBudW1iZXJzXG4gICAgICBzWysraV0gPSBudWxsO1xuICAgICAgcS5wdXNoKHtpOiBpLCB4OiBudW1iZXIoYW0sIGJtKX0pO1xuICAgIH1cbiAgICBiaSA9IHJlQi5sYXN0SW5kZXg7XG4gIH1cblxuICAvLyBBZGQgcmVtYWlucyBvZiBiLlxuICBpZiAoYmkgPCBiLmxlbmd0aCkge1xuICAgIGJzID0gYi5zbGljZShiaSk7XG4gICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgZWxzZSBzWysraV0gPSBicztcbiAgfVxuXG4gIC8vIFNwZWNpYWwgb3B0aW1pemF0aW9uIGZvciBvbmx5IGEgc2luZ2xlIG1hdGNoLlxuICAvLyBPdGhlcndpc2UsIGludGVycG9sYXRlIGVhY2ggb2YgdGhlIG51bWJlcnMgYW5kIHJlam9pbiB0aGUgc3RyaW5nLlxuICByZXR1cm4gcy5sZW5ndGggPCAyID8gKHFbMF1cbiAgICAgID8gb25lKHFbMF0ueClcbiAgICAgIDogemVybyhiKSlcbiAgICAgIDogKGIgPSBxLmxlbmd0aCwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYjsgKytpKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICAgICAgfSk7XG59XG4iLCJ2YXIgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG5cbmV4cG9ydCB2YXIgaWRlbnRpdHkgPSB7XG4gIHRyYW5zbGF0ZVg6IDAsXG4gIHRyYW5zbGF0ZVk6IDAsXG4gIHJvdGF0ZTogMCxcbiAgc2tld1g6IDAsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBzY2FsZVgsIHNjYWxlWSwgc2tld1g7XG4gIGlmIChzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYikpIGEgLz0gc2NhbGVYLCBiIC89IHNjYWxlWDtcbiAgaWYgKHNrZXdYID0gYSAqIGMgKyBiICogZCkgYyAtPSBhICogc2tld1gsIGQgLT0gYiAqIHNrZXdYO1xuICBpZiAoc2NhbGVZID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpKSBjIC89IHNjYWxlWSwgZCAvPSBzY2FsZVksIHNrZXdYIC89IHNjYWxlWTtcbiAgaWYgKGEgKiBkIDwgYiAqIGMpIGEgPSAtYSwgYiA9IC1iLCBza2V3WCA9IC1za2V3WCwgc2NhbGVYID0gLXNjYWxlWDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGVYOiBlLFxuICAgIHRyYW5zbGF0ZVk6IGYsXG4gICAgcm90YXRlOiBNYXRoLmF0YW4yKGIsIGEpICogZGVncmVlcyxcbiAgICBza2V3WDogTWF0aC5hdGFuKHNrZXdYKSAqIGRlZ3JlZXMsXG4gICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgc2NhbGVZOiBzY2FsZVlcbiAgfTtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4uL251bWJlci5qc1wiO1xuaW1wb3J0IHtwYXJzZUNzcywgcGFyc2VTdmd9IGZyb20gXCIuL3BhcnNlLmpzXCI7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlLCBweENvbW1hLCBweFBhcmVuLCBkZWdQYXJlbikge1xuXG4gIGZ1bmN0aW9uIHBvcChzKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoID8gcy5wb3AoKSArIFwiIFwiIDogXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChcInRyYW5zbGF0ZShcIiwgbnVsbCwgcHhDb21tYSwgbnVsbCwgcHhQYXJlbik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiIHx8IHliKSB7XG4gICAgICBzLnB1c2goXCJ0cmFuc2xhdGUoXCIgKyB4YiArIHB4Q29tbWEgKyB5YiArIHB4UGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJvdGF0ZShhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIGlmIChhIC0gYiA+IDE4MCkgYiArPSAzNjA7IGVsc2UgaWYgKGIgLSBhID4gMTgwKSBhICs9IDM2MDsgLy8gc2hvcnRlc3QgcGF0aFxuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBza2V3WChhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIsIG51bGwsIFwiLFwiLCBudWxsLCBcIilcIik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiICE9PSAxIHx8IHliICE9PSAxKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiArIHhiICsgXCIsXCIgKyB5YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG4gICAgYSA9IHBhcnNlKGEpLCBiID0gcGFyc2UoYik7XG4gICAgdHJhbnNsYXRlKGEudHJhbnNsYXRlWCwgYS50cmFuc2xhdGVZLCBiLnRyYW5zbGF0ZVgsIGIudHJhbnNsYXRlWSwgcywgcSk7XG4gICAgcm90YXRlKGEucm90YXRlLCBiLnJvdGF0ZSwgcywgcSk7XG4gICAgc2tld1goYS5za2V3WCwgYi5za2V3WCwgcywgcSk7XG4gICAgc2NhbGUoYS5zY2FsZVgsIGEuc2NhbGVZLCBiLnNjYWxlWCwgYi5zY2FsZVksIHMsIHEpO1xuICAgIGEgPSBiID0gbnVsbDsgLy8gZ2NcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHEubGVuZ3RoLCBvO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlQ3NzLCBcInB4LCBcIiwgXCJweClcIiwgXCJkZWcpXCIpO1xuZXhwb3J0IHZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlU3ZnLCBcIiwgXCIsIFwiKVwiLCBcIilcIik7XG4iLCJpbXBvcnQgZGVjb21wb3NlLCB7aWRlbnRpdHl9IGZyb20gXCIuL2RlY29tcG9zZS5qc1wiO1xuXG52YXIgc3ZnTm9kZTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNzcyh2YWx1ZSkge1xuICBjb25zdCBtID0gbmV3ICh0eXBlb2YgRE9NTWF0cml4ID09PSBcImZ1bmN0aW9uXCIgPyBET01NYXRyaXggOiBXZWJLaXRDU1NNYXRyaXgpKHZhbHVlICsgXCJcIik7XG4gIHJldHVybiBtLmlzSWRlbnRpdHkgPyBpZGVudGl0eSA6IGRlY29tcG9zZShtLmEsIG0uYiwgbS5jLCBtLmQsIG0uZSwgbS5mKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3ZnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIGlmICghc3ZnTm9kZSkgc3ZnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdmFsdWUpO1xuICBpZiAoISh2YWx1ZSA9IHN2Z05vZGUudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKSkpIHJldHVybiBpZGVudGl0eTtcbiAgdmFsdWUgPSB2YWx1ZS5tYXRyaXg7XG4gIHJldHVybiBkZWNvbXBvc2UodmFsdWUuYSwgdmFsdWUuYiwgdmFsdWUuYywgdmFsdWUuZCwgdmFsdWUuZSwgdmFsdWUuZik7XG59XG4iLCJ2YXIgZXBzaWxvbjIgPSAxZS0xMjtcblxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHpvb21SaG8ocmhvLCByaG8yLCByaG80KSB7XG5cbiAgLy8gcDAgPSBbdXgwLCB1eTAsIHcwXVxuICAvLyBwMSA9IFt1eDEsIHV5MSwgdzFdXG4gIGZ1bmN0aW9uIHpvb20ocDAsIHAxKSB7XG4gICAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcbiAgICAgICAgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLFxuICAgICAgICBkeCA9IHV4MSAtIHV4MCxcbiAgICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICAgIGksXG4gICAgICAgIFM7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHUwIOKJhSB1MS5cbiAgICBpZiAoZDIgPCBlcHNpbG9uMikge1xuICAgICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB0ICogZHgsXG4gICAgICAgICAgdXkwICsgdCAqIGR5LFxuICAgICAgICAgIHcwICogTWF0aC5leHAocmhvICogdCAqIFMpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhbCBjYXNlLlxuICAgIGVsc2Uge1xuICAgICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSxcbiAgICAgICAgICBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzQgKiBkMikgLyAoMiAqIHcwICogcmhvMiAqIGQxKSxcbiAgICAgICAgICBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzQgKiBkMikgLyAoMiAqIHcxICogcmhvMiAqIGQxKSxcbiAgICAgICAgICByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksXG4gICAgICAgICAgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgICAgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzID0gdCAqIFMsXG4gICAgICAgICAgICBjb3NocjAgPSBjb3NoKHIwKSxcbiAgICAgICAgICAgIHUgPSB3MCAvIChyaG8yICogZDEpICogKGNvc2hyMCAqIHRhbmgocmhvICogcyArIHIwKSAtIHNpbmgocjApKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB1ICogZHgsXG4gICAgICAgICAgdXkwICsgdSAqIGR5LFxuICAgICAgICAgIHcwICogY29zaHIwIC8gY29zaChyaG8gKiBzICsgcjApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaS5kdXJhdGlvbiA9IFMgKiAxMDAwICogcmhvIC8gTWF0aC5TUVJUMjtcblxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgem9vbS5yaG8gPSBmdW5jdGlvbihfKSB7XG4gICAgdmFyIF8xID0gTWF0aC5tYXgoMWUtMywgK18pLCBfMiA9IF8xICogXzEsIF80ID0gXzIgKiBfMjtcbiAgICByZXR1cm4gem9vbVJobyhfMSwgXzIsIF80KTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn0pKE1hdGguU1FSVDIsIDIsIDQpO1xuIiwiZXhwb3J0IGRlZmF1bHQgTWF0aC5yYW5kb207XG4iLCJpbXBvcnQgZGVmYXVsdFNvdXJjZSBmcm9tIFwiLi9kZWZhdWx0U291cmNlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBzb3VyY2VSYW5kb21Ob3JtYWwoc291cmNlKSB7XG4gIGZ1bmN0aW9uIHJhbmRvbU5vcm1hbChtdSwgc2lnbWEpIHtcbiAgICB2YXIgeCwgcjtcbiAgICBtdSA9IG11ID09IG51bGwgPyAwIDogK211O1xuICAgIHNpZ21hID0gc2lnbWEgPT0gbnVsbCA/IDEgOiArc2lnbWE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHk7XG5cbiAgICAgIC8vIElmIGF2YWlsYWJsZSwgdXNlIHRoZSBzZWNvbmQgcHJldmlvdXNseS1nZW5lcmF0ZWQgdW5pZm9ybSByYW5kb20uXG4gICAgICBpZiAoeCAhPSBudWxsKSB5ID0geCwgeCA9IG51bGw7XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgZ2VuZXJhdGUgYSBuZXcgeCBhbmQgeS5cbiAgICAgIGVsc2UgZG8ge1xuICAgICAgICB4ID0gc291cmNlKCkgKiAyIC0gMTtcbiAgICAgICAgeSA9IHNvdXJjZSgpICogMiAtIDE7XG4gICAgICAgIHIgPSB4ICogeCArIHkgKiB5O1xuICAgICAgfSB3aGlsZSAoIXIgfHwgciA+IDEpO1xuXG4gICAgICByZXR1cm4gbXUgKyBzaWdtYSAqIHkgKiBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhyKSAvIHIpO1xuICAgIH07XG4gIH1cblxuICByYW5kb21Ob3JtYWwuc291cmNlID0gc291cmNlUmFuZG9tTm9ybWFsO1xuXG4gIHJldHVybiByYW5kb21Ob3JtYWw7XG59KShkZWZhdWx0U291cmNlKTtcbiIsImV4cG9ydCBmdW5jdGlvbiBpbml0UmFuZ2UoZG9tYWluLCByYW5nZSkge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IGJyZWFrO1xuICAgIGNhc2UgMTogdGhpcy5yYW5nZShkb21haW4pOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aGlzLnJhbmdlKHJhbmdlKS5kb21haW4oZG9tYWluKTsgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0SW50ZXJwb2xhdG9yKGRvbWFpbiwgaW50ZXJwb2xhdG9yKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB7XG4gICAgICBpZiAodHlwZW9mIGRvbWFpbiA9PT0gXCJmdW5jdGlvblwiKSB0aGlzLmludGVycG9sYXRvcihkb21haW4pO1xuICAgICAgZWxzZSB0aGlzLnJhbmdlKGRvbWFpbik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhpcy5kb21haW4oZG9tYWluKTtcbiAgICAgIGlmICh0eXBlb2YgaW50ZXJwb2xhdG9yID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuaW50ZXJwb2xhdG9yKGludGVycG9sYXRvcik7XG4gICAgICBlbHNlIHRoaXMucmFuZ2UoaW50ZXJwb2xhdG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImltcG9ydCB7YXNjZW5kaW5nLCBiaXNlY3QsIHF1YW50aWxlU29ydGVkIGFzIHRocmVzaG9sZH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHRocmVzaG9sZHMgPSBbXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBNYXRoLm1heCgxLCByYW5nZS5sZW5ndGgpO1xuICAgIHRocmVzaG9sZHMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IHRocmVzaG9sZChkb21haW4sIGkgLyBuKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbCB8fCBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IHJhbmdlW2Jpc2VjdCh0aHJlc2hvbGRzLCB4KV07XG4gIH1cblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl0gOiBbXG4gICAgICBpID4gMCA/IHRocmVzaG9sZHNbaSAtIDFdIDogZG9tYWluWzBdLFxuICAgICAgaSA8IHRocmVzaG9sZHMubGVuZ3RoID8gdGhyZXNob2xkc1tpXSA6IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV1cbiAgICBdO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXTtcbiAgICBmb3IgKGxldCBkIG9mIF8pIGlmIChkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgIGRvbWFpbi5zb3J0KGFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZHMuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aWxlKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsIi8vIEdpdmVuIHNvbWV0aGluZyBhcnJheSBsaWtlIChvciBudWxsKSwgcmV0dXJucyBzb21ldGhpbmcgdGhhdCBpcyBzdHJpY3RseSBhblxuLy8gYXJyYXkuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCBhcnJheS1saWtlIG9iamVjdHMgcGFzc2VkIHRvIGQzLnNlbGVjdEFsbFxuLy8gb3Igc2VsZWN0aW9uLnNlbGVjdEFsbCBhcmUgY29udmVydGVkIGludG8gcHJvcGVyIGFycmF5cyB3aGVuIGNyZWF0aW5nIGFcbi8vIHNlbGVjdGlvbjsgd2UgZG9u4oCZdCBldmVyIHdhbnQgdG8gY3JlYXRlIGEgc2VsZWN0aW9uIGJhY2tlZCBieSBhIGxpdmVcbi8vIEhUTUxDb2xsZWN0aW9uIG9yIE5vZGVMaXN0LiBIb3dldmVyLCBub3RlIHRoYXQgc2VsZWN0aW9uLnNlbGVjdEFsbCB3aWxsIHVzZSBhXG4vLyBzdGF0aWMgTm9kZUxpc3QgYXMgYSBncm91cCwgc2luY2UgaXQgc2FmZWx5IGRlcml2ZWQgZnJvbSBxdWVyeVNlbGVjdG9yQWxsLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXJyYXkoeCkge1xuICByZXR1cm4geCA9PSBudWxsID8gW10gOiBBcnJheS5pc0FycmF5KHgpID8geCA6IEFycmF5LmZyb20oeCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSBcIi4vbmFtZXNwYWNlLmpzXCI7XG5pbXBvcnQge3hodG1sfSBmcm9tIFwiLi9uYW1lc3BhY2VzLmpzXCI7XG5cbmZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCxcbiAgICAgICAgdXJpID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgcmV0dXJuIHVyaSA9PT0geGh0bWwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0geGh0bWxcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3JGaXhlZChmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiAoZnVsbG5hbWUubG9jYWxcbiAgICAgID8gY3JlYXRvckZpeGVkXG4gICAgICA6IGNyZWF0b3JJbmhlcml0KShmdWxsbmFtZSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZE1hdGNoZXIoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuIiwiaW1wb3J0IG5hbWVzcGFjZXMgZnJvbSBcIi4vbmFtZXNwYWNlcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIG5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtzcGFjZTogbmFtZXNwYWNlc1twcmVmaXhdLCBsb2NhbDogbmFtZX0gOiBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xufVxuIiwiZXhwb3J0IHZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB4aHRtbDogeGh0bWwsXG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG59O1xuIiwiaW1wb3J0IHNvdXJjZUV2ZW50IGZyb20gXCIuL3NvdXJjZUV2ZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50LCBub2RlKSB7XG4gIGV2ZW50ID0gc291cmNlRXZlbnQoZXZlbnQpO1xuICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSBub2RlID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgc3ZnID0gbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgbm9kZTtcbiAgICBpZiAoc3ZnLmNyZWF0ZVNWR1BvaW50KSB7XG4gICAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgIHBvaW50LnggPSBldmVudC5jbGllbnRYLCBwb2ludC55ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKG5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XG4gICAgfVxuICAgIGlmIChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XG4gICAgfVxuICB9XG4gIHJldHVybiBbZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZXTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9uLCByb290fSBmcm9tIFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcildXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW1tzZWxlY3Rvcl1dLCByb290KTtcbn1cbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuLi9jcmVhdG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gXCIuLi9uYW1lc3BhY2UuanNcIjtcblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgcmV0dXJuIGZ1bGxuYW1lLmxvY2FsXG4gICAgICAgID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpXG4gICAgICAgIDogbm9kZS5nZXRBdHRyaWJ1dGUoZnVsbG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbilcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKSkoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICBhcmd1bWVudHNbMF0gPSB0aGlzO1xuICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KC9efFxccysvKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0IHx8IG5ldyBDbGFzc0xpc3Qobm9kZSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChub2RlKSB7XG4gIHRoaXMuX25vZGUgPSBub2RlO1xuICB0aGlzLl9uYW1lcyA9IGNsYXNzQXJyYXkobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcbn1cblxuQ2xhc3NMaXN0LnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgdGhpcy5fbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LmFkZChuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRSZW1vdmUobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QucmVtb3ZlKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFRydWUobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRSZW1vdmUodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24obmFtZXMsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAodmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IGNsYXNzZWRBZGQgOiBjbGFzc2VkUmVtb3ZlKSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IGNsYXNzQXJyYXkobmFtZSArIFwiXCIpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KHRoaXMubm9kZSgpKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWxpc3QuY29udGFpbnMobmFtZXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBjbGFzc2VkRnVuY3Rpb24gOiB2YWx1ZVxuICAgICAgPyBjbGFzc2VkVHJ1ZVxuICAgICAgOiBjbGFzc2VkRmFsc2UpKG5hbWVzLCB2YWx1ZSkpO1xufVxuIiwiZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lU2hhbGxvdygpIHtcbiAgdmFyIGNsb25lID0gdGhpcy5jbG9uZU5vZGUoZmFsc2UpLCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHRTaWJsaW5nKSA6IGNsb25lO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVEZWVwKCkge1xuICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZSh0cnVlKSwgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICByZXR1cm4gcGFyZW50ID8gcGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcy5uZXh0U2libGluZykgOiBjbG9uZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGVlcCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZGVlcCA/IHNlbGVjdGlvbl9jbG9uZURlZXAgOiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHtFbnRlck5vZGV9IGZyb20gXCIuL2VudGVyLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4uL2NvbnN0YW50LmpzXCI7XG5cbmZ1bmN0aW9uIGJpbmRJbmRleChwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhKSB7XG4gIHZhciBpID0gMCxcbiAgICAgIG5vZGUsXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZml0IGludG8gdXBkYXRlLlxuICAvLyBQdXQgYW55IG51bGwgbm9kZXMgaW50byBlbnRlci5cbiAgLy8gUHV0IGFueSByZW1haW5pbmcgZGF0YSBpbnRvIGVudGVyLlxuICBmb3IgKDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGRvbuKAmXQgZml0IGludG8gZXhpdC5cbiAgZm9yICg7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRLZXkocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSwga2V5KSB7XG4gIHZhciBpLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVCeUtleVZhbHVlID0gbmV3IE1hcCxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAga2V5VmFsdWVzID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKSxcbiAgICAgIGtleVZhbHVlO1xuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBub2RlLlxuICAvLyBJZiBtdWx0aXBsZSBub2RlcyBoYXZlIHRoZSBzYW1lIGtleSwgdGhlIGR1cGxpY2F0ZXMgYXJlIGFkZGVkIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWUgPSBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkgKyBcIlwiO1xuICAgICAgaWYgKG5vZGVCeUtleVZhbHVlLmhhcyhrZXlWYWx1ZSkpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlQnlLZXlWYWx1ZS5zZXQoa2V5VmFsdWUsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBkYXR1bS5cbiAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cbiAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAga2V5VmFsdWUgPSBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpICsgXCJcIjtcbiAgICBpZiAobm9kZSA9IG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZSkpIHtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIG5vZGVCeUtleVZhbHVlLmRlbGV0ZShrZXlWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBhbnkgcmVtYWluaW5nIG5vZGVzIHRoYXQgd2VyZSBub3QgYm91bmQgdG8gZGF0YSB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAobm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlc1tpXSkgPT09IG5vZGUpKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0dW0obm9kZSkge1xuICByZXR1cm4gbm9kZS5fX2RhdGFfXztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBBcnJheS5mcm9tKHRoaXMsIGRhdHVtKTtcblxuICB2YXIgYmluZCA9IGtleSA/IGJpbmRLZXkgOiBiaW5kSW5kZXgsXG4gICAgICBwYXJlbnRzID0gdGhpcy5fcGFyZW50cyxcbiAgICAgIGdyb3VwcyA9IHRoaXMuX2dyb3VwcztcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHZhbHVlID0gY29uc3RhbnQodmFsdWUpO1xuXG4gIGZvciAodmFyIG0gPSBncm91cHMubGVuZ3RoLCB1cGRhdGUgPSBuZXcgQXJyYXkobSksIGVudGVyID0gbmV3IEFycmF5KG0pLCBleGl0ID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2pdLFxuICAgICAgICBncm91cCA9IGdyb3Vwc1tqXSxcbiAgICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICAgIGRhdGEgPSBhcnJheWxpa2UodmFsdWUuY2FsbChwYXJlbnQsIHBhcmVudCAmJiBwYXJlbnQuX19kYXRhX18sIGosIHBhcmVudHMpKSxcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBlbnRlckdyb3VwID0gZW50ZXJbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIHVwZGF0ZUdyb3VwID0gdXBkYXRlW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICBleGl0R3JvdXAgPSBleGl0W2pdID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKTtcblxuICAgIGJpbmQocGFyZW50LCBncm91cCwgZW50ZXJHcm91cCwgdXBkYXRlR3JvdXAsIGV4aXRHcm91cCwgZGF0YSwga2V5KTtcblxuICAgIC8vIE5vdyBjb25uZWN0IHRoZSBlbnRlciBub2RlcyB0byB0aGVpciBmb2xsb3dpbmcgdXBkYXRlIG5vZGUsIHN1Y2ggdGhhdFxuICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXG4gICAgLy8gcmF0aGVyIHRoYW4gYXQgdGhlIGVuZCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDAsIHByZXZpb3VzLCBuZXh0OyBpMCA8IGRhdGFMZW5ndGg7ICsraTApIHtcbiAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XG4gICAgICAgIGlmIChpMCA+PSBpMSkgaTEgPSBpMCArIDE7XG4gICAgICAgIHdoaWxlICghKG5leHQgPSB1cGRhdGVHcm91cFtpMV0pICYmICsraTEgPCBkYXRhTGVuZ3RoKTtcbiAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlID0gbmV3IFNlbGVjdGlvbih1cGRhdGUsIHBhcmVudHMpO1xuICB1cGRhdGUuX2VudGVyID0gZW50ZXI7XG4gIHVwZGF0ZS5fZXhpdCA9IGV4aXQ7XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbi8vIEdpdmVuIHNvbWUgZGF0YSwgdGhpcyByZXR1cm5zIGFuIGFycmF5LWxpa2UgdmlldyBvZiBpdDogYW4gb2JqZWN0IHRoYXRcbi8vIGV4cG9zZXMgYSBsZW5ndGggcHJvcGVydHkgYW5kIGFsbG93cyBudW1lcmljIGluZGV4aW5nLiBOb3RlIHRoYXQgdW5saWtlXG4vLyBzZWxlY3RBbGwsIHRoaXMgaXNu4oCZdCB3b3JyaWVkIGFib3V0IOKAnGxpdmXigJ0gY29sbGVjdGlvbnMgYmVjYXVzZSB0aGUgcmVzdWx0aW5nXG4vLyBhcnJheSB3aWxsIG9ubHkgYmUgdXNlZCBicmllZmx5IHdoaWxlIGRhdGEgaXMgYmVpbmcgYm91bmQuIChJdCBpcyBwb3NzaWJsZSB0b1xuLy8gY2F1c2UgdGhlIGRhdGEgdG8gY2hhbmdlIHdoaWxlIGl0ZXJhdGluZyBieSB1c2luZyBhIGtleSBmdW5jdGlvbiwgYnV0IHBsZWFzZVxuLy8gZG9u4oCZdDsgd2XigJlkIHJhdGhlciBhdm9pZCBhIGdyYXR1aXRvdXMgY29weS4pXG5mdW5jdGlvbiBhcnJheWxpa2UoZGF0YSkge1xuICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgXCJsZW5ndGhcIiBpbiBkYXRhXG4gICAgPyBkYXRhIC8vIEFycmF5LCBUeXBlZEFycmF5LCBOb2RlTGlzdCwgYXJyYXktbGlrZVxuICAgIDogQXJyYXkuZnJvbShkYXRhKTsgLy8gTWFwLCBTZXQsIGl0ZXJhYmxlLCBzdHJpbmcsIG9yIGFueXRoaW5nIGVsc2Vcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiLCB2YWx1ZSlcbiAgICAgIDogdGhpcy5ub2RlKCkuX19kYXRhX187XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KG5vZGUsIHR5cGUsIHBhcmFtcykge1xuICB2YXIgd2luZG93ID0gZGVmYXVsdFZpZXcobm9kZSksXG4gICAgICBldmVudCA9IHdpbmRvdy5DdXN0b21FdmVudDtcblxuICBpZiAodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBldmVudCA9IG5ldyBldmVudCh0eXBlLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgaWYgKHBhcmFtcykgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSksIGV2ZW50LmRldGFpbCA9IHBhcmFtcy5kZXRhaWw7XG4gICAgZWxzZSBldmVudC5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQ29uc3RhbnQodHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGRpc3BhdGNoRnVuY3Rpb25cbiAgICAgIDogZGlzcGF0Y2hDb25zdGFudCkodHlwZSwgcGFyYW1zKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaykge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBjYWxsYmFjay5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMubm9kZSgpO1xufVxuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2UuanNcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZW50ZXIgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEVudGVyTm9kZShwYXJlbnQsIGRhdHVtKSB7XG4gIHRoaXMub3duZXJEb2N1bWVudCA9IHBhcmVudC5vd25lckRvY3VtZW50O1xuICB0aGlzLm5hbWVzcGFjZVVSSSA9IHBhcmVudC5uYW1lc3BhY2VVUkk7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX19kYXRhX18gPSBkYXR1bTtcbn1cblxuRW50ZXJOb2RlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEVudGVyTm9kZSxcbiAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCB0aGlzLl9uZXh0KTsgfSxcbiAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihjaGlsZCwgbmV4dCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgbmV4dCk7IH0sXG4gIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7IH1cbn07XG4iLCJpbXBvcnQgc3BhcnNlIGZyb20gXCIuL3NwYXJzZS5qc1wiO1xuaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9leGl0IHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBtYXRjaGVyIGZyb20gXCIuLi9tYXRjaGVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZnVuY3Rpb24gaHRtbFJlbW92ZSgpIHtcbiAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBodG1sQ29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh0bWxGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBodG1sUmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBodG1sRnVuY3Rpb25cbiAgICAgICAgICA6IGh0bWxDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG59XG4iLCJpbXBvcnQgc2VsZWN0aW9uX3NlbGVjdCBmcm9tIFwiLi9zZWxlY3QuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0QWxsIGZyb20gXCIuL3NlbGVjdEFsbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RDaGlsZCBmcm9tIFwiLi9zZWxlY3RDaGlsZC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RDaGlsZHJlbiBmcm9tIFwiLi9zZWxlY3RDaGlsZHJlbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9maWx0ZXIgZnJvbSBcIi4vZmlsdGVyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2RhdGEgZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9lbnRlciBmcm9tIFwiLi9lbnRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9leGl0IGZyb20gXCIuL2V4aXQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fam9pbiBmcm9tIFwiLi9qb2luLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX21lcmdlIGZyb20gXCIuL21lcmdlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX29yZGVyIGZyb20gXCIuL29yZGVyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NvcnQgZnJvbSBcIi4vc29ydC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jYWxsIGZyb20gXCIuL2NhbGwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbm9kZXMgZnJvbSBcIi4vbm9kZXMuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbm9kZSBmcm9tIFwiLi9ub2RlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NpemUgZnJvbSBcIi4vc2l6ZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9lbXB0eSBmcm9tIFwiLi9lbXB0eS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9lYWNoIGZyb20gXCIuL2VhY2guanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fYXR0ciBmcm9tIFwiLi9hdHRyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3N0eWxlIGZyb20gXCIuL3N0eWxlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3Byb3BlcnR5IGZyb20gXCIuL3Byb3BlcnR5LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2NsYXNzZWQgZnJvbSBcIi4vY2xhc3NlZC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl90ZXh0IGZyb20gXCIuL3RleHQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25faHRtbCBmcm9tIFwiLi9odG1sLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3JhaXNlIGZyb20gXCIuL3JhaXNlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2xvd2VyIGZyb20gXCIuL2xvd2VyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2FwcGVuZCBmcm9tIFwiLi9hcHBlbmQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25faW5zZXJ0IGZyb20gXCIuL2luc2VydC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9yZW1vdmUgZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2Nsb25lIGZyb20gXCIuL2Nsb25lLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2RhdHVtIGZyb20gXCIuL2RhdHVtLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX29uIGZyb20gXCIuL29uLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2Rpc3BhdGNoIGZyb20gXCIuL2Rpc3BhdGNoLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2l0ZXJhdG9yIGZyb20gXCIuL2l0ZXJhdG9yLmpzXCI7XG5cbmV4cG9ydCB2YXIgcm9vdCA9IFtudWxsXTtcblxuZXhwb3J0IGZ1bmN0aW9uIFNlbGVjdGlvbihncm91cHMsIHBhcmVudHMpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF1dLCByb290KTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3NlbGVjdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgc2VsZWN0Q2hpbGQ6IHNlbGVjdGlvbl9zZWxlY3RDaGlsZCxcbiAgc2VsZWN0Q2hpbGRyZW46IHNlbGVjdGlvbl9zZWxlY3RDaGlsZHJlbixcbiAgZmlsdGVyOiBzZWxlY3Rpb25fZmlsdGVyLFxuICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgZXhpdDogc2VsZWN0aW9uX2V4aXQsXG4gIGpvaW46IHNlbGVjdGlvbl9qb2luLFxuICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICBzZWxlY3Rpb246IHNlbGVjdGlvbl9zZWxlY3Rpb24sXG4gIG9yZGVyOiBzZWxlY3Rpb25fb3JkZXIsXG4gIHNvcnQ6IHNlbGVjdGlvbl9zb3J0LFxuICBjYWxsOiBzZWxlY3Rpb25fY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX25vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX2VtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fZWFjaCxcbiAgYXR0cjogc2VsZWN0aW9uX2F0dHIsXG4gIHN0eWxlOiBzZWxlY3Rpb25fc3R5bGUsXG4gIHByb3BlcnR5OiBzZWxlY3Rpb25fcHJvcGVydHksXG4gIGNsYXNzZWQ6IHNlbGVjdGlvbl9jbGFzc2VkLFxuICB0ZXh0OiBzZWxlY3Rpb25fdGV4dCxcbiAgaHRtbDogc2VsZWN0aW9uX2h0bWwsXG4gIHJhaXNlOiBzZWxlY3Rpb25fcmFpc2UsXG4gIGxvd2VyOiBzZWxlY3Rpb25fbG93ZXIsXG4gIGFwcGVuZDogc2VsZWN0aW9uX2FwcGVuZCxcbiAgaW5zZXJ0OiBzZWxlY3Rpb25faW5zZXJ0LFxuICByZW1vdmU6IHNlbGVjdGlvbl9yZW1vdmUsXG4gIGNsb25lOiBzZWxlY3Rpb25fY2xvbmUsXG4gIGRhdHVtOiBzZWxlY3Rpb25fZGF0dW0sXG4gIG9uOiBzZWxlY3Rpb25fb24sXG4gIGRpc3BhdGNoOiBzZWxlY3Rpb25fZGlzcGF0Y2gsXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiBzZWxlY3Rpb25faXRlcmF0b3Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNlbGVjdGlvbjtcbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuLi9jcmVhdG9yLmpzXCI7XG5pbXBvcnQgc2VsZWN0b3IgZnJvbSBcIi4uL3NlbGVjdG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGNvbnN0YW50TnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIGJlZm9yZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpLFxuICAgICAgc2VsZWN0ID0gYmVmb3JlID09IG51bGwgPyBjb25zdGFudE51bGwgOiB0eXBlb2YgYmVmb3JlID09PSBcImZ1bmN0aW9uXCIgPyBiZWZvcmUgOiBzZWxlY3RvcihiZWZvcmUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBzZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBudWxsKTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiooKSB7XG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB5aWVsZCBub2RlO1xuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob25lbnRlciwgb251cGRhdGUsIG9uZXhpdCkge1xuICB2YXIgZW50ZXIgPSB0aGlzLmVudGVyKCksIHVwZGF0ZSA9IHRoaXMsIGV4aXQgPSB0aGlzLmV4aXQoKTtcbiAgaWYgKHR5cGVvZiBvbmVudGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBlbnRlciA9IG9uZW50ZXIoZW50ZXIpO1xuICAgIGlmIChlbnRlcikgZW50ZXIgPSBlbnRlci5zZWxlY3Rpb24oKTtcbiAgfSBlbHNlIHtcbiAgICBlbnRlciA9IGVudGVyLmFwcGVuZChvbmVudGVyICsgXCJcIik7XG4gIH1cbiAgaWYgKG9udXBkYXRlICE9IG51bGwpIHtcbiAgICB1cGRhdGUgPSBvbnVwZGF0ZSh1cGRhdGUpO1xuICAgIGlmICh1cGRhdGUpIHVwZGF0ZSA9IHVwZGF0ZS5zZWxlY3Rpb24oKTtcbiAgfVxuICBpZiAob25leGl0ID09IG51bGwpIGV4aXQucmVtb3ZlKCk7IGVsc2Ugb25leGl0KGV4aXQpO1xuICByZXR1cm4gZW50ZXIgJiYgdXBkYXRlID8gZW50ZXIubWVyZ2UodXBkYXRlKS5vcmRlcigpIDogdXBkYXRlO1xufVxuIiwiZnVuY3Rpb24gbG93ZXIoKSB7XG4gIGlmICh0aGlzLnByZXZpb3VzU2libGluZykgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKGxvd2VyKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSBjb250ZXh0LnNlbGVjdGlvbiA/IGNvbnRleHQuc2VsZWN0aW9uKCkgOiBjb250ZXh0O1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSBzZWxlY3Rpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG5vZGUpIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xufVxuIiwiZnVuY3Rpb24gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQsIHRoaXMuX19kYXRhX18pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblJlbW92ZSh0eXBlbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uO1xuICAgIGlmICghb24pIHJldHVybjtcbiAgICBmb3IgKHZhciBqID0gMCwgaSA9IC0xLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAobyA9IG9uW2pdLCAoIXR5cGVuYW1lLnR5cGUgfHwgby50eXBlID09PSB0eXBlbmFtZS50eXBlKSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uWysraV0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKytpKSBvbi5sZW5ndGggPSBpO1xuICAgIGVsc2UgZGVsZXRlIHRoaXMuX19vbjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25BZGQodHlwZW5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb24sIG8sIGxpc3RlbmVyID0gY29udGV4dExpc3RlbmVyKHZhbHVlKTtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoKG8gPSBvbltqXSkudHlwZSA9PT0gdHlwZW5hbWUudHlwZSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciA9IGxpc3RlbmVyLCBvLm9wdGlvbnMgPSBvcHRpb25zKTtcbiAgICAgICAgby52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgbyA9IHt0eXBlOiB0eXBlbmFtZS50eXBlLCBuYW1lOiB0eXBlbmFtZS5uYW1lLCB2YWx1ZTogdmFsdWUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgb3B0aW9uczogb3B0aW9uc307XG4gICAgaWYgKCFvbikgdGhpcy5fX29uID0gW29dO1xuICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZW5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB0aGlzLmVhY2gob24odHlwZW5hbWVzW2ldLCB2YWx1ZSwgb3B0aW9ucykpO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obmV4dCkgXiA0KSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIHByb3BlcnR5UmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICBlbHNlIHRoaXNbbmFtZV0gPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xufVxuIiwiZnVuY3Rpb24gcmFpc2UoKSB7XG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyZW1vdmUpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2VsZWN0b3IgZnJvbSBcIi4uL3NlbGVjdG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgYXJyYXkgZnJvbSBcIi4uL2FycmF5LmpzXCI7XG5pbXBvcnQgc2VsZWN0b3JBbGwgZnJvbSBcIi4uL3NlbGVjdG9yQWxsLmpzXCI7XG5cbmZ1bmN0aW9uIGFycmF5QWxsKHNlbGVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFycmF5KHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ID09PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IGFycmF5QWxsKHNlbGVjdCk7XG4gIGVsc2Ugc2VsZWN0ID0gc2VsZWN0b3JBbGwoc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzdWJncm91cHMucHVzaChzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpO1xuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCBwYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7Y2hpbGRNYXRjaGVyfSBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG52YXIgZmluZCA9IEFycmF5LnByb3RvdHlwZS5maW5kO1xuXG5mdW5jdGlvbiBjaGlsZEZpbmQobWF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmaW5kLmNhbGwodGhpcy5jaGlsZHJlbiwgbWF0Y2gpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjaGlsZEZpcnN0KCkge1xuICByZXR1cm4gdGhpcy5maXJzdEVsZW1lbnRDaGlsZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KG1hdGNoID09IG51bGwgPyBjaGlsZEZpcnN0XG4gICAgICA6IGNoaWxkRmluZCh0eXBlb2YgbWF0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IG1hdGNoIDogY2hpbGRNYXRjaGVyKG1hdGNoKSkpO1xufVxuIiwiaW1wb3J0IHtjaGlsZE1hdGNoZXJ9IGZyb20gXCIuLi9tYXRjaGVyLmpzXCI7XG5cbnZhciBmaWx0ZXIgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyO1xuXG5mdW5jdGlvbiBjaGlsZHJlbigpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIGNoaWxkcmVuRmlsdGVyKG1hdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwodGhpcy5jaGlsZHJlbiwgbWF0Y2gpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3RBbGwobWF0Y2ggPT0gbnVsbCA/IGNoaWxkcmVuXG4gICAgICA6IGNoaWxkcmVuRmlsdGVyKHR5cGVvZiBtYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gbWF0Y2ggOiBjaGlsZE1hdGNoZXIobWF0Y2gpKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgbGV0IHNpemUgPSAwO1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcykgKytzaXplOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiBzaXplO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgaWYgKCFjb21wYXJlKSBjb21wYXJlID0gYXNjZW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVOb2RlKGEsIGIpIHtcbiAgICByZXR1cm4gYSAmJiBiID8gY29tcGFyZShhLl9fZGF0YV9fLCBiLl9fZGF0YV9fKSA6ICFhIC0gIWI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzb3J0Z3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzb3J0Z3JvdXAgPSBzb3J0Z3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzb3J0Z3JvdXBbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3J0Z3JvdXAuc29ydChjb21wYXJlTm9kZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzb3J0Z3JvdXBzLCB0aGlzLl9wYXJlbnRzKS5vcmRlcigpO1xufVxuXG5mdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih1cGRhdGUpIHtcbiAgcmV0dXJuIG5ldyBBcnJheSh1cGRhdGUubGVuZ3RoKTtcbn1cbiIsImltcG9ydCBkZWZhdWx0VmlldyBmcm9tIFwiLi4vd2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdiwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyBzdHlsZVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHN0eWxlRnVuY3Rpb25cbiAgICAgICAgICAgIDogc3R5bGVDb25zdGFudCkobmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKVxuICAgICAgOiBzdHlsZVZhbHVlKHRoaXMubm9kZSgpLCBuYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0eWxlVmFsdWUobm9kZSwgbmFtZSkge1xuICByZXR1cm4gbm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpXG4gICAgICB8fCBkZWZhdWx0Vmlldyhub2RlKS5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG59XG4iLCJmdW5jdGlvbiB0ZXh0UmVtb3ZlKCkge1xuICB0aGlzLnRleHRDb250ZW50ID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHRleHRSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHRleHRGdW5jdGlvblxuICAgICAgICAgIDogdGV4dENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xufVxuIiwiZnVuY3Rpb24gbm9uZSgpIHt9XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gbm9uZSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9O1xufVxuIiwiZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBlbXB0eSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgbGV0IHNvdXJjZUV2ZW50O1xuICB3aGlsZSAoc291cmNlRXZlbnQgPSBldmVudC5zb3VyY2VFdmVudCkgZXZlbnQgPSBzb3VyY2VFdmVudDtcbiAgcmV0dXJuIGV2ZW50O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIC8vIG5vZGUgaXMgYSBOb2RlXG4gICAgICB8fCAobm9kZS5kb2N1bWVudCAmJiBub2RlKSAvLyBub2RlIGlzIGEgV2luZG93XG4gICAgICB8fCBub2RlLmRlZmF1bHRWaWV3OyAvLyBub2RlIGlzIGEgRG9jdW1lbnRcbn1cbiIsImltcG9ydCB7VGltZXJ9IGZyb20gXCIuL3RpbWVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgZGVsYXkgPSBkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheTtcbiAgdC5yZXN0YXJ0KGVsYXBzZWQgPT4ge1xuICAgIHQuc3RvcCgpO1xuICAgIGNhbGxiYWNrKGVsYXBzZWQgKyBkZWxheSk7XG4gIH0sIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG4iLCJ2YXIgZnJhbWUgPSAwLCAvLyBpcyBhbiBhbmltYXRpb24gZnJhbWUgcGVuZGluZz9cbiAgICB0aW1lb3V0ID0gMCwgLy8gaXMgYSB0aW1lb3V0IHBlbmRpbmc/XG4gICAgaW50ZXJ2YWwgPSAwLCAvLyBhcmUgYW55IHRpbWVycyBhY3RpdmU/XG4gICAgcG9rZURlbGF5ID0gMTAwMCwgLy8gaG93IGZyZXF1ZW50bHkgd2UgY2hlY2sgZm9yIGNsb2NrIHNrZXdcbiAgICB0YXNrSGVhZCxcbiAgICB0YXNrVGFpbCxcbiAgICBjbG9ja0xhc3QgPSAwLFxuICAgIGNsb2NrTm93ID0gMCxcbiAgICBjbG9ja1NrZXcgPSAwLFxuICAgIGNsb2NrID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSBcIm9iamVjdFwiICYmIHBlcmZvcm1hbmNlLm5vdyA/IHBlcmZvcm1hbmNlIDogRGF0ZSxcbiAgICBzZXRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDE3KTsgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIGNsb2NrTm93IHx8IChzZXRGcmFtZShjbGVhck5vdyksIGNsb2NrTm93ID0gY2xvY2subm93KCkgKyBjbG9ja1NrZXcpO1xufVxuXG5mdW5jdGlvbiBjbGVhck5vdygpIHtcbiAgY2xvY2tOb3cgPSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gVGltZXIoKSB7XG4gIHRoaXMuX2NhbGwgPVxuICB0aGlzLl90aW1lID1cbiAgdGhpcy5fbmV4dCA9IG51bGw7XG59XG5cblRpbWVyLnByb3RvdHlwZSA9IHRpbWVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRpbWVyLFxuICByZXN0YXJ0OiBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICB0aW1lID0gKHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWUpICsgKGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5KTtcbiAgICBpZiAoIXRoaXMuX25leHQgJiYgdGFza1RhaWwgIT09IHRoaXMpIHtcbiAgICAgIGlmICh0YXNrVGFpbCkgdGFza1RhaWwuX25leHQgPSB0aGlzO1xuICAgICAgZWxzZSB0YXNrSGVhZCA9IHRoaXM7XG4gICAgICB0YXNrVGFpbCA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX2NhbGwgPSBjYWxsYmFjaztcbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICBzbGVlcCgpO1xuICB9LFxuICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fY2FsbCkge1xuICAgICAgdGhpcy5fY2FsbCA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lID0gSW5maW5pdHk7XG4gICAgICBzbGVlcCgpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZXJGbHVzaCgpIHtcbiAgbm93KCk7IC8vIEdldCB0aGUgY3VycmVudCB0aW1lLCBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICsrZnJhbWU7IC8vIFByZXRlbmQgd2XigJl2ZSBzZXQgYW4gYWxhcm0sIGlmIHdlIGhhdmVu4oCZdCBhbHJlYWR5LlxuICB2YXIgdCA9IHRhc2tIZWFkLCBlO1xuICB3aGlsZSAodCkge1xuICAgIGlmICgoZSA9IGNsb2NrTm93IC0gdC5fdGltZSkgPj0gMCkgdC5fY2FsbC5jYWxsKHVuZGVmaW5lZCwgZSk7XG4gICAgdCA9IHQuX25leHQ7XG4gIH1cbiAgLS1mcmFtZTtcbn1cblxuZnVuY3Rpb24gd2FrZSgpIHtcbiAgY2xvY2tOb3cgPSAoY2xvY2tMYXN0ID0gY2xvY2subm93KCkpICsgY2xvY2tTa2V3O1xuICBmcmFtZSA9IHRpbWVvdXQgPSAwO1xuICB0cnkge1xuICAgIHRpbWVyRmx1c2goKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmcmFtZSA9IDA7XG4gICAgbmFwKCk7XG4gICAgY2xvY2tOb3cgPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBva2UoKSB7XG4gIHZhciBub3cgPSBjbG9jay5ub3coKSwgZGVsYXkgPSBub3cgLSBjbG9ja0xhc3Q7XG4gIGlmIChkZWxheSA+IHBva2VEZWxheSkgY2xvY2tTa2V3IC09IGRlbGF5LCBjbG9ja0xhc3QgPSBub3c7XG59XG5cbmZ1bmN0aW9uIG5hcCgpIHtcbiAgdmFyIHQwLCB0MSA9IHRhc2tIZWFkLCB0MiwgdGltZSA9IEluZmluaXR5O1xuICB3aGlsZSAodDEpIHtcbiAgICBpZiAodDEuX2NhbGwpIHtcbiAgICAgIGlmICh0aW1lID4gdDEuX3RpbWUpIHRpbWUgPSB0MS5fdGltZTtcbiAgICAgIHQwID0gdDEsIHQxID0gdDEuX25leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQyID0gdDEuX25leHQsIHQxLl9uZXh0ID0gbnVsbDtcbiAgICAgIHQxID0gdDAgPyB0MC5fbmV4dCA9IHQyIDogdGFza0hlYWQgPSB0MjtcbiAgICB9XG4gIH1cbiAgdGFza1RhaWwgPSB0MDtcbiAgc2xlZXAodGltZSk7XG59XG5cbmZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgaWYgKGZyYW1lKSByZXR1cm47IC8vIFNvb25lc3QgYWxhcm0gYWxyZWFkeSBzZXQsIG9yIHdpbGwgYmUuXG4gIGlmICh0aW1lb3V0KSB0aW1lb3V0ID0gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB2YXIgZGVsYXkgPSB0aW1lIC0gY2xvY2tOb3c7IC8vIFN0cmljdGx5IGxlc3MgdGhhbiBpZiB3ZSByZWNvbXB1dGVkIGNsb2NrTm93LlxuICBpZiAoZGVsYXkgPiAyNCkge1xuICAgIGlmICh0aW1lIDwgSW5maW5pdHkpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHdha2UsIHRpbWUgLSBjbG9jay5ub3coKSAtIGNsb2NrU2tldyk7XG4gICAgaWYgKGludGVydmFsKSBpbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW50ZXJ2YWwpIGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpLCBpbnRlcnZhbCA9IHNldEludGVydmFsKHBva2UsIHBva2VEZWxheSk7XG4gICAgZnJhbWUgPSAxLCBzZXRGcmFtZSh3YWtlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQge1NDSEVEVUxFRH0gZnJvbSBcIi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuXG52YXIgcm9vdCA9IFtudWxsXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGk7XG5cbiAgaWYgKHNjaGVkdWxlcykge1xuICAgIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkuc3RhdGUgPiBTQ0hFRFVMRUQgJiYgc2NoZWR1bGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zaXRpb24oW1tub2RlXV0sIHJvb3QsIG5hbWUsICtpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJhbnNpdGlvbn0gZnJvbSBcIi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGFjdGl2ZX0gZnJvbSBcIi4vYWN0aXZlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJydXB0fSBmcm9tIFwiLi9pbnRlcnJ1cHQuanNcIjtcbiIsImltcG9ydCB7U1RBUlRJTkcsIEVORElORywgRU5ERUR9IGZyb20gXCIuL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGVtcHR5ID0gdHJ1ZSxcbiAgICAgIGk7XG5cbiAgaWYgKCFzY2hlZHVsZXMpIHJldHVybjtcblxuICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuXG4gIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5uYW1lICE9PSBuYW1lKSB7IGVtcHR5ID0gZmFsc2U7IGNvbnRpbnVlOyB9XG4gICAgYWN0aXZlID0gc2NoZWR1bGUuc3RhdGUgPiBTVEFSVElORyAmJiBzY2hlZHVsZS5zdGF0ZSA8IEVORElORztcbiAgICBzY2hlZHVsZS5zdGF0ZSA9IEVOREVEO1xuICAgIHNjaGVkdWxlLnRpbWVyLnN0b3AoKTtcbiAgICBzY2hlZHVsZS5vbi5jYWxsKGFjdGl2ZSA/IFwiaW50ZXJydXB0XCIgOiBcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzY2hlZHVsZS5pbmRleCwgc2NoZWR1bGUuZ3JvdXApO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gIH1cblxuICBpZiAoZW1wdHkpIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2ludGVycnVwdCBmcm9tIFwiLi9pbnRlcnJ1cHQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fdHJhbnNpdGlvbiBmcm9tIFwiLi90cmFuc2l0aW9uLmpzXCI7XG5cbnNlbGVjdGlvbi5wcm90b3R5cGUuaW50ZXJydXB0ID0gc2VsZWN0aW9uX2ludGVycnVwdDtcbnNlbGVjdGlvbi5wcm90b3R5cGUudHJhbnNpdGlvbiA9IHNlbGVjdGlvbl90cmFuc2l0aW9uO1xuIiwiaW1wb3J0IGludGVycnVwdCBmcm9tIFwiLi4vaW50ZXJydXB0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICBpbnRlcnJ1cHQodGhpcywgbmFtZSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9uLCBuZXdJZH0gZnJvbSBcIi4uL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSBmcm9tIFwiLi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuaW1wb3J0IHtlYXNlQ3ViaWNJbk91dH0gZnJvbSBcImQzLWVhc2VcIjtcbmltcG9ydCB7bm93fSBmcm9tIFwiZDMtdGltZXJcIjtcblxudmFyIGRlZmF1bHRUaW1pbmcgPSB7XG4gIHRpbWU6IG51bGwsIC8vIFNldCBvbiB1c2UuXG4gIGRlbGF5OiAwLFxuICBkdXJhdGlvbjogMjUwLFxuICBlYXNlOiBlYXNlQ3ViaWNJbk91dFxufTtcblxuZnVuY3Rpb24gaW5oZXJpdChub2RlLCBpZCkge1xuICB2YXIgdGltaW5nO1xuICB3aGlsZSAoISh0aW1pbmcgPSBub2RlLl9fdHJhbnNpdGlvbikgfHwgISh0aW1pbmcgPSB0aW1pbmdbaWRdKSkge1xuICAgIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyYW5zaXRpb24gJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aW1pbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGlkLFxuICAgICAgdGltaW5nO1xuXG4gIGlmIChuYW1lIGluc3RhbmNlb2YgVHJhbnNpdGlvbikge1xuICAgIGlkID0gbmFtZS5faWQsIG5hbWUgPSBuYW1lLl9uYW1lO1xuICB9IGVsc2Uge1xuICAgIGlkID0gbmV3SWQoKSwgKHRpbWluZyA9IGRlZmF1bHRUaW1pbmcpLnRpbWUgPSBub3coKSwgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkLCBpLCBncm91cCwgdGltaW5nIHx8IGluaGVyaXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtU3ZnIGFzIGludGVycG9sYXRlVHJhbnNmb3JtfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7bmFtZXNwYWNlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgaW50ZXJwb2xhdGUgZnJvbSBcIi4vaW50ZXJwb2xhdGUuanNcIjtcblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSwgc3RyaW5nMTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCwgdmFsdWUxID0gdmFsdWUodGhpcyksIHN0cmluZzE7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKSwgaSA9IGZ1bGxuYW1lID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHRoaXMuYXR0clR3ZWVuKG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKShmdWxsbmFtZSwgaSwgdHdlZW5WYWx1ZSh0aGlzLCBcImF0dHIuXCIgKyBuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHZhbHVlID09IG51bGwgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKShmdWxsbmFtZSlcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKGZ1bGxuYW1lLCBpLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtuYW1lc3BhY2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxuZnVuY3Rpb24gYXR0ckludGVycG9sYXRlKG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBpLmNhbGwodGhpcywgdCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRySW50ZXJwb2xhdGVOUyhmdWxsbmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCBpLmNhbGwodGhpcywgdCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW5OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiBhdHRySW50ZXJwb2xhdGVOUyhmdWxsbmFtZSwgaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2VlbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIGF0dHJJbnRlcnBvbGF0ZShuYW1lLCBpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGtleSA9IFwiYXR0ci5cIiArIG5hbWU7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIChmdWxsbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBpbml0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBkZWxheUZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVsYXlDb25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBkZWxheUZ1bmN0aW9uXG4gICAgICAgICAgOiBkZWxheUNvbnN0YW50KShpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5kZWxheTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGR1cmF0aW9uRnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBkdXJhdGlvbkZ1bmN0aW9uXG4gICAgICAgICAgOiBkdXJhdGlvbkNvbnN0YW50KShpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5kdXJhdGlvbjtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGVhc2VDb25zdGFudChpZCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmVhc2UgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKGVhc2VDb25zdGFudChpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5lYXNlO1xufVxuIiwiaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGVhc2VWYXJ5aW5nKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0eXBlb2YgdiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gICAgc2V0KHRoaXMsIGlkKS5lYXNlID0gdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLmVhY2goZWFzZVZhcnlpbmcodGhpcy5faWQsIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge3NldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBvbjAsIG9uMSwgdGhhdCA9IHRoaXMsIGlkID0gdGhhdC5faWQsIHNpemUgPSB0aGF0LnNpemUoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBjYW5jZWwgPSB7dmFsdWU6IHJlamVjdH0sXG4gICAgICAgIGVuZCA9IHt2YWx1ZTogZnVuY3Rpb24oKSB7IGlmICgtLXNpemUgPT09IDApIHJlc29sdmUoKTsgfX07XG5cbiAgICB0aGF0LmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICAgIG9uID0gc2NoZWR1bGUub247XG5cbiAgICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgICBpZiAob24gIT09IG9uMCkge1xuICAgICAgICBvbjEgPSAob24wID0gb24pLmNvcHkoKTtcbiAgICAgICAgb24xLl8uY2FuY2VsLnB1c2goY2FuY2VsKTtcbiAgICAgICAgb24xLl8uaW50ZXJydXB0LnB1c2goY2FuY2VsKTtcbiAgICAgICAgb24xLl8uZW5kLnB1c2goZW5kKTtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGUub24gPSBvbjE7XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgc2VsZWN0aW9uIHdhcyBlbXB0eSwgcmVzb2x2ZSBlbmQgaW1tZWRpYXRlbHlcbiAgICBpZiAoc2l6ZSA9PT0gMCkgcmVzb2x2ZSgpO1xuICB9KTtcbn1cbiIsImltcG9ydCB7bWF0Y2hlcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB0cmFuc2l0aW9uX2F0dHIgZnJvbSBcIi4vYXR0ci5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fYXR0clR3ZWVuIGZyb20gXCIuL2F0dHJUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZGVsYXkgZnJvbSBcIi4vZGVsYXkuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2R1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lYXNlIGZyb20gXCIuL2Vhc2UuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2Vhc2VWYXJ5aW5nIGZyb20gXCIuL2Vhc2VWYXJ5aW5nLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9maWx0ZXIgZnJvbSBcIi4vZmlsdGVyLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fb24gZnJvbSBcIi4vb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3JlbW92ZSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3NlbGVjdCBmcm9tIFwiLi9zZWxlY3QuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGwuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3NlbGVjdGlvbiBmcm9tIFwiLi9zZWxlY3Rpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3N0eWxlIGZyb20gXCIuL3N0eWxlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zdHlsZVR3ZWVuIGZyb20gXCIuL3N0eWxlVHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RleHQgZnJvbSBcIi4vdGV4dC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdGV4dFR3ZWVuIGZyb20gXCIuL3RleHRUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdHJhbnNpdGlvbiBmcm9tIFwiLi90cmFuc2l0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90d2VlbiBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZW5kIGZyb20gXCIuL2VuZC5qc1wiO1xuXG52YXIgaWQgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gVHJhbnNpdGlvbihncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG4gIHRoaXMuX25hbWUgPSBuYW1lO1xuICB0aGlzLl9pZCA9IGlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2l0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHNlbGVjdGlvbigpLnRyYW5zaXRpb24obmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdJZCgpIHtcbiAgcmV0dXJuICsraWQ7XG59XG5cbnZhciBzZWxlY3Rpb25fcHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZTtcblxuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB0cmFuc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zaXRpb24sXG4gIHNlbGVjdDogdHJhbnNpdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogdHJhbnNpdGlvbl9zZWxlY3RBbGwsXG4gIHNlbGVjdENoaWxkOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNlbGVjdENoaWxkLFxuICBzZWxlY3RDaGlsZHJlbjogc2VsZWN0aW9uX3Byb3RvdHlwZS5zZWxlY3RDaGlsZHJlbixcbiAgZmlsdGVyOiB0cmFuc2l0aW9uX2ZpbHRlcixcbiAgbWVyZ2U6IHRyYW5zaXRpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogdHJhbnNpdGlvbl9zZWxlY3Rpb24sXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25fdHJhbnNpdGlvbixcbiAgY2FsbDogc2VsZWN0aW9uX3Byb3RvdHlwZS5jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fcHJvdG90eXBlLmVtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fcHJvdG90eXBlLmVhY2gsXG4gIG9uOiB0cmFuc2l0aW9uX29uLFxuICBhdHRyOiB0cmFuc2l0aW9uX2F0dHIsXG4gIGF0dHJUd2VlbjogdHJhbnNpdGlvbl9hdHRyVHdlZW4sXG4gIHN0eWxlOiB0cmFuc2l0aW9uX3N0eWxlLFxuICBzdHlsZVR3ZWVuOiB0cmFuc2l0aW9uX3N0eWxlVHdlZW4sXG4gIHRleHQ6IHRyYW5zaXRpb25fdGV4dCxcbiAgdGV4dFR3ZWVuOiB0cmFuc2l0aW9uX3RleHRUd2VlbixcbiAgcmVtb3ZlOiB0cmFuc2l0aW9uX3JlbW92ZSxcbiAgdHdlZW46IHRyYW5zaXRpb25fdHdlZW4sXG4gIGRlbGF5OiB0cmFuc2l0aW9uX2RlbGF5LFxuICBkdXJhdGlvbjogdHJhbnNpdGlvbl9kdXJhdGlvbixcbiAgZWFzZTogdHJhbnNpdGlvbl9lYXNlLFxuICBlYXNlVmFyeWluZzogdHJhbnNpdGlvbl9lYXNlVmFyeWluZyxcbiAgZW5kOiB0cmFuc2l0aW9uX2VuZCxcbiAgW1N5bWJvbC5pdGVyYXRvcl06IHNlbGVjdGlvbl9wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXVxufTtcbiIsImltcG9ydCB7Y29sb3J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZU51bWJlciwgaW50ZXJwb2xhdGVSZ2IsIGludGVycG9sYXRlU3RyaW5nfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYztcbiAgcmV0dXJuICh0eXBlb2YgYiA9PT0gXCJudW1iZXJcIiA/IGludGVycG9sYXRlTnVtYmVyXG4gICAgICA6IGIgaW5zdGFuY2VvZiBjb2xvciA/IGludGVycG9sYXRlUmdiXG4gICAgICA6IChjID0gY29sb3IoYikpID8gKGIgPSBjLCBpbnRlcnBvbGF0ZVJnYilcbiAgICAgIDogaW50ZXJwb2xhdGVTdHJpbmcpKGEsIGIpO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XG4gIGlmICh0cmFuc2l0aW9uLl9pZCAhPT0gdGhpcy5faWQpIHRocm93IG5ldyBFcnJvcjtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gdHJhbnNpdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0LCBpbml0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBzdGFydChuYW1lKSB7XG4gIHJldHVybiAobmFtZSArIFwiXCIpLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykuZXZlcnkoZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gIXQgfHwgdCA9PT0gXCJzdGFydFwiO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG9uMCwgb24xLCBzaXQgPSBzdGFydChuYW1lKSA/IGluaXQgOiBzZXQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzaXQodGhpcywgaWQpLFxuICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmIChvbiAhPT0gb24wKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKG5hbWUsIGxpc3RlbmVyKTtcblxuICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDJcbiAgICAgID8gZ2V0KHRoaXMubm9kZSgpLCBpZCkub24ub24obmFtZSlcbiAgICAgIDogdGhpcy5lYWNoKG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSk7XG59XG4iLCJmdW5jdGlvbiByZW1vdmVGdW5jdGlvbihpZCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuX190cmFuc2l0aW9uKSBpZiAoK2kgIT09IGlkKSByZXR1cm47XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub24oXCJlbmQucmVtb3ZlXCIsIHJlbW92ZUZ1bmN0aW9uKHRoaXMuX2lkKSk7XG59XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7dGltZXIsIHRpbWVvdXR9IGZyb20gXCJkMy10aW1lclwiO1xuXG52YXIgZW1wdHlPbiA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJlbmRcIiwgXCJjYW5jZWxcIiwgXCJpbnRlcnJ1cHRcIik7XG52YXIgZW1wdHlUd2VlbiA9IFtdO1xuXG5leHBvcnQgdmFyIENSRUFURUQgPSAwO1xuZXhwb3J0IHZhciBTQ0hFRFVMRUQgPSAxO1xuZXhwb3J0IHZhciBTVEFSVElORyA9IDI7XG5leHBvcnQgdmFyIFNUQVJURUQgPSAzO1xuZXhwb3J0IHZhciBSVU5OSU5HID0gNDtcbmV4cG9ydCB2YXIgRU5ESU5HID0gNTtcbmV4cG9ydCB2YXIgRU5ERUQgPSA2O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lLCBpZCwgaW5kZXgsIGdyb3VwLCB0aW1pbmcpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlcykgbm9kZS5fX3RyYW5zaXRpb24gPSB7fTtcbiAgZWxzZSBpZiAoaWQgaW4gc2NoZWR1bGVzKSByZXR1cm47XG4gIGNyZWF0ZShub2RlLCBpZCwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgaW5kZXg6IGluZGV4LCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgZ3JvdXA6IGdyb3VwLCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgb246IGVtcHR5T24sXG4gICAgdHdlZW46IGVtcHR5VHdlZW4sXG4gICAgdGltZTogdGltaW5nLnRpbWUsXG4gICAgZGVsYXk6IHRpbWluZy5kZWxheSxcbiAgICBkdXJhdGlvbjogdGltaW5nLmR1cmF0aW9uLFxuICAgIGVhc2U6IHRpbWluZy5lYXNlLFxuICAgIHRpbWVyOiBudWxsLFxuICAgIHN0YXRlOiBDUkVBVEVEXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBnZXQobm9kZSwgaWQpO1xuICBpZiAoc2NoZWR1bGUuc3RhdGUgPiBDUkVBVEVEKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBzY2hlZHVsZWRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBnZXQobm9kZSwgaWQpO1xuICBpZiAoc2NoZWR1bGUuc3RhdGUgPiBTVEFSVEVEKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBydW5uaW5nXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGUgfHwgIShzY2hlZHVsZSA9IHNjaGVkdWxlW2lkXSkpIHRocm93IG5ldyBFcnJvcihcInRyYW5zaXRpb24gbm90IGZvdW5kXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShub2RlLCBpZCwgc2VsZikge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICB0d2VlbjtcblxuICAvLyBJbml0aWFsaXplIHRoZSBzZWxmIHRpbWVyIHdoZW4gdGhlIHRyYW5zaXRpb24gaXMgY3JlYXRlZC5cbiAgLy8gTm90ZSB0aGUgYWN0dWFsIGRlbGF5IGlzIG5vdCBrbm93biB1bnRpbCB0aGUgZmlyc3QgY2FsbGJhY2shXG4gIHNjaGVkdWxlc1tpZF0gPSBzZWxmO1xuICBzZWxmLnRpbWVyID0gdGltZXIoc2NoZWR1bGUsIDAsIHNlbGYudGltZSk7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUoZWxhcHNlZCkge1xuICAgIHNlbGYuc3RhdGUgPSBTQ0hFRFVMRUQ7XG4gICAgc2VsZi50aW1lci5yZXN0YXJ0KHN0YXJ0LCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuXG4gICAgLy8gSWYgdGhlIGVsYXBzZWQgZGVsYXkgaXMgbGVzcyB0aGFuIG91ciBmaXJzdCBzbGVlcCwgc3RhcnQgaW1tZWRpYXRlbHkuXG4gICAgaWYgKHNlbGYuZGVsYXkgPD0gZWxhcHNlZCkgc3RhcnQoZWxhcHNlZCAtIHNlbGYuZGVsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnQoZWxhcHNlZCkge1xuICAgIHZhciBpLCBqLCBuLCBvO1xuXG4gICAgLy8gSWYgdGhlIHN0YXRlIGlzIG5vdCBTQ0hFRFVMRUQsIHRoZW4gd2UgcHJldmlvdXNseSBlcnJvcmVkIG9uIHN0YXJ0LlxuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTQ0hFRFVMRUQpIHJldHVybiBzdG9wKCk7XG5cbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBvID0gc2NoZWR1bGVzW2ldO1xuICAgICAgaWYgKG8ubmFtZSAhPT0gc2VsZi5uYW1lKSBjb250aW51ZTtcblxuICAgICAgLy8gV2hpbGUgdGhpcyBlbGVtZW50IGFscmVhZHkgaGFzIGEgc3RhcnRpbmcgdHJhbnNpdGlvbiBkdXJpbmcgdGhpcyBmcmFtZSxcbiAgICAgIC8vIGRlZmVyIHN0YXJ0aW5nIGFuIGludGVycnVwdGluZyB0cmFuc2l0aW9uIHVudGlsIHRoYXQgdHJhbnNpdGlvbiBoYXMgYVxuICAgICAgLy8gY2hhbmNlIHRvIHRpY2sgKGFuZCBwb3NzaWJseSBlbmQpOyBzZWUgZDMvZDMtdHJhbnNpdGlvbiM1NCFcbiAgICAgIGlmIChvLnN0YXRlID09PSBTVEFSVEVEKSByZXR1cm4gdGltZW91dChzdGFydCk7XG5cbiAgICAgIC8vIEludGVycnVwdCB0aGUgYWN0aXZlIHRyYW5zaXRpb24sIGlmIGFueS5cbiAgICAgIGlmIChvLnN0YXRlID09PSBSVU5OSU5HKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImludGVycnVwdFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FuY2VsIGFueSBwcmUtZW1wdGVkIHRyYW5zaXRpb25zLlxuICAgICAgZWxzZSBpZiAoK2kgPCBpZCkge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBvLm9uLmNhbGwoXCJjYW5jZWxcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmZXIgdGhlIGZpcnN0IHRpY2sgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGZyYW1lOyBzZWUgZDMvZDMjMTU3Ni5cbiAgICAvLyBOb3RlIHRoZSB0cmFuc2l0aW9uIG1heSBiZSBjYW5jZWxlZCBhZnRlciBzdGFydCBhbmQgYmVmb3JlIHRoZSBmaXJzdCB0aWNrIVxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIHNjaGVkdWxlZCBiZWZvcmUgdGhlIHN0YXJ0IGV2ZW50OyBzZWUgZDMvZDMtdHJhbnNpdGlvbiMxNiFcbiAgICAvLyBBc3N1bWluZyB0aGlzIGlzIHN1Y2Nlc3NmdWwsIHN1YnNlcXVlbnQgY2FsbGJhY2tzIGdvIHN0cmFpZ2h0IHRvIHRpY2suXG4gICAgdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBTVEFSVEVEKSB7XG4gICAgICAgIHNlbGYuc3RhdGUgPSBSVU5OSU5HO1xuICAgICAgICBzZWxmLnRpbWVyLnJlc3RhcnQodGljaywgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcbiAgICAgICAgdGljayhlbGFwc2VkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERpc3BhdGNoIHRoZSBzdGFydCBldmVudC5cbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBkb25lIGJlZm9yZSB0aGUgdHdlZW4gYXJlIGluaXRpYWxpemVkLlxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVElORztcbiAgICBzZWxmLm9uLmNhbGwoXCJzdGFydFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU1RBUlRJTkcpIHJldHVybjsgLy8gaW50ZXJydXB0ZWRcbiAgICBzZWxmLnN0YXRlID0gU1RBUlRFRDtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHR3ZWVuLCBkZWxldGluZyBudWxsIHR3ZWVuLlxuICAgIHR3ZWVuID0gbmV3IEFycmF5KG4gPSBzZWxmLnR3ZWVuLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgaiA9IC0xOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobyA9IHNlbGYudHdlZW5baV0udmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKSkge1xuICAgICAgICB0d2VlblsrK2pdID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgdHdlZW4ubGVuZ3RoID0gaiArIDE7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICB2YXIgdCA9IGVsYXBzZWQgPCBzZWxmLmR1cmF0aW9uID8gc2VsZi5lYXNlLmNhbGwobnVsbCwgZWxhcHNlZCAvIHNlbGYuZHVyYXRpb24pIDogKHNlbGYudGltZXIucmVzdGFydChzdG9wKSwgc2VsZi5zdGF0ZSA9IEVORElORywgMSksXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IHR3ZWVuLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICB0d2VlbltpXS5jYWxsKG5vZGUsIHQpO1xuICAgIH1cblxuICAgIC8vIERpc3BhdGNoIHRoZSBlbmQgZXZlbnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgPT09IEVORElORykge1xuICAgICAgc2VsZi5vbi5jYWxsKFwiZW5kXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgICAgc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgc2VsZi5zdGF0ZSA9IEVOREVEO1xuICAgIHNlbGYudGltZXIuc3RvcCgpO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaWRdO1xuICAgIGZvciAodmFyIGkgaW4gc2NoZWR1bGVzKSByZXR1cm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG4gIH1cbn1cbiIsImltcG9ydCB7c2VsZWN0b3J9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSwge2dldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkID0gdGhpcy5faWQ7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICAgIHNjaGVkdWxlKHN1Ymdyb3VwW2ldLCBuYW1lLCBpZCwgaSwgc3ViZ3JvdXAsIGdldChub2RlLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0b3JBbGx9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSwge2dldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkID0gdGhpcy5faWQ7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3JBbGwoc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBmb3IgKHZhciBjaGlsZHJlbiA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSwgY2hpbGQsIGluaGVyaXQgPSBnZXQobm9kZSwgaWQpLCBrID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgayA8IGw7ICsraykge1xuICAgICAgICAgIGlmIChjaGlsZCA9IGNoaWxkcmVuW2tdKSB7XG4gICAgICAgICAgICBzY2hlZHVsZShjaGlsZCwgbmFtZSwgaWQsIGssIGNoaWxkcmVuLCBpbmhlcml0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goY2hpbGRyZW4pO1xuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxudmFyIFNlbGVjdGlvbiA9IHNlbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3I7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9ncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyBhcyBpbnRlcnBvbGF0ZVRyYW5zZm9ybX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge3N0eWxlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge3NldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcbmltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCBpbnRlcnBvbGF0ZSBmcm9tIFwiLi9pbnRlcnBvbGF0ZS5qc1wiO1xuXG5mdW5jdGlvbiBzdHlsZU51bGwobmFtZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpLFxuICAgICAgICBzdHJpbmcxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIHN0eWxlKHRoaXMsIG5hbWUpKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgc3RyaW5nMTAgPSBzdHJpbmcxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpLFxuICAgICAgICB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSxcbiAgICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSBzdHJpbmcxID0gdmFsdWUxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIHN0eWxlKHRoaXMsIG5hbWUpKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlTWF5YmVSZW1vdmUoaWQsIG5hbWUpIHtcbiAgdmFyIG9uMCwgb24xLCBsaXN0ZW5lcjAsIGtleSA9IFwic3R5bGUuXCIgKyBuYW1lLCBldmVudCA9IFwiZW5kLlwiICsga2V5LCByZW1vdmU7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICBvbiA9IHNjaGVkdWxlLm9uLFxuICAgICAgICBsaXN0ZW5lciA9IHNjaGVkdWxlLnZhbHVlW2tleV0gPT0gbnVsbCA/IHJlbW92ZSB8fCAocmVtb3ZlID0gc3R5bGVSZW1vdmUobmFtZSkpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmIChvbiAhPT0gb24wIHx8IGxpc3RlbmVyMCAhPT0gbGlzdGVuZXIpIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24oZXZlbnQsIGxpc3RlbmVyMCA9IGxpc3RlbmVyKTtcblxuICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGkgPSAobmFtZSArPSBcIlwiKSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGludGVycG9sYXRlVHJhbnNmb3JtIDogaW50ZXJwb2xhdGU7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVOdWxsKG5hbWUsIGkpKVxuICAgICAgLm9uKFwiZW5kLnN0eWxlLlwiICsgbmFtZSwgc3R5bGVSZW1vdmUobmFtZSkpXG4gICAgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlRnVuY3Rpb24obmFtZSwgaSwgdHdlZW5WYWx1ZSh0aGlzLCBcInN0eWxlLlwiICsgbmFtZSwgdmFsdWUpKSlcbiAgICAgIC5lYWNoKHN0eWxlTWF5YmVSZW1vdmUodGhpcy5faWQsIG5hbWUpKVxuICAgIDogdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVDb25zdGFudChuYW1lLCBpLCB2YWx1ZSksIHByaW9yaXR5KVxuICAgICAgLm9uKFwiZW5kLnN0eWxlLlwiICsgbmFtZSwgbnVsbCk7XG59XG4iLCJmdW5jdGlvbiBzdHlsZUludGVycG9sYXRlKG5hbWUsIGksIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBpLmNhbGwodGhpcywgdCksIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIHQsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0ID0gKGkwID0gaSkgJiYgc3R5bGVJbnRlcnBvbGF0ZShuYW1lLCBpLCBwcmlvcml0eSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBrZXkgPSBcInN0eWxlLlwiICsgKG5hbWUgKz0gXCJcIik7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSk7XG59XG4iLCJpbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWUxID09IG51bGwgPyBcIlwiIDogdmFsdWUxO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdGhpcy50d2VlbihcInRleHRcIiwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gdGV4dEZ1bmN0aW9uKHR3ZWVuVmFsdWUodGhpcywgXCJ0ZXh0XCIsIHZhbHVlKSlcbiAgICAgIDogdGV4dENvbnN0YW50KHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiKSk7XG59XG4iLCJmdW5jdGlvbiB0ZXh0SW50ZXJwb2xhdGUoaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSBpLmNhbGwodGhpcywgdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRUd2Vlbih2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIHRleHRJbnRlcnBvbGF0ZShpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGtleSA9IFwidGV4dFwiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgdGV4dFR3ZWVuKHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb24sIG5ld0lkfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQwID0gdGhpcy5faWQsXG4gICAgICBpZDEgPSBuZXdJZCgpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHZhciBpbmhlcml0ID0gZ2V0KG5vZGUsIGlkMCk7XG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkMSwgaSwgZ3JvdXAsIHtcbiAgICAgICAgICB0aW1lOiBpbmhlcml0LnRpbWUgKyBpbmhlcml0LmRlbGF5ICsgaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBkZWxheTogMCxcbiAgICAgICAgICBkdXJhdGlvbjogaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBlYXNlOiBpbmhlcml0LmVhc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQxKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIHR3ZWVuUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSB0d2VlbjAgPSB0d2VlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjEgPSB0d2VlbjEuc2xpY2UoKTtcbiAgICAgICAgICB0d2VlbjEuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHR3ZWVuRnVuY3Rpb24oaWQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gKHR3ZWVuMCA9IHR3ZWVuKS5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgdCA9IHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9LCBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xW2ldID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPT09IG4pIHR3ZWVuMS5wdXNoKHQpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICBuYW1lICs9IFwiXCI7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIHR3ZWVuID0gZ2V0KHRoaXMubm9kZSgpLCBpZCkudHdlZW47XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2Vlbi5sZW5ndGgsIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodCA9IHR3ZWVuW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGwgPyB0d2VlblJlbW92ZSA6IHR3ZWVuRnVuY3Rpb24pKGlkLCBuYW1lLCB2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHdlZW5WYWx1ZSh0cmFuc2l0aW9uLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWQgPSB0cmFuc2l0aW9uLl9pZDtcblxuICB0cmFuc2l0aW9uLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKTtcbiAgICAoc2NoZWR1bGUudmFsdWUgfHwgKHNjaGVkdWxlLnZhbHVlID0ge30pKVtuYW1lXSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIGdldChub2RlLCBpZCkudmFsdWVbbmFtZV07XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+ICgpID0+IHg7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBab29tRXZlbnQodHlwZSwge1xuICBzb3VyY2VFdmVudCxcbiAgdGFyZ2V0LFxuICB0cmFuc2Zvcm0sXG4gIGRpc3BhdGNoXG59KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICB0eXBlOiB7dmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgc291cmNlRXZlbnQ6IHt2YWx1ZTogc291cmNlRXZlbnQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgdGFyZ2V0OiB7dmFsdWU6IHRhcmdldCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB0cmFuc2Zvcm06IHt2YWx1ZTogdHJhbnNmb3JtLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIF86IHt2YWx1ZTogZGlzcGF0Y2h9XG4gIH0pO1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIHpvb219IGZyb20gXCIuL3pvb20uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB6b29tVHJhbnNmb3JtLCBpZGVudGl0eSBhcyB6b29tSWRlbnRpdHksIFRyYW5zZm9ybSBhcyBab29tVHJhbnNmb3JtfSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbiIsImV4cG9ydCBmdW5jdGlvbiBub3Byb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm0oaywgeCwgeSkge1xuICB0aGlzLmsgPSBrO1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNmb3JtLFxuICBzY2FsZTogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrID09PSAxID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rICogaywgdGhpcy54LCB0aGlzLnkpO1xuICB9LFxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geCA9PT0gMCAmIHkgPT09IDAgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmssIHRoaXMueCArIHRoaXMuayAqIHgsIHRoaXMueSArIHRoaXMuayAqIHkpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gW3BvaW50WzBdICogdGhpcy5rICsgdGhpcy54LCBwb2ludFsxXSAqIHRoaXMuayArIHRoaXMueV07XG4gIH0sXG4gIGFwcGx5WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4ICogdGhpcy5rICsgdGhpcy54O1xuICB9LFxuICBhcHBseVk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geSAqIHRoaXMuayArIHRoaXMueTtcbiAgfSxcbiAgaW52ZXJ0OiBmdW5jdGlvbihsb2NhdGlvbikge1xuICAgIHJldHVybiBbKGxvY2F0aW9uWzBdIC0gdGhpcy54KSAvIHRoaXMuaywgKGxvY2F0aW9uWzFdIC0gdGhpcy55KSAvIHRoaXMua107XG4gIH0sXG4gIGludmVydFg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gKHggLSB0aGlzLngpIC8gdGhpcy5rO1xuICB9LFxuICBpbnZlcnRZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuICh5IC0gdGhpcy55KSAvIHRoaXMuaztcbiAgfSxcbiAgcmVzY2FsZVg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geC5jb3B5KCkuZG9tYWluKHgucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRYLCB0aGlzKS5tYXAoeC5pbnZlcnQsIHgpKTtcbiAgfSxcbiAgcmVzY2FsZVk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geS5jb3B5KCkuZG9tYWluKHkucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRZLCB0aGlzKS5tYXAoeS5pbnZlcnQsIHkpKTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHRoaXMueCArIFwiLFwiICsgdGhpcy55ICsgXCIpIHNjYWxlKFwiICsgdGhpcy5rICsgXCIpXCI7XG4gIH1cbn07XG5cbmV4cG9ydCB2YXIgaWRlbnRpdHkgPSBuZXcgVHJhbnNmb3JtKDEsIDAsIDApO1xuXG50cmFuc2Zvcm0ucHJvdG90eXBlID0gVHJhbnNmb3JtLnByb3RvdHlwZTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUpIHtcbiAgd2hpbGUgKCFub2RlLl9fem9vbSkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybiBpZGVudGl0eTtcbiAgcmV0dXJuIG5vZGUuX196b29tO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge2RyYWdEaXNhYmxlLCBkcmFnRW5hYmxlfSBmcm9tIFwiZDMtZHJhZ1wiO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZVpvb219IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtzZWxlY3QsIHBvaW50ZXJ9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7aW50ZXJydXB0fSBmcm9tIFwiZDMtdHJhbnNpdGlvblwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgWm9vbUV2ZW50IGZyb20gXCIuL2V2ZW50LmpzXCI7XG5pbXBvcnQge1RyYW5zZm9ybSwgaWRlbnRpdHl9IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuaW1wb3J0IG5vZXZlbnQsIHtub3Byb3BhZ2F0aW9ufSBmcm9tIFwiLi9ub2V2ZW50LmpzXCI7XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuLy8gZXhjZXB0IGZvciBwaW5jaC10by16b29tLCB3aGljaCBpcyBzZW50IGFzIGEgd2hlZWwrY3RybEtleSBldmVudFxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcihldmVudCkge1xuICByZXR1cm4gKCFldmVudC5jdHJsS2V5IHx8IGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpICYmICFldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRFeHRlbnQoKSB7XG4gIHZhciBlID0gdGhpcztcbiAgaWYgKGUgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgZSA9IGUub3duZXJTVkdFbGVtZW50IHx8IGU7XG4gICAgaWYgKGUuaGFzQXR0cmlidXRlKFwidmlld0JveFwiKSkge1xuICAgICAgZSA9IGUudmlld0JveC5iYXNlVmFsO1xuICAgICAgcmV0dXJuIFtbZS54LCBlLnldLCBbZS54ICsgZS53aWR0aCwgZS55ICsgZS5oZWlnaHRdXTtcbiAgICB9XG4gICAgcmV0dXJuIFtbMCwgMF0sIFtlLndpZHRoLmJhc2VWYWwudmFsdWUsIGUuaGVpZ2h0LmJhc2VWYWwudmFsdWVdXTtcbiAgfVxuICByZXR1cm4gW1swLCAwXSwgW2UuY2xpZW50V2lkdGgsIGUuY2xpZW50SGVpZ2h0XV07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUcmFuc2Zvcm0oKSB7XG4gIHJldHVybiB0aGlzLl9fem9vbSB8fCBpZGVudGl0eTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdoZWVsRGVsdGEoZXZlbnQpIHtcbiAgcmV0dXJuIC1ldmVudC5kZWx0YVkgKiAoZXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKiAoZXZlbnQuY3RybEtleSA/IDEwIDogMSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgKFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb25zdHJhaW4odHJhbnNmb3JtLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkge1xuICB2YXIgZHgwID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzBdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFswXVswXSxcbiAgICAgIGR4MSA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFsxXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMF0sXG4gICAgICBkeTAgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMF1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzFdLFxuICAgICAgZHkxID0gdHJhbnNmb3JtLmludmVydFkoZXh0ZW50WzFdWzFdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVsxXTtcbiAgcmV0dXJuIHRyYW5zZm9ybS50cmFuc2xhdGUoXG4gICAgZHgxID4gZHgwID8gKGR4MCArIGR4MSkgLyAyIDogTWF0aC5taW4oMCwgZHgwKSB8fCBNYXRoLm1heCgwLCBkeDEpLFxuICAgIGR5MSA+IGR5MCA/IChkeTAgKyBkeTEpIC8gMiA6IE1hdGgubWluKDAsIGR5MCkgfHwgTWF0aC5tYXgoMCwgZHkxKVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICBleHRlbnQgPSBkZWZhdWx0RXh0ZW50LFxuICAgICAgY29uc3RyYWluID0gZGVmYXVsdENvbnN0cmFpbixcbiAgICAgIHdoZWVsRGVsdGEgPSBkZWZhdWx0V2hlZWxEZWx0YSxcbiAgICAgIHRvdWNoYWJsZSA9IGRlZmF1bHRUb3VjaGFibGUsXG4gICAgICBzY2FsZUV4dGVudCA9IFswLCBJbmZpbml0eV0sXG4gICAgICB0cmFuc2xhdGVFeHRlbnQgPSBbWy1JbmZpbml0eSwgLUluZmluaXR5XSwgW0luZmluaXR5LCBJbmZpbml0eV1dLFxuICAgICAgZHVyYXRpb24gPSAyNTAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlWm9vbSxcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJ6b29tXCIsIFwiZW5kXCIpLFxuICAgICAgdG91Y2hzdGFydGluZyxcbiAgICAgIHRvdWNoZmlyc3QsXG4gICAgICB0b3VjaGVuZGluZyxcbiAgICAgIHRvdWNoRGVsYXkgPSA1MDAsXG4gICAgICB3aGVlbERlbGF5ID0gMTUwLFxuICAgICAgY2xpY2tEaXN0YW5jZTIgPSAwLFxuICAgICAgdGFwRGlzdGFuY2UgPSAxMDtcblxuICBmdW5jdGlvbiB6b29tKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvblxuICAgICAgICAucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSlcbiAgICAgICAgLm9uKFwid2hlZWwuem9vbVwiLCB3aGVlbGVkLCB7cGFzc2l2ZTogZmFsc2V9KVxuICAgICAgICAub24oXCJtb3VzZWRvd24uem9vbVwiLCBtb3VzZWRvd25lZClcbiAgICAgICAgLm9uKFwiZGJsY2xpY2suem9vbVwiLCBkYmxjbGlja2VkKVxuICAgICAgLmZpbHRlcih0b3VjaGFibGUpXG4gICAgICAgIC5vbihcInRvdWNoc3RhcnQuem9vbVwiLCB0b3VjaHN0YXJ0ZWQpXG4gICAgICAgIC5vbihcInRvdWNobW92ZS56b29tXCIsIHRvdWNobW92ZWQpXG4gICAgICAgIC5vbihcInRvdWNoZW5kLnpvb20gdG91Y2hjYW5jZWwuem9vbVwiLCB0b3VjaGVuZGVkKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgem9vbS50cmFuc2Zvcm0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCB0cmFuc2Zvcm0sIHBvaW50LCBldmVudCkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBjb2xsZWN0aW9uLnNlbGVjdGlvbiA/IGNvbGxlY3Rpb24uc2VsZWN0aW9uKCkgOiBjb2xsZWN0aW9uO1xuICAgIHNlbGVjdGlvbi5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKTtcbiAgICBpZiAoY29sbGVjdGlvbiAhPT0gc2VsZWN0aW9uKSB7XG4gICAgICBzY2hlZHVsZShjb2xsZWN0aW9uLCB0cmFuc2Zvcm0sIHBvaW50LCBldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5pbnRlcnJ1cHQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAuZXZlbnQoZXZlbnQpXG4gICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICAuem9vbShudWxsLCB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRyYW5zZm9ybSlcbiAgICAgICAgICAuZW5kKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgem9vbS5zY2FsZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBrLCBwLCBldmVudCkge1xuICAgIHpvb20uc2NhbGVUbyhzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGswID0gdGhpcy5fX3pvb20uayxcbiAgICAgICAgICBrMSA9IHR5cGVvZiBrID09PSBcImZ1bmN0aW9uXCIgPyBrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrO1xuICAgICAgcmV0dXJuIGswICogazE7XG4gICAgfSwgcCwgZXZlbnQpO1xuICB9O1xuXG4gIHpvb20uc2NhbGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgaywgcCwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0MCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcCxcbiAgICAgICAgICBwMSA9IHQwLmludmVydChwMCksXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCwgZXZlbnQpO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24sIHgsIHksIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW4odGhpcy5fX3pvb20udHJhbnNsYXRlKFxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHlcbiAgICAgICksIGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0sIG51bGwsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZVRvID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5LCBwLCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgICBwMCA9IHAgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHAgPT09IFwiZnVuY3Rpb25cIiA/IHAuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHA7XG4gICAgICByZXR1cm4gY29uc3RyYWluKGlkZW50aXR5LnRyYW5zbGF0ZShwMFswXSwgcDBbMV0pLnNjYWxlKHQuaykudHJhbnNsYXRlKFxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8gLXguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IC14LFxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8gLXkuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IC15XG4gICAgICApLCBlLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICBmdW5jdGlvbiBzY2FsZSh0cmFuc2Zvcm0sIGspIHtcbiAgICBrID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCBrKSk7XG4gICAgcmV0dXJuIGsgPT09IHRyYW5zZm9ybS5rID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybShrLCB0cmFuc2Zvcm0ueCwgdHJhbnNmb3JtLnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHRyYW5zZm9ybSwgcDAsIHAxKSB7XG4gICAgdmFyIHggPSBwMFswXSAtIHAxWzBdICogdHJhbnNmb3JtLmssIHkgPSBwMFsxXSAtIHAxWzFdICogdHJhbnNmb3JtLms7XG4gICAgcmV0dXJuIHggPT09IHRyYW5zZm9ybS54ICYmIHkgPT09IHRyYW5zZm9ybS55ID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybSh0cmFuc2Zvcm0uaywgeCwgeSk7XG4gIH1cblxuICBmdW5jdGlvbiBjZW50cm9pZChleHRlbnQpIHtcbiAgICByZXR1cm4gWygrZXh0ZW50WzBdWzBdICsgK2V4dGVudFsxXVswXSkgLyAyLCAoK2V4dGVudFswXVsxXSArICtleHRlbnRbMV1bMV0pIC8gMl07XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZSh0cmFuc2l0aW9uLCB0cmFuc2Zvcm0sIHBvaW50LCBldmVudCkge1xuICAgIHRyYW5zaXRpb25cbiAgICAgICAgLm9uKFwic3RhcnQuem9vbVwiLCBmdW5jdGlvbigpIHsgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLmV2ZW50KGV2ZW50KS5zdGFydCgpOyB9KVxuICAgICAgICAub24oXCJpbnRlcnJ1cHQuem9vbSBlbmQuem9vbVwiLCBmdW5jdGlvbigpIHsgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLmV2ZW50KGV2ZW50KS5lbmQoKTsgfSlcbiAgICAgICAgLnR3ZWVuKFwiem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGcgPSBnZXN0dXJlKHRoYXQsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgICAgICAgZSA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKSxcbiAgICAgICAgICAgICAgcCA9IHBvaW50ID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwb2ludCA9PT0gXCJmdW5jdGlvblwiID8gcG9pbnQuYXBwbHkodGhhdCwgYXJncykgOiBwb2ludCxcbiAgICAgICAgICAgICAgdyA9IE1hdGgubWF4KGVbMV1bMF0gLSBlWzBdWzBdLCBlWzFdWzFdIC0gZVswXVsxXSksXG4gICAgICAgICAgICAgIGEgPSB0aGF0Ll9fem9vbSxcbiAgICAgICAgICAgICAgYiA9IHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIiA/IHRyYW5zZm9ybS5hcHBseSh0aGF0LCBhcmdzKSA6IHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgaSA9IGludGVycG9sYXRlKGEuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYS5rKSwgYi5pbnZlcnQocCkuY29uY2F0KHcgLyBiLmspKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgaWYgKHQgPT09IDEpIHQgPSBiOyAvLyBBdm9pZCByb3VuZGluZyBlcnJvciBvbiBlbmQuXG4gICAgICAgICAgICBlbHNlIHsgdmFyIGwgPSBpKHQpLCBrID0gdyAvIGxbMl07IHQgPSBuZXcgVHJhbnNmb3JtKGssIHBbMF0gLSBsWzBdICogaywgcFsxXSAtIGxbMV0gKiBrKTsgfVxuICAgICAgICAgICAgZy56b29tKG51bGwsIHQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VzdHVyZSh0aGF0LCBhcmdzLCBjbGVhbikge1xuICAgIHJldHVybiAoIWNsZWFuICYmIHRoYXQuX196b29taW5nKSB8fCBuZXcgR2VzdHVyZSh0aGF0LCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEdlc3R1cmUodGhhdCwgYXJncykge1xuICAgIHRoaXMudGhhdCA9IHRoYXQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgdGhpcy5zb3VyY2VFdmVudCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyk7XG4gICAgdGhpcy50YXBzID0gMDtcbiAgfVxuXG4gIEdlc3R1cmUucHJvdG90eXBlID0ge1xuICAgIGV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGV2ZW50KSB0aGlzLnNvdXJjZUV2ZW50ID0gZXZlbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgrK3RoaXMuYWN0aXZlID09PSAxKSB7XG4gICAgICAgIHRoaXMudGhhdC5fX3pvb21pbmcgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgem9vbTogZnVuY3Rpb24oa2V5LCB0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICh0aGlzLm1vdXNlICYmIGtleSAhPT0gXCJtb3VzZVwiKSB0aGlzLm1vdXNlWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLm1vdXNlWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMCAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDBbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMudG91Y2gwWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMSAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDFbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMudG91Y2gxWzBdKTtcbiAgICAgIHRoaXMudGhhdC5fX3pvb20gPSB0cmFuc2Zvcm07XG4gICAgICB0aGlzLmVtaXQoXCJ6b29tXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGhhdC5fX3pvb21pbmc7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgdmFyIGQgPSBzZWxlY3QodGhpcy50aGF0KS5kYXR1bSgpO1xuICAgICAgbGlzdGVuZXJzLmNhbGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRoaXMudGhhdCxcbiAgICAgICAgbmV3IFpvb21FdmVudCh0eXBlLCB7XG4gICAgICAgICAgc291cmNlRXZlbnQ6IHRoaXMuc291cmNlRXZlbnQsXG4gICAgICAgICAgdGFyZ2V0OiB6b29tLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnRoYXQuX196b29tLFxuICAgICAgICAgIGRpc3BhdGNoOiBsaXN0ZW5lcnNcbiAgICAgICAgfSksXG4gICAgICAgIGRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHdoZWVsZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICBrID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCB0LmsgKiBNYXRoLnBvdygyLCB3aGVlbERlbHRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSksXG4gICAgICAgIHAgPSBwb2ludGVyKGV2ZW50KTtcblxuICAgIC8vIElmIHRoZSBtb3VzZSBpcyBpbiB0aGUgc2FtZSBsb2NhdGlvbiBhcyBiZWZvcmUsIHJldXNlIGl0LlxuICAgIC8vIElmIHRoZXJlIHdlcmUgcmVjZW50IHdoZWVsIGV2ZW50cywgcmVzZXQgdGhlIHdoZWVsIGlkbGUgdGltZW91dC5cbiAgICBpZiAoZy53aGVlbCkge1xuICAgICAgaWYgKGcubW91c2VbMF1bMF0gIT09IHBbMF0gfHwgZy5tb3VzZVswXVsxXSAhPT0gcFsxXSkge1xuICAgICAgICBnLm1vdXNlWzFdID0gdC5pbnZlcnQoZy5tb3VzZVswXSA9IHApO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KGcud2hlZWwpO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2hlZWwgZXZlbnQgd29u4oCZdCB0cmlnZ2VyIGEgdHJhbnNmb3JtIGNoYW5nZSwgaWdub3JlIGl0LlxuICAgIGVsc2UgaWYgKHQuayA9PT0gaykgcmV0dXJuO1xuXG4gICAgLy8gT3RoZXJ3aXNlLCBjYXB0dXJlIHRoZSBtb3VzZSBwb2ludCBhbmQgbG9jYXRpb24gYXQgdGhlIHN0YXJ0LlxuICAgIGVsc2Uge1xuICAgICAgZy5tb3VzZSA9IFtwLCB0LmludmVydChwKV07XG4gICAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgbm9ldmVudChldmVudCk7XG4gICAgZy53aGVlbCA9IHNldFRpbWVvdXQod2hlZWxpZGxlZCwgd2hlZWxEZWxheSk7XG4gICAgZy56b29tKFwibW91c2VcIiwgY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0LCBrKSwgZy5tb3VzZVswXSwgZy5tb3VzZVsxXSksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcblxuICAgIGZ1bmN0aW9uIHdoZWVsaWRsZWQoKSB7XG4gICAgICBnLndoZWVsID0gbnVsbDtcbiAgICAgIGcuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vkb3duZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAodG91Y2hlbmRpbmcgfHwgIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzLCB0cnVlKS5ldmVudChldmVudCksXG4gICAgICAgIHYgPSBzZWxlY3QoZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuem9vbVwiLCBtb3VzZW1vdmVkLCB0cnVlKS5vbihcIm1vdXNldXAuem9vbVwiLCBtb3VzZXVwcGVkLCB0cnVlKSxcbiAgICAgICAgcCA9IHBvaW50ZXIoZXZlbnQsIGN1cnJlbnRUYXJnZXQpLFxuICAgICAgICB4MCA9IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHkwID0gZXZlbnQuY2xpZW50WTtcblxuICAgIGRyYWdEaXNhYmxlKGV2ZW50LnZpZXcpO1xuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGcubW91c2UgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApXTtcbiAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgZy5zdGFydCgpO1xuXG4gICAgZnVuY3Rpb24gbW91c2Vtb3ZlZChldmVudCkge1xuICAgICAgbm9ldmVudChldmVudCk7XG4gICAgICBpZiAoIWcubW92ZWQpIHtcbiAgICAgICAgdmFyIGR4ID0gZXZlbnQuY2xpZW50WCAtIHgwLCBkeSA9IGV2ZW50LmNsaWVudFkgLSB5MDtcbiAgICAgICAgZy5tb3ZlZCA9IGR4ICogZHggKyBkeSAqIGR5ID4gY2xpY2tEaXN0YW5jZTI7XG4gICAgICB9XG4gICAgICBnLmV2ZW50KGV2ZW50KVxuICAgICAgIC56b29tKFwibW91c2VcIiwgY29uc3RyYWluKHRyYW5zbGF0ZShnLnRoYXQuX196b29tLCBnLm1vdXNlWzBdID0gcG9pbnRlcihldmVudCwgY3VycmVudFRhcmdldCksIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cHBlZChldmVudCkge1xuICAgICAgdi5vbihcIm1vdXNlbW92ZS56b29tIG1vdXNldXAuem9vbVwiLCBudWxsKTtcbiAgICAgIGRyYWdFbmFibGUoZXZlbnQudmlldywgZy5tb3ZlZCk7XG4gICAgICBub2V2ZW50KGV2ZW50KTtcbiAgICAgIGcuZXZlbnQoZXZlbnQpLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRibGNsaWNrZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgIHAwID0gcG9pbnRlcihldmVudC5jaGFuZ2VkVG91Y2hlcyA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQsIHRoaXMpLFxuICAgICAgICBwMSA9IHQwLmludmVydChwMCksXG4gICAgICAgIGsxID0gdDAuayAqIChldmVudC5zaGlmdEtleSA/IDAuNSA6IDIpLFxuICAgICAgICB0MSA9IGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodDAsIGsxKSwgcDAsIHAxKSwgZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3MpLCB0cmFuc2xhdGVFeHRlbnQpO1xuXG4gICAgbm9ldmVudChldmVudCk7XG4gICAgaWYgKGR1cmF0aW9uID4gMCkgc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuY2FsbChzY2hlZHVsZSwgdDEsIHAwLCBldmVudCk7XG4gICAgZWxzZSBzZWxlY3QodGhpcykuY2FsbCh6b29tLnRyYW5zZm9ybSwgdDEsIHAwLCBldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsXG4gICAgICAgIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MsIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA9PT0gbikuZXZlbnQoZXZlbnQpLFxuICAgICAgICBzdGFydGVkLCBpLCB0LCBwO1xuXG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV0sIHAgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgcCA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCksIHQuaWRlbnRpZmllcl07XG4gICAgICBpZiAoIWcudG91Y2gwKSBnLnRvdWNoMCA9IHAsIHN0YXJ0ZWQgPSB0cnVlLCBnLnRhcHMgPSAxICsgISF0b3VjaHN0YXJ0aW5nO1xuICAgICAgZWxzZSBpZiAoIWcudG91Y2gxICYmIGcudG91Y2gwWzJdICE9PSBwWzJdKSBnLnRvdWNoMSA9IHAsIGcudGFwcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRvdWNoc3RhcnRpbmcpIHRvdWNoc3RhcnRpbmcgPSBjbGVhclRpbWVvdXQodG91Y2hzdGFydGluZyk7XG5cbiAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgaWYgKGcudGFwcyA8IDIpIHRvdWNoZmlyc3QgPSBwWzBdLCB0b3VjaHN0YXJ0aW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hzdGFydGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgICAgaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuX196b29taW5nKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIHQsIHAsIGw7XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDBbMF0gPSBwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDFbMF0gPSBwO1xuICAgIH1cbiAgICB0ID0gZy50aGF0Ll9fem9vbTtcbiAgICBpZiAoZy50b3VjaDEpIHtcbiAgICAgIHZhciBwMCA9IGcudG91Y2gwWzBdLCBsMCA9IGcudG91Y2gwWzFdLFxuICAgICAgICAgIHAxID0gZy50b3VjaDFbMF0sIGwxID0gZy50b3VjaDFbMV0sXG4gICAgICAgICAgZHAgPSAoZHAgPSBwMVswXSAtIHAwWzBdKSAqIGRwICsgKGRwID0gcDFbMV0gLSBwMFsxXSkgKiBkcCxcbiAgICAgICAgICBkbCA9IChkbCA9IGwxWzBdIC0gbDBbMF0pICogZGwgKyAoZGwgPSBsMVsxXSAtIGwwWzFdKSAqIGRsO1xuICAgICAgdCA9IHNjYWxlKHQsIE1hdGguc3FydChkcCAvIGRsKSk7XG4gICAgICBwID0gWyhwMFswXSArIHAxWzBdKSAvIDIsIChwMFsxXSArIHAxWzFdKSAvIDJdO1xuICAgICAgbCA9IFsobDBbMF0gKyBsMVswXSkgLyAyLCAobDBbMV0gKyBsMVsxXSkgLyAyXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZy50b3VjaDApIHAgPSBnLnRvdWNoMFswXSwgbCA9IGcudG91Y2gwWzFdO1xuICAgIGVsc2UgcmV0dXJuO1xuXG4gICAgZy56b29tKFwidG91Y2hcIiwgY29uc3RyYWluKHRyYW5zbGF0ZSh0LCBwLCBsKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fX3pvb21pbmcpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdDtcblxuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcbiAgICB0b3VjaGVuZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoZW5kaW5nID0gbnVsbDsgfSwgdG91Y2hEZWxheSk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV07XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZGVsZXRlIGcudG91Y2gwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZGVsZXRlIGcudG91Y2gxO1xuICAgIH1cbiAgICBpZiAoZy50b3VjaDEgJiYgIWcudG91Y2gwKSBnLnRvdWNoMCA9IGcudG91Y2gxLCBkZWxldGUgZy50b3VjaDE7XG4gICAgaWYgKGcudG91Y2gwKSBnLnRvdWNoMFsxXSA9IHRoaXMuX196b29tLmludmVydChnLnRvdWNoMFswXSk7XG4gICAgZWxzZSB7XG4gICAgICBnLmVuZCgpO1xuICAgICAgLy8gSWYgdGhpcyB3YXMgYSBkYmx0YXAsIHJlcm91dGUgdG8gdGhlIChvcHRpb25hbCkgZGJsY2xpY2suem9vbSBoYW5kbGVyLlxuICAgICAgaWYgKGcudGFwcyA9PT0gMikge1xuICAgICAgICB0ID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgICAgaWYgKE1hdGguaHlwb3QodG91Y2hmaXJzdFswXSAtIHRbMF0sIHRvdWNoZmlyc3RbMV0gLSB0WzFdKSA8IHRhcERpc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIHAgPSBzZWxlY3QodGhpcykub24oXCJkYmxjbGljay56b29tXCIpO1xuICAgICAgICAgIGlmIChwKSBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB6b29tLndoZWVsRGVsdGEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAod2hlZWxEZWx0YSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB6b29tKSA6IHdoZWVsRGVsdGE7XG4gIH07XG5cbiAgem9vbS5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCB6b29tKSA6IGZpbHRlcjtcbiAgfTtcblxuICB6b29tLnRvdWNoYWJsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0b3VjaGFibGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIHpvb20pIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIHpvb20uZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0pLCB6b29tKSA6IGV4dGVudDtcbiAgfTtcblxuICB6b29tLnNjYWxlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlRXh0ZW50WzBdID0gK19bMF0sIHNjYWxlRXh0ZW50WzFdID0gK19bMV0sIHpvb20pIDogW3NjYWxlRXh0ZW50WzBdLCBzY2FsZUV4dGVudFsxXV07XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNsYXRlRXh0ZW50WzBdWzBdID0gK19bMF1bMF0sIHRyYW5zbGF0ZUV4dGVudFsxXVswXSA9ICtfWzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV0gPSArX1swXVsxXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzFdID0gK19bMV1bMV0sIHpvb20pIDogW1t0cmFuc2xhdGVFeHRlbnRbMF1bMF0sIHRyYW5zbGF0ZUV4dGVudFswXVsxXV0sIFt0cmFuc2xhdGVFeHRlbnRbMV1bMF0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXV1dO1xuICB9O1xuXG4gIHpvb20uY29uc3RyYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnN0cmFpbiA9IF8sIHpvb20pIDogY29uc3RyYWluO1xuICB9O1xuXG4gIHpvb20uZHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHVyYXRpb24gPSArXywgem9vbSkgOiBkdXJhdGlvbjtcbiAgfTtcblxuICB6b29tLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgem9vbSkgOiBpbnRlcnBvbGF0ZTtcbiAgfTtcblxuICB6b29tLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IHpvb20gOiB2YWx1ZTtcbiAgfTtcblxuICB6b29tLmNsaWNrRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xpY2tEaXN0YW5jZTIgPSAoXyA9ICtfKSAqIF8sIHpvb20pIDogTWF0aC5zcXJ0KGNsaWNrRGlzdGFuY2UyKTtcbiAgfTtcblxuICB6b29tLnRhcERpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcERpc3RhbmNlID0gK18sIHpvb20pIDogdGFwRGlzdGFuY2U7XG4gIH07XG5cbiAgcmV0dXJuIHpvb207XG59XG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXG5cbi8qKlxuICogUGFyZW50IGNsYXNzIGZvciBidXR0b24gZWxlbWVudHMgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBncmlkdml6IHZpZXdlci5cbiAqXG4gKiBAbW9kdWxlIGJ1dHRvblxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgQnV0dG9uIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIG9wdHMucGFyZW50Tm9kZVxuICAgICAqIG9wdHMuaWRcbiAgICAgKiBvcHRzLnRpdGxlXG4gICAgICogb3B0cy5jbGFzc1xuICAgICAqIG9wdHMub25DbGlja0Z1bmN0aW9uXG4gICAgICogb3B0cy54XG4gICAgICogb3B0cy55XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG5cbiAgICAgICAgdGhpcy5tYXAgPSBvcHRzLm1hcFxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBvcHRzLnBhcmVudE5vZGUgfHwgb3B0cy5tYXAuY29udGFpbmVyXG5cbiAgICAgICAgLy8gdGhlIGRpdiBlbGVtZW50XG4gICAgICAgIGlmICh0aGlzLmlkKSB0aGlzLmRpdiA9IHNlbGVjdCgnIycgKyB0aGlzLmlkKVxuXG4gICAgICAgIGlmICghdGhpcy5kaXYgfHwgdGhpcy5kaXYuZW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5kaXYgPSBzZWxlY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICAgICBpZiAodGhpcy5pZCkgdGhpcy5kaXYuYXR0cignaWQnLCB0aGlzLmlkKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMudGl0bGUpIHRoaXMuZGl2LmF0dHIoJ3RpdGxlJywgb3B0cy50aXRsZSlcbiAgICAgICAgaWYgKG9wdHMuY2xhc3MpIHRoaXMuZGl2LmF0dHIoJ2NsYXNzJywgb3B0cy5jbGFzcylcblxuICAgICAgICAvLyBhZGQgZXZlbnRzXG4gICAgICAgIGlmIChvcHRzLm9uQ2xpY2tGdW5jdGlvbikgdGhpcy5kaXYub24oJ2NsaWNrJywgb3B0cy5vbkNsaWNrRnVuY3Rpb24pXG5cbiAgICAgICAgLy9zZXQgc3R5bGVzXG4gICAgICAgIHRoaXMuc3R5bGUoJ2JveC1zaGFkb3cnLCAnMCA3cHggOHB4IHJnYmEoMCw0NywxMDMsLjA4KSwgMCAwIDIycHggcmdiYSgwLDQ3LDEwMywuMDQpLCAwIDEycHggMTdweCByZ2JhKDAsNDcsMTAzLC4wNCksIDAgLTRweCA0cHggcmdiYSgwLDQ3LDEwMywuMDQpJykgLy8uZWNsLXUtc2hhZG93LTNcbiAgICAgICAgdGhpcy5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsICcjZmZmZmZmJylcbiAgICAgICAgdGhpcy5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxuICAgICAgICB0aGlzLnN0eWxlKCdjdXJzb3InLCAncG9pbnRlcicpXG4gICAgICAgIHRoaXMuc3R5bGUoJ2Rpc3BsYXknLCAnZmxleCcpXG4gICAgICAgIHRoaXMuc3R5bGUoJ2p1c3RpZnktY29udGVudCcsICdjZW50ZXInKVxuICAgICAgICB0aGlzLnN0eWxlKCdhbGlnbi1pdGVtcycsICdjZW50ZXInKVxuICAgICAgICB0aGlzLnN0eWxlKCd3aWR0aCcsICczMHB4JylcbiAgICAgICAgdGhpcy5zdHlsZSgnaGVpZ2h0JywgJzMwcHgnKVxuICAgICAgICAvLyB0aGlzLnN0eWxlKHBhZGRpbmcgLCAnNHB4J1xuXG5cbiAgICAgICAgLy8gYXBwZW5kIHRvIHBhcmVudFxuICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5kaXYubm9kZSgpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgc3R5bGUgdG8gdGhlIGJ1dHRvbiBkaXYuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0eWxlKGssIHYpIHtcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUoaywgdilcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBCdXR0b24gfSBmcm9tICcuL0J1dHRvbi5qcydcblxuLyoqXG4gKiBCdXR0b24gZm9yIHRvZ2dsaW5nIGZ1bGxzY3JlZW4gbW9kZVxuICpcbiAqIEBtb2R1bGUgYnV0dG9uXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBGdWxsc2NyZWVuQnV0dG9uIGV4dGVuZHMgQnV0dG9uIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIG9wdHMucGFyZW50Tm9kZSAtIHRoZSBub2RlIHRoYXQgdGhlIGJ1dHRvbiBpcyBhcHBlbmRlZCB0b1xuICAgICAqIG9wdHMuY2FudmFzIC0gdGhlIGdyaWR2aXogY2FudmFzXG4gICAgICogb3B0cy5pZFxuICAgICAqIG9wdHMudGl0bGUgLSBIVE1MIHRpdGxlIGF0dHJpYnV0ZVxuICAgICAqIG9wdHMuY2xhc3MgLSBjc3MgY2xhc3NcbiAgICAgKiBvcHRzLm9uQ2xpY2tGdW5jdGlvblxuICAgICAqIG9wdHMueCAtIHggcG9zaXRpb24gb2YgdGhlIGJ1dHRvblxuICAgICAqIG9wdHMueSAtIHkgcG9zaXRpb24gb2YgdGhlIGJ1dHRvblxuICAgICAqL1xuXG4gICAgLy8gZGVmYXVsdCBzdGF0ZVxuICAgIGlzRnVsbHNjcmVlbiA9IGZhbHNlXG5cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG5cbiAgICAgICAgLy8gYXBwZW5kIGZ1bGxzY3JlZW4gaWNvbiB0byBidXR0b24gY29udGFpbmVyXG4gICAgICAgIHRoaXMuZGl2Lm5vZGUoKS5pbm5lckhUTUwgPSBgXG4gICAgICAgIDxzdmdcbiAgICAgICAgICAgIHN0eWxlPVwiaGVpZ2h0OiAxLjJyZW07IHdpZHRoOiAxLjJyZW07IGZpbGw6YmxhY2s7IG1hcmdpbjowO1wiXG4gICAgICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8c3ZnIGZpbGw9XCIjMDAwMDAwXCIgdmlld0JveD1cIjAgMCA5NiA5NlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgICAgIDx0aXRsZS8+XG4gICAgICAgICAgICA8Zz5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMzAsMEg2QTUuOTk2Niw1Ljk5NjYsMCwwLDAsMCw2VjMwYTYsNiwwLDAsMCwxMiwwVjEySDMwQTYsNiwwLDAsMCwzMCwwWlwiLz5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNOTAsMEg2NmE2LDYsMCwwLDAsMCwxMkg4NFYzMGE2LDYsMCwwLDAsMTIsMFY2QTUuOTk2Niw1Ljk5NjYsMCwwLDAsOTAsMFpcIi8+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTMwLDg0SDEyVjY2QTYsNiwwLDAsMCwwLDY2VjkwYTUuOTk2Niw1Ljk5NjYsMCwwLDAsNiw2SDMwYTYsNiwwLDAsMCwwLTEyWlwiLz5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNOTAsNjBhNS45OTY2LDUuOTk2NiwwLDAsMC02LDZWODRINjZhNiw2LDAsMCwwLDAsMTJIOTBhNS45OTY2LDUuOTk2NiwwLDAsMCw2LTZWNjZBNS45OTY2LDUuOTk2NiwwLDAsMCw5MCw2MFpcIi8+XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9zdmc+XG4gICAgICAgIGBcblxuICAgICAgICAvL3NhdmUgaW5pdGlhbCBtYXAgZGltZW5zaW9uc1xuICAgICAgICB0aGlzLmRlZmF1bHRIZWlnaHQgPSB0aGlzLm1hcC5oXG4gICAgICAgIHRoaXMuZGVmYXVsdFdpZHRoID0gdGhpcy5tYXAud1xuXG4gICAgICAgIC8vIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgdGhpcy5kaXYub24oJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DbGlja0Z1bmN0aW9uKGUpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuZGl2Lm9uKCdtb3VzZW92ZXInLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsICdsaWdodGdyZXknKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLmRpdi5vbignbW91c2VvdXQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsICcjZmZmZmZmJylcbiAgICAgICAgfSlcblxuICAgICAgICAvL3NldCBwb3NpdGlvblxuICAgICAgICBpZiAob3B0cy54KSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKCdsZWZ0Jywgb3B0cy54ICsgJ3B4JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ3JpZ2h0JywgJzEwcHgnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnkpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ3RvcCcsIG9wdHMueSArICdweCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKCd0b3AnLCAnOTBweCcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNsaWNrRnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGdWxsc2NyZWVuKHRoaXMubWFwLmNvbnRhaW5lcilcbiAgICAgICAgICAgIC8vcmVzaXplIGNhbnZhcyB0byBkZWZhdWx0XG4gICAgICAgICAgICB0aGlzLm1hcC5oID0gdGhpcy5kZWZhdWx0SGVpZ2h0XG4gICAgICAgICAgICB0aGlzLm1hcC53ID0gdGhpcy5kZWZhdWx0V2lkdGhcbiAgICAgICAgICAgIHRoaXMubWFwLmdlb0NhbnZhcy5oID0gdGhpcy5kZWZhdWx0SGVpZ2h0XG4gICAgICAgICAgICB0aGlzLm1hcC5nZW9DYW52YXMudyA9IHRoaXMuZGVmYXVsdFdpZHRoXG4gICAgICAgICAgICB0aGlzLm1hcC5nZW9DYW52YXMuY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnJyArIHRoaXMuZGVmYXVsdFdpZHRoKVxuICAgICAgICAgICAgdGhpcy5tYXAuZ2VvQ2FudmFzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcnICsgdGhpcy5kZWZhdWx0SGVpZ2h0KVxuICAgICAgICAgICAgdGhpcy5tYXAucmVkcmF3KClcbiAgICAgICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkZ1bGxzY3JlZW4odGhpcy5tYXAuY29udGFpbmVyKVxuICAgICAgICAgICAgLy9yZXNpemUgY2FudmFzIHRvIGZ1bGxzY3JlZW5cbiAgICAgICAgICAgIHRoaXMubWFwLmggPSB3aW5kb3cuc2NyZWVuLmhlaWdodFxuICAgICAgICAgICAgdGhpcy5tYXAudyA9IHdpbmRvdy5zY3JlZW4ud2lkdGhcbiAgICAgICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogT3BlbiBmdWxsc2NyZWVuICovXG4gICAgb3BlbkZ1bGxzY3JlZW4oZWxlbSkge1xuICAgICAgICBpZiAoZWxlbS5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgZWxlbS5yZXF1ZXN0RnVsbHNjcmVlbigpXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgLyogU2FmYXJpICovXG4gICAgICAgICAgICBlbGVtLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtLm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIC8qIElFMTEgKi9cbiAgICAgICAgICAgIGVsZW0ubXNSZXF1ZXN0RnVsbHNjcmVlbigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBDbG9zZSBmdWxsc2NyZWVuICovXG4gICAgY2xvc2VGdWxsc2NyZWVuKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKClcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgLyogU2FmYXJpICovXG4gICAgICAgICAgICBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpXG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgLyogSUUxMSAqL1xuICAgICAgICAgICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBCdXR0b24gfSBmcm9tICcuL0J1dHRvbi5qcydcblxuLyoqXG4gKiBCdXR0b24gZm9yIHRvZ2dsaW5nIGZ1bGxzY3JlZW4gbW9kZVxuICpcbiAqIEBtb2R1bGUgYnV0dG9uXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBab29tQnV0dG9ucyBleHRlbmRzIEJ1dHRvbiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG5cbiAgICAgICAgdGhpcy5vblpvb20gPSBvcHRzLm9uWm9vbSAvLyBjdXN0b20gdXNlciBldmVudCBoYW5kbGVyXG4gICAgICAgIHRoaXMuZGVsdGEgPSBvcHRzLmRlbHRhIHx8IDAuMlxuXG4gICAgICAgIC8vIHpvb20gaW4gYnRuXG4gICAgICAgIHRoaXMuem9vbUluQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICAgIHRoaXMuem9vbUluQnRuLmlubmVySFRNTCA9IGA8YSBpZD1cInpvb21pblwiIGNsYXNzPVwiZ3JpZHZpei16b29tLWJ1dHRvblwiIHRpdGxlPVwiWm9vbSBpblwiPis8L2E+YFxuICAgICAgICB0aGlzLnpvb21JbkJ0bi50aXRsZSA9ICdab29tIGluJ1xuICAgICAgICB0aGlzLnpvb21JbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnpvb21JbihlKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnpvb21JbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy56b29tSW5CdG4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2xpZ2h0Z3JleSdcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy56b29tSW5CdG4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy56b29tSW5CdG4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmZmZmZmYnXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gem9vbSBvdXQgYnRuXG4gICAgICAgIHRoaXMuem9vbU91dEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICB0aGlzLnpvb21PdXRCdG4uaW5uZXJIVE1MID0gYDxhIGlkPVwiem9vbWluXCIgY2xhc3M9XCJncmlkdml6LXpvb20tYnV0dG9uXCIgdGl0bGU9XCJab29tIG91dFwiPi08L2E+YFxuICAgICAgICB0aGlzLnpvb21PdXRCdG4udGl0bGUgPSAnWm9vbSBvdXQnXG4gICAgICAgIHRoaXMuem9vbU91dEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnpvb21PdXQoZSlcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy56b29tT3V0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnpvb21PdXRCdG4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2xpZ2h0Z3JleSdcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy56b29tT3V0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuem9vbU91dEJ0bi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZmZmZidcbiAgICAgICAgfSlcblxuICAgICAgICAvL3NldCBzdHlsZXNcbiAgICAgICAgbGV0IGJ0bnMgPSBbdGhpcy56b29tSW5CdG4sIHRoaXMuem9vbU91dEJ0bl1cbiAgICAgICAgYnRucy5mb3JFYWNoKChidG4sIGkpID0+IHtcbiAgICAgICAgICAgIGJ0bi5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcidcbiAgICAgICAgICAgIGJ0bi5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdjZW50ZXInXG4gICAgICAgICAgICBidG4uc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xuICAgICAgICAgICAgYnRuLnN0eWxlLmJvcmRlciA9ICdub25lJ1xuICAgICAgICAgICAgYnRuLnN0eWxlLmNvbG9yID0gJ2JsYWNrJ1xuICAgICAgICAgICAgYnRuLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInXG4gICAgICAgICAgICBidG4uc3R5bGUudGV4dERlY29yYXRpb24gPSAnbm9uZSdcbiAgICAgICAgICAgIGJ0bi5zdHlsZS5wYWRkaW5nID0gJzRweCdcbiAgICAgICAgICAgIGJ0bi5zdHlsZS5mb250U2l6ZSA9ICcyMHB4J1xuICAgICAgICAgICAgYnRuLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCdcbiAgICAgICAgICAgIGJ0bi5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnXG4gICAgICAgICAgICBpZiAoaSA9PSAwKSBidG4uc3R5bGUuYm9yZGVyQm90dG9tID0gJzFweCBzb2xpZCBncmV5J1xuICAgICAgICB9KVxuXG4gICAgICAgIC8vIHVuc2V0IHBhcmVudCBjbGFzcyBoZWlnaHQgYW5kIGRpc3BsYXkgZm9yIGR1YWwgYnV0dG9uc1xuICAgICAgICB0aGlzLnN0eWxlKCdoZWlnaHQnLCAndW5zZXQnKVxuICAgICAgICB0aGlzLnN0eWxlKCdkaXNwbGF5JywgJ3Vuc2V0JylcblxuICAgICAgICAvL3NldCBwb3NpdGlvblxuICAgICAgICBpZiAob3B0cy54KSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKCdsZWZ0Jywgb3B0cy54ICsgJ3B4JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ3JpZ2h0JywgJzEwcHgnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnkpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ3RvcCcsIG9wdHMueSArICdweCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKCd0b3AnLCAnMTBweCcpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBlbmQgdG8gYnV0dG9uIGNvbnRhaW5lclxuICAgICAgICB0aGlzLmRpdi5ub2RlKCkuYXBwZW5kQ2hpbGQodGhpcy56b29tSW5CdG4pXG4gICAgICAgIHRoaXMuZGl2Lm5vZGUoKS5hcHBlbmRDaGlsZCh0aGlzLnpvb21PdXRCdG4pXG4gICAgfVxuXG4gICAgLyogWm9vbSBpbiAqL1xuICAgIHpvb21JbihlKSB7XG4gICAgICAgIHRoaXMubWFwLnNldFpvb20odGhpcy5tYXAuZ2V0Wm9vbSgpICogKDEgLSB0aGlzLmRlbHRhKSkucmVkcmF3KClcbiAgICAgICAgaWYgKHRoaXMub25ab29tKSB0aGlzLm9uWm9vbShlKVxuICAgIH1cblxuICAgIC8qIFpvb20gb3V0ICovXG4gICAgem9vbU91dChlKSB7XG4gICAgICAgIHRoaXMubWFwLnNldFpvb20odGhpcy5tYXAuZ2V0Wm9vbSgpICogKDEgKyB0aGlzLmRlbHRhKSkucmVkcmF3KClcbiAgICAgICAgaWYgKHRoaXMub25ab29tKSB0aGlzLm9uWm9vbShlKVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBBIGdyaWQgY2VsbC5cbiAqIEB0eXBlZGVmIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBDZWxsICovXG5cbi8qKlxuICogQSBkYXRhc2V0IGNvbXBvbmVudCwgb2YgZ3JpZCBjZWxscy5cbiAqIEBhYnN0cmFjdFxuICpcbiAqIEBtb2R1bGUgY29yZVxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgRGF0YXNldCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL01hcC5qc1wiKS5NYXB9IG1hcCBUaGUgbWFwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgZGF0YXNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBUaGUgZGF0YXNldCByZXNvbHV0aW9uLCBpbiB0aGUgQ1JTIGdlb2dyYXBoaWNhbCB1bml0LlxuICAgICAqIEBwYXJhbSB7e3ByZXByb2Nlc3M/OmZ1bmN0aW9uKENlbGwpOmJvb2xlYW4sIG1peGVkUmVzb2x1dGlvbj86ZnVuY3Rpb24oQ2VsbCk6bnVtYmVyfX0gb3B0c1xuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hcCwgdXJsLCByZXNvbHV0aW9uLCBvcHRzID0ge30pIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1hcC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9NYXAuanNcIikuTWFwfSAqL1xuICAgICAgICB0aGlzLm1hcCA9IG1hcFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXJsIG9mIHRoZSBkYXRhc2V0LlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMudXJsID0gdXJsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRhc2V0IHJlc29sdXRpb24gaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvblxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEluIGNhc2UgdGhlIGRhdGFzZXQgaXMgYSBkYXRhc2V0IHdpdGggY2VsbHMgaGF2aW5nIGRpZmZlcmVudCByZXNvbHV0aW9uLFxuICAgICAgICAqIHRoaXMgaXMgdGhlIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgcmVzb2x1dGlvbiBvZiBlYWNoIGNlbGwuXG4gICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAqIEB0eXBlIHsoZnVuY3Rpb24oQ2VsbCk6bnVtYmVyICl8IHVuZGVmaW5lZCB9ICovXG4gICAgICAgIHRoaXMubWl4ZWRSZXNvbHV0aW9uID0gb3B0cy5taXhlZFJlc29sdXRpb25cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBwcmVwcm9jZXNzIHRvIHJ1biBvbiBlYWNoIGNlbGwgYWZ0ZXIgbG9hZGluZy4gSXQgY2FuIGJlIHVzZWQgdG8gYXBwbHkgc29tZSBzcGVjaWZpYyB0cmVhdG1lbnQgYmVmb3JlIG9yIGNvbXB1dGUgYSBuZXcgY29sdW1uLiBBbmQgYWxzbyB0byBkZXRlcm1pbmUgd2hpY2ggY2VsbHMgdG8ga2VlcCBhZnRlciBsb2FkaW5nLlxuICAgICAgICAgKiBAdHlwZSB7KGZ1bmN0aW9uKENlbGwpOmJvb2xlYW4gKXwgdW5kZWZpbmVkIH0gKi9cbiAgICAgICAgdGhpcy5wcmVwcm9jZXNzID0gb3B0cy5wcmVwcm9jZXNzIHx8IHVuZGVmaW5lZFxuXG4gICAgICAgIC8qKiBUaGUgY2VsbHMgd2l0aGluIHRoZSB2aWV3XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxDZWxsPn0gKi9cbiAgICAgICAgdGhpcy5jZWxsc1ZpZXdDYWNoZSA9IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBkYXRhIHdpdGhpbiBhIGdlb2dyYXBoaWMgZW52ZWxvcGUuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvQ2FudmFzXCIpLkVudmVsb3BlfHVuZGVmaW5lZH0gZXh0R2VvXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgZ2V0RGF0YShleHRHZW8gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgZ2V0RGF0YSBub3QgaW1wbGVtZW50ZWQuJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxsIHRoZSB2aWV3IGNhY2hlIHdpdGggYWxsIGNlbGxzIHdoaWNoIGFyZSB3aXRoaW4gYSBnZW9ncmFwaGljYWwgZW52ZWxvcGUuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb0NhbnZhc1wiKS5FbnZlbG9wZX0gZXh0R2VvIFRoZSB2aWV3IGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVWaWV3Q2FjaGUoZXh0R2VvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIHVwZGF0ZVZpZXdDYWNoZSBub3QgaW1wbGVtZW50ZWQuJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBjZWxsIHVuZGVyIGEgZ2l2ZW4gcG9zaXRpb24sIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gcG9zR2VvXG4gICAgICogQHBhcmFtIHtBcnJheS48Q2VsbD59IGNlbGxzIFNvbWUgY2VsbHMgZnJvbSB0aGUgZGF0YXNldCAoYSBzdWJzZXQgaWYgbmVjZXNzYXJ5LCB1c3VhbGx5IHRoZSB2aWV3IGNhY2hlKS5cbiAgICAgKiBAcmV0dXJucyB7Q2VsbHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0Q2VsbEZyb21Qb3NpdGlvbihwb3NHZW8sIGNlbGxzKSB7XG4gICAgICAgIC8vY29tcHV0ZSBjYW5kaWRhdGUgY2VsbCBwb3NpdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgLy9jb25zdCByID0gdGhpcy5nZXRSZXNvbHV0aW9uKClcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIC8vY29uc3QgY2VsbFggPSByICogTWF0aC5mbG9vcihwb3NHZW8ueCAvIHIpXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAvL2NvbnN0IGNlbGxZID0gciAqIE1hdGguZmxvb3IocG9zR2VvLnkgLyByKVxuXG4gICAgICAgIC8qL2dldCBjZWxsXG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiBjZWxscykge1xuICAgICAgICAgICAgaWYgKGNlbGwueCAhPSBjZWxsWCkgY29udGludWVcbiAgICAgICAgICAgIGlmIChjZWxsLnkgIT0gY2VsbFkpIGNvbnRpbnVlXG4gICAgICAgICAgICByZXR1cm4gY2VsbFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQqL1xuXG4gICAgICAgIC8vcmFyZSBjYXNlIG9mIG1peGVkIHJlc29sdXRpb24gZGF0YXNldFxuICAgICAgICBpZiAodGhpcy5taXhlZFJlc29sdXRpb24pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBjZWxscykge1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLm1peGVkUmVzb2x1dGlvbihjKVxuICAgICAgICAgICAgICAgIGlmIChwb3NHZW8ueCA8IGMueCkgY29udGludWVcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjLnggKyByIDwgcG9zR2VvLngpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocG9zR2VvLnkgPCBjLnkpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYy55ICsgciA8IHBvc0dlby55KSBjb250aW51ZVxuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29tbW9uIGNhc2VcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgY29uc3QgciA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpXG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiBjZWxscykge1xuICAgICAgICAgICAgaWYgKHBvc0dlby54IDwgY2VsbC54KSBjb250aW51ZVxuICAgICAgICAgICAgZWxzZSBpZiAoY2VsbC54ICsgciA8IHBvc0dlby54KSBjb250aW51ZVxuICAgICAgICAgICAgZWxzZSBpZiAocG9zR2VvLnkgPCBjZWxsLnkpIGNvbnRpbnVlXG4gICAgICAgICAgICBlbHNlIGlmIChjZWxsLnkgKyByIDwgcG9zR2VvLnkpIGNvbnRpbnVlXG4gICAgICAgICAgICBlbHNlIHJldHVybiBjZWxsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuXG4gICAgfVxuXG4gICAgLy9nZXR0ZXJzIGFuZCBzZXR0ZXJzXG5cbiAgICAvKiogQHJldHVybnMge251bWJlcn0gKi9cbiAgICBnZXRSZXNvbHV0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uXG4gICAgfVxuXG4gICAgLyoqIEByZXR1cm5zIHtBcnJheS48Q2VsbD59ICovXG4gICAgZ2V0Vmlld0NhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsc1ZpZXdDYWNoZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcmVsZXZhbnQgZGF0YXNldCBmb3IgYSBzcGVjaWZpZWQgem9vbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gelxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5QaXhlbHNQZXJDZWxsXG4gICAgICogQHJldHVybnMge0RhdGFzZXR8dW5kZWZpbmVkfVxuICAgICAqICovXG4gICAgZ2V0RGF0YXNldCh6LCBtaW5QaXhlbHNQZXJDZWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogVGhpcyBpcyBhbiBhYnN0cmFjdCBjbGFzcyB1c2VkIHRvIGdyb3VwIGVsZW1lbnRzIHNoYXJlZCBiZXR3ZWVuIExheWVyIGFuZCBTdHlsZSBjbGFzc2VzLlxuICogXG4gKiBAYWJzdHJhY3RcbiAqIEBtb2R1bGUgY29yZVxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgRHJhd2FibGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHNwZWNpZnlpbmcgaWYgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIHZpc2libGUgb3Igbm90LlxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gcGFyYW1ldGVyIGlzIHRoZSB6b29tIGxldmVsLlxuICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIpOmJvb2xlYW59ICovXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IG9wdHMudmlzaWJsZVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgYWxwaGEgKHRyYW5zcGFyZW5jeS9vcGFjaXR5KSwgYmV0d2VlbiAwLjAgKGZ1bGx5IHRyYW5zcGFyZW50KSBhbmQgMS4wIChmdWxseSBvcGFxdWUpLlxuICAgICAgICAgKiAgVGhlIGZ1bmN0aW9uIHBhcmFtZXRlciBpcyB0aGUgem9vbSBsZXZlbC5cbiAgICAgICAgICogKHNlZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ6IGdsb2JhbEFscGhhIHByb3BlcnR5KVxuICAgICAgICAgKiBAdHlwZSB7KGZ1bmN0aW9uKG51bWJlcik6bnVtYmVyKXx1bmRlZmluZWR9ICovXG4gICAgICAgIHRoaXMuYWxwaGEgPSBvcHRzLmFscGhhXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBibGVuZCBvcGVyYXRpb24uXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBwYXJhbWV0ZXIgaXMgdGhlIHpvb20gbGV2ZWwuXG4gICAgICAgICAqIChzZWUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gcHJvcGVydHkpXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIpOkdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbn0gKi9cbiAgICAgICAgdGhpcy5ibGVuZE9wZXJhdGlvbiA9IG9wdHMuYmxlbmRPcGVyYXRpb24gfHwgKHogPT4gXCJzb3VyY2Utb3ZlclwiKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7KGZ1bmN0aW9uKG51bWJlcik6c3RyaW5nKXx1bmRlZmluZWR9ICovXG4gICAgICAgIHRoaXMuZmlsdGVyQ29sb3IgPSBvcHRzLmZpbHRlckNvbG9yIC8vICh6KSA9PiBcIiNlZWU3XCJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGxheWVyIGZpbHRlci5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGUgbGF5ZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgZHJhd0ZpbHRlcihnZW9DYW52YXMpIHtcbiAgICAgICAgLy9ubyBmaWx0ZXI6IHJldHVyblxuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyQ29sb3IpIHJldHVyblxuXG4gICAgICAgIC8vZ2V0IGZpbHRlclxuICAgICAgICBjb25zdCBmYyA9IHRoaXMuZmlsdGVyQ29sb3IoZ2VvQ2FudmFzLnZpZXcueilcblxuICAgICAgICAvL25vIGZpbHRlcjogcmV0dXJuXG4gICAgICAgIGlmICghZmMgfHwgZmMgPT0gJ25vbmUnKSByZXR1cm5cblxuICAgICAgICAvL2RyYXcgZmlsdGVyXG4gICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbFN0eWxlID0gZmNcbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsUmVjdCgwLCAwLCBnZW9DYW52YXMudywgZ2VvQ2FudmFzLmgpXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7IHt4TWluOiBudW1iZXIsIHhNYXg6IG51bWJlciwgeU1pbjogbnVtYmVyLCB5TWF4OiBudW1iZXJ9IH0gRW52ZWxvcGUgKi9cblxuLyoqXG4gKiBBIHZpZXdzaGVkLlxuICogQHR5cGVkZWYge3t4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyfX0gVmlldyAqL1xuXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXG5pbXBvcnQgeyB6b29tIGFzIGQzem9vbSwgem9vbUlkZW50aXR5IH0gZnJvbSAnZDMtem9vbSdcblxuLyoqXG4gKiBBIEhUTUwgY2FudmFzIGZvciBnZW8gZGF0YSBkaXNwbGF5LCBlbmhhbmNlZCB3aXRoIHpvb20gYW5kIHBhbiBjYXBhYmlsaXRpZXMuXG4gKlxuICogQG1vZHVsZSBjb3JlXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBHZW9DYW52YXMge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHZpZXdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSB2aWV3XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHogVGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXcgKHBpeGVsIHNpemUsIGluIGdyb3VuZCBtKVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FudmFzLCB4ID0gMCwgeSA9IDAsIHogPSAwLCBvcHRzID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqL1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhc1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gdGhpcy5jYW52YXMub2Zmc2V0SGVpZ2h0XG5cbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oXG5cbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICBpZiAoIWN0eCkgdGhyb3cgJ0ltcG9zc2libGUgdG8gY3JlYXRlIGNhbnZhcyAyRCBjb250ZXh0J1xuICAgICAgICAvKipAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqL1xuICAgICAgICB0aGlzLmN0eCA9IGN0eFxuXG4gICAgICAgIC8qKiBcbiAgICAgICAgICogejogcGl4ZWwgc2l6ZSwgaW4gbS9waXhcbiAgICAgICAgICogQHR5cGUge1ZpZXd9ICAqL1xuICAgICAgICB0aGlzLnZpZXcgPSB7IHg6IHgsIHk6IHksIHo6IHogfVxuXG4gICAgICAgIC8qKiBCYWNrZ3JvdW5kIGNvbG9yLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yIHx8ICd3aGl0ZSdcblxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKG9iamVjdHx1bmRlZmluZWQpOnZvaWR9ICovXG4gICAgICAgIHRoaXMub25ab29tU3RhcnRGdW4gPSBvcHRzLm9uWm9vbVN0YXJ0RnVuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihvYmplY3R8dW5kZWZpbmVkKTp2b2lkfSAqL1xuICAgICAgICB0aGlzLm9uWm9vbUVuZEZ1biA9IG9wdHMub25ab29tRW5kRnVuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihvYmplY3R8dW5kZWZpbmVkKTp2b2lkfSAqL1xuICAgICAgICB0aGlzLm9uWm9vbUZ1biA9IG9wdHMub25ab29tRnVuXG5cbiAgICAgICAgLy9jdXJyZW50IGV4dGVudFxuICAgICAgICAvKiogQHR5cGUge0VudmVsb3BlfSAqL1xuICAgICAgICB0aGlzLmV4dEdlbyA9IHsgeE1pbjogTmFOLCB4TWF4OiBOYU4sIHlNaW46IE5hTiwgeU1heDogTmFOIH1cbiAgICAgICAgdGhpcy51cGRhdGVFeHRlbnRHZW8oKVxuXG4gICAgICAgIC8vcmVseSBvbiBkMyB6b29tIGZvciBwYW4vem9vbVxuICAgICAgICBpZiAoIW9wdHMuZGlzYWJsZVpvb20pIHtcbiAgICAgICAgICAgIGxldCB0UCA9IHpvb21JZGVudGl0eVxuICAgICAgICAgICAgY29uc3QgeiA9IGQzem9vbSgpXG4gICAgICAgICAgICAgICAgLy90byBtYWtlIHRoZSB6b29taW5nIGEgYml0IGZhc3RlclxuICAgICAgICAgICAgICAgIC53aGVlbERlbHRhKChlKSA9PiAtZS5kZWx0YVkgKiAoZS5kZWx0YU1vZGUgPT09IDEgPyAwLjA3IDogZS5kZWx0YU1vZGUgPyAxIDogMC4wMDQpKVxuICAgICAgICAgICAgICAgIC5vbignem9vbScsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlLnRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmID0gdFAuayAvIHQua1xuICAgICAgICAgICAgICAgICAgICBpZiAoZiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHggPSB0UC54IC0gdC54XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkeSA9IHRQLnkgLSB0LnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFuKGR4ICogdGhpcy52aWV3LnosIC1keSAqIHRoaXMudmlldy56KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2UgPSBlLnNvdXJjZUV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2UgaW5zdGFuY2VvZiBXaGVlbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy96b29tIGF0IHRoZSBtb3VzZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waXhUb0dlb1goZS5zb3VyY2VFdmVudC5vZmZzZXRYKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waXhUb0dlb1koZS5zb3VyY2VFdmVudC5vZmZzZXRZKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2UgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wdXRlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIHRvdWNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHggPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eSA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0dCBvZiBzZS50YXJnZXRUb3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4ICs9IHR0LmNsaWVudFhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHkgKz0gdHQuY2xpZW50WVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eCAvPSBzZS50YXJnZXRUb3VjaGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5IC89IHNlLnRhcmdldFRvdWNoZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy96b29tIGF0IHRoaXMgYXZlcmFnZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbShmLCB0aGlzLnBpeFRvR2VvWCh0eCksIHRoaXMucGl4VG9HZW9ZKHR5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0UCA9IHRcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vblpvb21GdW4pIHRoaXMub25ab29tRnVuKGUpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ3N0YXJ0JywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuYy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJycgKyB0aGlzLncpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuYy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcnICsgdGhpcy5oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmMuZ2V0Q29udGV4dCgnMmQnKT8uZHJhd0ltYWdlKHRoaXMuY2FudmFzLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmYgPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uWm9vbVN0YXJ0RnVuKSB0aGlzLm9uWm9vbVN0YXJ0RnVuKGUpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkcmF3KClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlID0geyBjOiBudWxsLCBkeDogMCwgZHk6IDAsIGY6IDEgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uWm9vbUVuZEZ1bikgdGhpcy5vblpvb21FbmRGdW4oZSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgeihzZWxlY3QodGhpcy5jYW52YXMpKVxuICAgICAgICB9XG4gICAgICAgIC8vc2VsZWN0KHRoaXMuY2FudmFzKS5jYWxsKHopO1xuXG4gICAgICAgIC8qKiBab29tIGV4dGVudCwgdG8gbGltaXQgem9vbSBpbiBhbmQgb3V0XG4gICAgICAgICAqICBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXG4gICAgICAgIHRoaXMuem9vbUV4dGVudCA9IG9wdHMuem9vbUV4dGVudCB8fCBbMCwgSW5maW5pdHldXG5cbiAgICAgICAgLyoqIENhbnZhcyBzdGF0ZSwgdG8gYmUgdXNlZCB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZWRyYXdzIG9uIHpvb20vcGFuXG4gICAgICAgICAqICBAdHlwZSB7e2M6SFRNTENhbnZhc0VsZW1lbnR8bnVsbCxkeDpudW1iZXIsZHk6bnVtYmVyLGY6bnVtYmVyfX0gKi9cbiAgICAgICAgdGhpcy5jYW52YXNTYXZlID0geyBjOiBudWxsLCBkeDogMCwgZHk6IDAsIGY6IDEgfVxuICAgIH1cblxuICAgIC8qKiBAcmV0dXJucyB7Vmlld30gKi9cbiAgICBnZXRWaWV3KCkgeyByZXR1cm4gdGhpcy52aWV3IH1cblxuXG4gICAgLyoqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHYgKi9cbiAgICBzZXRab29tRXh0ZW50KHYpIHtcbiAgICAgICAgdGhpcy56b29tRXh0ZW50ID0gdlxuICAgIH1cbiAgICAvKiogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAqL1xuICAgIGdldFpvb21FeHRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvb21FeHRlbnRcbiAgICB9XG5cbiAgICAvKiogSW5pdGlhbGlzZSBjYW52YXMgdHJhbnNmb3JtIHdpdGggaWRlbnRpdHkgdHJhbnNmb3JtYXRpb24uICovXG4gICAgaW5pdENhbnZhc1RyYW5zZm9ybSgpIHtcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXG4gICAgfVxuXG4gICAgLyoqIEluaXRpYWxpc2UgY2FudmFzIHRyYW5zZm9ybSB3aXRoIGdlbyB0byBzY3JlZW4gdHJhbnNmb3JtYXRpb24sIHNvIHRoYXQgZ2VvIG9iamVjdHMgY2FuIGJlIGRyYXduIGRpcmVjdGx5IGluIGdlbyBjb29yZGluYXRlcy4gKi9cbiAgICBzZXRDYW52YXNUcmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC8gdGhpcy52aWV3LnpcbiAgICAgICAgY29uc3QgdHggPSAtdGhpcy52aWV3LnggLyB0aGlzLnZpZXcueiArIHRoaXMudyAqIDAuNVxuICAgICAgICBjb25zdCB0eSA9IHRoaXMudmlldy55IC8gdGhpcy52aWV3LnogKyB0aGlzLmggKiAwLjVcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKGssIDAsIDAsIC1rLCB0eCwgdHkpXG4gICAgfVxuXG4gICAgLyoqIEdldCB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIHdlYkdMIHNjcmVlbiBjb29yZGluYXRlcywgd2l0aGluIFstMSwxXSpbLTEsMV0gKi9cbiAgICBnZXRXZWJHTFRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3Qga3ggPSAyLjAgLyAodGhpcy53ICogdGhpcy52aWV3LnopXG4gICAgICAgIGNvbnN0IGt5ID0gMi4wIC8gKHRoaXMuaCAqIHRoaXMudmlldy56KVxuICAgICAgICByZXR1cm4gW2t4LCAwLjAsIDAuMCwgMC4wLCBreSwgMC4wLCAta3ggKiB0aGlzLnZpZXcueCwgLWt5ICogdGhpcy52aWV3LnksIDEuMF1cbiAgICB9XG5cbiAgICAvKiogVGhlIGZ1bmN0aW9uIHNwZWNpZnlpbmcgaG93IHRvIGRyYXcgdGhlIG1hcC4gKi9cbiAgICByZWRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIHJlZHJhdyBub3QgaW1wbGVtZW50ZWQuJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhci4gVG8gYmUgdXNlZCBiZWZvcmUgYSByZWRyYXcgZm9yIGV4YW1wbGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICovXG4gICAgY2xlYXIoY29sb3IgPSAnd2hpdGUnKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMudHJhbnNwYXJlbnRCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53LCB0aGlzLmgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdHgpIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yXG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeEdlb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeUdlb1xuICAgICAqL1xuICAgIHBhbihkeEdlbyA9IDAsIGR5R2VvID0gMCkge1xuICAgICAgICAvL1RPRE8gZm9yY2UgZXh0ZW5kIHRvIHJlbWFpblxuICAgICAgICB0aGlzLnZpZXcueCArPSBkeEdlb1xuICAgICAgICB0aGlzLnZpZXcueSArPSBkeUdlb1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXG5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzU2F2ZS5jKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHggLT0gZHhHZW8gLyB0aGlzLnZpZXcuelxuICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmR5ICs9IGR5R2VvIC8gdGhpcy52aWV3LnpcbiAgICAgICAgICAgIHRoaXMuY2xlYXIodGhpcy5iYWNrZ3JvdW5kQ29sb3IpXG4gICAgICAgICAgICAvLyB0aGlzIGRvZXNudCB3b3JrIG9uIG1vYmlsZSBodHRwczovL2dpdGh1Yi5jb20vZXVyb3N0YXQvZ3JpZHZpei9pc3N1ZXMvOThcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhc1NhdmUuYywgdGhpcy5jYW52YXNTYXZlLmR4LCB0aGlzLmNhbnZhc1NhdmUuZHkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBab29tLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmIFRoZSAsIHdpdGhpbiBdMCwgSW5maW5pdHldLiAxIGlzIGZvciBubyBjaGFuZ2UuIDwxIHRvIHpvb20taW4sID4xIHRvIHpvb20tb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4R2VvIFRoZSB4IGdlbyBwb3NpdGlvbiBmaXhlZCBpbiB0aGUgc2NyZWVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5R2VvIFRoZSB5IGdlbyBwb3NpdGlvbiBmaXhlZCBpbiB0aGUgc2NyZWVuLlxuICAgICAqL1xuICAgIHpvb20oZiA9IDEsIHhHZW8gPSB0aGlzLnZpZXcueCwgeUdlbyA9IHRoaXMudmlldy55KSB7XG4gICAgICAgIC8vVE9ETyBmb3JjZSBnZW8gZXh0ZW5kIHRvIHJlbWFpblxuXG4gICAgICAgIC8vdHJ5aW5nIHRvIHpvb20gaW4vb3V0IGJleW9uZCBsaW1pdFxuICAgICAgICBpZiAodGhpcy56b29tRXh0ZW50WzBdID09IHRoaXMudmlldy56ICYmIGYgPD0gMSkgcmV0dXJuXG4gICAgICAgIGlmICh0aGlzLnpvb21FeHRlbnRbMV0gPT0gdGhpcy52aWV3LnogJiYgZiA+PSAxKSByZXR1cm5cblxuICAgICAgICAvL2Vuc3VyZSB6b29tIGV4dGVudCBwcmVzZXJ2ZWRcbiAgICAgICAgY29uc3QgbmV3WmYgPSBmICogdGhpcy52aWV3LnpcbiAgICAgICAgaWYgKG5ld1pmIDwgdGhpcy56b29tRXh0ZW50WzBdKSBmID0gdGhpcy56b29tRXh0ZW50WzBdIC8gdGhpcy52aWV3LnpcbiAgICAgICAgaWYgKG5ld1pmID4gdGhpcy56b29tRXh0ZW50WzFdKSBmID0gdGhpcy56b29tRXh0ZW50WzFdIC8gdGhpcy52aWV3LnpcblxuICAgICAgICB0aGlzLnZpZXcueiAqPSBmXG4gICAgICAgIGNvbnN0IGR4R2VvID0gKHhHZW8gLSB0aGlzLnZpZXcueCkgKiAoMSAtIGYpXG4gICAgICAgIHRoaXMudmlldy54ICs9IGR4R2VvXG4gICAgICAgIGNvbnN0IGR5R2VvID0gKHlHZW8gLSB0aGlzLnZpZXcueSkgKiAoMSAtIGYpXG4gICAgICAgIHRoaXMudmlldy55ICs9IGR5R2VvXG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZW50R2VvKClcblxuICAgICAgICBpZiAodGhpcy5jYW52YXNTYXZlLmMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIodGhpcy5iYWNrZ3JvdW5kQ29sb3IpXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZiAvPSBmXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHggPSB0aGlzLmdlb1RvUGl4WCh4R2VvKSAqICgxIC0gdGhpcy5jYW52YXNTYXZlLmYpXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHkgPSB0aGlzLmdlb1RvUGl4WSh5R2VvKSAqICgxIC0gdGhpcy5jYW52YXNTYXZlLmYpXG4gICAgICAgICAgICB0aGlzLmNsZWFyKHRoaXMuYmFja2dyb3VuZENvbG9yKVxuICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5jLFxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5keCxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHksXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmYgKiB0aGlzLmNhbnZhc1NhdmUuYy53aWR0aCxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZiAqIHRoaXMuY2FudmFzU2F2ZS5jLmhlaWdodFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hcmdpblB4XG4gICAgICogQHJldHVybnMge0VudmVsb3BlfSBUaGUgZW52ZWxvcGUgb2YgdGhlIHZpZXcsIGluIGdlbyBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICB1cGRhdGVFeHRlbnRHZW8obWFyZ2luUHggPSAyMCkge1xuICAgICAgICB0aGlzLmV4dEdlbyA9IHtcbiAgICAgICAgICAgIHhNaW46IHRoaXMucGl4VG9HZW9YKC1tYXJnaW5QeCksXG4gICAgICAgICAgICB4TWF4OiB0aGlzLnBpeFRvR2VvWCh0aGlzLncgKyBtYXJnaW5QeCksXG4gICAgICAgICAgICB5TWluOiB0aGlzLnBpeFRvR2VvWSh0aGlzLmggKyBtYXJnaW5QeCksXG4gICAgICAgICAgICB5TWF4OiB0aGlzLnBpeFRvR2VvWSgtbWFyZ2luUHgpLFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4dEdlb1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBvYmplY3QgaGFzIHRvIGJlIGRyYXduXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IG9ialxuICAgICAqL1xuICAgIHRvRHJhdyhvYmopIHtcbiAgICAgICAgaWYgKG9iai54IDwgdGhpcy5leHRHZW8ueE1pbikgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmIChvYmoueCA+IHRoaXMuZXh0R2VvLnhNYXgpIHJldHVybiBmYWxzZVxuICAgICAgICBpZiAob2JqLnkgPCB0aGlzLmV4dEdlby55TWluKSByZXR1cm4gZmFsc2VcbiAgICAgICAgaWYgKG9iai55ID4gdGhpcy5leHRHZW8ueU1heCkgcmV0dXJuIGZhbHNlXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy9jb252ZXJzaW9uIGZ1bmN0aW9uc1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4R2VvIEdlbyB4IGNvb3JkaW5hdGUsIGluIG0uXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2NyZWVuIHggY29vcmRpbmF0ZSwgaW4gcGl4LlxuICAgICAqL1xuICAgIGdlb1RvUGl4WCh4R2VvKSB7XG4gICAgICAgIHJldHVybiAoeEdlbyAtIHRoaXMudmlldy54KSAvIHRoaXMudmlldy56ICsgdGhpcy53ICogMC41XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5R2VvIEdlbyB5IGNvb3JkaW5hdGUsIGluIG0uXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2NyZWVuIHkgY29vcmRpbmF0ZSwgaW4gcGl4LlxuICAgICAqL1xuICAgIGdlb1RvUGl4WSh5R2VvKSB7XG4gICAgICAgIHJldHVybiAtKHlHZW8gLSB0aGlzLnZpZXcueSkgLyB0aGlzLnZpZXcueiArIHRoaXMuaCAqIDAuNVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBTY3JlZW4geCBjb29yZGluYXRlLCBpbiBwaXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gR2VvIHggY29vcmRpbmF0ZSwgaW4gbS5cbiAgICAgKi9cbiAgICBwaXhUb0dlb1goeCkge1xuICAgICAgICByZXR1cm4gKHggLSB0aGlzLncgKiAwLjUpICogdGhpcy52aWV3LnogKyB0aGlzLnZpZXcueFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBTY3JlZW4geSBjb29yZGluYXRlLCBpbiBwaXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gR2VvIHkgY29vcmRpbmF0ZSwgaW4gbS5cbiAgICAgKi9cbiAgICBwaXhUb0dlb1koeSkge1xuICAgICAgICByZXR1cm4gLSh5IC0gdGhpcy5oICogMC41KSAqIHRoaXMudmlldy56ICsgdGhpcy52aWV3LnlcbiAgICB9XG5cbiAgICAvKiogR2V0IHgseSx6IGVsZW1lbnRzIGZyb20gVVJMIGFuZCBhc3NpZ24gdGhlbSB0byB0aGUgdmlldy4gKi9cbiAgICBzZXRWaWV3RnJvbVVSTCgpIHtcbiAgICAgICAgY29uc3QgeCA9IEdlb0NhbnZhcy5nZXRQYXJhbWV0ZXJCeU5hbWUoJ3gnKSxcbiAgICAgICAgICAgIHkgPSBHZW9DYW52YXMuZ2V0UGFyYW1ldGVyQnlOYW1lKCd5JyksXG4gICAgICAgICAgICB6ID0gR2VvQ2FudmFzLmdldFBhcmFtZXRlckJ5TmFtZSgneicpXG4gICAgICAgIGlmICh4ICE9IG51bGwgJiYgeCAhPSB1bmRlZmluZWQgJiYgIWlzTmFOKCt4KSkgdGhpcy52aWV3LnggPSAreFxuICAgICAgICBpZiAoeSAhPSBudWxsICYmIHkgIT0gdW5kZWZpbmVkICYmICFpc05hTigreSkpIHRoaXMudmlldy55ID0gK3lcbiAgICAgICAgaWYgKHogIT0gbnVsbCAmJiB6ICE9IHVuZGVmaW5lZCAmJiAhaXNOYU4oK3opKSB0aGlzLnZpZXcueiA9ICt6XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgVVJMIHBhcmFtZXRlciBieSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGFyYW1ldGVyQnlOYW1lKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS8sICdcXFxcXScpXG4gICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1tcXFxcPyZdJyArIG5hbWUgKyAnPShbXiYjXSopJyksXG4gICAgICAgICAgICByZXN1bHRzID0gcmVnZXguZXhlYyhsb2NhdGlvbi5zZWFyY2gpXG4gICAgICAgIHJldHVybiAhcmVzdWx0cyA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSlcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IERyYXdhYmxlIH0gZnJvbSBcIi4vRHJhd2FibGUuanNcIlxuXG4vKipcbiAqIEBtb2R1bGUgY29yZVxuICogQGFic3RyYWN0XG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXllciBleHRlbmRzIERyYXdhYmxlIHtcblxuICAgIC8qKlxuICAgICAqIERyYXcgbGF5ZXIuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhcyBUaGUgY2FudmFzIHdoZXJlIHRvIGRyYXcgdGhlIGxheWVyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsZWdlbmRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBkcmF3KGdlb0NhbnZhcywgbGVnZW5kID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIGRyYXcgbm90IGltcGxlbWVudGVkLicpXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcblxuLyoqXG4gKiBBIGxlZ2VuZCBjb250YWluZXIuXG4gKlxuICogQG1vZHVsZSBjb3JlXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBMZWdlbmQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmlkID0gb3B0cy5pZFxuXG4gICAgICAgIC8vVE9ETyBzdG9wIHVzaW5nIGl0LiBVc2Ugc3R5bGUgbWV0aG9kIGJlbG93IGluc3RlYWQuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IEBkZXByZWNhdGVkICovXG4gICAgICAgIHRoaXMudG9wID0gb3B0cy50b3BcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IEBkZXByZWNhdGVkICovXG4gICAgICAgIHRoaXMuYm90dG9tID0gb3B0cy5ib3R0b21cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IEBkZXByZWNhdGVkICovXG4gICAgICAgIHRoaXMubGVmdCA9IG9wdHMubGVmdFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgdGhpcy5yaWdodCA9IG9wdHMucmlnaHRcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG9wdHMuYmFja2dyb3VuZCB8fCAnbm9uZSdcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXG4gICAgICAgIHRoaXMucGFkZGluZyA9IG9wdHMucGFkZGluZyB8fCAnNXB4J1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgdGhpcy5ib3JkZXIgPSBvcHRzLmJvcmRlciB8fCAnMHB4J1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgdGhpc1snYm9yZGVyLXJhZGl1cyddID0gb3B0c1snYm9yZGVyLXJhZGl1cyddIHx8ICdub25lJ1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgdGhpc1snYm94LXNoYWRvdyddID0gb3B0c1snYm94LXNoYWRvdyddIHx8ICdub25lJ1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgdGhpc1snZm9udC1mYW1pbHknXSA9IG9wdHNbJ2ZvbnQtZmFtaWx5J10gfHwgJ0hlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYnXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBAZGVwcmVjYXRlZCAqL1xuICAgICAgICAvL3RoaXMud2lkdGggPSBvcHRzLndpZHRoXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBAZGVwcmVjYXRlZCAqL1xuICAgICAgICAvL3RoaXMuaGVpZ2h0ID0gb3B0cy5oZWlnaHRcblxuICAgICAgICAvL3RoZSBkaXYgZWxlbWVudFxuICAgICAgICBpZiAodGhpcy5pZCkgdGhpcy5kaXYgPSBzZWxlY3QoJyMnICsgdGhpcy5pZClcblxuICAgICAgICBpZiAoIXRoaXMuZGl2IHx8IHRoaXMuZGl2LmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2ID0gc2VsZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgICAgICAgICAgaWYgKHRoaXMuaWQpIHRoaXMuZGl2LmF0dHIoJ2lkJywgdGhpcy5pZClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2V0IHN0eWxlXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKCdiYWNrZ3JvdW5kJywgdGhpcy5iYWNrZ3JvdW5kKVxuICAgICAgICB0aGlzLmRpdi5zdHlsZSgncGFkZGluZycsIHRoaXMucGFkZGluZylcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUoJ2JvcmRlcicsIHRoaXMuYm9yZGVyKVxuICAgICAgICB0aGlzLmRpdi5zdHlsZSgnYm9yZGVyLXJhZGl1cycsIHRoaXNbJ2JvcmRlci1yYWRpdXMnXSlcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUoJ2JveC1zaGFkb3cnLCB0aGlzWydib3gtc2hhZG93J10pXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKCdmb250LWZhbWlseScsIHRoaXNbJ2ZvbnQtZmFtaWx5J10pXG5cbiAgICAgICAgLy9pZiAodGhpcy53aWR0aCkgdGhpcy5kaXYuc3R5bGUoJ3dpZHRoJywgdGhpcy53aWR0aClcbiAgICAgICAgLy9pZiAodGhpcy5oZWlnaHQpIHRoaXMuZGl2LnN0eWxlKCdoZWlnaHQnLCB0aGlzLmhlaWdodClcblxuICAgICAgICAvL3RpdGxlXG4gICAgICAgIHRoaXMudGl0bGUgPSBvcHRzLnRpdGxlXG4gICAgICAgIHRoaXMudGl0bGVGb250U2l6ZSA9IG9wdHMudGl0bGVGb250U2l6ZSB8fCAnMC44ZW0nXG4gICAgICAgIHRoaXMudGl0bGVGb250V2VpZ2h0ID0gb3B0cy50aXRsZUZvbnRXZWlnaHQgfHwgJ2JvbGQnXG5cbiAgICAgICAgLy9sYWJlbFxuICAgICAgICB0aGlzLmxhYmVsRm9udFNpemUgPSBvcHRzLmxhYmVsRm9udFNpemUgfHwgJzAuOGVtJ1xuICAgICAgICB0aGlzLmxhYmVsVW5pdFRleHQgPSBvcHRzLmxhYmVsVW5pdFRleHQgfHwgJydcbiAgICAgICAgdGhpcy5sYWJlbEZvcm1hdCA9IG9wdHMubGFiZWxGb3JtYXRcbiAgICB9XG5cblxuICAgIG1ha2VUaXRsZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRpdGxlKSByZXR1cm5cbiAgICAgICAgdGhpcy5kaXZcbiAgICAgICAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMudGl0bGVGb250U2l6ZSlcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC13ZWlnaHQnLCB0aGlzLnRpdGxlRm9udFdlaWdodClcbiAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLWJvdHRvbScsICc3cHgnKVxuICAgICAgICAgICAgLnRleHQodGhpcy50aXRsZSlcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgc3R5bGUgdG8gdGhlIGxlZ2VuZCBkaXYuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdlxuICAgICAqIEByZXR1cm5zIHt0aGlzfHN0cmluZ31cbiAgICAgKi9cbiAgICBzdHlsZShrLCB2KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLmRpdi5zdHlsZShrKVxuICAgICAgICB0aGlzLmRpdi5zdHlsZShrLCB2KVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdXBkYXRlKG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdMZWdlbmQgdXBkYXRlIG5vdCBpbXBsZW1lbnRlZCB5ZXQuJylcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbi8vIGludGVybmFsIGltcG9ydHNcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4vR2VvQ2FudmFzLmpzJ1xuaW1wb3J0IHsgVG9vbHRpcCB9IGZyb20gJy4vVG9vbHRpcC5qcydcbmltcG9ydCB7IFpvb21CdXR0b25zIH0gZnJvbSAnLi4vYnV0dG9uL1pvb21CdXR0b25zLmpzJ1xuaW1wb3J0IHsgRnVsbHNjcmVlbkJ1dHRvbiB9IGZyb20gJy4uL2J1dHRvbi9GdWxsc2NyZWVuQnV0dG9uLmpzJ1xuXG4vLyBleHRlcm5hbCBpbXBvcnRzXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXG5cbi8qKlxuICogQSBncmlkdml6IGFwcGxpY2F0aW9uLlxuICpcbiAqIEBtb2R1bGUgY29yZVxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgTWFwIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgb3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGF5ZXJzLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4vTGF5ZXIuanNcIikuTGF5ZXI+fVxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmxheWVycyA9IG9wdHMubGF5ZXJzIHx8IFtdXG5cbiAgICAgICAgLy9nZXQgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dyaWR2aXonKVxuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgZmluZCBncmlkdml6IGNvbnRhaW5lciBlbGVtZW50LicpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9hYnNvbHV0ZS1wb3NpdGlvbmluZy1pbnNpZGUtcmVsYXRpdmUtcG9zaXRpb25pbmcvXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiOyAvLyBjb250YWluZXIgZWxlbWVudCBtdXN0IGhhdmUgcmVsYXRpdmUgcG9zaXRpb25pbmdcblxuICAgICAgICAvL3NldCBkaW1lbnNpb25zXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSBvcHRzLncgfHwgdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGhcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IG9wdHMuaCB8fCB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHRcblxuICAgICAgICAvL2NyZWF0ZSBjYW52YXMgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IG9wdHMuY2FudmFzIHx8IHRoaXMuaW5pdGlhbGlzZUNhbnZhcygpXG5cbiAgICAgICAgLyoqIE1ha2UgZ2VvIGNhbnZhc1xuICAgICAgICAgKiBAdHlwZSB7R2VvQ2FudmFzfVxuICAgICAgICAgKiBAcHJpdmF0ZSAqL1xuICAgICAgICB0aGlzLmdlb0NhbnZhcyA9IG5ldyBHZW9DYW52YXModGhpcy5fY2FudmFzLCBvcHRzLngsIG9wdHMueSwgb3B0cy56LCBvcHRzKVxuICAgICAgICB0aGlzLmdlb0NhbnZhcy5yZWRyYXcgPSAoKSA9PiB7IHRoaXMucmVkcmF3KCkgfVxuXG4gICAgICAgIC8vIGxlZ2VuZCBkaXZcbiAgICAgICAgdGhpcy5sZWdlbmREaXZJZCA9IG9wdHMubGVnZW5kRGl2SWQgfHwgJ2d2aXpMZWdlbmQnXG4gICAgICAgIHRoaXMubGVnZW5kID0gc2VsZWN0KCcjJyArIHRoaXMubGVnZW5kRGl2SWQpXG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZC5lbXB0eSgpKSB0aGlzLmluaXRpYWxpc2VMZWdlbmQoKVxuXG5cbiAgICAgICAgLy90b29sdGlwXG5cbiAgICAgICAgLy8gc2V0IEFwcCBjb250YWluZXIgYXMgZGVmYXVsdCBwYXJlbnQgZWxlbWVudCBmb3IgdG9vbHRpcFxuICAgICAgICBpZiAoIW9wdHMudG9vbHRpcCkgb3B0cy50b29sdGlwID0ge31cbiAgICAgICAgaWYgKCFvcHRzLnRvb2x0aXAucGFyZW50RWxlbWVudCkgb3B0cy50b29sdGlwLnBhcmVudEVsZW1lbnQgPSB0aGlzLmNvbnRhaW5lclxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7VG9vbHRpcH0gKi9cbiAgICAgICAgdGhpcy50b29sdGlwID0gbmV3IFRvb2x0aXAob3B0cy50b29sdGlwKVxuXG4gICAgICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lcnMgdG8gY29udGFpbmVyXG4gICAgICAgIHRoaXMubW91c2VPdmVySGFuZGxlciA9IChlKSA9PiB0aGlzLmZvY3VzQ2VsbChlKVxuICAgICAgICB0aGlzLm1vdXNlTW92ZUhhbmRsZXIgPSAoZSkgPT4gdGhpcy5mb2N1c0NlbGwoZSlcbiAgICAgICAgdGhpcy5tb3VzZU91dEhhbmRsZXIgPSAoZSkgPT4gdGhpcy50b29sdGlwLmhpZGUoKVxuICAgICAgICB0aGlzLmdlb0NhbnZhcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5tb3VzZU92ZXJIYW5kbGVyKVxuICAgICAgICB0aGlzLmdlb0NhbnZhcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKVxuICAgICAgICB0aGlzLmdlb0NhbnZhcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm1vdXNlT3V0SGFuZGxlcilcblxuICAgICAgICAvLyBhZGQgZXh0cmEgbG9naWMgdG8gb25ab29tU3RhcnRGdW5cbiAgICAgICAgdGhpcy5nZW9DYW52YXMub25ab29tU3RhcnRGdW4gPSAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdHMub25ab29tU3RhcnRGdW4pIG9wdHMub25ab29tU3RhcnRGdW4oZSlcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5oaWRlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZm9yIG1vdXNlIG92ZXJcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxudWxsfSAqL1xuICAgICAgICB0aGlzLmNhbnZhc1NhdmUgPSBudWxsXG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SZWN0YW5nbGVDb2xvciA9IG9wdHMuc2VsZWN0aW9uUmVjdGFuZ2xlQ29sb3IgfHwgJ3JlZCdcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SZWN0YW5nbGVXaWR0aFBpeCA9IG9wdHMuc2VsZWN0aW9uUmVjdGFuZ2xlV2lkdGhQaXggfHwgKCgpID0+IDQpIC8vKHIseikgPT4ge31cblxuICAgICAgICAvLyB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kIChlLmcuIGxlYWZsZXQpICdyZWQgcGFpbnRpbmcnIGZpeFxuICAgICAgICB0aGlzLnRyYW5zcGFyZW50QmFja2dyb3VuZCA9IG9wdHMudHJhbnNwYXJlbnRCYWNrZ3JvdW5kXG5cbiAgICAgICAgLy9zZXQgZGVmYXVsdCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICAgICAgdGhpcy5kZWZhdWx0R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID1cbiAgICAgICAgICAgIG9wdHMuZGVmYXVsdEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiB8fCB0aGlzLmdlb0NhbnZhcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEBwcm90ZWN0ZWQgXG4gICAgICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICovXG4gICAgaW5pdGlhbGlzZUNhbnZhcygpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnJyArIHRoaXMudylcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJycgKyB0aGlzLmgpXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcylcbiAgICAgICAgcmV0dXJuIGNhbnZhc1xuICAgIH1cblxuXG4gICAgaW5pdGlhbGlzZUxlZ2VuZCgpIHtcbiAgICAgICAgdGhpcy5sZWdlbmQgPSBzZWxlY3QodGhpcy5jb250YWluZXIuaWQgJiYgdGhpcy5jb250YWluZXIuaWQgIT0gJycgPyAnIycgKyB0aGlzLmNvbnRhaW5lci5pZCA6ICdib2R5JylcbiAgICAgICAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuYXR0cignaWQnLCB0aGlzLmxlZ2VuZERpdklkKVxuICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpXG4gICAgICAgICAgICAuc3R5bGUoJ3dpZHRoJywgJ2F1dG8nKVxuICAgICAgICAgICAgLnN0eWxlKCdoZWlnaHQnLCAnYXV0bycpXG4gICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQnLCAnI0ZGRkZGRicpXG4gICAgICAgICAgICAvLy5zdHlsZShcInBhZGRpbmdcIiwgdGhpcy5wYWRkaW5nKVxuICAgICAgICAgICAgLnN0eWxlKCdib3JkZXInLCAnMHB4JylcbiAgICAgICAgICAgIC8vLnN0eWxlKCdib3JkZXItcmFkaXVzJywgJzVweCcpXG4gICAgICAgICAgICAuc3R5bGUoJ2JveC1zaGFkb3cnLCAnM3B4IDNweCAzcHggZ3JleSwgLTNweCAtM3B4IDNweCAjZGRkJylcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1mYW1pbHknLCAnSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZicpXG4gICAgICAgICAgICAuc3R5bGUoJ2JvdHRvbScsICcxNXB4JylcbiAgICAgICAgICAgIC5zdHlsZSgncmlnaHQnLCAnMTVweCcpXG4gICAgICAgIC8vaGlkZVxuICAgICAgICAvLy5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQvZ2V0IGxheWVyIHN0YWNrLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfGltcG9ydChcIi4vTGF5ZXIuanNcIikuTGF5ZXJ8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5MYXllcltdfSBsYXllcnMgXG4gICAgICogQHJldHVybnMgeyB0aGlzIHwgaW1wb3J0KFwiLi9MYXllci5qc1wiKS5MYXllcltdIH1cbiAgICAgKi9cbiAgICBsYXllcnNfKGxheWVycykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMubGF5ZXJzXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGF5ZXJzKSkgdGhpcy5sYXllcnMgPSBsYXllcnNcbiAgICAgICAgICAgIGVsc2UgdGhpcy5sYXllcnMgPSBbbGF5ZXJzXVxuICAgICAgICBlbHNlIHRoaXMubGF5ZXJzID0gYXJndW1lbnRzXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqIEByZXR1cm5zIHt0aGlzfSAqL1xuICAgIHJlZHJhdygpIHtcbiAgICAgICAgLy9yZW1vdmUgbGVnZW5kIGVsZW1lbnRzXG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZCkgdGhpcy5sZWdlbmQuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcblxuICAgICAgICAvL2NsZWFyXG4gICAgICAgIHRoaXMuZ2VvQ2FudmFzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICB0aGlzLmdlb0NhbnZhcy5jbGVhcih0aGlzLmdlb0NhbnZhcy5iYWNrZ3JvdW5kQ29sb3IpXG5cbiAgICAgICAgY29uc3QgeiA9IHRoaXMuZ2VvQ2FudmFzLnZpZXcuelxuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXG5cbiAgICAgICAgLy9nbyB0aHJvdWdoIHRoZSBsYXllcnNcbiAgICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuXG4gICAgICAgICAgICAvL2NoZWNrIGlmIGxheWVyIGlzIHZpc2libGVcbiAgICAgICAgICAgIGlmIChsYXllci52aXNpYmxlICYmICFsYXllci52aXNpYmxlKHopKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL3NldCBsYXllciBhbHBoYSBhbmQgYmxlbmQgbW9kZVxuICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMuY3R4Lmdsb2JhbEFscGhhID0gbGF5ZXIuYWxwaGEgPyBsYXllci5hbHBoYSh6KSA6IDEuMFxuICAgICAgICAgICAgaWYgKGxheWVyLmJsZW5kT3BlcmF0aW9uKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VvQ2FudmFzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBsYXllci5ibGVuZE9wZXJhdGlvbih6KVxuXG4gICAgICAgICAgICAvL3NldCBhZmZpbiB0cmFuc2Zvcm0gdG8gZHJhdyB3aXRoIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlc1xuICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICAgICAgLy9kcmF3IGxheWVyXG4gICAgICAgICAgICBsYXllci5kcmF3KHRoaXMuZ2VvQ2FudmFzLCB0aGlzLmxlZ2VuZClcblxuICAgICAgICAgICAgLy9kcmF3IGxheWVyIGZpbHRlclxuICAgICAgICAgICAgaWYgKGxheWVyLmZpbHRlckNvbG9yKVxuICAgICAgICAgICAgICAgIGxheWVyLmRyYXdGaWx0ZXIodGhpcy5nZW9DYW52YXMpXG5cbiAgICAgICAgICAgIC8vcmVzdG9yZSBkZWZhdWx0IGFscGhhIGFuZCBibGVuZCBvcGVyYXRpb25cbiAgICAgICAgICAgIHRoaXMuZ2VvQ2FudmFzLmN0eC5nbG9iYWxBbHBoYSA9IDEuMFxuICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuZGVmYXVsdEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5jYW52YXNTYXZlID0gbnVsbFxuXG4gICAgICAgIC8vIGxpc3RlbiBmb3IgcmVzaXplIGV2ZW50cyBvbiB0aGUgQXBwJ3MgY29udGFpbmVyIGFuZCBoYW5kbGUgdGhlbVxuICAgICAgICB0aGlzLmRlZmluZVJlc2l6ZU9ic2VydmVyKHRoaXMuY29udGFpbmVyLCB0aGlzLl9jYW52YXMpXG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXJnaW5QeFxuICAgICAqIEByZXR1cm5zIHtpbXBvcnQoJy4vR2VvQ2FudmFzLmpzJykuRW52ZWxvcGV9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVwZGF0ZUV4dGVudEdlbyhtYXJnaW5QeCA9IDIwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlb0NhbnZhcy51cGRhdGVFeHRlbnRHZW8obWFyZ2luUHgpXG4gICAgfVxuXG5cblxuICAgIC8qKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgKi9cbiAgICBmb2N1c0NlbGwoZSkge1xuICAgICAgICAvL2NvbXB1dGUgbW91c2UgZ2VvIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IG1vdXNlUG9zaXRpb25HZW8gPSB7XG4gICAgICAgICAgICB4OiB0aGlzLmdlb0NhbnZhcy5waXhUb0dlb1goZS5vZmZzZXRYICsgdGhpcy50b29sdGlwLnhNb3VzZU9mZnNldCksXG4gICAgICAgICAgICB5OiB0aGlzLmdlb0NhbnZhcy5waXhUb0dlb1koZS5vZmZzZXRZICsgdGhpcy50b29sdGlwLnlNb3VzZU9mZnNldCksXG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHt7Y2VsbDppbXBvcnQoJy4vRGF0YXNldC5qcycpLkNlbGwsaHRtbDpzdHJpbmcscmVzb2x1dGlvbjpudW1iZXJ9IHwgdW5kZWZpbmVkfSAqL1xuICAgICAgICBjb25zdCBmb2N1cyA9IHRoaXMuZ2V0Q2VsbEZvY3VzSW5mbyhtb3VzZVBvc2l0aW9uR2VvKVxuXG4gICAgICAgIC8vIHRyYW5zcGFyZW50IGJhY2tncm91bmQgKGUuZy4gbGVhZmxldCkgJ3JlZCBwYWludGluZycgZml4XG4gICAgICAgIGlmICh0aGlzLnRyYW5zcGFyZW50QmFja2dyb3VuZCkge1xuICAgICAgICAgICAgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwLmh0bWwoZm9jdXMuaHRtbClcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuc2V0UG9zaXRpb24oZSlcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuc2hvdygpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5oaWRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcnICsgdGhpcy53KVxuICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJycgKyB0aGlzLmgpXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZ2V0Q29udGV4dCgnMmQnKT8uZHJhd0ltYWdlKHRoaXMuZ2VvQ2FudmFzLmNhbnZhcywgMCwgMClcbiAgICAgICAgICAgIHRoaXMuZ2VvQ2FudmFzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5odG1sKGZvY3VzLmh0bWwpXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuc2V0UG9zaXRpb24oZSlcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zaG93KClcblxuICAgICAgICAgICAgLy9zaG93IGNlbGwgcG9zaXRpb24gYXMgYSByZWN0YW5nbGVcbiAgICAgICAgICAgIGlmICghdGhpcy5jYW52YXNTYXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcnICsgdGhpcy53KVxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcnICsgdGhpcy5oKVxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5nZXRDb250ZXh0KCcyZCcpPy5kcmF3SW1hZ2UodGhpcy5nZW9DYW52YXMuY2FudmFzLCAwLCAwKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy5jdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzU2F2ZSwgMCwgMClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kcmF3IGltYWdlIHNhdmVkICsgZHJhdyByZWN0YW5nbGVcbiAgICAgICAgICAgIGNvbnN0IHJlY3RXUGl4ID0gdGhpcy5zZWxlY3Rpb25SZWN0YW5nbGVXaWR0aFBpeFxuICAgICAgICAgICAgICAgID8gdGhpcy5zZWxlY3Rpb25SZWN0YW5nbGVXaWR0aFBpeChmb2N1cy5yZXNvbHV0aW9uLCB0aGlzLmdlb0NhbnZhcy52aWV3LnopXG4gICAgICAgICAgICAgICAgOiA0XG4gICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy5pbml0Q2FudmFzVHJhbnNmb3JtKClcbiAgICAgICAgICAgIHRoaXMuZ2VvQ2FudmFzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc2VsZWN0aW9uUmVjdGFuZ2xlQ29sb3JcbiAgICAgICAgICAgIHRoaXMuZ2VvQ2FudmFzLmN0eC5saW5lV2lkdGggPSByZWN0V1BpeFxuICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMuY3R4LmJlZ2luUGF0aCgpXG5cbiAgICAgICAgICAgIHRoaXMuZ2VvQ2FudmFzLmN0eC5yZWN0KFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VvQ2FudmFzLmdlb1RvUGl4WChmb2N1cy5jZWxsLngpIC0gcmVjdFdQaXggLyAyLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VvQ2FudmFzLmdlb1RvUGl4WShmb2N1cy5jZWxsLnkpICsgcmVjdFdQaXggLyAyLFxuICAgICAgICAgICAgICAgIGZvY3VzLnJlc29sdXRpb24gLyB0aGlzLmdlb0NhbnZhcy52aWV3LnogKyByZWN0V1BpeCxcbiAgICAgICAgICAgICAgICAtZm9jdXMucmVzb2x1dGlvbiAvIHRoaXMuZ2VvQ2FudmFzLnZpZXcueiAtIHJlY3RXUGl4XG4gICAgICAgICAgICApXG4gICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy5jdHguc3Ryb2tlKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5oaWRlKClcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhc1NhdmUpIHRoaXMuZ2VvQ2FudmFzLmN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXNTYXZlLCAwLCAwKVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNlbGwgSFRNTCBpbmZvIGF0IGEgZ2l2ZW4gZ2VvIHBvc2l0aW9uLlxuICAgICAqIFRoaXMgaXMgdXNlZnVsbCBmb3IgdXNlciBpbnRlcmFjdGlvbnMsIHRvIHNob3cgdGhpcyBpbmZvIHdoZXJlIHRoZSB1c2VyIGNsaWNrcyBmb3IgZXhhbXBsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gcG9zR2VvXG4gICAgICogQHJldHVybnMge3tjZWxsOmltcG9ydCgnLi9EYXRhc2V0LmpzJykuQ2VsbCxodG1sOnN0cmluZyxyZXNvbHV0aW9uOm51bWJlcn0gfCB1bmRlZmluZWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldENlbGxGb2N1c0luZm8ocG9zR2VvKSB7XG4gICAgICAgIC8vZ28gdGhyb3VnaCB0aGUgbGF5ZXJzLCBzdGFydGluZyBmcm9tIHRvcFxuICAgICAgICBjb25zdCB6ID0gdGhpcy5nZW9DYW52YXMudmlldy56XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLkxheWVyfSAqL1xuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyc1tpXVxuICAgICAgICAgICAgaWYgKGxheWVyLnZpc2libGUgJiYgIWxheWVyLnZpc2libGUoeikpIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoIWxheWVyLmNlbGxJbmZvSFRNTCkgY29udGludWVcbiAgICAgICAgICAgIC8vaWYgKGxheWVyLmNlbGxJbmZvSFRNTCA9PT0gJ25vbmUnKSBjb250aW51ZVxuICAgICAgICAgICAgaWYgKCFsYXllci5nZXREYXRhc2V0KSBjb250aW51ZVxuICAgICAgICAgICAgY29uc3QgZHNjID0gbGF5ZXIuZ2V0RGF0YXNldCh6KVxuICAgICAgICAgICAgaWYgKCFkc2MpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vZ2V0IGNlbGwgYXQgbW91c2UgcG9zaXRpb25cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL0RhdGFzZXQuanMnKS5DZWxsfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBkc2MuZ2V0Q2VsbEZyb21Qb3NpdGlvbihwb3NHZW8sIGRzYy5nZXRWaWV3Q2FjaGUoKSlcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY2VsbCwgZHNjLnJlc29sdXRpb24pXG4gICAgICAgICAgICBpZiAoIWNlbGwpIHJldHVybiB1bmRlZmluZWRcblxuICAgICAgICAgICAgLy9yYXJlIGNhc2UgZm9yIGEgZGF0YXNldCB3aXRoIG1peGVkIHJlc29sdXRpb25zXG4gICAgICAgICAgICBpZiAoZHNjLm1peGVkUmVzb2x1dGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBkc2MubWl4ZWRSZXNvbHV0aW9uKGNlbGwpXG4gICAgICAgICAgICAgICAgY29uc3QgaHRtbCA9IGxheWVyLmNlbGxJbmZvSFRNTChjZWxsLCByKVxuICAgICAgICAgICAgICAgIGlmICghaHRtbCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNlbGw6IGNlbGwsIGh0bWw6IGh0bWwsIHJlc29sdXRpb246IHIgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBodG1sID0gbGF5ZXIuY2VsbEluZm9IVE1MKGNlbGwsIGRzYy5nZXRSZXNvbHV0aW9uKCkpXG4gICAgICAgICAgICBpZiAoIWh0bWwpIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiB7IGNlbGw6IGNlbGwsIGh0bWw6IGh0bWwsIHJlc29sdXRpb246IGRzYy5nZXRSZXNvbHV0aW9uKCkgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKiogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gelxuICAgICAqL1xuICAgIHNldFZpZXcoeCwgeSwgeiA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmdlb0NhbnZhcy52aWV3LnggPSB4XG4gICAgICAgIHRoaXMuZ2VvQ2FudmFzLnZpZXcueSA9IHlcbiAgICAgICAgaWYgKHogIT0gdW5kZWZpbmVkKSB0aGlzLmdlb0NhbnZhcy52aWV3LnogPSB6XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqIEByZXR1cm5zIHtpbXBvcnQoJy4vR2VvQ2FudmFzLmpzJykuVmlld30gKi9cbiAgICBnZXRWaWV3KCkgeyByZXR1cm4gdGhpcy5nZW9DYW52YXMudmlldyB9XG5cbiAgICAvKiogQHJldHVybnMge251bWJlcn0gKi9cbiAgICBnZXRab29tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW9DYW52YXMudmlldy56XG4gICAgfVxuICAgIC8qKiBAcGFyYW0ge251bWJlcn0geiBAcmV0dXJucyB7dGhpc30gKi9cbiAgICBzZXRab29tKHopIHtcbiAgICAgICAgdGhpcy5nZW9DYW52YXMudmlldy56ID0gelxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuXG4gICAgLyoqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gKi9cbiAgICBnZXRab29tRXh0ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW9DYW52YXMuZ2V0Wm9vbUV4dGVudCgpXG4gICAgfVxuICAgIC8qKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWwgQHJldHVybnMge3RoaXN9ICovXG4gICAgc2V0Wm9vbUV4dGVudCh2YWwpIHtcbiAgICAgICAgdGhpcy5nZW9DYW52YXMuc2V0Wm9vbUV4dGVudCh2YWwpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG5cblxuICAgIC8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuICAgIGdldEJhY2tncm91bmRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvQ2FudmFzLmJhY2tncm91bmRDb2xvclxuICAgIH1cbiAgICAvKiogQHBhcmFtIHtzdHJpbmd9IHZhbCBAcmV0dXJucyB7dGhpc30gKi9cbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3IodmFsKSB7XG4gICAgICAgIHRoaXMuZ2VvQ2FudmFzLmJhY2tncm91bmRDb2xvciA9IHZhbFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzZXQgb2Ygem9vbSBidXR0b25zIHRvIHRoZSBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgYWRkWm9vbUJ1dHRvbnMob3B0cykge1xuICAgICAgICAvLyAqIG9wdHMuaWRcbiAgICAgICAgLy8gKiBvcHRzLm9uWm9vbSAtIGN1c3RvbSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICAgIC8vICogb3B0cy54XG4gICAgICAgIC8vICogb3B0cy55XG4gICAgICAgIC8vICogb3B0cy5kZWx0YSAtIHpvb20gZGVsdGEgYXBwbGllZCBvbiBlYWNoIGNsaWNrXG5cbiAgICAgICAgdGhpcy56b29tQnV0dG9ucyA9IG5ldyBab29tQnV0dG9ucyh7XG4gICAgICAgICAgICBtYXA6IHRoaXMsXG4gICAgICAgICAgICBpZDogb3B0cz8uaWQgfHwgJ2dyaWR2aXotem9vbS1idXR0b25zJyxcbiAgICAgICAgICAgIGNsYXNzOiBvcHRzPy5jbGFzcyxcbiAgICAgICAgICAgIHg6IG9wdHM/LngsXG4gICAgICAgICAgICB5OiBvcHRzPy55LFxuICAgICAgICAgICAgb25ab29tOiBvcHRzPy5vblpvb20sXG4gICAgICAgICAgICBkZWx0YTogb3B0cz8uZGVsdGEgfHwgMC4yXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZnVsbHNjcmVlbiB0b2dnbGUgYnV0dG9uIHRvIHRoZSBhcHBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgYWRkRnVsbHNjcmVlbkJ1dHRvbihvcHRzKSB7XG4gICAgICAgIC8vICogb3B0cy5tYXAgLSB0aGUgZ3JpZHZpeiBtYXBcbiAgICAgICAgLy8gKiBvcHRzLmlkXG4gICAgICAgIC8vICogb3B0cy54XG4gICAgICAgIC8vICogb3B0cy55XG5cbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuQnV0dG9uID0gbmV3IEZ1bGxzY3JlZW5CdXR0b24oe1xuICAgICAgICAgICAgbWFwOiB0aGlzLFxuICAgICAgICAgICAgaWQ6IG9wdHM/LmlkIHx8ICdncmlkdml6LWZ1bGxzY3JlZW4tYnV0dG9uJyxcbiAgICAgICAgICAgIGNsYXNzOiBvcHRzPy5jbGFzcyxcbiAgICAgICAgICAgIHg6IG9wdHM/LngsXG4gICAgICAgICAgICB5OiBvcHRzPy55XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKiogQHJldHVybnMge3RoaXN9ICovXG4gICAgc2V0Vmlld0Zyb21VUkwoKSB7XG4gICAgICAgIHRoaXMuZ2VvQ2FudmFzLnNldFZpZXdGcm9tVVJMKClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIGEgcmVzaXplIGV2ZW50IG9ic2VydmVyIHRvIHRoZSBBcHBzIGNvbnRhaW5lciBhbmQgdXBkYXRlIHRoZSBjYW52YXMgYWNjb3JkaW5nbHlcbiAgICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBjb250YWluZXIgVGhlIEFwcCdzIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIFRoZSBBcHAgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyb2YgQXBwXG4gICAgICovXG4gICAgZGVmaW5lUmVzaXplT2JzZXJ2ZXIoY29udGFpbmVyLCBjYW52YXMpIHtcbiAgICAgICAgLy8gbGlzdGVuIHRvIHJlc2l6ZSBldmVudHNcbiAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjYW52YXMgaGFzIGJlZW4gYnVpbHRcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuY2xpZW50V2lkdGggPiAwICYmIGNvbnRhaW5lci5jbGllbnRIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvbnQgZXhjZWVkIGxvb3AgbGltaXQgZmlyc3RcbiAgICAgICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5Mzg0MTIwL3Jlc2l6ZW9ic2VydmVyLWxvb3AtbGltaXQtZXhjZWVkZWRcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVudHJpZXMpIHx8ICFlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBtYXAgYW5kIGNhbnZhcyBzaXplXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmggIT09IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgdGhpcy53ICE9PSBjb250YWluZXIuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMuaCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VvQ2FudmFzLncgPSBjb250YWluZXIuY2xpZW50V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJycgKyB0aGlzLncpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnJyArIHRoaXMuaClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVkcmF3KClcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgYnV0dG9uIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuem9vbUJ1dHRvbnMpIHRoaXMuem9vbUJ1dHRvbnMubm9kZS5zdHlsZS5sZWZ0ID0gdGhpcy53IC0gNTAgKyAncHgnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5mdWxsc2NyZWVuQnV0dG9uKSB0aGlzLmZ1bGxzY3JlZW5CdXR0b24ubm9kZS5zdHlsZS5sZWZ0ID0gdGhpcy53IC0gNTAgKyAncHgnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBEZXN0cm95IHRoZSBtYXAgYW5kIGl0J3MgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogVGhpcyBzaG91bGQgc2lnbmlmaWNhbnRseSByZWR1Y2UgdGhlIG1lbW9yeSB1c2VkIHdoZW4gY3JlYXRpbmcgYW5kIGRlc3Ryb3lpbmcgZ3JpZHZpeiBtYXAgaW5zdGFuY2VzIChmb3IgZXhhbXBsZSBpbiBsZWFmbGV0LWdyaWR2aXopXG4gICAgICogQG1lbWJlcm9mIEFwcFxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIGNsZWFyIGxheWVyc1xuICAgICAgICB0aGlzLmxheWVycyA9IFtdXG4gICAgICAgIHRoaXMuYmdMYXllcnMgPSBbXVxuXG4gICAgICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZnJvbSBjb250YWluZXJcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5tb3VzZU92ZXJIYW5kbGVyKVxuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXIpXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5tb3VzZU91dEhhbmRsZXIpXG5cbiAgICAgICAgLy8gcmVtb3ZlIGNhbnZhc1xuICAgICAgICB0aGlzLmdlb0NhbnZhcy5jYW52YXMucmVtb3ZlKClcblxuICAgICAgICAvLyByZW1vdmUgbGVnZW5kXG4gICAgICAgIHRoaXMubGVnZW5kPy5yZW1vdmUoKVxuXG4gICAgICAgIC8vIHJlbW92ZSB0b29sdGlwXG4gICAgICAgIHRoaXMudG9vbHRpcC50b29sdGlwPy5yZW1vdmUoKVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBBIG11bHRpIHJlc29sdXRpb24gZGF0YXNldCBvZiBncmlkIGNlbGxzLlxuICogSXQgY29uc2lzdHMgb2YgZGlmZmVyZW50IHtAbGluayBEYXRhc2V0fXMgZm9yIGVhY2ggcmVzb2x1dGlvbi5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqXG4gKiBAbW9kdWxlIGNvcmVcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpUmVzb2x1dGlvbkRhdGFzZXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJlc29sdXRpb25zIFRoZSByZXNvbHV0aW9ucyBvZiB0aGUgZGF0YXNldHMsIGluIENSUyBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuL0RhdGFzZXRcIikuRGF0YXNldD58ZnVuY3Rpb24obnVtYmVyKTppbXBvcnQoXCIuL0RhdGFzZXRcIikuRGF0YXNldH0gZGF0YXNldHMgVGhlIGRhdGFzZXRzIGxpc3QsIG9uZSBwZXIgcmVzb2x1dGlvbi4gT3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBkYXRhc2V0IGZyb20gYSByZXNvbHV0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7IHtwcmVwcm9jZXNzPzpmdW5jdGlvbihpbXBvcnQoXCIuL0RhdGFzZXRcIikuQ2VsbCk6Ym9vbGVhbn0gfSBvcHRzIE9wdGlvbnMuIHByZXByb2Nlc3M6IEEgZnVuY3Rpb24gdG8gYXBwbHkgb24gZWFjaCBkYXRhc2V0IGNlbGwgdG8gcHJlcGFyZSBpdHMgdmFsdWVzLiBDYW4gYmUgdXNlZCBhbHNvIHRvIHNlbGVjdCBjZWxscyB0byBrZWVwLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlc29sdXRpb25zLCBkYXRhc2V0cywgb3B0cyA9IHt9KSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIFRoZSByZXNvbHV0aW9ucyBvZiB0aGUgZGF0YXNldHMsIGluIENSUyBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgICAgICB0aGlzLnJlc29sdXRpb25zID0gcmVzb2x1dGlvbnNcblxuICAgICAgICAvKiogVGhlIGRhdGFzZXRzLiBJZiB0aGUgbGlzdCBpcyBub3QgZXhwbGljdGVseSBkZWZpbmVkLCBidWlsZCBpdCBmcm9tIHRoZSByZXNvbHV0aW9uIGxpc3Qgd2l0aCB0aGUgZnVuY3Rpb25cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxpbXBvcnQoXCIuL0RhdGFzZXRcIikuRGF0YXNldD59ICovXG4gICAgICAgIHRoaXMuZGF0YXNldHMgPSAodHlwZW9mIGRhdGFzZXRzID09PSAnZnVuY3Rpb24nKSA/IHRoaXMucmVzb2x1dGlvbnMubWFwKGRhdGFzZXRzKSA6IGRhdGFzZXRzXG5cbiAgICAgICAgLy90aGVyZSBtdXN0IGJlIGFzIG1hbnkgZGF0YXNldHMgYXMgcmVzb2x1dGlvbnNcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldHMubGVuZ3RoID4gMSAmJiB0aGlzLmRhdGFzZXRzLmxlbmd0aCAhPSB0aGlzLnJlc29sdXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnVW5jb21wYXRpYmxlIG51bWJlciBvZiBkYXRhc2V0cyBhbmQgcmVzb2x1dGlvbnM6ICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YXNldHMubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbnMubGVuZ3RoXG4gICAgICAgICAgICApXG5cbiAgICAgICAgLy9zZXQgZGF0YXNldCBwcmVwcm9jZXNzZXMgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRzLnByZXByb2Nlc3MpIHRoaXMuc2V0UHJlcG9jZXNzZXMob3B0cy5wcmVwcm9jZXNzKVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByZWxldmFudCBkYXRhc2V0IGZvciBhIHNwZWNpZmllZCB6b29tLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblBpeGVsc1BlckNlbGxcbiAgICAgKiBAcmV0dXJucyB7aW1wb3J0KFwiLi9EYXRhc2V0XCIpLkRhdGFzZXR8dW5kZWZpbmVkfVxuICAgICAqICovXG4gICAgZ2V0RGF0YXNldCh6LCBtaW5QaXhlbHNQZXJDZWxsKSB7XG5cbiAgICAgICAgLy9zcGVjaWFsIGNhc2Ugd2hpdGggc2luZ2xlIGRhdGFzZXRcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldHMubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLmRhdGFzZXRzWzBdXG5cbiAgICAgICAgY29uc3QgcnMgPSB0aGlzLnJlc29sdXRpb25zXG4gICAgICAgIGxldCBpID0gMFxuICAgICAgICBsZXQgel8gPSByc1tpXSAvIG1pblBpeGVsc1BlckNlbGxcbiAgICAgICAgd2hpbGUgKHpfIDwgeiAmJiBpIDwgcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpKytcbiAgICAgICAgICAgIHpfID0gcnNbaV0gLyBtaW5QaXhlbHNQZXJDZWxsXG4gICAgICAgIH1cbiAgICAgICAgLy9pZiAoaSA9PSAwKSByZXR1cm4gdGhpcy5kYXRhc2V0LmRhdGFzZXRzWzBdO1xuICAgICAgICAvL3JldHVybiB0aGlzLmRhdGFzZXQuZGF0YXNldHNbaSAtIDFdO1xuICAgICAgICBpZiAoaSA9PSBycy5sZW5ndGgpIHJldHVybiB0aGlzLmRhdGFzZXRzW3JzLmxlbmd0aCAtIDFdXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFzZXRzW2ldXG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIFNldCBhIHByZXByb2Nlc3MgZnVuY3Rpb24gZm9yIGFsbCBkYXRhc2V0cy5cbiAgICAgKiBUaGlzIGlzIGEgZnVuY3Rpb24gYXBwbGllZCBvbiBlYWNoIGNlbGwgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuL0RhdGFzZXRcIikuQ2VsbCk6Ym9vbGVhbn0gcHJlcHJvY2Vzc1xuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHNldFByZXBvY2Vzc2VzKHByZXByb2Nlc3MpIHtcbiAgICAgICAgZm9yIChsZXQgZHMgb2YgdGhpcy5kYXRhc2V0cykgZHMucHJlcHJvY2VzcyA9IHByZXByb2Nlc3NcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGVhc2UgdGhlIGNyZWF0aW9uIG9mIG11bHRpIHJlc29sdXRpb24gZGF0YXNldHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZXNvbHV0aW9ucyBUaGUgcmVzb2x1dGlvbnMgb2YgdGhlIGRhdGFzZXRzLCBpbiBDUlMgZ2VvZ3JhcGhpY2FsIHVuaXRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6aW1wb3J0KFwiLi9EYXRhc2V0XCIpLkRhdGFzZXR9IHJlc1RvRGF0YXNldCBGdW5jdGlvbiByZXR1cm5pbmcgYSBkYXRhc2V0IGZyb20gYSByZXNvbHV0aW9uXG4gICAgICogQHBhcmFtIHsge3ByZXByb2Nlc3M/OmZ1bmN0aW9uKGltcG9ydChcIi4vRGF0YXNldFwiKS5DZWxsKTpib29sZWFufSB9IG9wdHMgT3B0aW9ucy4gcHJlcHJvY2VzczogQSBmdW5jdGlvbiB0byBhcHBseSBvbiBlYWNoIGRhdGFzZXQgY2VsbCB0byBwcmVwYXJlIGl0cyB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7TXVsdGlSZXNvbHV0aW9uRGF0YXNldH1cbiAgICAgKi9cbiAgICAvKnN0YXRpYyBtYWtlKHJlc29sdXRpb25zLCByZXNUb0RhdGFzZXQsIG9wdHMpIHtcbiAgICAgICAgLy9tYWtlIGRhdGFzZXRzXG4gICAgICAgIGNvbnN0IGRzYyA9IFtdXG4gICAgICAgIGZvciAoY29uc3QgcmVzIG9mIHJlc29sdXRpb25zKSBkc2MucHVzaChyZXNUb0RhdGFzZXQocmVzKSlcbiAgICAgICAgLy9tYWtlIG11bHRpIHJlc29sdXRpb24gZGF0YXNldFxuICAgICAgICByZXR1cm4gbmV3IE11bHRpUmVzb2x1dGlvbkRhdGFzZXQoZHNjLCByZXNvbHV0aW9ucywgb3B0cylcbiAgICB9Ki9cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgRHJhd2FibGUgfSBmcm9tIFwiLi9EcmF3YWJsZS5qc1wiXG5cbi8qKiBAdHlwZWRlZiB7XCJzcXVhcmVcInxcImNpcmNsZVwifFwiZGlhbW9uZFwifFwiZG9udXRcInxcInRyaWFuZ2xlX3VwXCJ8XCJ0cmlhbmdsZV9kb3duXCJ8XCJ0cmlhbmdsZV9sZWZ0XCJ8XCJ0cmlhbmdsZV9yaWdodFwifFwibm9uZVwifSBTaGFwZSAqL1xuXG4vKipcbiAqIHZpZXdTY2FsZSB0eXBlXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBmcm9tIGEgbGlzdCBvZiBjZWxscywgXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oQXJyYXkuPGltcG9ydCgnLi9EYXRhc2V0LmpzJykuQ2VsbD4sbnVtYmVyLCBudW1iZXIpOip9IFZpZXdTY2FsZSAqL1xuXG4vKipcbiAqIEEgc3R5bGUsIHRvIHNob3cgYSBncmlkIGRhdGFzZXQuXG4gKlxuICogQG1vZHVsZSBjb3JlXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHlsZSBleHRlbmRzIERyYXdhYmxlIHtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge3tmaWx0ZXI/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCk6Ym9vbGVhbiwgb2Zmc2V0PzpmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwsIG51bWJlciwgbnVtYmVyKTp7ZHg6bnVtYmVyLGR5Om51bWJlcn0sIHZpc2libGU/OmZ1bmN0aW9uKG51bWJlcik6Ym9vbGVhbixhbHBoYT86ZnVuY3Rpb24obnVtYmVyKTpudW1iZXIsYmxlbmRPcGVyYXRpb24/OmZ1bmN0aW9uKG51bWJlcik6R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLGRyYXdGdW4/OmZ1bmN0aW9uLHZpZXdTY2FsZT86Vmlld1NjYWxlfX0gb3B0c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKipcbiAgICAgICAgKiBAdHlwZSB7Vmlld1NjYWxlfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgdGhpcy52aWV3U2NhbGUgPSBvcHRzLnZpZXdTY2FsZVxuXG4gICAgICAgIC8qKiBBIGZpbHRlciBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgY2VsbCBsaXN0LCB0byBmaWx0ZXIgb3V0IHNvbWUgY2VsbHMgbm90IHRvIGJlIGRyYXduIChzdWNoIGFzIGZvciBleGFtcGxlIHRoZSBjZWxscyB3aXRoIHZhbHVlPTApLlxuICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsKTpib29sZWFufSAqL1xuICAgICAgICB0aGlzLmZpbHRlciA9IG9wdHMuZmlsdGVyIHx8ICgoKSA9PiB0cnVlKVxuXG4gICAgICAgIC8qKiBBbiBvZmZzZXQuIFRoaXMgaXMgdG8gYWx0ZXIgdGhlIHBvc2l0aW9uIG9mIGFsbCBzeW1ib2xzIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLiBJbiBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsLG51bWJlcixudW1iZXIpOntkeDpudW1iZXIsZHk6bnVtYmVyfX0gKi9cbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvcHRzLm9mZnNldCB8fCAoKGMsIHIsIHopID0+ICh7IGR4OiAwLCBkeTogMCB9KSlcblxuICAgICAgICAvKiogQSBkcmF3IGZ1bmN0aW9uIGZvciB0aGUgc3R5bGUuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbnx1bmRlZmluZWR9ICovXG4gICAgICAgIHRoaXMuZHJhd0Z1biA9IG9wdHMuZHJhd0Z1blxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48aW1wb3J0KFwiLi9MZWdlbmRcIikuTGVnZW5kPn0gKi9cbiAgICAgICAgdGhpcy5sZWdlbmRzID0gW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGNlbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsPn0gY2VsbHMgVGhlIGNlbGxzIHRvIGRyYXcuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhcyBUaGUgY2FudmFzIHdoZXJlIHRvIGRyYXcgdGhlbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBUaGVpciByZXNvbHV0aW9uIChpbiBnZW9ncmFwaGljIHVuaXQpXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYXdGdW4pIHRoaXMuZHJhd0Z1bihjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKVxuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignTWV0aG9kIGRyYXcgbm90IGltcGxlbWVudGVkLicpXG4gICAgfVxuXG4gICAgLy9nZXR0ZXJzIGFuZCBzZXR0ZXJzXG5cbiAgICAvKiogQHJldHVybnMge2Z1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCxudW1iZXIsbnVtYmVyKTp7ZHg6bnVtYmVyLGR5Om51bWJlcn19ICovXG4gICAgZ2V0T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXRcbiAgICB9XG4gICAgLyoqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsLG51bWJlcixudW1iZXIpOntkeDpudW1iZXIsZHk6bnVtYmVyfX0gdmFsIEByZXR1cm5zIHt0aGlzfSAqL1xuICAgIHNldE9mZnNldCh2YWwpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB2YWxcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKiogVXBkYXRlIGxlZ2VuZHMgb2YgdGhlIHN0eWxlLCBpZiBhbnlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgICAqIEByZXR1cm5zIHt0aGlzfSAqL1xuICAgIHVwZGF0ZUxlZ2VuZHMob3B0cykge1xuICAgICAgICBTdHlsZS51cGRhdGVMZWdlbmRzUmVjdXJzaXZlKHRoaXMubGVnZW5kcywgb3B0cylcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBzdGF0aWMgdXBkYXRlTGVnZW5kc1JlY3Vyc2l2ZShsZywgb3B0cykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsZykpIGZvciAoY29uc3QgbGdfIG9mIGxnKSB0aGlzLnVwZGF0ZUxlZ2VuZHNSZWN1cnNpdmUobGdfLCBvcHRzKVxuICAgICAgICBlbHNlIGxnLnVwZGF0ZShvcHRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4vTGVnZW5kXCIpLkxlZ2VuZD59IGxlZ2VuZHNcbiAgICAgKiBAcmV0dXJucyB7dGhpc30gKi9cbiAgICBhZGRMZWdlbmRzKGxlZ2VuZHMpIHtcbiAgICAgICAgZm9yIChsZXQgbGVnZW5kIG9mIGxlZ2VuZHMpXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZHMucHVzaChsZWdlbmQpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXG4vL2ltcG9ydCB7IHRyYW5zaXRpb24gfSBmcm9tIFwiZDMtdHJhbnNpdGlvblwiO1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBjbGFzcyB0byBtYWtlIGEgdG9vbHRpcC5cbiAqIEl0IGlzIGEgZGl2IGVsZW1lbnQsIHdoaWNoIGNhbiBiZSBtb3ZlZCB1bmRlciB0aGUgbW91c2UgcG9pbnRlciBhbmQgZmlsbGVkIHdpdGggc29tZSBpbmZvcm1hdGlvbiBpbiBodG1sLlxuICogQG1vZHVsZSBjb3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUb29sdGlwIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5kaXYgPSBvcHRzLmRpdiB8fCAndG9vbHRpcF9ldXJvc3RhdCdcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMubWF4V2lkdGggPSBvcHRzLm1heFdpZHRoIHx8ICcyMGVtJ1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IG9wdHMuZm9udFNpemUgfHwgJzEuMmVtJ1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gb3B0cy5iYWNrZ3JvdW5kIHx8ICd3aGl0ZSdcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMucGFkZGluZyA9IG9wdHMucGFkZGluZyB8fCAnNXB4J1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5ib3JkZXIgPSBvcHRzLmJvcmRlciB8fCAnMHB4J1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpc1snYm9yZGVyLXJhZGl1cyddID0gb3B0c1snYm9yZGVyLXJhZGl1cyddIHx8ICcwcHgnXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzWydib3gtc2hhZG93J10gPSBvcHRzWydib3gtc2hhZG93J10gfHwgJzVweCA1cHggNXB4IGdyZXknXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzWydmb250LWZhbWlseSddID0gb3B0c1snZm9udC1mYW1pbHknXSB8fCAnSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZidcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gPSBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbiB8fCAxMDBcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueE9mZnNldCA9IG9wdHMueE9mZnNldCB8fCAzMFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy55T2Zmc2V0ID0gb3B0cy55T2Zmc2V0IHx8IDIwXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAvLyBlLmcuIHRvIHByZXZlbnQgbW91c2UgY3Vyc29yIGNvdmVyaW5nIGNlbGwgYmVpbmcgaGlnaGxpZ2h0ZWRcbiAgICAgICAgdGhpcy55TW91c2VPZmZzZXQgPSBvcHRzLnlNb3VzZU9mZnNldCB8fCAwXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnhNb3VzZU9mZnNldCA9IG9wdHMueE1vdXNlT2Zmc2V0IHx8IDBcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gb3B0cy5wYXJlbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHlcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAdHlwZSB7aW1wb3J0KFwiZDMtc2VsZWN0aW9uXCIpLlNlbGVjdGlvbn0gKi9cbiAgICAgICAgdGhpcy50b29sdGlwID0gc2VsZWN0KCcjJyArIHRoaXMuZGl2KVxuXG4gICAgICAgIGlmICh0aGlzLnRvb2x0aXAuZW1wdHkoKSkge1xuICAgICAgICAgICAgLy9jcmVhdGUgdG9vbHRpcCBET00gbm9kZVxuICAgICAgICAgICAgLy8gdGhpcy50b29sdGlwID0gc2VsZWN0KFxuICAgICAgICAgICAgLy8gICAgICcjJyArIHRoaXMucGFyZW50RWxlbWVudC5pZCAmJiB0aGlzLnBhcmVudEVsZW1lbnQuaWQgIT0gJydcbiAgICAgICAgICAgIC8vICAgICAgICAgPyAnIycgKyB0aGlzLnBhcmVudEVsZW1lbnQuaWRcbiAgICAgICAgICAgIC8vICAgICAgICAgOiAnYm9keSdcbiAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcCA9IHNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JykuYXR0cignaWQnLCB0aGlzLmRpdilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaW5pdGlhbGlzZVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ21heC13aWR0aCcsIHRoaXMubWF4V2lkdGgpXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnb3ZlcmZsb3cnLCAnaGlkZGVuJylcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmZvbnRTaXplKVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2JhY2tncm91bmQnLCB0aGlzLmJhY2tncm91bmQpXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgncGFkZGluZycsIHRoaXMucGFkZGluZylcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdib3JkZXInLCB0aGlzLmJvcmRlcilcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdib3JkZXItcmFkaXVzJywgdGhpc1snYm9yZGVyLXJhZGl1cyddKVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2JveC1zaGFkb3cnLCB0aGlzWydib3gtc2hhZG93J10pXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnZm9udC1mYW1pbHknLCB0aGlzWydmb250LWZhbWlseSddKVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJylcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdvcGFjaXR5JywgJzAnKVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ3RleHQtd3JhcCcsICdub3dyYXAnKVxuXG4gICAgICAgIC8vIGFyaWEtbGFiZWxzICh0aGFua3MgdG8gd2FobGF0bGFzKVxuICAgICAgICB0aGlzLnRvb2x0aXAuYXR0cigncm9sZScsICd0b29sdGlwJykuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpXG4gICAgfVxuXG4gICAgLyoqIFNob3cgdGhlIHRvb2x0aXAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMudG9vbHRpcC50cmFuc2l0aW9uKCkuZHVyYXRpb24odGhpcy50cmFuc2l0aW9uRHVyYXRpb24pLnN0eWxlKCdvcGFjaXR5JywgMSlcbiAgICB9XG5cbiAgICAvKiogSGlkZSB0aGUgdG9vbHRpcCAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy50b29sdGlwLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25EdXJhdGlvbikuc3R5bGUoJ29wYWNpdHknLCAwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAqL1xuICAgIGh0bWwoaHRtbCkge1xuICAgICAgICB0aGlzLnRvb2x0aXAuaHRtbChodG1sKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAgYXQgdGhlIG1vdXNlIGV2ZW50IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbihldmVudCkge1xuICAgICAgICBsZXQgcGFyZW50UmVjdCA9IHRoaXMucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICAgIGxldCB4ID0gZXZlbnQucGFnZVggKyB0aGlzLnhPZmZzZXRcbiAgICAgICAgbGV0IHkgPSBldmVudC5wYWdlWSAtIHRoaXMueU9mZnNldFxuXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnbGVmdCcsIHggKyAncHgnKS5zdHlsZSgndG9wJywgeSArICdweCcpXG5cbiAgICAgICAgdGhpcy5lbnN1cmVUb29sdGlwSW5zaWRlQ29udGFpbmVyKGV2ZW50LCBwYXJlbnRSZWN0KVxuICAgIH1cblxuICAgIC8qXG5cdG15Lm1vdXNlb3ZlciA9IGZ1bmN0aW9uIChldmVudCwgaHRtbCkge1xuXHRcdGlmIChodG1sKSBteS5odG1sKGh0bWwpO1xuXHRcdG15LnNldFBvc2l0aW9uKGV2ZW50KTtcblx0XHRteS5zaG93KClcblx0XHQvL3RoaXMuZW5zdXJlVG9vbHRpcEluc2lkZUNvbnRhaW5lcigpO1xuXHR9O1xuXHRcblx0bXkubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0bXkuc2V0UG9zaXRpb24oZXZlbnQpO1xuXHRcdC8vdGhpcy5lbnN1cmVUb29sdGlwSW5zaWRlQ29udGFpbmVyKCk7XG5cdH07XG5cdFxuXHRteS5tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcblx0XHRteS5oaWRlKCk7XG5cdH07Ki9cblxuICAgIHN0eWxlKGssIHYpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIHRoaXMudG9vbHRpcC5zdHlsZShrKVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoaywgdilcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBhdHRyKGssIHYpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIHRoaXMudG9vbHRpcC5hdHRyKGspXG4gICAgICAgIHRoaXMudG9vbHRpcC5hdHRyKGssIHYpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGVuc3VyZVRvb2x0aXBJbnNpZGVDb250YWluZXJcbiAgICAgKiBAZGVzY3JpcHRpb24gUHJldmVudHMgdGhlIHRvb2x0aXAgZnJvbSBvdmVyZmxvd2luZyBvdXQgb2YgdGhlIEFwcCBjb250YWluZXIgKGVuc3VyZXMgdGhhdCB0aGUgdG9vbHRpcCBpcyBpbnNpZGUgdGhlIGdyaWR2aXogY29udGFpbmVyKVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0RPTVJlY3R9IHBhcmVudFJlY3RcbiAgICAgKi9cbiAgICBlbnN1cmVUb29sdGlwSW5zaWRlQ29udGFpbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBwYXJlbnRSZWN0KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy50b29sdGlwLm5vZGUoKVxuICAgICAgICBsZXQgcGFyZW50V2lkdGggPSBwYXJlbnRSZWN0LndpZHRoXG4gICAgICAgIGxldCBwYXJlbnRIZWlnaHQgPSBwYXJlbnRSZWN0LmhlaWdodFxuXG4gICAgICAgIC8vdG9vIGZhciByaWdodFxuICAgICAgICBpZiAobm9kZS5vZmZzZXRMZWZ0ID4gcGFyZW50UmVjdC5sZWZ0ICsgcGFyZW50V2lkdGggLSBub2RlLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGV2ZW50LnggLSBub2RlLmNsaWVudFdpZHRoIC0gdGhpcy54T2Zmc2V0XG4gICAgICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4J1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgbW91c2UgY292ZXJzIHRvb2x0aXBcbiAgICAgICAgICAgIGlmIChub2RlLm9mZnNldExlZnQgKyBub2RlLmNsaWVudFdpZHRoID4gZXZlbnQueCkge1xuICAgICAgICAgICAgICAgIC8vbW92ZSB0b29sdGlwIGxlZnQgc28gaXQgZG9lc250IGNvdmVyIG1vdXNlXG4gICAgICAgICAgICAgICAgbGV0IGxlZnQyID0gZXZlbnQueCAtIG5vZGUuY2xpZW50V2lkdGggLSB0aGlzLnhPZmZzZXRcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBsZWZ0MiArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vZGUuc3R5bGUudG9wID0gbm9kZS5vZmZzZXRUb3AgKyBjb25maWcueU9mZnNldCArIFwicHhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdG9vIGZhciBkb3duXG4gICAgICAgIGlmIChub2RlLm9mZnNldFRvcCArIG5vZGUuY2xpZW50SGVpZ2h0ID4gcGFyZW50UmVjdC50b3AgKyBwYXJlbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUudG9wID0gbm9kZS5vZmZzZXRUb3AgLSBub2RlLmNsaWVudEhlaWdodCArICdweCdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdG9vIGZhciB1cFxuICAgICAgICBpZiAobm9kZS5vZmZzZXRUb3AgPCBwYXJlbnRSZWN0LnRvcCkge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS50b3AgPSBwYXJlbnRSZWN0LnRvcCArIHRoaXMueU9mZnNldCArICdweCdcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHt7IGRpbXM6IG9iamVjdCwgY3JzOiBzdHJpbmcsIHRpbGVTaXplQ2VsbDogbnVtYmVyLCBvcmlnaW5Qb2ludDoge3g6bnVtYmVyLHk6bnVtYmVyfSwgcmVzb2x1dGlvbkdlbzogbnVtYmVyLCB0aWxpbmdCb3VuZHM6aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuRW52ZWxvcGUgfX0gR3JpZEluZm8gKi9cblxuaW1wb3J0IHsgY3N2IH0gZnJvbSAnZDMtZmV0Y2gnXG5pbXBvcnQgeyBEYXRhc2V0IH0gZnJvbSAnLi4vY29yZS9EYXRhc2V0LmpzJ1xuXG4vKipcbiAqIEEgZGF0YXNldCBjb21wb3NlZCBvZiBhIHNpbmdsZSBDU1YgZmlsZSAobm90IHRpbGVkKS5cbiAqXG4gKiBAbW9kdWxlIGRhdGFzZXRcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIENTVkdyaWQgZXh0ZW5kcyBEYXRhc2V0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvTWFwLmpzXCIpLk1hcH0gbWFwIFRoZSBtYXAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoZSBkYXRhc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBkYXRhc2V0IHJlc29sdXRpb24gaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXG4gICAgICogQHBhcmFtIHt7cHJlcHJvY2Vzcz86KGZ1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsKTpib29sZWFuKX19IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXAsIHVybCwgcmVzb2x1dGlvbiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG1hcCwgdXJsLCByZXNvbHV0aW9uLCBvcHRzKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsPn0gKi9cbiAgICAgICAgdGhpcy5jZWxscyA9IFtdXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlICAqL1xuICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ25vdExvYWRlZCdcblxuICAgICAgICAvL2dldCBkYXRhXG4gICAgICAgIHRoaXMuZ2V0RGF0YSh1bmRlZmluZWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBkYXRhIHdpdGhpbiBhIGdlb2dyYXBoaWMgZW52ZWxvcGUuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5FbnZlbG9wZXx1bmRlZmluZWR9IGVcbiAgICAgKi9cbiAgICBnZXREYXRhKGUpIHtcbiAgICAgICAgLy9jaGVjayBpZiBkYXRhIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGlmICh0aGlzLmluZm9Mb2FkaW5nU3RhdHVzICE9ICdub3RMb2FkZWQnKSByZXR1cm4gdGhpc1xuXG4gICAgICAgIC8vbG9hZCBkYXRhXG4gICAgICAgIHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPSAnbG9hZGluZydcbiAgICAgICAgICAgIDsgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY3N2KHRoaXMudXJsKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vY29udmVydCBjb29yZGluYXRlcyBpbiBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnggPSArYy54XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnkgPSArYy55XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL3ByZXByb2Nlc3MvZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2VsbHMgPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5wcmVwcm9jZXNzKGMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gZmFsc2UpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxscy5wdXNoKGMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzID0gZGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIGNoZWNrIGlmIHJlZHJhdyBpcyBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgLy90aGF0IGlzIGlmIHRoZSBkYXRhc2V0IGJlbG9uZ3MgdG8gYSBsYXllciB3aGljaCBpcyB2aXNpYmxlIGF0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWxcblxuICAgICAgICAgICAgICAgICAgICAvL2V4ZWN1dGUgdGhlIGNhbGxiYWNrLCB1c3VhbGx5IGEgZHJhdyBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXApIHRoaXMubWFwLnJlZHJhdygpXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9ICdsb2FkZWQnXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9tYXJrIGFzIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxscyA9IFtdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKVxuXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbCB0aGUgdmlldyBjYWNoZSB3aXRoIGFsbCBjZWxscyB3aGljaCBhcmUgd2l0aGluIGEgZ2VvZ3JhcGhpY2FsIGVudmVsb3BlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5FbnZlbG9wZX0gZXh0R2VvXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlVmlld0NhY2hlKGV4dEdlbykge1xuICAgICAgICAvL2RhdGEgbm90IGxvYWRlZCB5ZXRcbiAgICAgICAgaWYgKCF0aGlzLmNlbGxzKSByZXR1cm5cblxuICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlID0gW11cbiAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHRoaXMuY2VsbHMpIHtcbiAgICAgICAgICAgIGlmICgrY2VsbC54ICsgdGhpcy5yZXNvbHV0aW9uIDwgZXh0R2VvLnhNaW4pIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoK2NlbGwueCAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby54TWF4KSBjb250aW51ZVxuICAgICAgICAgICAgaWYgKCtjZWxsLnkgKyB0aGlzLnJlc29sdXRpb24gPCBleHRHZW8ueU1pbikgY29udGludWVcbiAgICAgICAgICAgIGlmICgrY2VsbC55IC0gdGhpcy5yZXNvbHV0aW9uID4gZXh0R2VvLnlNYXgpIGNvbnRpbnVlXG4gICAgICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlLnB1c2goY2VsbClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgRGF0YXNldCB9IGZyb20gJy4uL2NvcmUvRGF0YXNldC5qcydcblxuLyoqXG4gKiBBIGRhdGFzZXQgY29tcG9zZWQgb2YgY2VsbHMgZGVmaW5lZCBpbiBqYXZhc2NyaXB0LCBvciBsb2FkZWQgb3V0c2lkZSBvZiBncmlkdml6IG1hcC5cbiAqXG4gKiBAbW9kdWxlIGRhdGFzZXRcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIEpTR3JpZCBleHRlbmRzIERhdGFzZXQge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIGRhdGFzZXQgcmVzb2x1dGlvbiBpbiBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjZWxscyBUaGUgY2VsbHMuXG4gICAgICogQHBhcmFtIHt9IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXNvbHV0aW9uLCBjZWxscywgb3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHVuZGVmaW5lZCwgXCJcIiwgcmVzb2x1dGlvbiwgb3B0cylcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGw+fSAqL1xuICAgICAgICB0aGlzLmNlbGxzID0gY2VsbHMgfHwgW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGRhdGEgd2l0aGluIGEgZ2VvZ3JhcGhpYyBlbnZlbG9wZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuRW52ZWxvcGV8dW5kZWZpbmVkfSBlXG4gICAgICovXG4gICAgZ2V0RGF0YShlKSB7IHJldHVybiB0aGlzIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGwgdGhlIHZpZXcgY2FjaGUgd2l0aCBhbGwgY2VsbHMgd2hpY2ggYXJlIHdpdGhpbiBhIGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuRW52ZWxvcGV9IGV4dEdlb1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHVwZGF0ZVZpZXdDYWNoZShleHRHZW8pIHtcbiAgICAgICAgLy9kYXRhIG5vdCBsb2FkZWQgeWV0XG4gICAgICAgIGlmICghdGhpcy5jZWxscykgcmV0dXJuXG5cbiAgICAgICAgdGhpcy5jZWxsc1ZpZXdDYWNoZSA9IFtdXG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB0aGlzLmNlbGxzKSB7XG4gICAgICAgICAgICBpZiAoK2NlbGwueCArIHRoaXMucmVzb2x1dGlvbiA8IGV4dEdlby54TWluKSBjb250aW51ZVxuICAgICAgICAgICAgaWYgKCtjZWxsLnggLSB0aGlzLnJlc29sdXRpb24gPiBleHRHZW8ueE1heCkgY29udGludWVcbiAgICAgICAgICAgIGlmICgrY2VsbC55ICsgdGhpcy5yZXNvbHV0aW9uIDwgZXh0R2VvLnlNaW4pIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoK2NlbGwueSAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby55TWF4KSBjb250aW51ZVxuICAgICAgICAgICAgdGhpcy5jZWxsc1ZpZXdDYWNoZS5wdXNoKGNlbGwpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7eyBkaW1zOiBvYmplY3QsIGNyczogc3RyaW5nLCB0aWxlU2l6ZUNlbGw6IG51bWJlciwgb3JpZ2luUG9pbnQ6IHt4Om51bWJlcix5Om51bWJlcn0sIHJlc29sdXRpb25HZW86IG51bWJlciwgdGlsaW5nQm91bmRzOmltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkVudmVsb3BlIH19IEdyaWRJbmZvICovXG5cbi8vIGludGVybmFsXG5pbXBvcnQgeyBEYXRhc2V0IH0gZnJvbSAnLi4vY29yZS9EYXRhc2V0LmpzJ1xuLy9pbXBvcnQgeyBtb25pdG9yLCBtb25pdG9yRHVyYXRpb24gfSBmcm9tICcuLi91dGlscy9VdGlscy5qcydcblxuLy8gZXh0ZXJuYWxcbmltcG9ydCB7IGpzb24sIGNzdiB9IGZyb20gJ2QzLWZldGNoJ1xuXG4vKipcbiAqIEEgdGlsZWQgZGF0YXNldCwgY29tcG9zZWQgb2YgQ1NWIHRpbGVzLlxuICpcbiAqIEBtb2R1bGUgZGF0YXNldFxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgVGlsZWRHcmlkIGV4dGVuZHMgRGF0YXNldCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL01hcC5qc1wiKS5NYXB9IG1hcCBUaGUgbWFwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgZGF0YXNldC5cbiAgICAgKiBAcGFyYW0ge3twcmVwcm9jZXNzPzooZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0LmpzXCIpLkNlbGwpOmJvb2xlYW4pIH19IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXAsIHVybCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG1hcCwgdXJsLCAwLCBvcHRzKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZ3JpZCBpbmZvIG9iamVjdCwgZnJvbSB0aGUgaW5mby5qc29uIGZpbGUuXG4gICAgICAgICAqICBAdHlwZSB7R3JpZEluZm8gfCB1bmRlZmluZWR9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqICAqL1xuICAgICAgICB0aGlzLmluZm8gPSB1bmRlZmluZWRcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHByaXZhdGUgICovXG4gICAgICAgIHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPSAnbm90TG9hZGVkJ1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2FjaGUgb2YgdGhlIGxvYWRlZCB0aWxlcy4gSXQgaXMgZG91YmxlIGluZGV4ZWQ6IGJ5IHhUIGFuZCB0aGVuIHlULlxuICAgICAgICAgKiBFeGFtcGxlOiB0aGlzLmNhY2hlW3hUXVt5VF0gcmV0dXJucyB0aGUgdGlsZSBhdCBbeFRdW3lUXSBsb2NhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9XG5cbiAgICAgICAgLy9sYXVuY2ggbG9hZGluZ1xuICAgICAgICB0aGlzLmxvYWRJbmZvKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBpbmZvLmpzb24gZnJvbSB0aGUgdXJsLlxuICAgICAqIEByZXR1cm5zIHRoaXNcbiAgICAgKi9cbiAgICBsb2FkSW5mbygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluZm8gJiYgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9PT0gJ25vdExvYWRlZCcpIHtcbiAgICAgICAgICAgIDsgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQganNvbih0aGlzLnVybCArICdpbmZvLmpzb24nKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm8gPSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IGRhdGEucmVzb2x1dGlvbkdlb1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2xvYWRlZCdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAucmVkcmF3KClcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvL21hcmsgYXMgZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPSAnZmFpbGVkJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKClcbiAgICAgICAgfSBlbHNlIGlmICgodGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9PT0gJ2xvYWRlZCcgfHwgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9PT0gJ2ZhaWxlZCcpKVxuICAgICAgICAgICAgdGhpcy5tYXAucmVkcmF3KClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGEgdGlsaW5nIGVudmVsb3BlIGZyb20gYSBnZW9ncmFwaGljYWwgZW52ZWxvcGUuXG4gICAgICogVGhpcyBpcyB0aGUgZnVuY3Rpb24gdG8gdXNlIHRvIGtub3cgd2hpY2ggdGlsZXMgdG8gZG93bmxvYWQgZm9yIGEgZ2VvZ3JhcGhpY2FsIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkVudmVsb3BlfSBlXG4gICAgICogQHJldHVybnMge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkVudmVsb3BlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRUaWxpbmdFbnZlbG9wZShlKSB7XG4gICAgICAgIGlmICghdGhpcy5pbmZvKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRJbmZvKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG8gPSB0aGlzLmluZm8ub3JpZ2luUG9pbnQsXG4gICAgICAgICAgICByID0gdGhpcy5pbmZvLnJlc29sdXRpb25HZW8sXG4gICAgICAgICAgICBzID0gdGhpcy5pbmZvLnRpbGVTaXplQ2VsbFxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4TWluOiBNYXRoLmZsb29yKChlLnhNaW4gLSBwby54KSAvIChyICogcykpLFxuICAgICAgICAgICAgeE1heDogTWF0aC5mbG9vcigoZS54TWF4IC0gcG8ueCkgLyAociAqIHMpKSxcbiAgICAgICAgICAgIHlNaW46IE1hdGguZmxvb3IoKGUueU1pbiAtIHBvLnkpIC8gKHIgKiBzKSksXG4gICAgICAgICAgICB5TWF4OiBNYXRoLmZsb29yKChlLnlNYXggLSBwby55KSAvIChyICogcykpLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBkYXRhIHdpdGhpbiBhIGdlb2dyYXBoaWMgZW52ZWxvcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9HZW9DYW52YXMuanMnKS5FbnZlbG9wZX0gZXh0R2VvXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgZ2V0RGF0YShleHRHZW8pIHtcbiAgICAgICAgLy9UT0RPIGVtcHR5IGNhY2hlIHdoZW4gaXQgZ2V0cyB0b28gYmlnID9cblxuICAgICAgICAvL2NoZWNrIGlmIGluZm8gaGFzIGJlZW4gbG9hZGVkXG4gICAgICAgIGlmICghdGhpcy5pbmZvKSByZXR1cm4gdGhpc1xuXG4gICAgICAgIC8vdGlsZXMgd2l0aGluIHRoZSBzY29wZVxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkVudmVsb3BlfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgY29uc3QgdGIgPSB0aGlzLmdldFRpbGluZ0VudmVsb3BlKGV4dEdlbylcbiAgICAgICAgaWYgKCF0YikgcmV0dXJuIHRoaXNcblxuICAgICAgICAvL2dyaWQgYm91bmRzXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuRW52ZWxvcGV9ICovXG4gICAgICAgIGNvbnN0IGdiID0gdGhpcy5pbmZvLnRpbGluZ0JvdW5kc1xuXG4gICAgICAgIGZvciAobGV0IHhUID0gTWF0aC5tYXgodGIueE1pbiwgZ2IueE1pbik7IHhUIDw9IE1hdGgubWluKHRiLnhNYXgsIGdiLnhNYXgpOyB4VCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5VCA9IE1hdGgubWF4KHRiLnlNaW4sIGdiLnlNaW4pOyB5VCA8PSBNYXRoLm1pbih0Yi55TWF4LCBnYi55TWF4KTsgeVQrKykge1xuICAgICAgICAgICAgICAgIC8vcHJlcGFyZSBjYWNoZVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZVt4VF0pIHRoaXMuY2FjaGVbeFRdID0ge31cblxuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgdGlsZSBleGlzdHMgaW4gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtvYmplY3R9ICovXG4gICAgICAgICAgICAgICAgbGV0IHRpbGUgPSB0aGlzLmNhY2hlW3hUXVt5VF1cbiAgICAgICAgICAgICAgICBpZiAodGlsZSkgY29udGludWVcblxuICAgICAgICAgICAgICAgIC8vbWFyayB0aWxlIGFzIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlW3hUXVt5VF0gPSBcImxvYWRpbmdcIjtcbiAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL3JlcXVlc3QgdGlsZVxuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbD59ICAqL1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbHNcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0LmpzXCIpLkNlbGw+fSAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjc3YodGhpcy51cmwgKyB4VCArICcvJyArIHlUICsgJy5jc3YnKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyoqKiBUaWxlZEdyaWQgcGFyc2Ugc3RhcnQnKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ByZXByb2Nlc3MvZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmVwcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHMgPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLnByZXByb2Nlc3MoYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gZmFsc2UpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzID0gZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJ3ByZXByb2Nlc3MgLyBmaWx0ZXInKVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYXJrIGFzIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZVt4VF1beVRdID0gJ2ZhaWxlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9zdG9yZSB0aWxlIGluIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaWxlIGluZm8gaW5rbm93bicpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWxlXyA9IGdldEdyaWRUaWxlKGNlbGxzLCB4VCwgeVQsIHRoaXMuaW5mbylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZVt4VF1beVRdID0gdGlsZV9cblxuICAgICAgICAgICAgICAgICAgICAvL2lmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJ3N0b3JhZ2UnKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgbm8gcmVkcmF3IGlzIHNwZWNpZmllZCwgdGhlbiBsZWF2ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcC5yZWRyYXcoKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgcmVkcmF3IGlzIHJlYWxseSBuZWVkZWQsIHRoYXQgaXMgaWY6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gdGhlIGRhdGFzZXQgYmVsb25ncyB0byBhIGxheWVyIHdoaWNoIGlzIHZpc2libGUgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVkcmF3ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgLy9nbyB0aHJvdWdoIHRoZSBsYXllcnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMubWFwLmdldFpvb20oKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxheSBvZiB0aGlzLm1hcC5sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXkudmlzaWJsZSAmJiAhbGF5LnZpc2libGUoeikpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxheS5nZXREYXRhc2V0KSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheS5nZXREYXRhc2V0KHopICE9IHRoaXMpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZvdW5kIG9uZSBsYXllci4gTm8gbmVlZCB0byBzZWVrIG1vcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWRyYXcgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignY2hlY2sgcmVkcmF3IDEnKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVkcmF3KSByZXR1cm5cblxuICAgICAgICAgICAgICAgICAgICAvLyAyLiB0aGUgdGlsZSBpcyB3aXRoaW4gdGhlIHZpZXcsIHRoYXQgaXMgaXRzIGdlbyBlbnZlbG9wZSBpbnRlcnNlY3RzIHRoZSB2aWV3ZXIgZ2VvIGVudmVsb3BlLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnYgPSB0aGlzLm1hcC51cGRhdGVFeHRlbnRHZW8oKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnZUID0gdGlsZV8uZXh0R2VvXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnYueE1heCA8PSBlbnZULnhNaW4pIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBpZiAoZW52LnhNaW4gPj0gZW52VC54TWF4KSByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudi55TWF4IDw9IGVudlQueU1pbikgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnYueU1pbiA+PSBlbnZULnlNYXgpIHJldHVyblxuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignY2hlY2sgcmVkcmF3IDInKVxuICAgICAgICAgICAgICAgICAgICAvL2lmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyoqKiBUaWxlZEdyaWQgcGFyc2UgZW5kJylcblxuICAgICAgICAgICAgICAgICAgICAvL3JlZHJhd1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcC5yZWRyYXcoKVxuICAgICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGwgdGhlIHZpZXcgY2FjaGUgd2l0aCBhbGwgY2VsbHMgd2hpY2ggYXJlIHdpdGhpbiBhIGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkVudmVsb3BlfSBleHRHZW9cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVWaWV3Q2FjaGUoZXh0R2VvKSB7XG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuY2VsbHNWaWV3Q2FjaGUgPSBbXVxuXG4gICAgICAgIC8vY2hlY2sgaWYgaW5mbyBoYXMgYmVlbiBsb2FkZWRcbiAgICAgICAgaWYgKCF0aGlzLmluZm8pIHJldHVyblxuXG4gICAgICAgIC8vdGlsZXMgd2l0aGluIHRoZSBzY29wZVxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkVudmVsb3BlfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgY29uc3QgdGIgPSB0aGlzLmdldFRpbGluZ0VudmVsb3BlKGV4dEdlbylcbiAgICAgICAgaWYgKCF0YikgcmV0dXJuXG5cbiAgICAgICAgLy9ncmlkIGJvdW5kc1xuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkVudmVsb3BlfSAqL1xuICAgICAgICBjb25zdCBnYiA9IHRoaXMuaW5mby50aWxpbmdCb3VuZHNcblxuICAgICAgICBmb3IgKGxldCB4VCA9IE1hdGgubWF4KHRiLnhNaW4sIGdiLnhNaW4pOyB4VCA8PSBNYXRoLm1pbih0Yi54TWF4LCBnYi54TWF4KTsgeFQrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlW3hUXSkgY29udGludWVcbiAgICAgICAgICAgIGZvciAobGV0IHlUID0gTWF0aC5tYXgodGIueU1pbiwgZ2IueU1pbik7IHlUIDw9IE1hdGgubWluKHRiLnlNYXgsIGdiLnlNYXgpOyB5VCsrKSB7XG4gICAgICAgICAgICAgICAgLy9nZXQgdGlsZVxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7b2JqZWN0fSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLmNhY2hlW3hUXVt5VF1cbiAgICAgICAgICAgICAgICBpZiAoIXRpbGUgfHwgdHlwZW9mIHRpbGUgPT09ICdzdHJpbmcnKSBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgLy9nZXQgY2VsbHNcbiAgICAgICAgICAgICAgICAvL3RoaXMuY2VsbHNWaWV3Q2FjaGUgPSB0aGlzLmNlbGxzVmlld0NhY2hlLmNvbmNhdCh0aWxlLmNlbGxzKVxuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHRpbGUuY2VsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCtjZWxsLnggKyB0aGlzLnJlc29sdXRpb24gPCBleHRHZW8ueE1pbikgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCtjZWxsLnggLSB0aGlzLnJlc29sdXRpb24gPiBleHRHZW8ueE1heCkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCtjZWxsLnkgKyB0aGlzLnJlc29sdXRpb24gPCBleHRHZW8ueU1pbikgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCtjZWxsLnkgLSB0aGlzLnJlc29sdXRpb24gPiBleHRHZW8ueU1heCkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxsc1ZpZXdDYWNoZS5wdXNoKGNlbGwpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRHcmlkVGlsZShjZWxscywgeFQsIHlULCBncmlkSW5mbykge1xuXG4gICAgY29uc3QgdGlsZSA9IHt9XG5cbiAgICAvKiogQHR5cGUge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD59ICovXG4gICAgdGlsZS5jZWxscyA9IGNlbGxzXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGlsZS54ID0geFRcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aWxlLnkgPSB5VFxuXG4gICAgY29uc3QgciA9IGdyaWRJbmZvLnJlc29sdXRpb25HZW9cbiAgICBjb25zdCBzID0gZ3JpZEluZm8udGlsZVNpemVDZWxsXG5cbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzXCIpLkVudmVsb3BlfSAqL1xuICAgIHRpbGUuZXh0R2VvID0ge1xuICAgICAgICB4TWluOiBncmlkSW5mby5vcmlnaW5Qb2ludC54ICsgciAqIHMgKiB0aWxlLngsXG4gICAgICAgIHhNYXg6IGdyaWRJbmZvLm9yaWdpblBvaW50LnggKyByICogcyAqICh0aWxlLnggKyAxKSxcbiAgICAgICAgeU1pbjogZ3JpZEluZm8ub3JpZ2luUG9pbnQueSArIHIgKiBzICogdGlsZS55LFxuICAgICAgICB5TWF4OiBncmlkSW5mby5vcmlnaW5Qb2ludC55ICsgciAqIHMgKiAodGlsZS55ICsgMSksXG4gICAgfVxuXG4gICAgLy9jb252ZXJ0IGNlbGwgY29vcmRpbmF0ZXMgaW50byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXNcbiAgICBmb3IgKGxldCBjZWxsIG9mIHRpbGUuY2VsbHMpIHtcbiAgICAgICAgY2VsbC54ID0gdGlsZS5leHRHZW8ueE1pbiArIGNlbGwueCAqIHJcbiAgICAgICAgY2VsbC55ID0gdGlsZS5leHRHZW8ueU1pbiArIGNlbGwueSAqIHJcbiAgICB9XG5cbiAgICByZXR1cm4gdGlsZVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG4vLyB0aGUgYXBwbGljYXRpb25cbmV4cG9ydCB7IE1hcCB9IGZyb20gJy4vY29yZS9NYXAuanMnXG5leHBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuL2NvcmUvR2VvQ2FudmFzLmpzJ1xuZXhwb3J0IHsgU3R5bGUgfSBmcm9tICcuL2NvcmUvU3R5bGUuanMnXG5leHBvcnQgeyBMYXllciB9IGZyb20gJy4vY29yZS9MYXllci5qcydcbmV4cG9ydCB7IE11bHRpUmVzb2x1dGlvbkRhdGFzZXQgfSBmcm9tICcuL2NvcmUvTXVsdGlSZXNvbHV0aW9uRGF0YXNldC5qcydcblxuLy8gZXhwb3J0IGRhdGFzZXQgdHlwZXNcbmV4cG9ydCB7IFRpbGVkR3JpZCB9IGZyb20gJy4vZGF0YXNldC9UaWxlZEdyaWQuanMnXG5leHBvcnQgeyBDU1ZHcmlkIH0gZnJvbSAnLi9kYXRhc2V0L0NTVkdyaWQuanMnXG5leHBvcnQgeyBKU0dyaWQgfSBmcm9tICcuL2RhdGFzZXQvSlNHcmlkLmpzJ1xuXG4vLyBleHBvcnQgc3R5bGVzXG5leHBvcnQgeyBTaGFwZUNvbG9yU2l6ZVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9TaGFwZUNvbG9yU2l6ZVN0eWxlLmpzJ1xuZXhwb3J0IHsgU3Ryb2tlU3R5bGUgfSBmcm9tICcuL3N0eWxlL1N0cm9rZVN0eWxlLmpzJ1xuZXhwb3J0IHsgSm95UGxvdFN0eWxlIH0gZnJvbSAnLi9zdHlsZS9Kb3lQbG90U3R5bGUuanMnXG5leHBvcnQgeyBDb21wb3NpdGlvblN0eWxlIH0gZnJvbSAnLi9zdHlsZS9Db21wb3NpdGlvblN0eWxlLmpzJ1xuZXhwb3J0IHsgU2VnbWVudFN0eWxlIH0gZnJvbSAnLi9zdHlsZS9TZWdtZW50U3R5bGUuanMnXG5leHBvcnQgeyBUZXh0U3R5bGUgfSBmcm9tICcuL3N0eWxlL1RleHRTdHlsZS5qcydcbmV4cG9ydCB7IFBpbGxhclN0eWxlIH0gZnJvbSAnLi9zdHlsZS9QaWxsYXJTdHlsZS5qcydcbmV4cG9ydCB7IFNpZGVTdHlsZSB9IGZyb20gJy4vc3R5bGUvU2lkZVN0eWxlLmpzJ1xuLy9leHBvcnQgeyBDb250b3VyU3R5bGUgfSBmcm9tICcuL3N0eWxlL0NvbnRvdXJTdHlsZS5qcydcbmV4cG9ydCB7IFNpZGVDYXRlZ29yeVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9TaWRlQ2F0ZWdvcnlTdHlsZS5qcydcbmV4cG9ydCB7IERvdERlbnNpdHlTdHlsZSB9IGZyb20gJy4vc3R5bGUvRG90RGVuc2l0eVN0eWxlLmpzJ1xuZXhwb3J0IHsgVGFuYWthU3R5bGUgfSBmcm9tICcuL3N0eWxlL1RhbmFrYVN0eWxlLmpzJ1xuZXhwb3J0IHsgTGVnb1N0eWxlIH0gZnJvbSAnLi9zdHlsZS9MZWdvU3R5bGUuanMnXG5leHBvcnQgeyBTcXVhcmVDb2xvcldlYkdMU3R5bGUgfSBmcm9tICcuL3N0eWxlL1NxdWFyZUNvbG9yV2ViR0xTdHlsZS5qcydcbmV4cG9ydCB7IFNxdWFyZUNvbG9yQ2F0ZWdvcnlXZWJHTFN0eWxlIH0gZnJvbSAnLi9zdHlsZS9TcXVhcmVDb2xvckNhdGVnb3J5V2ViR0xTdHlsZS5qcydcbmV4cG9ydCB7IE1vc2FpY1N0eWxlIH0gZnJvbSAnLi9zdHlsZS9Nb3NhaWNTdHlsZS5qcydcbmV4cG9ydCB7IE5pbmphU3RhclN0eWxlIH0gZnJvbSAnLi9zdHlsZS9OaW5qYVN0YXJTdHlsZS5qcydcbmV4cG9ydCB7IFRpbWVTZXJpZXNTdHlsZSB9IGZyb20gJy4vc3R5bGUvVGltZVNlcmllc1N0eWxlLmpzJ1xuZXhwb3J0IHsgSXNvRmVuY2VTdHlsZSB9IGZyb20gJy4vc3R5bGUvSXNvRmVuY2VTdHlsZS5qcydcbmV4cG9ydCB7IEltYWdlU3R5bGUgfSBmcm9tICcuL3N0eWxlL0ltYWdlU3R5bGUuanMnXG5cbi8vIGV4cG9ydCBhZGRpdGlvbmFsIGxheWVyc1xuZXhwb3J0IHsgR3JpZExheWVyIH0gZnJvbSAnLi9sYXllci9HcmlkTGF5ZXIuanMnXG5leHBvcnQgeyBCYWNrZ3JvdW5kTGF5ZXIgfSBmcm9tICcuL2xheWVyL0JhY2tncm91bmRMYXllci5qcydcbmV4cG9ydCB7IEJhY2tncm91bmRMYXllcldNUyB9IGZyb20gJy4vbGF5ZXIvQmFja2dyb3VuZExheWVyV01TLmpzJ1xuZXhwb3J0IHsgQmFja2dyb3VuZExheWVySW1hZ2UgfSBmcm9tICcuL2xheWVyL0JhY2tncm91bmRMYXllckltYWdlLmpzJ1xuZXhwb3J0IHsgTGFiZWxMYXllciB9IGZyb20gJy4vbGF5ZXIvTGFiZWxMYXllci5qcydcbmV4cG9ydCB7IEdlb0pTT05MYXllciB9IGZyb20gJy4vbGF5ZXIvR2VvSlNPTkxheWVyLmpzJ1xuXG4vLyBleHBvcnQgbGVnZW5kc1xuZXhwb3J0IHsgQ29sb3JMZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC9Db2xvckxlZ2VuZC5qcydcbmV4cG9ydCB7IENvbG9yRGlzY3JldGVMZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC9Db2xvckRpc2NyZXRlTGVnZW5kLmpzJ1xuZXhwb3J0IHsgQ29sb3JDYXRlZ29yeUxlZ2VuZCB9IGZyb20gJy4vbGVnZW5kL0NvbG9yQ2F0ZWdvcnlMZWdlbmQuanMnXG5leHBvcnQgeyBTaXplTGVnZW5kLCBzaXplTGVnZW5kLCBzaXplTGVnZW5kVmlld1NjYWxlLCBzaXplRGlzY3JldGVMZWdlbmQsIHNpemVEaXNjcmV0ZVZpZXdTY2FsZUxlZ2VuZCB9IGZyb20gJy4vbGVnZW5kL1NpemVMZWdlbmQuanMnXG5leHBvcnQgeyBPcmllbnRhdGlvbkxlZ2VuZCwgb3JpZW50YXRpb25MZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC9PcmllbnRhdGlvbkxlZ2VuZC5qcydcbmV4cG9ydCB7IFRyaXZhcmlhdGVMZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC9Ucml2YXJpYXRlTGVnZW5kLmpzJ1xuXG4vLyBleHBvcnQgeyBnb1RvU3RyYWlnaHQsIHpvb21UbyB9IGZyb20gXCIuL3V0aWxzL3pvb21VdGlsc1wiXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL3N0cmV0Y2hpbmcuanMnXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL3NjYWxlLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy90cml2YXJpYXRlLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9jaGVybm9mZi5qcydcbmV4cG9ydCB7IG5pY2UsIGxvYWRJbWFnZSB9IGZyb20gJy4vdXRpbHMvdXRpbHMuanMnXG5cbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4vY29yZS9HZW9DYW52YXMuanMnXG5leHBvcnQgY29uc3QgZ2V0UGFyYW1ldGVyQnlOYW1lID0gR2VvQ2FudmFzLmdldFBhcmFtZXRlckJ5TmFtZVxuXG4vLyBzZXQgZGVmYXVsdCBkMyBsb2NhbGVcbmltcG9ydCB7IGZvcm1hdERlZmF1bHRMb2NhbGUgfSBmcm9tICdkMy1mb3JtYXQnXG5mb3JtYXREZWZhdWx0TG9jYWxlKHtcbiAgICBkZWNpbWFsOiAnLicsXG4gICAgdGhvdXNhbmRzOiAnICcsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogWycnLCAn4oKsJ10sXG59KVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2NvcmUvTGF5ZXIuanMnXG5cbi8qKlxuICpcbiAqIEEgbWFwIGJhY2tncm91bmQgbGF5ZXIgaW4gXCJTbGlwcHkgbWFwXCIgWFlaIHN0YW5kYXJkLlxuICogU2VlIGh0dHBzOi8vd2lraS5vcGVuc3RyZWV0bWFwLm9yZy93aWtpL1NsaXBweV9tYXBfdGlsZW5hbWVzXG4gKiBodHRwczovL3d3dy5tYXB0aWxlci5jb20vZ29vZ2xlLW1hcHMtY29vcmRpbmF0ZXMtdGlsZS1ib3VuZHMtcHJvamVjdGlvbi8jNi8yNy44OC80NC40OFxuICogXG4gKiBAbW9kdWxlIGxheWVyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBCYWNrZ3JvdW5kTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIFRoZSBpbWFnZSBjYWNoZSwgaW5kZXhlZCBieSB6L3kveCAqL1xuICAgICAgICB0aGlzLmNhY2hlID0ge31cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy51cmwgPSBvcHRzLnVybFxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsbnVtYmVyKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMudXJsRnVuID0gb3B0cy51cmxGdW4gfHwgKCh4LCB5LCB6KSA9PiB0aGlzLnVybCArIHogKyAnLycgKyB4ICsgJy8nICsgeSArICcucG5nJylcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgICAgICB0aGlzLnJlc29sdXRpb25zID0gb3B0cy5yZXNvbHV0aW9uc1xuICAgICAgICBpZiAoIXRoaXMucmVzb2x1dGlvbnMgfHwgdGhpcy5yZXNvbHV0aW9ucy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVzb2x1dGlvbnMgcHJvdmlkZWQgZm9yIGJhY2tncm91bmQgbGF5ZXInKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm5iUGl4ID0gb3B0cy5uYlBpeCB8fCAyNTZcbiAgICAgICAgLyoqIENSUyBjb29yZGluYXRlcyBvZiB0b3AgbGVmdCBjb3JuZXJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgICAgICB0aGlzLm9yaWdpbiA9IG9wdHMub3JpZ2luIHx8IFswLCAwXVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy56MCA9IG9wdHMuejAgfHwgMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB6L3gveSBjYWNoZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fHN0cmluZ3x1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQoeiwgeCwgeSkge1xuICAgICAgICBsZXQgZCA9IHRoaXMuY2FjaGVbel1cbiAgICAgICAgaWYgKCFkKSByZXR1cm5cbiAgICAgICAgZCA9IGRbeF1cbiAgICAgICAgaWYgKCFkKSByZXR1cm5cbiAgICAgICAgcmV0dXJuIGRbeV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgei94L3kgY2FjaGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8c3RyaW5nfSBpbWdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gelxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHV0KGltZywgeiwgeCwgeSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVbel0pIHRoaXMuY2FjaGVbel0gPSB7fVxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVbel1beF0pIHRoaXMuY2FjaGVbel1beF0gPSB7fVxuICAgICAgICB0aGlzLmNhY2hlW3pdW3hdW3ldID0gaW1nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhcyBUaGUgY2FudmFzIHdoZXJlIHRvIGRyYXcgdGhlIGxheWVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGRyYXcoZ2VvQ2FudmFzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdXRpb25zIHx8IHRoaXMucmVzb2x1dGlvbnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHJlc29sdXRpb25zIHByb3ZpZGVkIGZvciBiYWNrZ3JvdW5kIGxheWVyJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcbiAgICAgICAgY29uc3QgeDAgPSB0aGlzLm9yaWdpblswXSxcbiAgICAgICAgICAgIHkwID0gdGhpcy5vcmlnaW5bMV1cblxuICAgICAgICAvL2dldCB6b29tIGxldmVsIGFuZCByZXNvbHV0aW9uXG4gICAgICAgIGxldCB6XyA9IDBcbiAgICAgICAgZm9yICh6XyA9IDA7IHpfIDwgdGhpcy5yZXNvbHV0aW9ucy5sZW5ndGg7IHpfKyspIGlmICh0aGlzLnJlc29sdXRpb25zW3pfXSA8IHopIGJyZWFrXG4gICAgICAgIHpfIC09IDFcbiAgICAgICAgel8gPSBNYXRoLm1heCgwLCB6XylcbiAgICAgICAgel8gPSBNYXRoLm1pbih6XywgdGhpcy5yZXNvbHV0aW9ucy5sZW5ndGggLSAxKVxuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMucmVzb2x1dGlvbnMubGVuZ3RoLCB6KVxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnJlc29sdXRpb25zW3pfXVxuXG4gICAgICAgIHpfICs9IHRoaXMuejBcblxuICAgICAgICBjb25zdCBzaXplRyA9IHRoaXMubmJQaXggKiByZXNcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHNpemVHIC8gelxuXG4gICAgICAgIC8vZ2V0IHRpbGUgbnVtYmVyc1xuICAgICAgICBjb25zdCB4R2VvVG9UTVMgPSAoeCkgPT4gTWF0aC5jZWlsKCh4IC0geDApIC8gc2l6ZUcpXG4gICAgICAgIGNvbnN0IHlHZW9Ub1RNUyA9ICh5KSA9PiBNYXRoLmNlaWwoLSh5IC0geTApIC8gc2l6ZUcpXG4gICAgICAgIGNvbnN0IHhNaW4gPSB4R2VvVG9UTVMoZ2VvQ2FudmFzLmV4dEdlby54TWluKSAtIDFcbiAgICAgICAgY29uc3QgeE1heCA9IHhHZW9Ub1RNUyhnZW9DYW52YXMuZXh0R2VvLnhNYXgpXG4gICAgICAgIGNvbnN0IHlNYXggPSB5R2VvVG9UTVMoZ2VvQ2FudmFzLmV4dEdlby55TWluKVxuICAgICAgICBjb25zdCB5TWluID0geUdlb1RvVE1TKGdlb0NhbnZhcy5leHRHZW8ueU1heCkgLSAxXG5cbiAgICAgICAgLy9oYW5kbGUgaW1hZ2VzXG4gICAgICAgIGZvciAobGV0IHggPSB4TWluOyB4IDwgeE1heDsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0geU1pbjsgeSA8IHlNYXg7IHkrKykge1xuICAgICAgICAgICAgICAgIC8vZ2V0IGltYWdlXG4gICAgICAgICAgICAgICAgbGV0IGltZyA9IHRoaXMuZ2V0KHpfLCB4LCB5KVxuXG4gICAgICAgICAgICAgICAgLy9sb2FkIGltYWdlXG4gICAgICAgICAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXQoaW1nLCB6XywgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5yZWRyYXcoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlIHdoZW4gbm8gaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHV0KCdmYWlsZWQnLCB6XywgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gdGhpcy51cmxGdW4oeCwgeSwgel8pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9jYXNlIHdoZW4gbm8gaW1hZ2VcbiAgICAgICAgICAgICAgICBpZiAoaW1nID09PSAnZmFpbGVkJykgY29udGludWVcbiAgICAgICAgICAgICAgICBpZiAoIShpbWcgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbWcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWcud2lkdGggPT0gMCB8fCBpbWcuaGVpZ2h0ID09IDApIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICAvL2RyYXcgaW1hZ2VcbiAgICAgICAgICAgICAgICBjb25zdCB4R2VvID0geDAgKyB4ICogc2l6ZUdcbiAgICAgICAgICAgICAgICBjb25zdCB5R2VvID0geTAgLSB5ICogc2l6ZUdcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZHJhd0ltYWdlKGltZywgZ2VvQ2FudmFzLmdlb1RvUGl4WCh4R2VvKSwgZ2VvQ2FudmFzLmdlb1RvUGl4WSh5R2VvKSwgc2l6ZSwgc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgLy9jZy5jdHguZHJhd0ltYWdlKGltZywgeEdlbywgeUdlbywgc2l6ZUcsIC1zaXplRylcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2NvcmUvTGF5ZXIuanMnXG5cbi8qKlxuICpcbiAqIEEgbWFwIGJhY2tncm91bmQgbGF5ZXIgY29tcG9zZWQgb2YgYSBzaW5nbGUgaW1hZ2UgZmlsZSwgZ2VvbG9jYXRlZC5cbiAqIFxuICogQG1vZHVsZSBsYXllclxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgQmFja2dyb3VuZExheWVySW1hZ2UgZXh0ZW5kcyBMYXllciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIFRoZSBpbWFnZSBmaWxlIFVSTFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnVybCA9IG9wdHMudXJsXG5cbiAgICAgICAgLyoqIFRoZSBpbWFnZSBsZWZ0IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy54TWluID0gb3B0cy54TWluIHx8IDA7XG4gICAgICAgIC8qKiBUaGUgaW1hZ2UgdG9wIGNvb3JkaW5hdGVcbiAgICAgICAgICogIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueU1heCA9IG9wdHMueU1heCB8fCAwO1xuXG4gICAgICAgIC8qKiBUaGUgaW1hZ2Ugd2lkdGgsIGluIGdlbyB1bml0XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8IDIwMDAwXG4gICAgICAgIC8qKiBUaGUgaW1hZ2UgaGVpZ2h0LCBpbiBnZW8gdW5pdFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8IDIwMDAwXG5cbiAgICAgICAgLyoqIFRoZSBpbWFnZSBvYmplY3RcbiAgICAgICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8dW5kZWZpbmVkfSAqL1xuICAgICAgICB0aGlzLmltZyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGUgbGF5ZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZHJhdyhnZW9DYW52YXMpIHtcblxuICAgICAgICAvL3VwZGF0ZSBtYXAgZXh0ZW50XG4gICAgICAgIC8vZ2VvQ2FudmFzLnVwZGF0ZUV4dGVudEdlbygwKVxuXG4gICAgICAgIGlmICh0aGlzLmltZykge1xuICAgICAgICAgICAgLy90aGUgaW1hZ2Ugd2FzIGFscmVhZHkgZG93bmxvYWRlZDogZHJhdyBpdFxuXG4gICAgICAgICAgICAvL2NvbXB1dGUgc2NyZWVuIGNvb3JkaW5hdGVzIGFuZCBzaXplIHJhdGlvXG4gICAgICAgICAgICBjb25zdCB4ID0gZ2VvQ2FudmFzLmdlb1RvUGl4WCh0aGlzLnhNaW4pXG4gICAgICAgICAgICBjb25zdCB5ID0gZ2VvQ2FudmFzLmdlb1RvUGl4WSh0aGlzLnlNYXgpXG4gICAgICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLmdldFZpZXcoKS56XG5cbiAgICAgICAgICAgIC8vZHJhdyBpbWFnZVxuICAgICAgICAgICAgZ2VvQ2FudmFzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5kcmF3SW1hZ2UodGhpcy5pbWcsIHgsIHksIHRoaXMud2lkdGggLyB6LCB0aGlzLmhlaWdodCAvIHopXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vcmV0cmlldmUgaW1hZ2VcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmltZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1nID0gbmV3IEltYWdlKClcbiAgICAgICAgICAgICAgICB0aGlzLmltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5yZWRyYXcoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL2Nhc2Ugd2hlbiBubyBpbWFnZVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgcmV0cmlldmUgYmFja2dyb3VuZCBpbWFnZSBmcm9tXCIsIHRoaXMudXJsKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9zZXQgVVJMIHRvIGxhdW5jaCB0aGUgZG93bmxvYWRcbiAgICAgICAgICAgIHRoaXMuaW1nLnNyYyA9IHRoaXMudXJsXG4gICAgICAgIH1cblxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9jb3JlL0xheWVyLmpzJ1xuXG4vKipcbiAqXG4gKiBBIG1hcCBXTVMgYmFja2dyb3VuZCBsYXllci5cbiAqIFxuICogQG1vZHVsZSBsYXllclxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgQmFja2dyb3VuZExheWVyV01TIGV4dGVuZHMgTGF5ZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnVybCA9IG9wdHMudXJsXG5cbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fHVuZGVmaW5lZH0gKi9cbiAgICAgICAgdGhpcy5pbWcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICB0aGlzLnhNaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgdGhpcy54TWF4ID0gdW5kZWZpbmVkO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgICAgIHRoaXMueU1pbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICB0aGlzLnlNYXggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqIENoZWNrIGlmIHRoZSB2aWV3IGhhcyBtb3ZlZCBhbmQgYSBuZXcgaW1hZ2UgbmVlZHMgdG8gYmUgcmV0cmlldmVkLlxuICAgICAqIEBwcml2YXRlICovXG4gICAgaGFzTW92ZWQoZXh0R2VvKSB7XG4gICAgICAgIGlmICgoZXh0R2VvLnhNaW4pICE9IHRoaXMueE1pbikgcmV0dXJuIHRydWVcbiAgICAgICAgZWxzZSBpZiAoKGV4dEdlby54TWF4KSAhPSB0aGlzLnhNYXgpIHJldHVybiB0cnVlXG4gICAgICAgIGVsc2UgaWYgKChleHRHZW8ueU1pbikgIT0gdGhpcy55TWluKSByZXR1cm4gdHJ1ZVxuICAgICAgICBlbHNlIGlmICgoZXh0R2VvLnlNYXgpICE9IHRoaXMueU1heCkgcmV0dXJuIHRydWVcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2VcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXNcIikuR2VvQ2FudmFzfSBnZW9DYW52YXMgVGhlIGNhbnZhcyB3aGVyZSB0byBkcmF3IHRoZSBsYXllci5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBkcmF3KGdlb0NhbnZhcykge1xuXG4gICAgICAgIC8vdXBkYXRlIG1hcCBleHRlbnRcbiAgICAgICAgZ2VvQ2FudmFzLnVwZGF0ZUV4dGVudEdlbygwKVxuXG4gICAgICAgIGlmICghdGhpcy5oYXNNb3ZlZChnZW9DYW52YXMuZXh0R2VvKSAmJiB0aGlzLmltZykge1xuICAgICAgICAgICAgLy90aGUgbWFwIGRpZCBub3QgbW92ZSBhbmQgdGhlIGltYWdlIHdhcyBhbHJlYWR5IGRvd25sb2FkZWQ6IGRyYXcgdGhlIGltYWdlXG4gICAgICAgICAgICBnZW9DYW52YXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmRyYXdJbWFnZSh0aGlzLmltZywgMCwgMCwgZ2VvQ2FudmFzLncsIGdlb0NhbnZhcy5oKVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3RoZSBtYXAgbW92ZWQ6IHJldHJpZXZlIG5ldyBpbWFnZVxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdGhpcy54TWluID0gZ2VvQ2FudmFzLmV4dEdlby54TWluXG4gICAgICAgICAgICB0aGlzLnhNYXggPSBnZW9DYW52YXMuZXh0R2VvLnhNYXhcbiAgICAgICAgICAgIHRoaXMueU1pbiA9IGdlb0NhbnZhcy5leHRHZW8ueU1pblxuICAgICAgICAgICAgdGhpcy55TWF4ID0gZ2VvQ2FudmFzLmV4dEdlby55TWF4XG5cbiAgICAgICAgICAgIC8vYnVpbGQgV01TIFVSTFxuICAgICAgICAgICAgY29uc3QgdXJsID0gW11cbiAgICAgICAgICAgIHVybC5wdXNoKHRoaXMudXJsKVxuICAgICAgICAgICAgdXJsLnB1c2goXCImd2lkdGg9XCIpXG4gICAgICAgICAgICB1cmwucHVzaChnZW9DYW52YXMudylcbiAgICAgICAgICAgIHVybC5wdXNoKFwiJmhlaWdodD1cIilcbiAgICAgICAgICAgIHVybC5wdXNoKGdlb0NhbnZhcy5oKVxuICAgICAgICAgICAgLy9iYm94OiB4bWluIHltaW4geG1heCB5bWF4XG4gICAgICAgICAgICB1cmwucHVzaChcIiZiYm94PVwiKVxuICAgICAgICAgICAgdXJsLnB1c2goZ2VvQ2FudmFzLmV4dEdlby54TWluKVxuICAgICAgICAgICAgdXJsLnB1c2goXCIsXCIpXG4gICAgICAgICAgICB1cmwucHVzaChnZW9DYW52YXMuZXh0R2VvLnlNaW4pXG4gICAgICAgICAgICB1cmwucHVzaChcIixcIilcbiAgICAgICAgICAgIHVybC5wdXNoKGdlb0NhbnZhcy5leHRHZW8ueE1heClcbiAgICAgICAgICAgIHVybC5wdXNoKFwiLFwiKVxuICAgICAgICAgICAgdXJsLnB1c2goZ2VvQ2FudmFzLmV4dEdlby55TWF4KVxuXG4gICAgICAgICAgICBjb25zdCB1cmxTID0gdXJsLmpvaW4oXCJcIilcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codXJsUylcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmltZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1nID0gbmV3IEltYWdlKClcbiAgICAgICAgICAgICAgICB0aGlzLmltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5yZWRyYXcoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL2Nhc2Ugd2hlbiBubyBpbWFnZVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgcmV0cmlldmUgV01TIGJhY2tncm91bmQgaW1hZ2UgZnJvbVwiLCB1cmxTKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9zZXQgVVJMIHRvIGxhdW5jaCB0aGUgZG93bmxvYWRcbiAgICAgICAgICAgIHRoaXMuaW1nLnNyYyA9IHVybFNcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2NvcmUvTGF5ZXIuanMnXG5pbXBvcnQgeyBqc29uIH0gZnJvbSAnZDMtZmV0Y2gnXG5cbi8qKlxuICogQG1vZHVsZSBsYXllclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgR2VvSlNPTkxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnVybCA9IG9wdHMudXJsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcHJlcHJvY2VzcyB0byBydW4gb24gZWFjaCBmZWF0dXJlIGFmdGVyIGxvYWRpbmcuXG4gICAgICAgICAqIEl0IGNhbiBiZSB1c2VkIHRvIGFwcGx5IHNvbWUgc3BlY2lmaWMgdHJlYXRtZW50IGJlZm9yZSwgZm9ybWF0IHRoZSBsYWJlbCBkYXRhLCBwcm9qZWN0IGNvb3JkaW5hdGVzLCBldGMuXG4gICAgICAgICAqIFJldHVybiBmYWxzZSBpZiB0aGUgbGFiZWwgc2hvdWxkIG5vdCBiZSBrZXB0LlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24ob2JqZWN0KTpib29sZWFufSAqL1xuICAgICAgICB0aGlzLnByZXByb2Nlc3MgPSBvcHRzLnByZXByb2Nlc3NcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG9iamVjdCxudW1iZXIpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKChmLCB6KSA9PiAnZ3JheScpXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24ob2JqZWN0LG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKGYsIHopID0+IDIpXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24ob2JqZWN0LG51bWJlcik6QXJyYXkuPG51bWJlcj58dW5kZWZpbmVkfSAqL1xuICAgICAgICB0aGlzLmxpbmVEYXNoID0gb3B0cy5saW5lRGFzaCB8fCAoKGYsIHopID0+IHVuZGVmaW5lZClcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxvYmplY3Q+IHwgdW5kZWZpbmVkfSAqL1xuICAgICAgICB0aGlzLmZzID0gdW5kZWZpbmVkXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdub3RMb2FkZWQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgbGF5ZXIuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhcyBUaGUgY2FudmFzIHdoZXJlIHRvIGRyYXcgdGhlIGxheWVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGRyYXcoZ2VvQ2FudmFzKSB7XG4gICAgICAgIC8vbG9hZCBkYXRhLCBpZiBub3QgZG9uZSB5ZXQuXG4gICAgICAgIGlmICghdGhpcy5mcykge1xuICAgICAgICAgICAgdGhpcy5sb2FkKGdlb0NhbnZhcy5yZWRyYXcpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vVE9ETyBzb3J0IGxpbmVzIGJ5IHdpZHRoID9cblxuICAgICAgICAvL1xuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxuXG4gICAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmZzKSB7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIGlmIChjcy5sZW5ndGggPCAyKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL3NldCBjb2xvclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvcihmLCB6KVxuICAgICAgICAgICAgaWYgKCFjb2wgfHwgY29sID09ICdub25lJykgY29udGludWVcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xcblxuICAgICAgICAgICAgLy9zZXQgbGluZXdpZHRoXG4gICAgICAgICAgICBjb25zdCB3UCA9IHRoaXMud2lkdGgoZiwgeilcbiAgICAgICAgICAgIGlmICghd1AgfHwgd1AgPCAwKSBjb250aW51ZVxuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lV2lkdGggPSB3UCAqIHpcblxuICAgICAgICAgICAgLy9zZXQgbGluZSBkYXNoXG4gICAgICAgICAgICBjb25zdCBsZFAgPSB0aGlzLmxpbmVEYXNoKGYsIHopXG4gICAgICAgICAgICBpZiAobGRQKSBnZW9DYW52YXMuY3R4LnNldExpbmVEYXNoKGxkUClcblxuICAgICAgICAgICAgLy9kcmF3IGxpbmVcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGNzWzBdWzBdLCBjc1swXVsxXSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY3MubGVuZ3RoOyBpKyspIGdlb0NhbnZhcy5jdHgubGluZVRvKGNzW2ldWzBdLCBjc1tpXVsxXSlcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLi4uXG4gICAgICAgIGdlb0NhbnZhcy5jdHguc2V0TGluZURhc2goW10pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBkYXRhIGZvciBsYWJlbHMsIGZyb20gVVJMIHRoaXMudXJsXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IGNhbGxiYWNrXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBsb2FkKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy51cmwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgbG9hZGluZyBib3VuZGFyaWVzOiBObyBVUkwgc3BlY2lmaWVkLiAnICsgdGhpcy51cmwpXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnZmFpbGVkJ1xuICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGlmIGRhdGEgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgaWYgKHRoaXMubG9hZGluZ1N0YXR1cyAhPSAnbm90TG9hZGVkJykgcmV0dXJuXG5cbiAgICAgICAgLy9sb2FkIGRhdGFcbiAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ2xvYWRpbmcnXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFfID0gYXdhaXQganNvbih0aGlzLnVybClcblxuICAgICAgICAgICAgLyoqIEB0eXBlIHsgQXJyYXkuPG9iamVjdD4gfSAqL1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGRhdGFfLmZlYXR1cmVzXG5cbiAgICAgICAgICAgIC8vcHJlcHJvY2Vzcy9maWx0ZXJcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZzID0gW11cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5wcmVwcm9jZXNzKGMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChiID09IGZhbHNlKSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZzLnB1c2goYylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vc3RvcmUgbGFiZWxzXG4gICAgICAgICAgICAgICAgdGhpcy5mcyA9IGRhdGFcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ2xvYWRlZCdcblxuICAgICAgICAgICAgLy9yZWRyYXdcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBsb2FkaW5nIGJvdW5kYXJpZXMgZnJvbSAnICsgdGhpcy51cmwpXG4gICAgICAgICAgICB0aGlzLmZzID0gW11cbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdmYWlsZWQnXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vY29yZS9MYXllci5qcydcblxuLyoqXG4gKiBBIGxheWVyLCB3aGljaCBzcGVjaWZpZXMgYSBkYXRhc2V0IHRvIGJlIHNob3duIHdpdGggc3BlY2lmaWVkIHN0eWxlcy5cbiAqXG4gKiBAbW9kdWxlIGxheWVyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBHcmlkTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuRGF0YXNldHxpbXBvcnQoXCIuLi9jb3JlL011bHRpUmVzb2x1dGlvbkRhdGFzZXRcIikuTXVsdGlSZXNvbHV0aW9uRGF0YXNldH0gZGF0YXNldCBUaGUgZGF0YXNldCB0byBzaG93LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvU3R5bGVcIikuU3R5bGU+fSBzdHlsZXMgVGhlIHN0eWxlcywgb3JkZXJlZCBpbiBkcmF3aW5nIG9yZGVyLlxuICAgICAqIEBwYXJhbSB7e3Zpc2libGU/OmZ1bmN0aW9uKG51bWJlcik6Ym9vbGVhbixhbHBoYT86ZnVuY3Rpb24obnVtYmVyKTpudW1iZXIsYmxlbmRPcGVyYXRpb24/OmZ1bmN0aW9uKG51bWJlcik6R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLG1pblBpeGVsc1BlckNlbGw/Om51bWJlcixjZWxsSW5mb0hUTUw/OmZ1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5DZWxsKTpzdHJpbmd9fSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YXNldCwgc3R5bGVzLCBvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5EYXRhc2V0fGltcG9ydChcIi4uL2NvcmUvTXVsdGlSZXNvbHV0aW9uRGF0YXNldFwiKS5NdWx0aVJlc29sdXRpb25EYXRhc2V0fSAqL1xuICAgICAgICB0aGlzLmRhdGFzZXQgPSBkYXRhc2V0XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48aW1wb3J0KFwiLi4vY29yZS9TdHlsZVwiKS5TdHlsZT59ICovXG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzXG5cbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIHdoZW4gdGhlIGRhdGFzZXQgaXMgYSBNdWx0aVJlc29sdXRpb25EYXRhc2V0LlxuICAgICAgICAgKiBJdCBkZWZpbmVzIHRoZSBtaW5pbXVtIG51bWJlciBvZiBwaXhlbHMgYSBncmlkIGNlbGwgc2hvdWxkIGhhdmUgdG8gc2VsZWN0IHRoZSBkYXRhc2V0IHRvIGRpc3BsYXkgYmFzZWQgb24gaXRzIHJlc29sdXRpb24uXG4gICAgICAgICAqIEEgbG93IHZhbHVlLCBtZWFucyB0aGF0IHRoZSBtYXAgd2lsbCBiZSBtb3JlIGRldGFpbGxlZCAoc21hbGxlciBjZWxscykuXG4gICAgICAgICAqIEEgaGlnaCB2YWx1ZSwgbWVhbnMgdGhhdCB0aGUgbWFwIHdpbGwgYmUgbGVzcyBkZXRhaWxsZWQgKGxhcmdlciBjZWxscykuXG4gICAgICAgICAqIFRoaXMgdmFsdWUgc2hvdWxkIGJlIGhpZ2hlciB0aGFuIDEsIG90aGVyd2lzZSBpdCBtZWFucyBhIGdyaWQgY2VsbCBpcyBzbWFsbGVyIHRoYW4gdGhlIHNjcmVlbiByZXNvbHV0aW9uLlxuICAgICAgICAgKiBGb3IgbW9yZSBjb21wbGV4IGNlbGwgcmVwcmVzZW50YXRpb25zIHRoYXQgcmVxdWlyZSBzb21lIG1vcmUgbWFwIHNwYWNlLCB0aGlzIHZhbHVlIHNob3VsZCBiZSBoaWdoZXIuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMubWluUGl4ZWxzUGVyQ2VsbCA9IG9wdHMubWluUGl4ZWxzUGVyQ2VsbCB8fCAzXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiByZXR1cm5pbmcgY2VsbCBpbmZvcm1hdGlvbiBhcyBIVE1MLlxuICAgICAgICAgKiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIGZvciB0b29sdGlwIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkNlbGwsIG51bWJlcik6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNlbGxJbmZvSFRNTCA9IG9wdHMuY2VsbEluZm9IVE1MIHx8IEdyaWRMYXllci5kZWZhdWx0Q2VsbEluZm9IVE1MXG4gICAgfVxuXG4gICAgLyoqICovXG4gICAgZHJhdyhnZW9DYW52YXMsIGxlZ2VuZCkge1xuXG4gICAgICAgIC8vZ2V0IHpvb20gbGV2ZWxcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcblxuICAgICAgICAvL2dldCBsYXllciBkYXRhc2V0IGNvbXBvbmVudFxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuRGF0YXNldHx1bmRlZmluZWR9ICovXG4gICAgICAgIGNvbnN0IGRzYyA9IHRoaXMuZ2V0RGF0YXNldCh6KVxuICAgICAgICBpZiAoIWRzYykgcmV0dXJuXG5cbiAgICAgICAgLy9sYXVuY2ggZGF0YSBkb3dubG9hZCwgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGRzYy5nZXREYXRhKGdlb0NhbnZhcy5leHRHZW8pXG5cbiAgICAgICAgLy91cGRhdGUgZGF0YXNldCB2aWV3IGNhY2hlXG4gICAgICAgIGRzYy51cGRhdGVWaWV3Q2FjaGUoZ2VvQ2FudmFzLmV4dEdlbylcblxuICAgICAgICAvL2RyYXcgY2VsbHMsIHN0eWxlIGJ5IHN0eWxlXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLnN0eWxlcykge1xuXG4gICAgICAgICAgICAvL2NoZWNrIGlmIHN0eWxlIGlzIHZpc2libGVcbiAgICAgICAgICAgIGlmIChzLnZpc2libGUgJiYgIXMudmlzaWJsZSh6KSkgY29udGludWVcblxuICAgICAgICAgICAgLy9zZXQgc3R5bGUgYWxwaGEgYW5kIGJsZW5kIG1vZGVcbiAgICAgICAgICAgIC8vVE9ETzogbXVsdGlwbHkgYnkgbGF5ZXIgYWxwaGEgP1xuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5nbG9iYWxBbHBoYSA9IHMuYWxwaGEgPyBzLmFscGhhKHopIDogMS4wXG4gICAgICAgICAgICBpZiAocy5ibGVuZE9wZXJhdGlvbilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHMuYmxlbmRPcGVyYXRpb24oeilcblxuICAgICAgICAgICAgLy9zZXQgYWZmaW4gdHJhbnNmb3JtIHRvIGRyYXcgd2l0aCBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIGdlb0NhbnZhcy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgICAgICAvL2RyYXcgd2l0aCBzdHlsZVxuICAgICAgICAgICAgcy5kcmF3KGRzYy5nZXRWaWV3Q2FjaGUoKSwgZ2VvQ2FudmFzLCBkc2MuZ2V0UmVzb2x1dGlvbigpKVxuXG4gICAgICAgICAgICAvL2RyYXcgc3R5bGUgZmlsdGVyXG4gICAgICAgICAgICBpZiAocy5maWx0ZXJDb2xvcilcbiAgICAgICAgICAgICAgICBzLmRyYXdGaWx0ZXIoZ2VvQ2FudmFzKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9hZGQgbGVnZW5kIGVsZW1lbnRcbiAgICAgICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBpZiBzdHlsZSBpcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgaWYgKHMudmlzaWJsZSAmJiAhcy52aXNpYmxlKHopKSBjb250aW51ZVxuICAgICAgICAgICAgICAgIEdyaWRMYXllci5hZGRMZWdlbmRzKGxlZ2VuZCwgcy5sZWdlbmRzKVxuXG4gICAgICAgICAgICAgICAgLy9jYXNlIGZvciBzdHlsZXMgb2Ygc3R5bGVzLCBsaWtlIGtlcm5lbCBzbW9vdGhpbmdcbiAgICAgICAgICAgICAgICAvL1RPRE8gZG8gYmV0dGVyXG4gICAgICAgICAgICAgICAgaWYgKHNbJ3N0eWxlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgczIgb2Ygc1snc3R5bGVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMi52aXNpYmxlICYmICFzMi52aXNpYmxlKHopKSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgR3JpZExheWVyLmFkZExlZ2VuZHMobGVnZW5kLCBzMi5sZWdlbmRzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBzdGF0aWMgYWRkTGVnZW5kcyhsZWdlbmRDb21wLCBsZykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsZykpIGZvciAoY29uc3QgbGdfIG9mIGxnKSB0aGlzLmFkZExlZ2VuZHMobGVnZW5kQ29tcCwgbGdfKVxuICAgICAgICBlbHNlIGxlZ2VuZENvbXAubm9kZSgpLmFwcGVuZChsZy5kaXYubm9kZSgpKVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByZWxldmFudCBkYXRhc2V0IGNvbXBvbmVudCBmb3IgYSBzcGVjaWZpZWQgem9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gICAgICogQHJldHVybnMge2ltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5EYXRhc2V0fHVuZGVmaW5lZH1cbiAgICAgKiAqL1xuICAgIGdldERhdGFzZXQoeikge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhc2V0LmdldERhdGFzZXQoeiwgdGhpcy5taW5QaXhlbHNQZXJDZWxsKTtcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogU2V0L2dldCBzdHlsZSBzdGFjay5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3VuZGVmaW5lZHxpbXBvcnQoXCIuLi9jb3JlL1N0eWxlXCIpLlN0eWxlfEFycmF5LjxpbXBvcnQoXCIuLi9jb3JlL1N0eWxlXCIpLlN0eWxlPn0gc3R5bGVzIFxuICAgICAqIEByZXR1cm5zIHsgdGhpcyB8IEFycmF5LjxpbXBvcnQoXCIuLi9jb3JlL1N0eWxlXCIpLlN0eWxlPiB9XG4gICAgICovXG4gICAgc3R5bGVzXyhzdHlsZXMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLnN0eWxlc1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHRoaXMuc3R5bGVzID0gc3R5bGVzXG4gICAgICAgICAgICBlbHNlIHRoaXMuc3R5bGVzID0gW3N0eWxlc11cbiAgICAgICAgZWxzZSB0aGlzLnN0eWxlcyA9IGFyZ3VtZW50c1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiByZXR1cm5pbmcgY2VsbCBpbmZvcm1hdGlvbiBhcyBIVE1MLlxuICAgICAqIFRoaXMgaXMgdHlwaWNhbGx5IHVzZWQgZm9yIHRvb2x0aXAgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5DZWxsfSBjZWxsXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVmYXVsdENlbGxJbmZvSFRNTChjZWxsKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IFtdXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNlbGwpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAneCcpIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAneScpIGNvbnRpbnVlXG4gICAgICAgICAgICBidWYucHVzaCgnPGI+Jywga2V5LCAnPC9iPicsICcgOiAnLCBjZWxsW2tleV0sICc8YnI+JylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmLmpvaW4oJycpXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2NvcmUvTGF5ZXIuanMnXG5pbXBvcnQgeyBjc3YgfSBmcm9tICdkMy1mZXRjaCdcblxuLyoqIEEgbGFiZWwuIFRoZSBuYW1lIGlzIHRoZSB0ZXh0IHRvIHNob3cuICh4LHkpIGFyZSB0aGUgY29vcmRpbmF0ZXMgaW4gdGhlIHNhbWUgQ1JTIGFzIHRoZSBncmlkLlxuICogQHR5cGVkZWYge3tuYW1lOiBzdHJpbmcsIHg6bnVtYmVyLCB5Om51bWJlciB9fSBMYWJlbCAqL1xuXG4vKipcbiAqIEEgKGdlbmVyaWMpIGxheWVyIGZvciBwbGFjZW5hbWUgbGFiZWxzLCB0byBiZSBzaG93biBvbiB0b3Agb2YgdGhlIGdyaWQgbGF5ZXJzLlxuICogVGhlIGlucHV0IGlzIGEgQ1NWIGZpbGUgd2l0aCB0aGUgcG9zaXRpb24gKHgsIHkpIG9mIHRoZSBsYWJlbHMgYW5kIG5hbWUgKyBzb21lIG90aGVyIGluZm8gb24gdGhlIGxhYmVsIGltcG9ydGFuY2UuXG4gKiBJZiB0aGUgbGFiZWwgZGF0YSBpcyBub3QgaW4gdGhlIGV4cGVjdGVkIGZvcm1hdCBvciBpbiB0aGUgc2FtZSBDUlMgYXMgdGhlIGdyaWQsIGl0IGNhbiBiZSBjb3JyZWN0ZWQgd2l0aCB0aGUgXCJwcmVwcm9jZXNzXCIgZnVuY3Rpb24uXG4gKiBUaGUgc2VsZWN0aW9uIG9mIHRoZSBsYWJlbCwgdGhlaXIgc3R5bGUgKGZvbnQsIHdlaWdodCwgZXRjLikgYW5kIGNvbG9yIGNhbiBiZSBzcGVjaWZpZWQgZGVwZW5kaW5nIG9uIHRoZWlyIGltcG9ydGFuY2UgYW5kIHRoZSB6b29tIGxldmVsLlxuICpcbiAqIEBtb2R1bGUgbGF5ZXJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIExhYmVsTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVUkwgb2YgdGhlIGxhYmVsIGRhdGEsIGFzIENTViBmaWxlLlxuICAgICAgICAgKiBUaGUgZmlsZSBzaG91bGQgY29udGFpbiB0aGUgaW5mb3JtYXRpb24gZm9yIGVhY2ggbGFiZWwgc3VjaCBhcyB0aGUgdGV4dCwgdGhlIHBvc2l0aW9uIGFuZCBvdGhlciBpbmZvcm1hdGlvbiBmb3IgdGhlIGRpc3BsYXkgb2YgdGhlIGxhYmVsIGFjY29yZGluZyB0byB0aGUgem9vbSBsZXZlbC5cbiAgICAgICAgICogSWYgbmVjZXNzYXJ5LCB0aGlzIGRhdGEgY2FuIGJlIHJlZm9ybWF0ZWQgd2l0aCB0aGUgJ3ByZXByb2Nlc3MnIHBhcmFtZXRlci5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy51cmwgPSBvcHRzLnVybFxuXG4gICAgICAgIC8qKiBTcGVjaWZ5IGlmIGFuZCBob3cgYSBsYWJlbCBzaG91bGQgYmUgZHJhd24sIGRlcGVuZGluZyBvbiBpdHMgaW1wb3J0YW5jZSBhbmQgdGhlIHpvb20gbGV2ZWwuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihMYWJlbCxudW1iZXIpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5zdHlsZSA9IG9wdHMuc3R5bGUgfHwgKCgpID0+ICdib2xkIDFlbSBBcmlhbCcpXG5cbiAgICAgICAgLyoqIFNwZWNpZnkgdGhlIGxhYmVsIGNvbG9yLCBkZXBlbmRpbmcgb24gaXRzIGltcG9ydGFuY2UgYW5kIHRoZSB6b29tIGxldmVsLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oTGFiZWwsbnVtYmVyKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8IChvcHRzLmRhcmsgPyAoKSA9PiAnI2RkZCcgOiAoKSA9PiAnIzIyMicpXG5cbiAgICAgICAgLyoqIFNwZWNpZnkgdGhlIGxhYmVsIGhhbG8gY29sb3IsIGRlcGVuZGluZyBvbiBpdHMgaW1wb3J0YW5jZSBhbmQgdGhlIHpvb20gbGV2ZWwuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihMYWJlbCxudW1iZXIpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5oYWxvQ29sb3IgPSBvcHRzLmhhbG9Db2xvciB8fCAob3B0cy5kYXJrID8gKCkgPT4gJyMwMDAwMDBCQicgOiAoKSA9PiAnI0ZGRkZGRkJCJylcblxuICAgICAgICAvKiogU3BlY2lmeSB0aGUgbGFiZWwgaGFsbyB3aWR0aCwgZGVwZW5kaW5nIG9uIGl0cyBpbXBvcnRhbmNlIGFuZCB0aGUgem9vbSBsZXZlbC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKExhYmVsLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmhhbG9XaWR0aCA9IG9wdHMuaGFsb1dpZHRoIHx8ICgoKSA9PiA0KVxuXG4gICAgICAgIC8qKiBUaGUgYW5jaG9yIHdoZXJlIHRvIGRyYXcgdGhlIHRleHQsIGZyb20gbGFiZWwgcG9zaXRpb24uIFNlZSBIVE1MLWNhbnZhcyB0ZXh0QWxpZ24gcHJvcGVydHkuXG4gICAgICAgICAqIFwibGVmdFwiIHx8IFwicmlnaHRcIiB8fCBcImNlbnRlclwiIHx8IFwic3RhcnRcIiB8fCBcImVuZFwiXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ259ICovXG4gICAgICAgIHRoaXMudGV4dEFsaWduID0gb3B0cy50ZXh0QWxpZ24gfHwgJ3N0YXJ0J1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXG4gICAgICAgIHRoaXMub2Zmc2V0UGl4ID0gb3B0cy5vZmZzZXRQaXggfHwgWzUsIDVdXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcHJlcHJvY2VzcyB0byBydW4gb24gZWFjaCBsYWJlbCBhZnRlciBsb2FkaW5nLlxuICAgICAgICAgKiBJdCBjYW4gYmUgdXNlZCB0byBhcHBseSBzb21lIHNwZWNpZmljIHRyZWF0bWVudCBiZWZvcmUsIGZvcm1hdCB0aGUgbGFiZWwgZGF0YSwgcHJvamVjdCBjb29yZGluYXRlcywgZXRjLlxuICAgICAgICAgKiBSZXR1cm4gZmFsc2UgaWYgdGhlIGxhYmVsIHNob3VsZCBub3QgYmUga2VwdC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKExhYmVsKTpib29sZWFufSAqL1xuICAgICAgICB0aGlzLnByZXByb2Nlc3MgPSBvcHRzLnByZXByb2Nlc3NcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxMYWJlbD4gfCB1bmRlZmluZWR9ICovXG4gICAgICAgIHRoaXMubGFiZWxzID0gdW5kZWZpbmVkXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdub3RMb2FkZWQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgbGFiZWwgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGUgbGF5ZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZHJhdyhnZW9DYW52YXMpIHtcbiAgICAgICAgLy9sb2FkIGxhYmVscywgaWYgbm90IGRvbmUgeWV0LlxuICAgICAgICBpZiAoIXRoaXMubGFiZWxzKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQoZ2VvQ2FudmFzLnJlZHJhdylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcblxuICAgICAgICAvL3RleHQgYWxpZ25cbiAgICAgICAgZ2VvQ2FudmFzLmN0eC50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbiB8fCAnc3RhcnQnXG5cbiAgICAgICAgLy9saW5lIGpvaW4gYW5kIGNhcFxuICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVKb2luID0gJ2JldmVsJyAvL3x8IFwicm91bmRcIiB8fCBcIm1pdGVyXCI7XG4gICAgICAgIGdlb0NhbnZhcy5jdHgubGluZUNhcCA9ICdidXR0JyAvL3x8IFwicm91bmRcIiB8fCBcInNxdWFyZVwiO1xuXG4gICAgICAgIC8vZHJhdyBpbiBwaXggY29vcmRpbmF0ZXNcbiAgICAgICAgZ2VvQ2FudmFzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgIC8vZHJhdyBsYWJlbHMsIG9uZSBieSBvbmVcbiAgICAgICAgZm9yIChjb25zdCBsYiBvZiB0aGlzLmxhYmVscykge1xuICAgICAgICAgICAgLy9nZXQgbGFiZWwgc3R5bGVcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gdGhpcy5zdHlsZShsYiwgeilcbiAgICAgICAgICAgIGlmICghc3QpIGNvbnRpbnVlXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZvbnQgPSBzdFxuXG4gICAgICAgICAgICAvL2NoZWNrIGxhYmVsIHdpdGhpbiB0aGUgdmlldywgdG8gYmUgZHJhd25cbiAgICAgICAgICAgIGlmICghZ2VvQ2FudmFzLnRvRHJhdyhsYikpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IHhQID0gZ2VvQ2FudmFzLmdlb1RvUGl4WChsYi54KSArIHRoaXMub2Zmc2V0UGl4WzBdXG4gICAgICAgICAgICBjb25zdCB5UCA9IGdlb0NhbnZhcy5nZW9Ub1BpeFkobGIueSkgLSB0aGlzLm9mZnNldFBpeFsxXVxuXG4gICAgICAgICAgICAvL2xhYmVsIHN0cm9rZSwgZm9yIHRoZSBoYWxvXG4gICAgICAgICAgICBpZiAodGhpcy5oYWxvQ29sb3IgJiYgdGhpcy5oYWxvV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYyA9IHRoaXMuaGFsb0NvbG9yKGxiLCB6KVxuICAgICAgICAgICAgICAgIGNvbnN0IGh3ID0gdGhpcy5oYWxvV2lkdGgobGIsIHopXG4gICAgICAgICAgICAgICAgaWYgKGhjICYmIGh3ICYmIGh3ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZVN0eWxlID0gaGNcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lV2lkdGggPSBod1xuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZVRleHQobGIubmFtZSwgeFAsIHlQKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9sYWJlbCBmaWxsXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IobGIsIHopXG4gICAgICAgICAgICAgICAgaWYgKGNvbCkge1xuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGxTdHlsZSA9IGNvbFxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGxUZXh0KGxiLm5hbWUsIHhQLCB5UClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGRhdGEgZm9yIGxhYmVscywgZnJvbSBVUkwgdGhpcy51cmxcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gY2FsbGJhY2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGxvYWQoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLnVybCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBsb2FkaW5nIGxhYmVsczogTm8gVVJMIHNwZWNpZmllZC4gJyArIHRoaXMudXJsKVxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcbiAgICAgICAgICAgIHRoaXMubGFiZWxzID0gW11cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBpZiBkYXRhIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmdTdGF0dXMgIT0gJ25vdExvYWRlZCcpIHJldHVyblxuXG4gICAgICAgIC8vbG9hZCBkYXRhXG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdsb2FkaW5nJ1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgeyBBcnJheS48TGFiZWw+IH0gKi9cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjc3YodGhpcy51cmwpXG5cbiAgICAgICAgICAgIC8vcHJlcHJvY2Vzcy9maWx0ZXJcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVscyA9IFtdXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMucHJlcHJvY2VzcyhjKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYiA9PSBmYWxzZSkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChjKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9zdG9yZSBsYWJlbHNcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVscyA9IGRhdGFcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ2xvYWRlZCdcblxuICAgICAgICAgICAgLy9yZWRyYXdcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBsb2FkaW5nIGxhYmVscyBmcm9tICcgKyB0aGlzLnVybClcbiAgICAgICAgICAgIHRoaXMubGFiZWxzID0gW11cbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdmYWlsZWQnXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL2NvcmUvTGVnZW5kLmpzJ1xuXG4vKipcbiAqIEEgbGVnZW5kIGVsZW1lbnQgZm9yIGNvbG9yIGNhdGVncm9yaWVzLlxuICpcbiAqIEBtb2R1bGUgbGVnZW5kXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2xvckNhdGVnb3J5TGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcbiAgICAvKiogQHBhcmFtIHtPYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLy9jb2wvY2F0ZWdvcmllcyBhcnJheSwgaW4gZGlzcGxheSBvcmRlclxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxbc3RyaW5nLHN0cmluZ10+fSAqL1xuICAgICAgICB0aGlzLmNvbG9yTGFiZWwgPSBvcHRzLmNvbG9yTGFiZWwgfHwgW1snZ3JheScsICctJ11dXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb3JlL1N0eWxlLmpzXCIpLlNoYXBlfSAqL1xuICAgICAgICB0aGlzLnNoYXBlID0gb3B0cy5zaGFwZSB8fCAnY2lyY2xlJ1xuICAgICAgICB0aGlzLmRpbWVuc2lvbiA9IG9wdHMuZGltZW5zaW9uIHx8IHsgcjogOCB9XG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBvcHRzLnN0cm9rZUNvbG9yIHx8ICdncmF5J1xuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aCB8fCAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuXG4gICAgICAgIC8vY2xlYXJcbiAgICAgICAgdGhpcy5kaXYuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcblxuICAgICAgICAvL3RpdGxlXG4gICAgICAgIHRoaXMubWFrZVRpdGxlKClcblxuICAgICAgICAvL2NhdGVnb3JpZXNcbiAgICAgICAgY29uc3QgbmIgPSB0aGlzLmNvbG9yTGFiZWwubGVuZ3RoXG4gICAgICAgIGlmIChuYiA9PSAwKSByZXR1cm5cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHRoaXMuY29sb3JMYWJlbFtpXVxuXG4gICAgICAgICAgICAvL21ha2UgZGl2IGZvciBjYXRlZ29yeVxuICAgICAgICAgICAgY29uc3QgZCA9IHRoaXMuZGl2LmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC8vdG8gZW5hYmxlIHZlcnRpY2FsIGNlbnRlcmluZ1xuICAgICAgICAgICAgLy8uc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpXG5cbiAgICAgICAgICAgIGNvbnN0IHN3ID0gdGhpcy5zdHJva2VXaWR0aFxuXG4gICAgICAgICAgICAvL2RyYXcgZ3JhcGhpYyBlbGVtZW50OiBib3ggLyBjaXJjbGVcbiAgICAgICAgICAgIGlmICh0aGlzLnNoYXBlID09PSAnc3F1YXJlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGggPSB0aGlzLmRpbWVuc2lvbi5oIHx8IDE1XG4gICAgICAgICAgICAgICAgY29uc3QgdyA9IHRoaXMuZGltZW5zaW9uLncgfHwgMjBcbiAgICAgICAgICAgICAgICBkLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgJ2lubGluZScpXG5cbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdyArIDIgKiBzdylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGggKyAyICogc3cpXG5cbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgc3cpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgc3cpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBjYXRbMF0pXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgdGhpcy5zdHJva2VDb2xvcilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0cm9rZVdpZHRoKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNoYXBlID09PSAnY2lyY2xlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmRpbWVuc2lvbi5yIHx8IDhcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gMiAqIHIgKyAyICogc3dcbiAgICAgICAgICAgICAgICBkLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgJ2lubGluZScpXG5cbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgaClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGgpXG5cbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgciArIHN3KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCByICsgc3cpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgcilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY2F0WzBdKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRoaXMuc3Ryb2tlQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5zdHJva2VXaWR0aClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNoYXBlOicgKyB0aGlzLnNoYXBlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3dyaXRlIGxhYmVsIHRleHRcbiAgICAgICAgICAgIGQuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgICAgIC8vc2hvdyBvbiByaWdodCBvZiBncmFwaGljXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgJ2lubGluZScpXG5cbiAgICAgICAgICAgICAgICAvL2NlbnRlciB2ZXJ0aWNhbGx5XG4gICAgICAgICAgICAgICAgLy8uc3R5bGUoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpLnN0eWxlKFwidG9wXCIsIFwiMFwiKS5zdHlsZShcImJvdHRvbVwiLCBcIjBcIilcblxuICAgICAgICAgICAgICAgIC5zdHlsZSgncGFkZGluZy1sZWZ0JywgJzVweCcpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpXG4gICAgICAgICAgICAgICAgLnRleHQoY2F0WzFdKVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9jb3JlL0xlZ2VuZC5qcydcblxuLyoqXG4gKiBBIGxlZ2VuZCBlbGVtZW50IGZvciBkaXNjcmV0ZSBjb2xvciBzdHlsZS5cbiAqIEluc3BpcmF0aW9uOiBodHRwczovL29ic2VydmFibGVocS5jb20vQGQzL2NvbG9yLWxlZ2VuZFxuICpcbiAqIEBtb2R1bGUgbGVnZW5kXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2xvckRpc2NyZXRlTGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcbiAgICAvKiogQHBhcmFtIHtPYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIEBwcml2YXRlIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvU3R5bGUnKS5WaWV3U2NhbGUpOkFycmF5LjxzdHJpbmc+fSAqL1xuICAgICAgICB0aGlzLmNvbG9ycyA9IG9wdHMuY29sb3JzXG4gICAgICAgIC8qKiBAcHJpdmF0ZSBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL1N0eWxlJykuVmlld1NjYWxlKTpBcnJheS48bnVtYmVyPn0gKi9cbiAgICAgICAgdGhpcy5icmVha3MgPSBvcHRzLmJyZWFrc1xuXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8IDMwMFxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8IDE1XG5cbiAgICAgICAgdGhpcy50aWNrU2l6ZSA9IG9wdHMudGlja1NpemUgfHwgM1xuXG4gICAgICAgIC8vbGFiZWxcbiAgICAgICAgdGhpcy5pbnZlcnQgPSBvcHRzLmludmVydFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7e3ZpZXdTY2FsZTppbXBvcnQoJy4uL2NvcmUvU3R5bGUnKS5WaWV3U2NhbGV9IH0gb3B0c1xuICAgICAqL1xuICAgIHVwZGF0ZShvcHRzKSB7XG5cbiAgICAgICAgLy9jbGVhclxuICAgICAgICB0aGlzLmRpdi5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxuXG4gICAgICAgIC8vdGl0bGVcbiAgICAgICAgdGhpcy5tYWtlVGl0bGUoKVxuXG4gICAgICAgIC8vZ2V0IGNvbG9ycyBhbmQgYnJlYWtzXG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuY29sb3JzKG9wdHMudmlld1NjYWxlKVxuICAgICAgICBjb25zdCBicmVha3MgPSB0aGlzLmJyZWFrcyhvcHRzLnZpZXdTY2FsZSlcbiAgICAgICAgaWYgKCFicmVha3MpIHJldHVyblxuXG4gICAgICAgIC8vY2xhc3Nlc1xuICAgICAgICBjb25zdCBuYiA9IGNvbG9ycy5sZW5ndGhcbiAgICAgICAgaWYgKG5iID09IDApIHJldHVyblxuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCAvIG5iXG5cbiAgICAgICAgLy9tYWtlIHN2ZyBlbGVtZW50XG4gICAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuZGl2XG4gICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy53aWR0aClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmhlaWdodCArIHRoaXMudGlja1NpemUgKyAyICsgMTApXG5cbiAgICAgICAgLy9kcmF3IGdyYXBoaWMgZWxlbWVudHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYjsgaSsrKSB7XG4gICAgICAgICAgICBzdmcuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGkgKiB3KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB3KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmhlaWdodClcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBjb2xvcnNbaV0pXG4gICAgICAgIH1cblxuICAgICAgICAvL3RpY2sgbGluZVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5iOyBpKyspIHtcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHcgKiBpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgdyAqIGkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgdGhpcy5oZWlnaHQgKyB0aGlzLnRpY2tTaXplKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbGFiZWxzXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmI7IGkrKykge1xuXG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBicmVha3NbaSAtIDFdXG4gICAgICAgICAgICBpZiAoaXNOYU4obGFiZWwpIHx8IGxhYmVsID09IHVuZGVmaW5lZCkgY29udGludWVcblxuICAgICAgICAgICAgLy9sYWJlbFxuICAgICAgICAgICAgc3ZnLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3RpY2tsYWJlbF8nICsgaSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHcgKiBpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgdGhpcy5oZWlnaHQgKyB0aGlzLnRpY2tTaXplICsgMilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMubGFiZWxGb250U2l6ZSlcbiAgICAgICAgICAgICAgICAvLy5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxuICAgICAgICAgICAgICAgIC8vLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJBcmlhbFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2FsaWdubWVudC1iYXNlbGluZScsICd0b3AnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZG9taW5hbnQtYmFzZWxpbmUnLCAnaGFuZ2luZycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcbiAgICAgICAgICAgICAgICAudGV4dChsYWJlbClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vY29yZS9MZWdlbmQuanMnXG5cbi8qKlxuICogQSBsZWdlbmQgZWxlbWVudCBmb3IgY29udGludW91cyBjb2xvciBzdHlsZS5cbiAqIEluc3BpcmF0aW9uOiBodHRwczovL29ic2VydmFibGVocS5jb20vQGQzL2NvbG9yLWxlZ2VuZFxuICpcbiAqIEBtb2R1bGUgbGVnZW5kXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2xvckxlZ2VuZCBleHRlbmRzIExlZ2VuZCB7XG4gICAgLyoqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8vYSBmdW5jdGlvbiBbMCwxXS0+Y29sb3IgZm9yIGNvbnRpbnVvdXMgY29sb3JzXG4gICAgICAgIC8vb3IgYXJyYXkgb2YgY29sb3JzIGZvciBkaXNjcmV0ZSBjb2xvcnNcbiAgICAgICAgdGhpcy5jb2xvclNjYWxlID0gb3B0cy5jb2xvclNjYWxlXG5cbiAgICAgICAgLy9mdW5jdGlvbiAodFswLDFdKSAtPiB2YWx1ZSAoZm9yIGxhYmVsIHRleHQpXG4gICAgICAgIHRoaXMudGV4dFNjYWxlID0gb3B0cy50ZXh0U2NhbGUgfHwgKHQgPT4gdClcblxuICAgICAgICB0aGlzLm1hcmdpbiA9IG9wdHMubWFyZ2luIHx8IDVcblxuICAgICAgICAvL3JlcGxhY2Ugd2l0aCBsYWJlbHMgP1xuICAgICAgICB0aGlzLnRpY2tTaXplID0gb3B0cy50aWNrU2l6ZSB8fCA2XG4gICAgICAgIHRoaXMudGlja3MgPSBvcHRzLnRpY2tzIHx8IE1hdGguZmxvb3IodGhpcy53aWR0aCAvIDUwKVxuICAgICAgICB0aGlzLnRpY2tGb3JtYXQgPSBvcHRzLnRpY2tGb3JtYXRcbiAgICAgICAgdGhpcy50aWNrVW5pdCA9IG9wdHMudGlja1VuaXRcblxuICAgICAgICB0aGlzLmZvbnRTaXplID0gb3B0cy5mb250U2l6ZSB8fCAnMC44ZW0nXG4gICAgICAgIHRoaXMuaW52ZXJ0ID0gb3B0cy5pbnZlcnRcblxuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAzMDBcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCAxNVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7e3ZpZXdTY2FsZTppbXBvcnQoJy4uL2NvcmUvU3R5bGUnKS5WaWV3U2NhbGV9IH0gb3B0c1xuICAgICAqL1xuICAgIHVwZGF0ZShvcHRzKSB7XG5cbiAgICAgICAgLy9jbGVhclxuICAgICAgICB0aGlzLmRpdi5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxuXG4gICAgICAgIC8vdGl0bGVcbiAgICAgICAgdGhpcy5tYWtlVGl0bGUoKVxuXG4gICAgICAgIGNvbnN0IHN2Z1cgPSB0aGlzLndpZHRoICsgMiAqIHRoaXMubWFyZ2luXG4gICAgICAgIGNvbnN0IHN2Z0ggPSB0aGlzLmhlaWdodCArIHRoaXMubWFyZ2luICsgdGhpcy50aWNrU2l6ZSArIDEwXG4gICAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuZGl2LmFwcGVuZCgnc3ZnJykuYXR0cignd2lkdGgnLCBzdmdXKS5hdHRyKCdoZWlnaHQnLCBzdmdIKVxuICAgICAgICAvLyAgPHJlY3Qgd2lkdGg9XCIzMDBcIiBoZWlnaHQ9XCIxMDBcIiBzdHlsZT1cImZpbGw6cmdiKDAsMCwyNTUpO3N0cm9rZS13aWR0aDozO3N0cm9rZTpyZ2IoMCwwLDApXCIgLz5cblxuICAgICAgICBjb25zdCBnID0gc3ZnXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB0aGlzLm1hcmdpbiArICcgJyArIDAgKyAnKScpXG5cbiAgICAgICAgLy9kcmF3IGNvbG9yIGJhclxuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGggPSB0aGlzLmhlaWdodFxuICAgICAgICBjb25zdCBzdGVwID0gNVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkgKz0gc3RlcCkge1xuICAgICAgICAgICAgbGV0IHQgPSBpIC8gKHcgLSAxKVxuICAgICAgICAgICAgaWYgKHRoaXMuaW52ZXJ0KSB0ID0gMSAtIHRcbiAgICAgICAgICAgIGcuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHN0ZXApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGgpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgdGhpcy5jb2xvclNjYWxlKHQsIG9wdHMudmlld1NjYWxlKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50aWNrczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdCA9IGkgLyAodGhpcy50aWNrcyAtIDEpXG5cbiAgICAgICAgICAgIC8vdGljayBsaW5lXG4gICAgICAgICAgICBnLmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgdyAqIHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMClcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3ICogdClcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBoICsgdGhpcy50aWNrU2l6ZSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdibGFjaycpXG5cbiAgICAgICAgICAgIC8vcHJlcGFyZSB0aWNrIGxhYmVsXG4gICAgICAgICAgICBnLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3RpY2tsYWJlbF8nICsgaSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHcgKiB0KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgaCArIHRoaXMudGlja1NpemUgKyAyKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy5mb250U2l6ZSlcbiAgICAgICAgICAgICAgICAvLy5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxuICAgICAgICAgICAgICAgIC8vLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJBcmlhbFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCBpID09IDAgPyAnc3RhcnQnIDogaSA9PSB0aGlzLnRpY2tzIC0gMSA/ICdlbmQnIDogJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAndG9wJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2RvbWluYW50LWJhc2VsaW5lJywgJ2hhbmdpbmcnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG4gICAgICAgICAgICAvLy50ZXh0KFwiLVwiKVxuICAgICAgICB9XG5cbiAgICAgICAgLy91cGRhdGUgdGljayBsYWJlbHNcblxuICAgICAgICAvL2xhYmVsIHRleHQgZm9ybWF0XG4gICAgICAgIGNvbnN0IGYgPSB0aGlzLnRpY2tGb3JtYXQgJiYgdGhpcy50aWNrRm9ybWF0ICE9ICd0ZXh0JyA/IHRoaXMudGlja0Zvcm1hdCA6ICh2KSA9PiB2XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50aWNrczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdCA9IGkgLyAodGhpcy50aWNrcyAtIDEpXG5cbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLnRleHRTY2FsZSh0LCBvcHRzLnZpZXdTY2FsZSlcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSAodiA/IGYodikgOiAnMCcpICsgKHRoaXMudGlja1VuaXQgPyB0aGlzLnRpY2tVbml0IDogJycpXG4gICAgICAgICAgICBpZiAodGV4dCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vdGljayBsYWJlbFxuICAgICAgICAgICAgdGhpcy5kaXYuc2VsZWN0KCcjJyArICd0aWNrbGFiZWxfJyArIGkpLnRleHQodGV4dClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vY29yZS9MZWdlbmQuanMnXG5cbi8qKlxuICogQSBsZWdlbmQgZWxlbWVudCBmb3Igc2VnbWVudCBvcmllbnRhdGlvbi5cbiAqXG4gKiBAbW9kdWxlIGxlZ2VuZFxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgT3JpZW50YXRpb25MZWdlbmQgZXh0ZW5kcyBMZWdlbmQge1xuICAgIC8qKiBAcGFyYW0ge09iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvL29yaWVudGF0aW9uXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSBvcHRzLm9yaWVudGF0aW9uIHx8IDBcbiAgICAgICAgLy9jb2xvclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgPT4gJ2dyYXknKVxuICAgICAgICAvL3dpZHRoXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8ICgocmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA9PiAzICogeilcbiAgICAgICAgLy9sZW5ndGhcbiAgICAgICAgdGhpcy5sZW5ndGggPSBvcHRzLmxlbmd0aCB8fCAoKHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgPT4gcmVzb2x1dGlvbilcblxuICAgICAgICAvL2xhYmVsXG4gICAgICAgIHRoaXMubGFiZWwgPSBvcHRzLmxhYmVsIHx8IFwiLVwiXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt7IHN0eWxlOiBpbXBvcnQoXCIuLi9zdHlsZS9TZWdtZW50U3R5bGUuanNcIikuU2VnbWVudFN0eWxlLCByZXNvbHV0aW9uOiBudW1iZXIsIHo6IG51bWJlciwgdmlld1NjYWxlOm9iamVjdCB9fSBvcHRzXG4gICAgICovXG4gICAgdXBkYXRlKG9wdHMpIHtcblxuICAgICAgICAvL2NsZWFyXG4gICAgICAgIHRoaXMuZGl2LnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXG5cbiAgICAgICAgLy90aXRsZVxuICAgICAgICB0aGlzLm1ha2VUaXRsZSgpXG5cbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZGl2LmFwcGVuZCgnZGl2JylcblxuICAgICAgICAvL2NvbXB1dGUgc2VnbWVudCBjb2xvciwgd2lkdGggYW5kIGxlbmd0aFxuICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuY29sb3Iob3B0cy5yZXNvbHV0aW9uLCBvcHRzLnosIG9wdHMudmlld1NjYWxlKVxuICAgICAgICBjb25zdCB3aWR0aFBpeCA9IHRoaXMud2lkdGgob3B0cy5yZXNvbHV0aW9uLCBvcHRzLnosIG9wdHMudmlld1NjYWxlKSAvIG9wdHMuelxuICAgICAgICBjb25zdCBsZW5ndGhQaXggPSB0aGlzLmxlbmd0aChvcHRzLnJlc29sdXRpb24sIG9wdHMueiwgb3B0cy52aWV3U2NhbGUpIC8gb3B0cy56XG5cbiAgICAgICAgLy9kcmF3IFNWRyBzZWdtZW50XG4gICAgICAgIGNvbnN0IHN2Z1MgPSBNYXRoLm1heChsZW5ndGhQaXgsIHdpZHRoUGl4KVxuICAgICAgICBjb25zdCBzdmcgPSBkLmFwcGVuZCgnc3ZnJykuYXR0cignd2lkdGgnLCBzdmdTKS5hdHRyKCdoZWlnaHQnLCBzdmdTKS5zdHlsZSgnJywgJ2lubGluZS1ibG9jaycpXG5cbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoKC10aGlzLm9yaWVudGF0aW9uICogTWF0aC5QSSkgLyAxODApXG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKCgtdGhpcy5vcmllbnRhdGlvbiAqIE1hdGguUEkpIC8gMTgwKVxuICAgICAgICBjb25zdCBkYyA9IHN2Z1MgKiAwLjUsXG4gICAgICAgICAgICBsMiA9IGxlbmd0aFBpeCAqIDAuNVxuICAgICAgICBzdmcuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIGRjIC0gY29zICogbDIpXG4gICAgICAgICAgICAuYXR0cigneTEnLCBkYyAtIHNpbiAqIGwyKVxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgZGMgKyBjb3MgKiBsMilcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIGRjICsgc2luICogbDIpXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGNvbG9yKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB3aWR0aFBpeClcblxuXG4gICAgICAgIC8vbGFiZWxcbiAgICAgICAgZC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnaW5saW5lJylcbiAgICAgICAgICAgIC5zdHlsZSgncGFkZGluZy1sZWZ0JywgJzVweCcpXG4gICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMubGFiZWxGb250U2l6ZSlcbiAgICAgICAgICAgIC50ZXh0KHRoaXMubGFiZWwgKyAodGhpcy5sYWJlbFVuaXRUZXh0ID8gJyAnIDogJycpICsgdGhpcy5sYWJlbFVuaXRUZXh0KVxuICAgIH1cbn1cblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG9yaWVudGF0aW9ucyBcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVscyBcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIFxuICogQHJldHVybnMgIHsgQXJyYXkuPE9yaWVudGF0aW9uTGVnZW5kPiB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcmllbnRhdGlvbkxlZ2VuZChvcmllbnRhdGlvbnMsIGxhYmVscywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgbGVnZW5kcyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmllbnRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3B0cy50aXRsZSA9IGkgPT0gMCA/IG9wdHMudGl0bGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIG9wdHMub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbnNbaV1cbiAgICAgICAgb3B0cy5sYWJlbCA9IGxhYmVsc1tpXVxuICAgICAgICBsZWdlbmRzLnB1c2gobmV3IE9yaWVudGF0aW9uTGVnZW5kKG9wdHMpKVxuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kc1xufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9jb3JlL0xlZ2VuZC5qcydcbmltcG9ydCB7IG5pY2UgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcbmltcG9ydCB7IG1heCB9IGZyb20gJ2QzLWFycmF5J1xuXG4vKipcbiAqIEEgbGVnZW5kIGVsZW1lbnQgZm9yIHByb3BvcnRpb25hbCBzeW1ib2xzLlxuICpcbiAqIEBtb2R1bGUgbGVnZW5kXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBTaXplTGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcbiAgICAvKiogQHBhcmFtIHtPYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB0ZXh0IGxhYmVsLCBmcm9tIHRoZSB2aWV3IHNjYWxlIGFuZCBsaXN0IG9mIGNlbGxzLCByZXNvbHV0aW9uIGFuZCB6b29tXG4gICAgICAgICAqICBAdHlwZSB7IGZ1bmN0aW9uKG9iamVjdCwgQXJyYXkuPGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbD4sIG51bWJlciwgbnVtYmVyKToobnVtYmVyfHN0cmluZykgfSAqL1xuICAgICAgICB0aGlzLmxhYmVsID0gb3B0cy5sYWJlbCB8fCB1bmRlZmluZWRcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgdGhlIGxlZ2VuZCBzeW1ib2wsIGluIGdlbyBVb00sIGZyb20gdGhlIHZpZXdzY2FsZSwgcmVzb2x1dGlvbiBhbmQgem9vbVxuICAgICAgICAgKiAgQHR5cGUgeyBmdW5jdGlvbihvYmplY3QsIG51bWJlciwgbnVtYmVyKTpudW1iZXIgfSAqL1xuICAgICAgICB0aGlzLnNpemUgPSBvcHRzLnNpemUgfHwgdW5kZWZpbmVkXG5cbiAgICAgICAgLy9zeW1ib2xcbiAgICAgICAgLyoqICBAdHlwZSB7KGltcG9ydChcIi4uL2NvcmUvU3R5bGVcIikuU2hhcGUpfFwibGluZVwifSAqL1xuICAgICAgICB0aGlzLnNoYXBlID0gb3B0cy5zaGFwZSB8fCAnY2lyY2xlJ1xuXG4gICAgICAgIC8vZ2VuZXJhbCBjYXNlXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gb3B0cy5maWxsQ29sb3IgfHwgJ25vbmUnXG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBvcHRzLnN0cm9rZUNvbG9yIHx8ICdncmF5J1xuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aCB8fCAxXG5cbiAgICAgICAgLy9mb3IgbGluZSBzaGFwZVxuICAgICAgICAvL1RPRE8gdGhpcy5vcmllbnRhdGlvbiA9IG9wdHMub3JpZW50YXRpb24gfHwgMFxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAnZ3JheSdcbiAgICAgICAgdGhpcy5sZW5ndGggPSBvcHRzLmxlbmd0aCB8fCAoKHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgPT4gcmVzb2x1dGlvbilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3sgdmlld1NjYWxlOm9iamVjdCwgcmVzb2x1dGlvbjogbnVtYmVyLCB6Om51bWJlciwgY2VsbHM6QXJyYXkuPGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbD4gfX0gb3B0c1xuICAgICAqL1xuICAgIHVwZGF0ZShvcHRzKSB7XG5cbiAgICAgICAgLy9jbGVhclxuICAgICAgICB0aGlzLmRpdi5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxuXG4gICAgICAgIC8vdGl0bGVcbiAgICAgICAgdGhpcy5tYWtlVGl0bGUoKVxuXG4gICAgICAgIC8vZ2V0IGxhYmVsLiBNYXkgbm90IGJlIGEgbnVtYmVyICghKVxuICAgICAgICBsZXQgbGFiZWwgPSB0aGlzLmxhYmVsKG9wdHMudmlld1NjYWxlLCBvcHRzLmNlbGxzLCBvcHRzLnJlc29sdXRpb24sIG9wdHMueilcblxuICAgICAgICAvL2NvbXB1dGUgc2l6ZSBvZiBzeW1ib2wsIGluIHBpeFxuICAgICAgICBsZXQgc2l6ZVBpeFxuICAgICAgICBpZiAodGhpcy5zaXplKVxuICAgICAgICAgICAgc2l6ZVBpeCA9IHRoaXMuc2l6ZShvcHRzLnZpZXdTY2FsZSwgb3B0cy5yZXNvbHV0aW9uLCBvcHRzLnopIC8gb3B0cy56XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNpemVQaXggPSBvcHRzLnZpZXdTY2FsZSgrbGFiZWwpIC8gb3B0cy56XG4gICAgICAgIGlmICghc2l6ZVBpeCkgcmV0dXJuXG5cbiAgICAgICAgLy9mb3JtYXQgbGFiZWwsIGlmIHNwZWNpZmllZCBhbmQgcG9zc2libGVcbiAgICAgICAgaWYgKHRoaXMubGFiZWxGb3JtYXQgJiYgIWlzTmFOKCtsYWJlbCkpIGxhYmVsID0gdGhpcy5sYWJlbEZvcm1hdChsYWJlbClcblxuICAgICAgICBjb25zdCBkID0gdGhpcy5kaXYuYXBwZW5kKCdkaXYnKVxuICAgICAgICAvL3RvIGVuYWJsZSB2ZXJ0aWNhbCBjZW50ZXJpbmdcbiAgICAgICAgLy8uc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpXG5cbiAgICAgICAgLy9kZWZhdWx0IHN2ZyBjb25zdHJ1Y3Rpb24sIGZvciBzcXVhcmUgYW5kIGNpcmNsZVxuICAgICAgICBjb25zdCBzdmcgPSAoKSA9PiBkXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc2l6ZVBpeCArIHRoaXMuc3Ryb2tlV2lkdGggKyAyKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHNpemVQaXggKyB0aGlzLnN0cm9rZVdpZHRoICsgMilcbiAgICAgICAgICAgIC5zdHlsZSgnJywgJ2lubGluZS1ibG9jaycpXG5cbiAgICAgICAgaWYgKHRoaXMuc2hhcGUgPT09ICdzcXVhcmUnKSB7XG4gICAgICAgICAgICBzdmcoKS5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc2l6ZVBpeClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgc2l6ZVBpeClcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCB0aGlzLmZpbGxDb2xvcilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRoaXMuc3Ryb2tlQ29sb3IpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0cm9rZVdpZHRoKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICAvLyA8Y2lyY2xlIGN4PVwiNTBcIiBjeT1cIjUwXCIgcj1cIjQwXCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2Utd2lkdGg9XCIzXCIgZmlsbD1cInJlZFwiIC8+XG4gICAgICAgICAgICBjb25zdCByID0gKHNpemVQaXggKyB0aGlzLnN0cm9rZVdpZHRoKSAqIDAuNVxuICAgICAgICAgICAgc3ZnKCkuYXBwZW5kKCdjaXJjbGUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIHIgKyAxKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIHIgKyAxKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgcilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCB0aGlzLmZpbGxDb2xvcilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRoaXMuc3Ryb2tlQ29sb3IpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0cm9rZVdpZHRoKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2hhcGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgICAgIC8vVE9ET1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2hhcGUgPT09ICdkaWFtb25kJykge1xuICAgICAgICAgICAgLy9UT0RPXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaGFwZSA9PT0gJ2xpbmUnKSB7XG5cbiAgICAgICAgICAgIC8vZ2V0IHNlZ21lbnQgbGVuZ3RoXG4gICAgICAgICAgICBsZXQgbGVuZ3RoUGl4ID0gdGhpcy5sZW5ndGggPyB0aGlzLmxlbmd0aChvcHRzLnJlc29sdXRpb24sIG9wdHMueiwgb3B0cy52aWV3U2NhbGUpIDogb3B0cy5yZXNvbHV0aW9uXG4gICAgICAgICAgICBsZW5ndGhQaXggLz0gb3B0cy56XG5cbiAgICAgICAgICAgIGNvbnN0IHN2ZyA9IGQuYXBwZW5kKCdzdmcnKS5hdHRyKCd3aWR0aCcsIGxlbmd0aFBpeCkuYXR0cignaGVpZ2h0Jywgc2l6ZVBpeCkuc3R5bGUoJycsICdpbmxpbmUtYmxvY2snKVxuXG4gICAgICAgICAgICAvL1RPRE8gb3JpZW50YXRpb25cbiAgICAgICAgICAgIC8vPGxpbmUgeDE9XCIwXCIgeTE9XCIwXCIgeDI9XCIyMDBcIiB5Mj1cIjIwMFwiIHN0eWxlPVwic3Ryb2tlOnJnYigyNTUsMCwwKTtzdHJva2Utd2lkdGg6MlwiIC8+XG4gICAgICAgICAgICBzdmcuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHNpemVQaXggLyAyKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGxlbmd0aFBpeClcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBzaXplUGl4IC8gMilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRoaXMuY29sb3IpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBzaXplUGl4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNoYXBlOicgKyB0aGlzLnNoYXBlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9sYWJlbFxuICAgICAgICBkLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICdpbmxpbmUnKVxuICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nLWxlZnQnLCAnNXB4JylcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy5sYWJlbEZvbnRTaXplKVxuICAgICAgICAgICAgLnRleHQobGFiZWwgKyAodGhpcy5sYWJlbFVuaXRUZXh0ID8gJyAnIDogJycpICsgdGhpcy5sYWJlbFVuaXRUZXh0KVxuICAgIH1cbn1cblxuXG5cblxuXG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBzaXplIFxuICogQHBhcmFtIHsgb2JqZWN0IH0gb3B0cyBcbiAqIEByZXR1cm5zIHtBcnJheS48U2l6ZUxlZ2VuZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaXplTGVnZW5kKHZhbHVlcywgc2l6ZSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgbGVnZW5kcyA9IFtdXG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgIG9wdHMudGl0bGUgPSB2YWx1ZSA9PSB2YWx1ZXNbMF0gPyBvcHRzLnRpdGxlIDogdW5kZWZpbmVkO1xuICAgICAgICBvcHRzLnNpemUgPSAoKSA9PiBzaXplKHZhbHVlKVxuICAgICAgICBvcHRzLmxhYmVsID0gKCkgPT4gdmFsdWVcbiAgICAgICAgbGVnZW5kcy5wdXNoKG5ldyBTaXplTGVnZW5kKG9wdHMpKVxuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IGZ1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCk6bnVtYmVyIH0gdmFsdWUgXG4gKiBAcGFyYW0geyp9IG9wdHMgXG4gKiBAcmV0dXJucyB7QXJyYXkuPFNpemVMZWdlbmQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZUxlZ2VuZFZpZXdTY2FsZSh2YWx1ZSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgayA9IG9wdHMuayB8fCBbMC45LCAwLjUsIDAuMiwgMC4wNV1cbiAgICBjb25zdCBsZWdlbmRzID0gW11cbiAgICBmb3IgKGxldCBrXyBvZiBrKSB7XG4gICAgICAgIG9wdHMudGl0bGUgPSBrXyA9PSBrWzBdID8gb3B0cy50aXRsZSA6IHVuZGVmaW5lZFxuICAgICAgICBvcHRzLmxhYmVsID0gKHZpZXdTY2FsZSwgY2VsbHMpID0+IG5pY2Uoa18gKiBtYXgoY2VsbHMsIHZhbHVlKSlcbiAgICAgICAgbGVnZW5kcy5wdXNoKG5ldyBTaXplTGVnZW5kKG9wdHMpKVxuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kc1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJuIGEgc3RhY2sgb2Ygc2l6ZSBsZWdlbmRzIGZvciBhIGRpc2NyZXRlIGNsYXNzaWZpY2F0aW9uLlxuICogXG4gKiBAcGFyYW0geyBBcnJheS48bnVtYmVyPiB9IGJyZWFrcyBcbiAqIEBwYXJhbSB7IEFycmF5LjxudW1iZXI+IH0gc2l6ZXMgXG4gKiBAcGFyYW0geyBvYmplY3QgfSBvcHRzIFxuICogQHJldHVybnMge0FycmF5LjxTaXplTGVnZW5kPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpemVEaXNjcmV0ZUxlZ2VuZChicmVha3MsIHNpemVzLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBmID0gb3B0cy5sYWJlbEZvcm1hdCB8fCAoeCA9PiB4KVxuICAgIGNvbnN0IGxhYmVsVGV4dCA9IG9wdHMubGFiZWxUZXh0IHx8IGRlZmF1bHRMYWJlbFRleHQoZilcbiAgICBjb25zdCBsZWdlbmRzID0gW11cbiAgICBmb3IgKGxldCBpID0gc2l6ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgb3B0cy50aXRsZSA9IGkgPT0gc2l6ZXMubGVuZ3RoIC0gMSA/IG9wdHMudGl0bGUgOiB1bmRlZmluZWRcbiAgICAgICAgb3B0cy5zaXplID0gKCkgPT4gc2l6ZXNbaV1cbiAgICAgICAgb3B0cy5sYWJlbCA9ICgpID0+IGxhYmVsVGV4dChicmVha3NbaSAtIDFdLCBicmVha3NbaV0pXG4gICAgICAgIGxlZ2VuZHMucHVzaChuZXcgU2l6ZUxlZ2VuZChvcHRzKSlcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZHNcbn1cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybiBhIHN0YWNrIG9mIHNpemUgbGVnZW5kcyBmb3IgYSBkaXNjcmV0ZSBjbGFzc2lmaWNhdGlvbiB1c2luZyBhIHZpZXdzY2FsZS5cbiAqIEBwYXJhbSB7IG51bWJlciB9IGNsYXNzTnVtYmVyIFxuICogQHBhcmFtIHsgb2JqZWN0IH0gb3B0cyBcbiAqIEByZXR1cm5zIHtBcnJheS48U2l6ZUxlZ2VuZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaXplRGlzY3JldGVWaWV3U2NhbGVMZWdlbmQoY2xhc3NOdW1iZXIsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGYgPSBvcHRzLmxhYmVsRm9ybWF0IHx8ICh4ID0+IHgpXG4gICAgY29uc3QgbGFiZWxUZXh0ID0gb3B0cy5sYWJlbFRleHQgfHwgZGVmYXVsdExhYmVsVGV4dChmKVxuICAgIGNvbnN0IGxlZ2VuZHMgPSBbXVxuICAgIGNvbnN0IHZpZXdTY2FsZUZ1biA9IG9wdHMudmlld1NjYWxlRnVuIHx8ICh0ID0+IHQpIC8vVE9ETyBkbyBpdCBkaWZmZXJlbnRseT8gQXQgc2l6ZWxlZ2VuZCBsZXZlbCAhXG4gICAgZm9yIChsZXQgaSA9IGNsYXNzTnVtYmVyIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgb3B0cy50aXRsZSA9IGkgPT0gY2xhc3NOdW1iZXIgLSAxID8gb3B0cy50aXRsZSA6IHVuZGVmaW5lZFxuICAgICAgICBvcHRzLnNpemUgPSAodmlld1NjYWxlKSA9PiB2aWV3U2NhbGVGdW4odmlld1NjYWxlKS52YWx1ZXNbaV1cbiAgICAgICAgb3B0cy5sYWJlbCA9ICh2aWV3U2NhbGUpID0+IGxhYmVsVGV4dCh2aWV3U2NhbGVGdW4odmlld1NjYWxlKS5icmVha3NbaSAtIDFdLCB2aWV3U2NhbGVGdW4odmlld1NjYWxlKS5icmVha3NbaV0pXG4gICAgICAgIGxlZ2VuZHMucHVzaChuZXcgU2l6ZUxlZ2VuZChvcHRzKSlcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZHNcbn1cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGZvcm1hdCBsYWJlcmxzIGZvciBkaXNjcmV0ZSBzY2FsZSBsZWdlbmRzLlxuICogQHBhcmFtIHsgZnVuY3Rpb24obnVtYmVyKTpzdHJpbmcgfSBmb3JtYXQgXG4gKiBAcmV0dXJucyB7IGZ1bmN0aW9uKG51bWJlcnx1bmRlZmluZWQsIG51bWJlcnx1bmRlZmluZWQpOiBzdHJpbmcgfVxuICovXG5mdW5jdGlvbiBkZWZhdWx0TGFiZWxUZXh0KGZvcm1hdCkge1xuICAgIHJldHVybiAodjAsIHYxKSA9PiB7XG4gICAgICAgIGlmICh2MCA9PSB1bmRlZmluZWQgJiYgdjEgPT0gdW5kZWZpbmVkKSByZXR1cm4gXCJcIlxuICAgICAgICBpZiAodjEgPT0gdW5kZWZpbmVkKSByZXR1cm4gXCI+IFwiICsgZm9ybWF0KHYwKVxuICAgICAgICBpZiAodjAgPT0gdW5kZWZpbmVkKSByZXR1cm4gXCI8IFwiICsgZm9ybWF0KHYxKVxuICAgICAgICByZXR1cm4gZm9ybWF0KHYwKSArIFwiIC0gXCIgKyBmb3JtYXQodjEpXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9jb3JlL0xlZ2VuZC5qcydcblxuLyoqXG4gKlxuICogQG1vZHVsZSBsZWdlbmRcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFRyaXZhcmlhdGVMZWdlbmQgZXh0ZW5kcyBMZWdlbmQge1xuICAgIC8qKiBAcGFyYW0ge09iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvL2NsYXNzaWZpZXJcbiAgICAgICAgdGhpcy5jbGFzc2lmaWVyID0gb3B0cy5jbGFzc2lmaWVyXG5cbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdHMud2lkdGggfHwgMTUwXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ29sb3IgPSB0aGlzLnNlbGVjdGlvbkNvbG9yIHx8IFwicmVkXCJcbiAgICAgICAgdGhpcy50b29sdGlwID0gb3B0cy50b29sdGlwXG4gICAgICAgIHRoaXMudGV4dHMgPSBvcHRzLnRleHRzXG5cbiAgICAgICAgdGhpcy5sZWZ0VGV4dCA9IG9wdHMubGVmdFRleHQgfHwgXCJDYXRlZ29yeSAwXCJcbiAgICAgICAgdGhpcy50b3BUZXh0ID0gb3B0cy50b3BUZXh0IHx8IFwiQ2F0ZWdvcnkgMVwiXG4gICAgICAgIHRoaXMucmlnaHRUZXh0ID0gb3B0cy5yaWdodFRleHQgfHwgXCJDYXRlZ29yeSAyXCJcblxuICAgICAgICB0aGlzLmNlbnRlckNvZWZmaWNpZW50ID0gb3B0cy5jZW50ZXJDb2VmZmljaWVudCB8fCB0aGlzLmNsYXNzaWZpZXIuY2VudGVyQ29lZmZpY2llbnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3t9IH0gb3B0c1xuICAgICAqL1xuICAgIHVwZGF0ZShvcHRzKSB7XG5cbiAgICAgICAgLy9jbGVhclxuICAgICAgICB0aGlzLmRpdi5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxuXG4gICAgICAgIC8vdGl0bGVcbiAgICAgICAgdGhpcy5tYWtlVGl0bGUoKVxuXG4gICAgICAgIGNvbnN0IHNxcnQzb3ZlcjIgPSAwLjg2NjAyNVxuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCwgaCA9IHcgKiBzcXJ0M292ZXIyXG4gICAgICAgIGNvbnN0IGNsYXNzaWZpZXIgPSB0aGlzLmNsYXNzaWZpZXJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uQ29sb3IgPSB0aGlzLnNlbGVjdGlvbkNvbG9yXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblN0cm9rZVdpZHRoID0gMFxuICAgICAgICBjb25zdCB0dCA9IHRoaXMudG9vbHRpcFxuICAgICAgICBjb25zdCB0ZXh0cyA9IHRoaXMudGV4dHMgfHwge31cblxuICAgICAgICBjb25zdCBwYWRkaW5nID0gMlxuICAgICAgICBjb25zdCBmb250U2l6ZSA9IDEyXG5cbiAgICAgICAgLy9tYWtlIHN2ZyBlbGVtZW50XG4gICAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuZGl2XG4gICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdyArIHNlbGVjdGlvblN0cm9rZVdpZHRoKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGggKyA0ICogcGFkZGluZyArIDIgKiBmb250U2l6ZSlcblxuICAgICAgICAvL3RvcCBsYWJlbFxuICAgICAgICBzdmcuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwieFwiLCB3IC8gMikuYXR0cihcInlcIiwgcGFkZGluZyArIGZvbnRTaXplKS50ZXh0KHRoaXMudG9wVGV4dCkuYXR0cihcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSlcbiAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgLy9sZWZ0IGxhYmVsXG4gICAgICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJ5XCIsIDMgKiBwYWRkaW5nICsgMiAqIGZvbnRTaXplICsgaCkudGV4dCh0aGlzLmxlZnRUZXh0KS5hdHRyKFwiZm9udC1zaXplXCIsIGZvbnRTaXplKVxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcInN0YXJ0XCIpXG4gICAgICAgIC8vcmlnaHQgbGFiZWxcbiAgICAgICAgc3ZnLmFwcGVuZChcInRleHRcIikuYXR0cihcInhcIiwgdykuYXR0cihcInlcIiwgMyAqIHBhZGRpbmcgKyAyICogZm9udFNpemUgKyBoKS50ZXh0KHRoaXMucmlnaHRUZXh0KS5hdHRyKFwiZm9udC1zaXplXCIsIGZvbnRTaXplKVxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuXG5cblxuICAgICAgICAvL3RyaWFuZ2xlIGdyb3VwXG4gICAgICAgIGNvbnN0IGcgPSBzdmcuYXBwZW5kKFwiZ1wiKS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKHNlbGVjdGlvblN0cm9rZVdpZHRoIC8gMikgKyBcIiBcIiArIChzZWxlY3Rpb25TdHJva2VXaWR0aCAvIDIgKyAoMiAqIHBhZGRpbmcgKyBmb250U2l6ZSkpICsgXCIpXCIpXG5cbiAgICAgICAgLy9jb21tb24gZnVuY3Rpb24gZm9yIHRyaWFuZ2xlIHBhdGNoZXNcbiAgICAgICAgY29uc3Qgc2V0QXR0cmlidXRlcyA9IChlbHQsIGNvbG9yLCB0ZXh0KSA9PiB7XG4gICAgICAgICAgICAvL2VsdC5yYWlzZSgpO1xuICAgICAgICAgICAgZWx0LmF0dHIoJ2ZpbGwnLCBjb2xvcilcbiAgICAgICAgICAgICAgICAvLy5hdHRyKFwic3Ryb2tlXCIsIGNvbG9yT3ZlcilcbiAgICAgICAgICAgICAgICAvLy5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDApXG4gICAgICAgICAgICAgICAgLy8uYXR0cihcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpOyBzZWxlY3QodGhpcykuYXR0cihcInN0cm9rZS13aWR0aFwiLCBzZWxlY3Rpb25TdHJva2VXaWR0aCk7Ki9cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGwnLCBzZWxlY3Rpb25Db2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHQgfHwgIXRleHQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdHQuaHRtbCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdHQuc2V0UG9zaXRpb24oZSk7XG4gICAgICAgICAgICAgICAgICAgIHR0LnNob3coKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvKnNlbGVjdCh0aGlzKS5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDApOyovXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsJywgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHQpIHR0LmhpZGUoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBpZiAodHQgJiYgdGV4dCkgZWx0Lm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChlKSB7IHR0LnNldFBvc2l0aW9uKGUpIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbnN0IFtjMCwgYzEsIGMyXSA9IGNsYXNzaWZpZXIuY2VudGVyXG5cbiAgICAgICAgLy90cmFwZXppdW0gczBcbiAgICAgICAgY29uc3QgdDAgPSBnLmFwcGVuZCgncG9seWdvbicpXG4gICAgICAgICAgICAuYXR0cigncG9pbnRzJywgXCIwLFwiICsgaCArIFwiIFwiICsgdyAvIDMgKyBcIixcIiArIGggKyBcIiBcIiArIHcgLyAyICsgXCIsXCIgKyBoICogMiAvIDMgKyBcIiBcIiArIHcgLyA2ICsgXCIsXCIgKyBoICogMiAvIDMpXG4gICAgICAgIHNldEF0dHJpYnV0ZXModDAsIGNsYXNzaWZpZXIuY29sb3JzWzBdLCB0ZXh0c1tcIjBcIl0pXG4gICAgICAgIC8vdHJhcGV6aXVtIHMxXG4gICAgICAgIGNvbnN0IHQxID0gZy5hcHBlbmQoJ3BvbHlnb24nKVxuICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsIHcgLyAyICsgXCIsMCBcIiArIHcgKiAyIC8gMyArIFwiLFwiICsgaCAvIDMgKyBcIiBcIiArIHcgLyAyICsgXCIsXCIgKyBoICogMiAvIDMgKyBcIiBcIiArIHcgLyAzICsgXCIsXCIgKyBoIC8gMylcbiAgICAgICAgc2V0QXR0cmlidXRlcyh0MSwgY2xhc3NpZmllci5jb2xvcnNbMV0sIHRleHRzW1wiMVwiXSlcbiAgICAgICAgLy90cmFwZXppdW0gczJcbiAgICAgICAgY29uc3QgdDIgPSBnLmFwcGVuZCgncG9seWdvbicpXG4gICAgICAgICAgICAuYXR0cigncG9pbnRzJywgdyArIFwiLFwiICsgaCArIFwiIFwiICsgdyAqIDUgLyA2ICsgXCIsXCIgKyAyICogaCAvIDMgKyBcIiBcIiArIHcgLyAyICsgXCIsXCIgKyBoICogMiAvIDMgKyBcIiBcIiArIHcgKiAyIC8gMyArIFwiLFwiICsgaClcbiAgICAgICAgc2V0QXR0cmlidXRlcyh0MiwgY2xhc3NpZmllci5jb2xvcnNbMl0sIHRleHRzW1wiMlwiXSlcbiAgICAgICAgLy90cmlhbmdsZSBzMFxuICAgICAgICBjb25zdCB0MF8gPSBnLmFwcGVuZCgncG9seWdvbicpXG4gICAgICAgICAgICAuYXR0cigncG9pbnRzJywgdyAvIDIgKyBcIixcIiArIGggKiAyIC8gMyArIFwiIFwiICsgdyAqIDUgLyA2ICsgXCIsXCIgKyBoICogMiAvIDMgKyBcIiBcIiArIHcgKiAyIC8gMyArIFwiLFwiICsgaCAvIDMpXG4gICAgICAgIHNldEF0dHJpYnV0ZXModDBfLCBjbGFzc2lmaWVyLm1peENvbG9yc1swXSwgdGV4dHNbXCIxMlwiXSlcbiAgICAgICAgLy90cmlhbmdsZSBzMVxuICAgICAgICBjb25zdCB0MV8gPSBnLmFwcGVuZCgncG9seWdvbicpXG4gICAgICAgICAgICAuYXR0cigncG9pbnRzJywgdyAvIDIgKyBcIixcIiArIGggKiAyIC8gMyArIFwiIFwiICsgdyAvIDMgKyBcIixcIiArIGggKyBcIiBcIiArIHcgKiAyIC8gMyArIFwiLFwiICsgaClcbiAgICAgICAgc2V0QXR0cmlidXRlcyh0MV8sIGNsYXNzaWZpZXIubWl4Q29sb3JzWzFdLCB0ZXh0c1tcIjAyXCJdKVxuICAgICAgICAvL3RyaWFuZ2xlIHMyXG4gICAgICAgIGNvbnN0IHQyXyA9IGcuYXBwZW5kKCdwb2x5Z29uJylcbiAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCB3IC8gMiArIFwiLFwiICsgaCAqIDIgLyAzICsgXCIgXCIgKyB3IC8gNiArIFwiLFwiICsgaCAqIDIgLyAzICsgXCIgXCIgKyB3IC8gMyArIFwiLFwiICsgaCAvIDMpXG4gICAgICAgIHNldEF0dHJpYnV0ZXModDJfLCBjbGFzc2lmaWVyLm1peENvbG9yc1syXSwgdGV4dHNbXCIwMVwiXSlcblxuICAgICAgICAvL2NlbnRlclxuICAgICAgICBpZiAodGhpcy5jZW50ZXJDb2VmZmljaWVudCkge1xuICAgICAgICAgICAgLy9UT0RPIG1ha2UgaXQgYW4gaGV4YWdvbiAhXG4gICAgICAgICAgICBjb25zdCBjZW50ZXIgPSBnLmFwcGVuZCgnY2lyY2xlJylcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCB3IC8gMikuYXR0cignY3knLCBoICogMiAvIDMpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCB0aGlzLmNlbnRlckNvZWZmaWNpZW50ICogaCAvIDMpXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGVzKGNlbnRlciwgY2xhc3NpZmllci5jZW50ZXJDb2xvciwgdGV4dHNbXCJjZW50ZXJcIl0pXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qXG4gICAgICAgIGxldCBtaWRkbGUsIGxlZnQsIHRvcCwgcmlnaHQsIGxlZnRfLCBib3R0b21fLCByaWdodF9cbiAgICAgICAgaWYgKCF0aGlzLnJlYWwpIHtcblxuICAgICAgICAgICAgLy8wIGxlZnQgdHJpYW5nbGVcbiAgICAgICAgICAgIGxlZnQgPSBnLmFwcGVuZCgncG9seWdvbicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsIFwiMCxcIiArIGggKyBcIiBcIiArICh3IC8gMykgKyBcIixcIiArIGggKyBcIiBcIiArICh3IC8gNikgKyBcIixcIiArICgyICogaCAvIDMpKVxuICAgICAgICAgICAgLy8xIHRvcCB0cmlhbmdsZVxuICAgICAgICAgICAgdG9wID0gZy5hcHBlbmQoJ3BvbHlnb24nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCAodyAvIDMpICsgXCIsXCIgKyAoaCAvIDMpICsgXCIgXCIgKyAodyAqIDIgLyAzKSArIFwiLFwiICsgKGggLyAzKSArIFwiIFwiICsgKHcgLyAyKSArIFwiLDBcIilcbiAgICAgICAgICAgIC8vMiByaWdodCB0cmlhbmdsZVxuICAgICAgICAgICAgcmlnaHQgPSBnLmFwcGVuZCgncG9seWdvbicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsICh3ICogMiAvIDMpICsgXCIsXCIgKyBoICsgXCIgXCIgKyB3ICsgXCIsXCIgKyBoICsgXCIgXCIgKyAodyAqIDUgLyA2KSArIFwiLFwiICsgKDIgKiBoIC8gMykpXG4gICAgICAgICAgICAvL21pZGRsZSB0cmlhbmdsZVxuICAgICAgICAgICAgbWlkZGxlID0gZy5hcHBlbmQoJ3BvbHlnb24nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCAodyAvIDIpICsgXCIsXCIgKyAoaCAvIDMpICsgXCIgXCIgKyAodyAvIDQpICsgXCIsXCIgKyAoaCAqIDUgLyA2KSArIFwiIFwiICsgKDMgKiB3IC8gNCkgKyBcIixcIiArIChoICogNSAvIDYpKVxuICAgICAgICAgICAgLy8wMSBsZWZ0IHRyYXBleml1bVxuICAgICAgICAgICAgbGVmdF8gPSBnLmFwcGVuZCgncG9seWdvbicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsICh3IC8gNikgKyBcIixcIiArIChoICogMiAvIDMpICsgXCIgXCIgKyAodyAvIDQpICsgXCIsXCIgKyAoaCAqIDUgLyA2KSArIFwiIFwiICsgKHcgLyAyKSArIFwiLFwiICsgKGggLyAzKSArIFwiIFwiICsgKHcgLyAzKSArIFwiLFwiICsgKGggLyAzKSlcbiAgICAgICAgICAgIC8vMDIgYm90dG9tIHRyYXBleml1bVxuICAgICAgICAgICAgYm90dG9tXyA9IGcuYXBwZW5kKCdwb2x5Z29uJylcbiAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgKHcgLyAzKSArIFwiLFwiICsgKGgpICsgXCIgXCIgKyAoMiAqIHcgLyAzKSArIFwiLFwiICsgKGgpICsgXCIgXCIgKyAodyAqIDMgLyA0KSArIFwiLFwiICsgKGggKiA1IC8gNikgKyBcIiBcIiArICh3IC8gNCkgKyBcIixcIiArIChoICogNSAvIDYpKVxuICAgICAgICAgICAgLy8xMiByaWdodCB0cmFwZXppdW1cbiAgICAgICAgICAgIHJpZ2h0XyA9IGcuYXBwZW5kKCdwb2x5Z29uJylcbiAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgKHcgLyAyKSArIFwiLFwiICsgKGggLyAzKSArIFwiIFwiICsgKHcgKiAzIC8gNCkgKyBcIixcIiArIChoICogNSAvIDYpICsgXCIgXCIgKyAodyAqIDUgLyA2KSArIFwiLFwiICsgKGggKiAyIC8gMykgKyBcIiBcIiArICh3ICogMiAvIDMpICsgXCIsXCIgKyAoaCAvIDMpKVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vbWlkZGxlIHRyaWFuZ2xlXG4gICAgICAgICAgICBtaWRkbGUgPSBnLmFwcGVuZCgncG9seWdvbicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsICh3IC8gMikgKyBcIiwwIDAsXCIgKyBoICsgXCIgXCIgKyB3ICsgXCIsXCIgKyBoKVxuXG4gICAgICAgICAgICAvL2RyYXcgdHJhcGV6aXVtXG4gICAgICAgICAgICAvL2RyYXcgbGFyZ2UgdHJhcGV6aXVtIGZpcnN0XG4gICAgICAgICAgICBmb3IgKGxldCBpXyA9IDI7IGlfID49IDA7IGlfLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gdGhpcy5jbGFzc2lmaWVyLmxvd0luZGV4W2lfXVxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNsYXNzaWZpZXIubG93VGhyZXNob2xkW2ldXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMilcbiAgICAgICAgICAgICAgICAgICAgLy8wMSBsZWZ0IHRyYXBleml1bVxuICAgICAgICAgICAgICAgICAgICBsZWZ0XyA9IGcuYXBwZW5kKCdwb2x5Z29uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCB3IC8gMiArIFwiLDAgMCxcIiArIGggKyBcIiBcIiArIHcgKiByICsgXCIsXCIgKyBoICsgXCIgXCIgKyB3ICogKDEgKyByKSAvIDIgKyBcIixcIiArIHIgKiBoKVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgLy8wMiBib3R0b20gdHJhcGV6aXVtXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbV8gPSBnLmFwcGVuZCgncG9seWdvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgXCIwLFwiICsgaCArIFwiIFwiICsgdyArIFwiLFwiICsgaCArIFwiIFwiICsgdyAqICgxIC0gciAvIDIpICsgXCIsXCIgKyBoICogKDEgLSByKSArIFwiIFwiICsgciAqIHcgLyAyICsgXCIsXCIgKyBoICogKDEgLSByKSlcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vMTIgcmlnaHQgdHJhcGV6aXVtXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0XyA9IGcuYXBwZW5kKCdwb2x5Z29uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCB3ICsgXCIsXCIgKyBoICsgXCIgXCIgKyB3IC8gMiArIFwiLDAgXCIgKyB3ICogKDEgLSByKSAvIDIgKyBcIixcIiArIGggKiByICsgXCIgXCIgKyB3ICogKDEgLSByKSArIFwiLFwiICsgaClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kcmF3IHRyaWFuZ2xlc1xuICAgICAgICAgICAgLy9kcmF3IGxhcmdlIHRyaWFuZ2xlcyBmaXJzdFxuICAgICAgICAgICAgZm9yIChsZXQgaV8gPSAyOyBpXyA+PSAwOyBpXy0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IHRoaXMuY2xhc3NpZmllci5oaWdoSW5kZXhbaV9dXG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuY2xhc3NpZmllci5oaWdoVGhyZXNob2xkW2ldXG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAyKVxuICAgICAgICAgICAgICAgICAgICAvLzIgcmlnaHQgdHJpYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBnLmFwcGVuZCgncG9seWdvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgdyArIFwiLFwiICsgaCArIFwiIFwiICsgdyAqIHIgKyBcIixcIiArIGggKyBcIiBcIiArIHcgKiAoMSArIHIpIC8gMiArIFwiLFwiICsgaCAqIHIpXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAvLzEgdG9wIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGcuYXBwZW5kKCdwb2x5Z29uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCAodyAvIDIpICsgXCIsMCBcIiArIHcgKiByIC8gMiArIFwiLFwiICsgaCAqICgxIC0gcikgKyBcIiBcIiArIHcgKiAoMSAtIHIgLyAyKSArIFwiLFwiICsgaCAqICgxIC0gcikpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAvLzAgbGVmdCB0cmlhbmdsZVxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gZy5hcHBlbmQoJ3BvbHlnb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsIFwiMCxcIiArIGggKyBcIiBcIiArIHcgKiAoMSAtIHIpICsgXCIsXCIgKyBoICsgXCIgXCIgKyB3ICogKDEgLSByKSAvIDIgKyBcIixcIiArIGggKiByKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0qL1xuXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXG5cbi8qKiBAdHlwZWRlZiB7XCJmbGFnXCJ8XCJwaWVjaGFydFwifFwicmluZ1wifFwic2VnbWVudFwifFwicmFkYXJcInxcImFnZXB5cmFtaWRcInxcImhhbGZ0b25lXCJ9IENvbXBvc2l0aW9uVHlwZSAqL1xuXG4vKipcbiAqIEEgc3R5bGUgc2hvd2luZyB0aGUgY29tcG9zaXRpb24gb2YgYSB0b3RhbCBpbiBkaWZmZXJlbnQgY2F0ZWdvcmllcywgd2l0aCBkaWZmZXJlbnQgY29sb3IgaHVlcy5cbiAqIEl0IGNvbnNpc3RzIG9mIGEgc3ltYm9sIHdpdGggZGlmZmVyZW50IHBhcnRzLCB3aG9zZSBzaXplIHJlZmxlY3QgdGhlIHByb3BvcnRpb24gb2YgdGhlIGNvcnJlc3BvbmRpbmcgY2F0ZWdvcnkuXG4gKiBGb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCBzeW1ib2xzLCBAc2VlIENvbXBvc2l0aW9uVHlwZVxuICogVGhlIHN5bWJvbCBjYW4gYmUgc2NhbGVkIGRlcGVuZGluZyBvbiB0aGUgY2VsbCBpbXBvcnRhbmNlLlxuICpcbiAqIEBtb2R1bGUgc3R5bGVcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIENvbXBvc2l0aW9uU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGljdGlvbmFyeSAoc3RyaW5nIC0+IGNvbG9yKSB3aGljaCBnaXZlIHRoZSBjb2xvciBvZiBlYWNoIGNhdGVnb3J5LlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fSAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvclxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgdHlwZSBvZiBkZWNvbXBvc2l0aW9uIHN5bWJvbCBvZiBhIGNlbGwsIEBzZWUgQ29tcG9zaXRpb25UeXBlXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbCxudW1iZXIsIG51bWJlcixvYmplY3QpOkNvbXBvc2l0aW9uVHlwZX0gKi9cbiAgICAgICAgdGhpcy50eXBlID0gb3B0cy50eXBlIHx8ICgoKSA9PiBcImZsYWdcIikgLy8oYyxyLHosdnMpID0+IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIGEgY2VsbCBpbiBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnNpemUgPSBvcHRzLnNpemUgfHwgKChjLCByKSA9PiByKSAvLyhjLHIseix2cykgPT4ge31cblxuICAgICAgICAvKiogRm9yIHN0eWxlIHR5cGVzIHdpdGggc3RyaXBlcyAoZmxhZywgc2VnbWVudCksIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgc3RyaXBlcyAoMCBmb3IgaG9yaXpvbnRhbCwgb3RoZXIgZm9yIHZlcnRpY2FsKS5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIsb2JqZWN0KTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc3RyaXBlc09yaWVudGF0aW9uID0gb3B0cy5zdHJpcGVzT3JpZW50YXRpb24gfHwgKCgpID0+IDApIC8vKGMscix6LHZzKSA9PiAuLi5cblxuICAgICAgICAvKiogVGhlIGZ1bmN0aW9uIHNwZWNpZnlpbmcgYW4gb2Zmc2V0IGFuZ2xlIGZvciBhIHJhZGFyLCBoYWxmdG9uZSBvciBwaWUgY2hhcnQgc3R5bGUuXG4gICAgICAgICAqIFRoZSBhbmdsZSBpcyBzcGVjaWZpZWQgaW4gZGVncmVlLiBUaGUgcm90YXRpb24gaXMgYW50aS1jbG9ja3dpc2UuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbCxudW1iZXIsbnVtYmVyLG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm9mZnNldEFuZ2xlID0gb3B0cy5vZmZzZXRBbmdsZSB8fCAoKCkgPT4gMCkgLy8oYyxyLHosdnMpID0+IC4uLlxuXG4gICAgICAgIC8qKiBUaGUgZnVuY3Rpb24gc3BlY2lmeWluZyB0aGUgaGVpZ2h0IG9mIHRoZSBhZ2UgcHlyYW1pZCwgaW4gZ2VvIHVuaXQuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbCxudW1iZXIsbnVtYmVyLG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmFnZVB5cmFtaWRIZWlnaHQgPSBvcHRzLmFnZVB5cmFtaWRIZWlnaHQgfHwgKChjLCByKSA9PiByKSAvLyhjLHIseix2cykgPT4gLi4uXG5cbiAgICAgICAgLyoqIEZvciBwaWUgY2hhcnQsIHRoaXMgaXMgcGFyYW1ldGVyIGZvciBpbnRlcm5hbCByYWRpdXMsIHNvIHRoYXQgdGhlIHBpZSBjaGFydCBsb29rcyBsaWtlIGEgZG9udXQuXG4gICAgICAgICAqIDAgZm9yIG5vcm1hbCBwaWUgY2hhcnRzLCAwLjUgdG8gZW1wdHkgaGFsZiBvZiB0aGUgcmFkaXVzLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnBpZUNoYXJ0SW50ZXJuYWxSYWRpdXNGYWN0b3IgPSBvcHRzLnBpZUNoYXJ0SW50ZXJuYWxSYWRpdXNGYWN0b3IgfHwgMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgY2VsbHMgYXMgc3F1YXJlcyBkZXBlbmRpbmcgb24gdGhlaXIgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XG5cbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL1xuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxuXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcbiAgICAgICAgY29uc3Qgdmlld1NjYWxlID0gdGhpcy52aWV3U2NhbGUgPyB0aGlzLnZpZXdTY2FsZShjZWxscywgcmVzb2x1dGlvbiwgeikgOiB1bmRlZmluZWRcblxuICAgICAgICAvL25iIGNhdGVnb3JpZXMgLSB1c2VkIGZvciByYWRhciBhbmQgYWdlcHlyYW1pZFxuICAgICAgICBjb25zdCBuYkNhdCA9IE9iamVjdC5lbnRyaWVzKHRoaXMuY29sb3IpLmxlbmd0aFxuXG4gICAgICAgIC8vZHJhdyBjYWxsc1xuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIGNlbGxzKSB7XG5cbiAgICAgICAgICAgIC8vc2l6ZVxuICAgICAgICAgICAgY29uc3Qgc0cgPSB0aGlzLnNpemUgPyB0aGlzLnNpemUoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHJlc29sdXRpb25cbiAgICAgICAgICAgIGlmICghc0cpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoY2VsbCwgcmVzb2x1dGlvbiwgeilcblxuICAgICAgICAgICAgLy9nZXQgc3ltYm9sIHR5cGVcbiAgICAgICAgICAgIGNvbnN0IHR5cGVfID0gdGhpcy50eXBlID8gdGhpcy50eXBlKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiAnZmxhZydcblxuICAgICAgICAgICAgLy9jb21wdXRlIGNlbnRlciBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgeGMgPSBjZWxsLnggKyBvZmZzZXQuZHggKyAodHlwZV8gPT09ICdhZ2VweXJhbWlkJyA/IDAgOiByZXNvbHV0aW9uICogMC41KVxuICAgICAgICAgICAgY29uc3QgeWMgPSBjZWxsLnkgKyBvZmZzZXQuZHkgKyAodHlwZV8gPT09ICdhZ2VweXJhbWlkJyA/IDAgOiByZXNvbHV0aW9uICogMC41KVxuXG4gICAgICAgICAgICAvL2NvbXB1dGUgb2Zmc2V0IGFuZ2xlLCB3aGVuIHJlbGV2YW50XG4gICAgICAgICAgICBjb25zdCBvZmZBbmcgPSB0aGlzLm9mZnNldEFuZ2xlID8gKHRoaXMub2Zmc2V0QW5nbGUoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSAqIE1hdGguUEkpIC8gMTgwIDogMFxuXG4gICAgICAgICAgICBpZiAodHlwZV8gPT09ICdhZ2VweXJhbWlkJyB8fCB0eXBlXyA9PT0gJ3JhZGFyJyB8fCB0eXBlXyA9PT0gJ2hhbGZ0b25lJykge1xuICAgICAgICAgICAgICAgIC8vZ2V0IGNlbGwgY2F0ZWdvcnkgbWF4IHZhbHVlXG4gICAgICAgICAgICAgICAgbGV0IG1heFZhbCA9IC1JbmZpbml0eVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmNvbG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gK2NlbGxba2V5XVxuICAgICAgICAgICAgICAgICAgICBpZiAodiA+IG1heFZhbCkgbWF4VmFsID0gdlxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY3VtdWxcbiAgICAgICAgICAgICAgICBsZXQgY3VtdWwgPSAwXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVfID09PSAnYWdlcHlyYW1pZCcgJiYgdGhpcy5hZ2VQeXJhbWlkSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICBjdW11bCA9IChyZXNvbHV0aW9uIC0gdGhpcy5hZ2VQeXJhbWlkSGVpZ2h0KGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkpIC8gMlxuICAgICAgICAgICAgICAgIGlmICh0eXBlXyA9PT0gJ3JhZGFyJyB8fCB0eXBlXyA9PT0gJ2hhbGZ0b25lJykgY3VtdWwgPSBNYXRoLlBJIC8gMiArIG9mZkFuZ1xuXG4gICAgICAgICAgICAgICAgLy9jb21wdXRlIHRoZSBpbmNyZW1lbnQsIHdoaWNoIGlzIHRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgdGhlIGN1bXVsIGZvciBlYWNoIGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgY29uc3QgaW5jciA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVfID09PSAnYWdlcHlyYW1pZCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKHRoaXMuYWdlUHlyYW1pZEhlaWdodCA/IHRoaXMuYWdlUHlyYW1pZEhlaWdodChjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogcmVzb2x1dGlvbikgLyBuYkNhdFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlXyA9PT0gJ3JhZGFyJyB8fCB0eXBlXyA9PT0gJ2hhbGZ0b25lJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKDIgKiBNYXRoLlBJKSAvIG5iQ2F0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBpZiAoaW5jciA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc3ltYm9sIHR5cGU6JyArIHR5cGVfKVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2NvbHVtbiwgY29sb3JdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlXyA9PT0gJ2FnZXB5cmFtaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NldCBjYXRlZ29yeSBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsU3R5bGUgPSBjb2xvclxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldCBjYXRlZ29yeSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gY2VsbFtjb2x1bW5dXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBjYXRlZ29yeSBsZW5ndGggLSBpbiBnZW9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd0cgPSAoc0cgKiB2YWwpIC8gbWF4VmFsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyBiYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbFJlY3QoeGMgKyAocmVzb2x1dGlvbiAtIHdHKSAvIDIsIHljICsgY3VtdWwsIHdHLCBpbmNyKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICBjdW11bCArPSBpbmNyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZV8gPT09ICdyYWRhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGNhdGVnb3J5IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IGNhdGVncm95IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBjZWxsW2NvbHVtbl1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wdXRlIGNhdGVnb3J5IHJhZGl1cyAtIGluIGdlb1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IHJHID0gdGhpcy5yYWRpdXModmFsLCByLCBzdGF0LCBjZWxsU3RhdCwgeilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJHID0gKHNHIC8gMikgKiBNYXRoLnNxcnQodmFsIC8gbWF4VmFsKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgYW5ndWxhciBzZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKHhjLCB5YylcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYXJjKHhjLCB5YywgckcsIGN1bXVsIC0gaW5jciwgY3VtdWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyh4YywgeWMpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGwoKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgYW5ndWxhciBzZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1bXVsICs9IGluY3JcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlXyA9PT0gJ2hhbGZ0b25lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXQgY2F0ZWdvcnkgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbFN0eWxlID0gY29sb3JcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY2F0ZWdyb3kgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNlbGxbY29sdW1uXVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgY2F0ZWdvcnkgcmFkaXVzIC0gaW4gZ2VvXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJHID0gc0cgKiAwLjMzMyAqIE1hdGguc3FydCh2YWwgLyBtYXhWYWwpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyBjaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjICsgcmVzb2x1dGlvbiAqIDAuMjUgKiBNYXRoLmNvcyhjdW11bCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWMgKyByZXNvbHV0aW9uICogMC4yNSAqIE1hdGguc2luKGN1bXVsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByRyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgKiBNYXRoLlBJXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGwoKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgYW5ndWxhciBzZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1bXVsICs9IGluY3JcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzeW1ib2wgdHlwZTonICsgdHlwZV8pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSB0b3RhbFxuICAgICAgICAgICAgICAgIGxldCB0b3RhbCA9IDBcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgT2JqZWN0LmtleXModGhpcy5jb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9ICtjZWxsW2NvbHVtbl1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2KSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB2XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdG90YWwgfHwgaXNOYU4odG90YWwpKSBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgLy9kcmF3IGRlY29tcG9zaXRpb24gc3ltYm9sXG4gICAgICAgICAgICAgICAgbGV0IGN1bXVsID0gMFxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSByZXNvbHV0aW9uICogKDEgLSBzRyAvIHJlc29sdXRpb24pICogMC41XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpID0gdGhpcy5zdHJpcGVzT3JpZW50YXRpb24oY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2NvbHVtbiwgY29sb3JdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0IHNoYXJlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlID0gY2VsbFtjb2x1bW5dIC8gdG90YWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaGFyZSB8fCBpc05hTihzaGFyZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsU3R5bGUgPSBjb2xvclxuXG4gICAgICAgICAgICAgICAgICAgIC8vZHJhdyBzeW1ib2wgcGFydFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZV8gPT09ICdmbGFnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3IGZsYWcgc3RyaXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnggKyBkICsgb2Zmc2V0LmR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnkgKyBkICsgY3VtdWwgKiBzRyArIG9mZnNldC5keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlICogc0dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnggKyBkICsgY3VtdWwgKiBzRyArIG9mZnNldC5keCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC55ICsgZCArIG9mZnNldC5keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmUgKiBzRyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZV8gPT09ICdwaWVjaGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyBwaWUgY2hhcnQgYW5ndWxhciBzZWN0b3JcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wdXRlIGFuZ2xlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYTEgPSBjdW11bCAqIDIgKiBNYXRoLlBJXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhMiA9IChjdW11bCArIHNoYXJlKSAqIDIgKiBNYXRoLlBJXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhd1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5tb3ZlVG8oeGMsIHljKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5hcmMoeGMsIHljLCBzRyAqIDAuNSwgYTEgKyBvZmZBbmcsIGEyICsgb2ZmQW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGllQ2hhcnRJbnRlcm5hbFJhZGl1c0ZhY3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzRyAqIDAuNSAqIHRoaXMucGllQ2hhcnRJbnRlcm5hbFJhZGl1c0ZhY3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYTEgKyBvZmZBbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEyICsgb2ZmQW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5jbG9zZVBhdGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsKClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlXyA9PT0gJ3JpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgcmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5hcmMoeGMsIHljLCBNYXRoLnNxcnQoMSAtIGN1bXVsKSAqIHNHICogMC41LCAwLCAyICogTWF0aC5QSSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbCgpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZV8gPT09ICdzZWdtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3IHNlZ21lbnQgc2VjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdHID0gKHNHICogc0cpIC8gcmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC54ICsgb2Zmc2V0LmR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnkgKyAocmVzb2x1dGlvbiAtIHdHKSAvIDIgKyBjdW11bCAqIHdHICsgb2Zmc2V0LmR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZSAqIHdHXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC54ICsgY3VtdWwgKiByZXNvbHV0aW9uICsgb2Zmc2V0LmR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnkgKyAocmVzb2x1dGlvbiAtIHdHKSAvIDIgKyBvZmZzZXQuZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd0dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc3ltYm9sIHR5cGU6JyArIHR5cGVfKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VtdWwgKz0gc2hhcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByZXNvbHV0aW9uOiByZXNvbHV0aW9uLCB6OiB6LCB2aWV3U2NhbGU6IHZpZXdTY2FsZSB9KVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xuaW1wb3J0IHsgcmFuZG9tTm9ybWFsIH0gZnJvbSAnZDMtcmFuZG9tJ1xuaW1wb3J0IHsgY2hlY2tXZWJHTFN1cHBvcnQsIG1ha2VXZWJHTENhbnZhcyB9IGZyb20gJy4uL3V0aWxzL3dlYkdMVXRpbHMuanMnXG5pbXBvcnQgeyBXZWJHTFNxdWFyZUNvbG9yaW5nIH0gZnJvbSAnLi4vdXRpbHMvV2ViR0xTcXVhcmVDb2xvcmluZy5qcydcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnZDMtY29sb3InXG5cbi8qKlxuICpcbiAqIEBtb2R1bGUgc3R5bGVcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIERvdERlbnNpdHlTdHlsZSBleHRlbmRzIFN0eWxlIHtcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBudW1iZXIgb2YgZG90cyBmb3IgYSBjZWxsIHZhbHVlLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlciwgb2JqZWN0KTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuZG90TnVtYmVyID0gb3B0cy5kb3ROdW1iZXIgfHwgKChjZWxsLCByZXNvbHV0aW9uKSA9PiByZXNvbHV0aW9uIC8gMTAwKS8vKGMscix6LHZzKSA9PiB7fVxuXG4gICAgICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIGRvdHMuIFNhbWUgY29sb3IgZm9yIGFsbCBkb3RzIHdpdGhpbiBhIGNlbGwuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKCgpID0+ICcjRkY1NzMzJykgLy8oYyxyLHosdnMpID0+IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIHRoZSBkb3RzLCBpbiBnZW8gdW5pdC4gU2FtZSBzaXplIGZvciBhbGwgY2VsbHMuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcixvYmplY3QpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5kb3RTaXplID0gb3B0cy5kb3RTaXplIHx8ICgocmVzb2x1dGlvbiwgeikgPT4gMS41ICogeikgLy8oYyxyLHosdnMpID0+IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaWdtYSBvZiB0aGUgZG90cyBkaXN0cmlidXRpb24uIFNhbWUgdmFsdWUgZm9yIGFsbCBjZWxscy5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyLG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnNpZ21hID0gb3B0cy5zaWdtYSB8fCAoKHJlc29sdXRpb24sIHopID0+IHJlc29sdXRpb24gLyAyKS8vKGMscix6LHZzKSA9PiB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgY2VsbHMgYXMgdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb25cbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcblxuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IHogPSBnZW9DYW52YXMudmlldy56XG5cbiAgICAgICAgLy9nZXQgdmlldyBzY2FsZVxuICAgICAgICBjb25zdCB2aWV3U2NhbGUgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vZ2V0IHNpemVcbiAgICAgICAgY29uc3Qgc0dlbyA9IHRoaXMuZG90U2l6ZSA/IHRoaXMuZG90U2l6ZShyZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogelxuXG4gICAgICAgIC8vbWFrZSByYW5kb20gZnVuY3Rpb25cbiAgICAgICAgY29uc3Qgc2lnID0gdGhpcy5zaWdtYSA/IHRoaXMuc2lnbWEocmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHJlc29sdXRpb24gKiAwLjRcbiAgICAgICAgY29uc3QgcmFuZCA9IHJhbmRvbU5vcm1hbCgwLCBzaWcpXG5cbiAgICAgICAgaWYgKGNoZWNrV2ViR0xTdXBwb3J0KCkpIHtcbiAgICAgICAgICAgIC8vY3JlYXRlIGNhbnZhcyBhbmQgd2ViZ2wgcmVuZGVyZXJcbiAgICAgICAgICAgIGNvbnN0IGN2V0dMID0gbWFrZVdlYkdMQ2FudmFzKGdlb0NhbnZhcy53ICsgJycsIGdlb0NhbnZhcy5oICsgJycpXG4gICAgICAgICAgICBpZiAoIWN2V0dMKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gd2ViR0wnKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2NyZWF0ZSB3ZWJHTCBwcm9ncmFtXG4gICAgICAgICAgICBjb25zdCBwcm9nID0gbmV3IFdlYkdMU3F1YXJlQ29sb3JpbmcoY3ZXR0wuZ2wsIHNHZW8gLyB6KVxuXG4gICAgICAgICAgICBjb25zdCByMiA9IHJlc29sdXRpb24gLyAyXG5cbiAgICAgICAgICAgIGZvciAobGV0IGNlbGwgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgICAgICAvL2dldCBjb2xvclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKVxuICAgICAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgLy9udW1iZXIgb2YgZG90c1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvdE51bWJlciA9IHRoaXMuZG90TnVtYmVyKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSlcblxuICAgICAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGNlbGwsIHJlc29sdXRpb24sIHopXG5cbiAgICAgICAgICAgICAgICAvL2NlbGwgY2VudGVyXG4gICAgICAgICAgICAgICAgY29uc3QgY3ggPSBjZWxsLnggKyBvZmZzZXQuZHggKyByMlxuICAgICAgICAgICAgICAgIGNvbnN0IGN5ID0gY2VsbC55ICsgb2Zmc2V0LmR5ICsgcjJcblxuICAgICAgICAgICAgICAgIC8vY29udmVydCBjb2xvclxuICAgICAgICAgICAgICAgIGNvbnN0IGNjID0gY29sb3IoY29sKVxuICAgICAgICAgICAgICAgIGlmICghY2MpIHJldHVyblxuXG4gICAgICAgICAgICAgICAgLy9yYW5kb20gcG9pbnRzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gZG90TnVtYmVyOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHByb2cuYWRkUG9pbnREYXRhMihjeCArIHJhbmQoKSwgY3kgKyByYW5kKCksIGNjLnIsIGNjLmcsIGNjLmIsIGNjLm9wYWNpdHkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZHJhd1xuICAgICAgICAgICAgcHJvZy5kcmF3KGdlb0NhbnZhcy5nZXRXZWJHTFRyYW5zZm9ybSgpKVxuXG4gICAgICAgICAgICAvL2RyYXcgaW4gY2FudmFzIGdlb1xuICAgICAgICAgICAgZ2VvQ2FudmFzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5kcmF3SW1hZ2UoY3ZXR0wuY2FudmFzLCAwLCAwKVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjZWxsIG9mIGNlbGxzKSB7XG5cbiAgICAgICAgICAgICAgICAvL2dldCBjb2xvclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKVxuICAgICAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxuICAgICAgICAgICAgICAgIC8vc2V0IGNvbG9yXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsU3R5bGUgPSBjb2xcblxuICAgICAgICAgICAgICAgIC8vbnVtYmVyIG9mIGRvdHNcbiAgICAgICAgICAgICAgICBjb25zdCBkb3ROdW1iZXIgPSB0aGlzLmRvdE51bWJlcihjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpXG5cbiAgICAgICAgICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjZWxsLCByZXNvbHV0aW9uLCB6KVxuXG4gICAgICAgICAgICAgICAgLy9kcmF3IHJhbmRvbSBkb3RzXG4gICAgICAgICAgICAgICAgY29uc3QgY3ggPSBjZWxsLnggKyBvZmZzZXQuZHggKyByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgICAgICAgICAgICAgY3kgPSBjZWxsLnkgKyBvZmZzZXQuZHkgKyByZXNvbHV0aW9uIC8gMlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRvdE51bWJlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbFJlY3QoY3ggKyByYW5kKCksIGN5ICsgcmFuZCgpLCBzR2VvLCBzR2VvKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHJlc29sdXRpb246IHJlc29sdXRpb24sIHo6IHosIHZpZXdTY2FsZTogdmlld1NjYWxlIH0pXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXG5cbi8qKlxuICogQG1vZHVsZSBzdHlsZVxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgSW1hZ2VTdHlsZSBleHRlbmRzIFN0eWxlIHtcblxuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGltYWdlIGNvZGUgb2YgYSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlciwgb2JqZWN0KTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuaW1hZ2VDb2RlID0gb3B0cy5pbWFnZUNvZGUgfHwgKCgpID0+ICcnKSAvLyhjLHIseix2cykgPT4ge31cblxuICAgICAgICAvKiogVGhlIGRpY3Rpb25uYXJ5IGNvZGUgLT4gaW1hZ2VcbiAgICAgICAgICogIEB0eXBlIHtvYmplY3R9ICAgICAgICAqL1xuICAgICAgICB0aGlzLmltYWdlcyA9IG9wdHMuaW1hZ2VzIHx8IHt9XG5cbiAgICAgICAgLyoqIFRoZSBpbWFnZSBzaXplIGluIGdyb3VuZCBtZXRlcnNcbiAgICAgICAgICogIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOm51bWJlcn0gICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZSB8fCAoKGNlbGwsIHJlc29sdXRpb24pID0+IHJlc29sdXRpb24pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0LmpzXCIpLkNlbGw+fSBjZWxsc1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuR2VvQ2FudmFzfSBnZW9DYW52YXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGRyYXcoY2VsbHMsIGdlb0NhbnZhcywgcmVzb2x1dGlvbikge1xuXG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IHogPSBnZW9DYW52YXMudmlldy56LFxuICAgICAgICAgICAgcmVzb2x1dGlvblBpeCA9IHJlc29sdXRpb24gLyB6XG5cbiAgICAgICAgLy9nZXQgdmlldyBzY2FsZVxuICAgICAgICBjb25zdCB2aWV3U2NhbGUgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vZHJhdyBpbiBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAgICAgZ2VvQ2FudmFzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgIC8vXG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgY2VsbHMpIHtcblxuICAgICAgICAgICAgLy9nZXQgY2VsbCBpbWFnZSBjb2RlXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5pbWFnZUNvZGUoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKVxuXG4gICAgICAgICAgICAvL2dldCBpbWFnZVxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlc1tjb2RlXVxuICAgICAgICAgICAgaWYgKCFpbWFnZSkgY29udGludWVcblxuICAgICAgICAgICAgLy9zaXplIGFuZCBwb3NpdGlvbiB2YWx1ZXNcbiAgICAgICAgICAgIGxldCBzaXplUGl4ID0gdGhpcy5zaXplKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgLyB6XG4gICAgICAgICAgICBpZiAoIXNpemVQaXgpIGNvbnRpbnVlXG4gICAgICAgICAgICBjb25zdCBkID0gKHJlc29sdXRpb25QaXggLSBzaXplUGl4KSAvIDJcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmRyYXdJbWFnZShpbWFnZSwgZ2VvQ2FudmFzLmdlb1RvUGl4WChjZWxsLngpICsgZCwgZ2VvQ2FudmFzLmdlb1RvUGl4WShjZWxsLnkpICsgZCAtcmVzb2x1dGlvblBpeCwgc2l6ZVBpeCwgc2l6ZVBpeClcblxuICAgICAgICAgICAgICAgIC8qL3JlZCBjb2xvciBmaWx0ZXJcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2UtaW4nO1xuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsUmVjdChnZW9DYW52YXMuZ2VvVG9QaXhYKGNlbGwueCkgKyBkLCBnZW9DYW52YXMuZ2VvVG9QaXhZKGNlbGwueSkgKyBkLCBzaXplUGl4LCBzaXplUGl4KTtcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7Ki9cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByZXNvbHV0aW9uOiByZXNvbHV0aW9uLCB6OiB6LCB2aWV3U2NhbGU6IHZpZXdTY2FsZSB9KVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xuaW1wb3J0IHsgU2lkZVN0eWxlIH0gZnJvbSAnLi9TaWRlU3R5bGUuanMnXG5cbi8qKiBAdHlwZWRlZiB7e3g6bnVtYmVyLHk6bnVtYmVyLG9yOlwidlwifFwiaFwiLGMxOmltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbHx1bmRlZmluZWQsYzI6aW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsfHVuZGVmaW5lZH19IFNpZGUgKi9cblxuLyoqXG4gKiBAbW9kdWxlIHN0eWxlXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBJc29GZW5jZVN0eWxlIGV4dGVuZHMgU3R5bGUge1xuXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGljdGlvbmFyeSAoc3RyaW5nIC0+IGNvbG9yKSB3aGljaCBnaXZlIHRoZSBjb2xvciBvZiBlYWNoIGNhdGVnb3J5LlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fSAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvclxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgaGVpZ2h0IG9mIGEgY2VsbCBpbiBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8ICgoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA9PiByZXNvbHV0aW9uICogMC40KVxuXG4gICAgICAgIC8qKiBUaGUgcGVyc3BlY3RpdmUgYW5nbGUsIGluIGRlZ3JlZSwgd2l0aGluIFstMTgwLDE4MF0sIGZyb20gW08seF0gYXhpcy5cbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5hbmdsZSA9IG9wdHMuYW5nbGUgIT0gdW5kZWZpbmVkID8gb3B0cy5hbmdsZSA6IDUwXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb3JuZXIgbGluZSBzdHJva2Ugc3R5bGUuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsbnVtYmVyLG51bWJlcixudW1iZXIpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb3JuZXJMaW5lU3Ryb2tlQ29sb3IgPSBvcHRzLmNvcm5lckxpbmVTdHJva2VDb2xvciB8fCAoKGMsIHIsIHosIGFuZ2xlKSA9PiBcIiM5OTlcIilcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvcm5lciBsaW5lIHdpZHRoLlxuICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsbnVtYmVyLG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5jb3JuZXJMaW5lV2lkdGggPSBvcHRzLmNvcm5lckxpbmVXaWR0aCB8fCAoKGMsIHIsIHosIGFuZ2xlKSA9PiAoYW5nbGUgJSA5MCA9PSAwID8gMCA6IDAuOCAqIHopKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFNob3cgdmVydGljYWwgY3Jvc3Mtc2VjdGlvbnMuXG4gICAgICAgICogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuc1ZlcnQgPSBvcHRzLnNWZXJ0ICE9IHVuZGVmaW5lZCA/IG9wdHMuc1ZlcnQgOiB0cnVlXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogU2hvdyBob3Jpem9udGFsIGNyb3NzLXNlY3Rpb25zLlxuICAgICAgICAqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnNIb3IgPSBvcHRzLnNIb3IgIT0gdW5kZWZpbmVkID8gb3B0cy5zSG9yIDogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb25cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcblxuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IHogPSBnZW9DYW52YXMudmlldy56XG5cbiAgICAgICAgLy9nZXQgdmlldyBzY2FsZVxuICAgICAgICBjb25zdCB2aWV3U2NhbGUgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vbmIgY2F0ZWdvcmllcyAtIHVzZWQgZm9yIHJhZGFyIGFuZCBhZ2VweXJhbWlkXG4gICAgICAgIGNvbnN0IGNhdHMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbG9yKVxuXG4gICAgICAgIC8vaGFsZiByZXNvbHV0aW9uXG4gICAgICAgIGNvbnN0IHIyID0gcmVzb2x1dGlvbiAvIDJcblxuICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldCh1bmRlZmluZWQsIHJlc29sdXRpb24sIHopLCBkeCA9IG9mZnNldC5keCwgZHkgPSBvZmZzZXQuZHlcblxuICAgICAgICAvL21ha2Ugc2lkZXNcbiAgICAgICAgLyoqICBAdHlwZSB7QXJyYXkuPFNpZGU+fSAqL1xuICAgICAgICBjb25zdCBzaWRlcyA9IFNpZGVTdHlsZS5idWlsZFNpZGVzKGNlbGxzLCByZXNvbHV0aW9uLCB0aGlzLmFuZ2xlICUgMTgwICE9IDkwICYmIHRoaXMuc1ZlcnQsIHRoaXMuYW5nbGUgJSAxODAgIT0gMCAmJiB0aGlzLnNIb3IpXG5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHNpZGVzLmxlbmd0aCA9PSAwKSByZXR1cm5cblxuICAgICAgICAvL2FuZ2xlIGluIHJhZGlhbnNcbiAgICAgICAgY29uc3QgYVJhZCA9IHRoaXMuYW5nbGUgKiBNYXRoLlBJIC8gMTgwLCBjb3MgPSBNYXRoLmNvcyhhUmFkKSwgc2luID0gTWF0aC5zaW4oYVJhZClcblxuICAgICAgICAvL3NvcnQgc2lkZXMgc28gdGhhdCB0aGUgYmFjayBvbmVzIGFyZSBkcmF3biBmaXJzdC4gVGhpcyBkZXBlbmRzIG9uIHRoZSBhbmdsZS5cbiAgICAgICAgLy9kZXBlbmRpbmcgb24gZGlzdGFuY2UgdG8gdGhlIHJlZmVyZW5jZSBjb3JuZXIgcG9pbnRcbiAgICAgICAgY29uc3QgeENvcm5lciA9IE1hdGguYWJzKHRoaXMuYW5nbGUpIDwgOTAgPyBnZW9DYW52YXMuZXh0R2VvLnhNaW4gOiBnZW9DYW52YXMuZXh0R2VvLnhNYXhcbiAgICAgICAgY29uc3QgeUNvcm5lciA9IHRoaXMuYW5nbGUgPCAwID8gZ2VvQ2FudmFzLmV4dEdlby55TWF4IDogZ2VvQ2FudmFzLmV4dEdlby55TWluXG4gICAgICAgIHNpZGVzLnNvcnQoKHMxLCBzMikgPT4gKE1hdGguaHlwb3QoczIueCAtIHhDb3JuZXIsIHMyLnkgLSB5Q29ybmVyKSAtIE1hdGguaHlwb3QoczEueCAtIHhDb3JuZXIsIHMxLnkgLSB5Q29ybmVyKSkpXG5cbiAgICAgICAgLy9wcmVwYXJlIGZ1bmN0aW9uIHRvIGRyYXcgY29ybmVyIGxpbmUgZm9yIGEgY2VsbCAqYypcbiAgICAgICAgY29uc3QgZHJhd0Nvcm5lckxpbmUgPSAoY2VsbCkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoIWNlbGwpIHJldHVyblxuICAgICAgICAgICAgLy9saW5lIHN0eWxlXG4gICAgICAgICAgICBjb25zdCBsdyA9IHRoaXMuY29ybmVyTGluZVdpZHRoID8gdGhpcy5jb3JuZXJMaW5lV2lkdGgoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdGhpcy5hbmdsZSkgOiAwLjggKiB6XG4gICAgICAgICAgICBpZiAobHcgPT0gMCkgcmV0dXJuXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb3JuZXJMaW5lU3Ryb2tlQ29sb3IgPyB0aGlzLmNvcm5lckxpbmVTdHJva2VDb2xvcihjZWxsLCByZXNvbHV0aW9uLCB6LCB0aGlzLmFuZ2xlKSA6IFwiIzMzM1wiXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVXaWR0aCA9IGx3XG5cbiAgICAgICAgICAgIC8vaGVpZ2h0IC0gaW4gZ2VvXG4gICAgICAgICAgICBjb25zdCBoRyA9IHRoaXMuaGVpZ2h0KGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSlcblxuICAgICAgICAgICAgLy9kcmF3IGxpbmVcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGNlbGwueCArIHIyICsgZHgsIGNlbGwueSArIHIyICsgZHkpXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjZWxsLnggKyByMiArIGhHICogY29zICsgZHgsIGNlbGwueSArIHIyICsgaEcgKiBzaW4gKyBkeSlcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZHJhdyBzaWRlc1xuICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgICAgIGZvciAobGV0IHNpZGUgb2Ygc2lkZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gc2lkZS5jMSwgYzIgPSBzaWRlLmMyLCB4ID0gc2lkZS54LCB5ID0gc2lkZS55XG5cbiAgICAgICAgICAgIC8vaGVpZ2h0cyAtIGluIGdlb1xuICAgICAgICAgICAgY29uc3QgaEcxID0gYzEgPyB0aGlzLmhlaWdodChjMSwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IDAsXG4gICAgICAgICAgICAgICAgaEcyID0gYzIgPyB0aGlzLmhlaWdodChjMiwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IDBcblxuICAgICAgICAgICAgLy9jb21wdXRlIHRvdGFscyBmb3IgYm90aCBjZWxsc1xuICAgICAgICAgICAgY29uc3QgdG90YWwxID0gY29tcHV0ZVRvdGFsKGMxLCBjYXRzKSxcbiAgICAgICAgICAgICAgICB0b3RhbDIgPSBjb21wdXRlVG90YWwoYzIsIGNhdHMpXG4gICAgICAgICAgICBpZiAodG90YWwxID09IDAgJiYgdG90YWwyID09IDApIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGxldCBjdW11bDEgPSAwLCBjdW11bDIgPSAwXG4gICAgICAgICAgICBmb3IgKGxldCBbY29sdW1uLCBjb2xvcl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb2xvcikpIHtcbiAgICAgICAgICAgICAgICAvL2RyYXcgc3RyaXBlIG9mIHNpZGUgcyBhbmQgY2F0ZWdvcnkgY29sdW1uXG5cbiAgICAgICAgICAgICAgICAvL2dldCB2YWx1ZXMgZm9yIGJvdGggY2VsbHNcbiAgICAgICAgICAgICAgICBsZXQgdjEgPSBjMSA/ICtjMVtjb2x1bW5dIDogMFxuICAgICAgICAgICAgICAgIGxldCB2MiA9IGMyID8gK2MyW2NvbHVtbl0gOiAwXG4gICAgICAgICAgICAgICAgaWYgKHYxID09IDAgJiYgdjIgPT0gMCkgY29udGludWVcblxuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBoZWlnaHRzXG4gICAgICAgICAgICAgICAgY29uc3QgaDEgPSBoRzEgKiBjdW11bDEgLyB0b3RhbDEgfHwgMFxuICAgICAgICAgICAgICAgIGNvbnN0IGgxbiA9IGhHMSAqIChjdW11bDEgKyB2MSkgLyB0b3RhbDEgfHwgMFxuICAgICAgICAgICAgICAgIGNvbnN0IGgyID0gaEcyICogY3VtdWwyIC8gdG90YWwyIHx8IDBcbiAgICAgICAgICAgICAgICBjb25zdCBoMm4gPSBoRzIgKiAoY3VtdWwyICsgdjIpIC8gdG90YWwyIHx8IDBcblxuICAgICAgICAgICAgICAgIC8vbWFrZSBwYXRoXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGlmIChzaWRlLm9yID09IFwiaFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaG9yaXpvbnRhbCBzaWRlIC0gdmVydGljYWwgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKHggKyBoMSAqIGNvcyArIGR4LCB5IC0gcjIgKyBoMSAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgICAgICAvL3RvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKHggKyBoMiAqIGNvcyArIGR4LCB5ICsgcjIgKyBoMiAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgICAgICAvL3RvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyh4ICsgaDJuICogY29zICsgZHgsIHkgKyByMiArIGgybiAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyh4ICsgaDFuICogY29zICsgZHgsIHkgLSByMiArIGgxbiAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdmVydGljYWwgc2lkZSAtIGhvcml6b250YWwgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKHggLSByMiArIGgxICogY29zICsgZHgsIHkgKyBoMSAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyh4ICsgcjIgKyBoMiAqIGNvcyArIGR4LCB5ICsgaDIgKiBzaW4gKyBkeSlcbiAgICAgICAgICAgICAgICAgICAgLy90b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oeCArIHIyICsgaDJuICogY29zICsgZHgsIHkgKyBoMm4gKiBzaW4gKyBkeSlcbiAgICAgICAgICAgICAgICAgICAgLy90b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyh4IC0gcjIgKyBoMW4gKiBjb3MgKyBkeCwgeSArIGgxbiAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2NnLmN0eC5jbG9zZVBhdGgoKVxuXG4gICAgICAgICAgICAgICAgLy9maWxsXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsU3R5bGUgPSBjb2xvclxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbCgpXG5cbiAgICAgICAgICAgICAgICBjdW11bDEgKz0gdjFcbiAgICAgICAgICAgICAgICBjdW11bDIgKz0gdjJcblxuICAgICAgICAgICAgICAgIC8vVE9ETyBkcmF3IG9ubHkgb25lIGxpbmVcbiAgICAgICAgICAgICAgICAvL2RyYXcgY29ybmVyIGxpbmVcbiAgICAgICAgICAgICAgICAvL2lmIChzaWRlLm9yID09IFwiaFwiKSB7XG4gICAgICAgICAgICAgICAgZHJhd0Nvcm5lckxpbmUoYzEpXG4gICAgICAgICAgICAgICAgZHJhd0Nvcm5lckxpbmUoYzIpXG4gICAgICAgICAgICAgICAgLy9pZiAodGhpcy5hbmdsZSA+IDAgJiYgc2lkZS5vciA9PSBcImhcIikgZHJhd0Nvcm5lckxpbmUoYzIpXG4gICAgICAgICAgICAgICAgLy9lbHNlIGRyYXdDb3JuZXJMaW5lKGMyKVxuICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgdmlld1NjYWxlOiB2aWV3U2NhbGUgfSlcbiAgICB9XG59XG5cblxuXG5jb25zdCBjb21wdXRlVG90YWwgPSAoY2VsbCwgY2F0ZWdvcmllcykgPT4ge1xuICAgIGlmICghY2VsbCkgcmV0dXJuIDBcbiAgICBsZXQgdG90YWwgPSAwXG4gICAgZm9yIChsZXQgY29sdW1uIG9mIGNhdGVnb3JpZXMpIHtcbiAgICAgICAgY29uc3QgdiA9IGNlbGxbY29sdW1uXVxuICAgICAgICBpZiAoIXYpIGNvbnRpbnVlXG4gICAgICAgIHRvdGFsICs9ICt2XG4gICAgfVxuICAgIHJldHVybiB0b3RhbCB8fCAwXG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vY29yZS9TdHlsZS5qcydcblxuLyoqXG4gKiBAbW9kdWxlIHN0eWxlXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBKb3lQbG90U3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgaGVpZ2h0IG9mIGEgY2VsbCBpbiBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8ICgoYywgcikgPT4gciAqIE1hdGgucmFuZG9tKCkpIC8vKGMscix6LHZzKSA9PiB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLHttaW46bnVtYmVyLCBtYXg6bnVtYmVyfSxudW1iZXIsbnVtYmVyKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMubGluZUNvbG9yID0gb3B0cy5saW5lQ29sb3IgfHwgKCh5LCB5cywgciwgeikgPT4gJyNCQkInKVxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcix7bWluOm51bWJlciwgbWF4Om51bWJlcn0sbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IG9wdHMubGluZVdpZHRoIHx8ICgoeSwgeXMsIHIsIHopID0+IHopXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLHttaW46bnVtYmVyLCBtYXg6bnVtYmVyfSxudW1iZXIsbnVtYmVyKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gb3B0cy5maWxsQ29sb3IgfHwgKCh5LCB5cywgciwgeikgPT4gJyNjMDhjNTk2OCcpXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XG5cbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL1xuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxuXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcbiAgICAgICAgY29uc3Qgdmlld1NjYWxlID0gdGhpcy52aWV3U2NhbGUgPyB0aGlzLnZpZXdTY2FsZShjZWxscywgcmVzb2x1dGlvbiwgeikgOiB1bmRlZmluZWRcblxuICAgICAgICAvL2luZGV4IGNlbGxzIGJ5IHkgYW5kIHhcbiAgICAgICAgLyoqICBAdHlwZSB7b2JqZWN0fSAqL1xuICAgICAgICBjb25zdCBpbmQgPSB7fVxuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgIGxldCByb3cgPSBpbmRbY2VsbC55XVxuICAgICAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgICAgICByb3cgPSB7fVxuICAgICAgICAgICAgICAgIGluZFtjZWxsLnldID0gcm93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dbY2VsbC54XSA9IHRoaXMuaGVpZ2h0KGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29tcHV0ZSBleHRlbnRcbiAgICAgICAgY29uc3QgZSA9IGdlb0NhbnZhcy5leHRHZW9cbiAgICAgICAgaWYgKCFlKSByZXR1cm5cbiAgICAgICAgY29uc3QgeE1pbiA9IE1hdGguZmxvb3IoZS54TWluIC8gcmVzb2x1dGlvbikgKiByZXNvbHV0aW9uXG4gICAgICAgIGNvbnN0IHhNYXggPSBNYXRoLmZsb29yKGUueE1heCAvIHJlc29sdXRpb24pICogcmVzb2x1dGlvblxuICAgICAgICBjb25zdCB5TWluID0gTWF0aC5mbG9vcihlLnlNaW4gLyByZXNvbHV0aW9uKSAqIHJlc29sdXRpb25cbiAgICAgICAgY29uc3QgeU1heCA9IE1hdGguZmxvb3IoZS55TWF4IC8gcmVzb2x1dGlvbikgKiByZXNvbHV0aW9uXG5cbiAgICAgICAgLyoqICBAdHlwZSB7e21pbjpudW1iZXIsIG1heDpudW1iZXJ9fSAqL1xuICAgICAgICBjb25zdCB5cyA9IHsgbWluOiB5TWluLCBtYXg6IHlNYXggfVxuXG4gICAgICAgIC8vZHJhdyBsaW5lcywgcm93IGJ5IHJvdywgc3RhdGluZyBmcm9tIHRoZSB0b3BcbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lSm9pbiA9ICdyb3VuZCdcbiAgICAgICAgZm9yIChsZXQgeSA9IHlNYXg7IHkgPj0geU1pbjsgeSAtPSByZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICAvL2dldCByb3dcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGluZFt5XVxuXG4gICAgICAgICAgICAvL25vIHJvd1xuICAgICAgICAgICAgaWYgKCFyb3cpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vcGxhY2UgZmlyc3QgcG9pbnRcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKHhNaW4gLSByZXNvbHV0aW9uIC8gMiwgeSlcblxuICAgICAgICAgICAgLy9zdG9yZSB0aGUgcHJldmlvdXMgaGVpZ2h0XG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICBsZXQgaEdfXG5cbiAgICAgICAgICAgIC8vZ28gdGhyb3VnaCB0aGUgbGluZSBjZWxsc1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHhNaW47IHggPD0geE1heDsgeCArPSByZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy9nZXQgY29sdW1uIHZhbHVlXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICAgICAgbGV0IGhHID0gcm93W3hdXG4gICAgICAgICAgICAgICAgaWYgKCFoRykgaEcgPSAwXG5cbiAgICAgICAgICAgICAgICBpZiAoaEcgfHwgaEdfKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZHJhdyBsaW5lIG9ubHkgd2hlbiBhdCBsZWFzdCBvbmUgb2YgYm90aCB2YWx1ZXMgaXMgbm9uLW51bGxcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIHRlc3QgYmV6aWVyQ3VydmVUb1xuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyh4ICsgcmVzb2x1dGlvbiAvIDIsIHkgKyBoRylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2Vsc2UgbW92ZSB0aGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5tb3ZlVG8oeCArIHJlc29sdXRpb24gLyAyLCB5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL3N0b3JlIHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICAgICAgICAgIGhHXyA9IGhHXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vbGFzdCBwb2ludFxuICAgICAgICAgICAgaWYgKGhHXykgZ2VvQ2FudmFzLmN0eC5saW5lVG8oeE1heCArIHJlc29sdXRpb24gLyAyLCB5KVxuXG4gICAgICAgICAgICAvL2RyYXcgZmlsbFxuICAgICAgICAgICAgY29uc3QgZmMgPSB0aGlzLmZpbGxDb2xvcih5LCB5cywgcmVzb2x1dGlvbiwgeilcbiAgICAgICAgICAgIGlmIChmYyAmJiBmYyAhPSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGxTdHlsZSA9IGZjXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kcmF3IGxpbmVcbiAgICAgICAgICAgIGNvbnN0IGxjID0gdGhpcy5saW5lQ29sb3IoeSwgeXMsIHJlc29sdXRpb24sIHopXG4gICAgICAgICAgICBjb25zdCBsdyA9IHRoaXMubGluZVdpZHRoKHksIHlzLCByZXNvbHV0aW9uLCB6KVxuICAgICAgICAgICAgaWYgKGxjICYmIGxjICE9ICdub25lJyAmJiBsdyA+IDApIHtcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZVN0eWxlID0gbGNcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVXaWR0aCA9IGx3XG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2UoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBUYW5ha2FTdHlsZSB9IGZyb20gJy4vVGFuYWthU3R5bGUuanMnXG5pbXBvcnQgeyBTdHJva2VTdHlsZSB9IGZyb20gJy4vU3Ryb2tlU3R5bGUuanMnXG5pbXBvcnQgeyBTcXVhcmVDb2xvckNhdGVnb3J5V2ViR0xTdHlsZSB9IGZyb20gJy4vU3F1YXJlQ29sb3JDYXRlZ29yeVdlYkdMU3R5bGUuanMnXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXG5cbi8qKlxuICogQG1vZHVsZSBzdHlsZVxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgTGVnb1N0eWxlIHtcblxuICAgIHN0YXRpYyBnZXQodmFsdWUsIGJyZWFrcywgY29sb3JzLCBvcHRzID0ge30pIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvL3RoZSBjb2xvcnNcbiAgICAgICAgLy9odHRwOi8vd3d3Lmplbm55c2NyYXlvbmNvbGxlY3Rpb24uY29tLzIwMjEvMDYvYWxsLWN1cnJlbnQtbGVnby1jb2xvcnMuaHRtbFxuICAgICAgICAvL2h0dHBzOi8vbGVvbmF3aWN6LmdpdGh1Yi5pby9sZWdvY29sb3JzL3JlZmVyZW5jZS9maWd1cmVzL1JFQURNRS1wbG90LTEucG5nXG4gICAgICAgIC8qb3B0cy5jb2xvcnMgPSBvcHRzLmNvbG9ycyB8fCBbXG4gICAgICAgICAgICAnIzAwODUyYicsIC8vZGFya2VyIGdyZWVuXG4gICAgICAgICAgICAnI2FmZDI0NicsIC8vbGlnaHQgZ3JlZW5cbiAgICAgICAgICAgICcjZmFjODBhJywgLy9kYXJrIHllbGxvd1xuICAgICAgICAgICAgJyNiYjgwNWEnLCAvL2Jyb3duXG4gICAgICAgICAgICAnI2Q2NzkyMycsIC8vbW9zdGFyZFxuICAgICAgICAgICAgJyNjYjRlMjknLCAvL3JlZGlzaFxuICAgICAgICAgICAgJyNiNDAwMDAnLCAvL3JlZFxuICAgICAgICAgICAgJyM3MjAwMTInLCAvL2RhcmsgcmVkXG4gICAgICAgICAgICAvL1wicHVycGxlXCIsXG4gICAgICAgICAgICAvL1wiI2VlZVwiIC8vd2hpdGhlXG4gICAgICAgIF0qL1xuXG4gICAgICAgIG9wdHMuY29sRGFyayA9IG9wdHMuY29sRGFyayB8fCAnIzMzMydcbiAgICAgICAgb3B0cy5jb2xCcmlnaHQgPSBvcHRzLmNvbEJyaWdodCB8fCAnI2FhYSdcbiAgICAgICAgb3B0cy53aWR0aEZhY3RvciA9IG9wdHMud2lkdGhGYWN0b3IgfHwgMC4xMlxuXG4gICAgICAgIC8vcmV1c2UgdGFuYWthIGFzIGJhc2lzXG4gICAgICAgIGNvbnN0IHRzID0gVGFuYWthU3R5bGUuZ2V0KHZhbHVlLCBicmVha3MsIGNvbG9ycywgb3B0cylcbiAgICAgICAgLy9zdHlsZSB0byBzaG93IGxpbWl0cyBiZXR3ZWVuIHBpZWNlc1xuICAgICAgICBjb25zdCBzc3QgPSBuZXcgU3Ryb2tlU3R5bGUoe1xuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6ICgpID0+ICcjNjY2JyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAoYywgciwgeikgPT4gMC4yICogeixcbiAgICAgICAgICAgIGZpbHRlcjogb3B0cy5maWx0ZXIsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRzWzBdLFxuICAgICAgICAgICAgc3N0LFxuICAgICAgICAgICAgdHNbMV0sXG4gICAgICAgICAgICBuZXcgTGVnb1RvcFN0eWxlKHsgY29sRGFyazogb3B0cy5jb2xEYXJrLCBjb2xCcmlnaHQ6IG9wdHMuY29sQnJpZ2h0LCBmaWx0ZXI6IG9wdHMuZmlsdGVyIH0pLFxuICAgICAgICBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwpOnN0cmluZ30gY29kZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb2xvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICogQHJldHVybnMge0FycmF5LjxTdHlsZT59XG4gICAgICovXG4gICAgc3RhdGljIGdldENhdGVnb3J5KGNvZGUsIGNvbG9yLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgb3B0cy5jb2xEYXJrID0gb3B0cy5jb2xEYXJrIHx8ICcjMzMzJ1xuICAgICAgICBvcHRzLmNvbEJyaWdodCA9IG9wdHMuY29sQnJpZ2h0IHx8ICcjYWFhJ1xuXG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IHMgPSBuZXcgU3F1YXJlQ29sb3JDYXRlZ29yeVdlYkdMU3R5bGUoeyBjb2RlOiBjb2RlLCBjb2xvcjogY29sb3IgfSlcbiAgICAgICAgLy9zdHlsZSB0byBzaG93IGxpbWl0cyBiZXR3ZWVuIHBpZWNlc1xuICAgICAgICBjb25zdCBzc3QgPSBuZXcgU3Ryb2tlU3R5bGUoeyBzdHJva2VDb2xvcjogKCkgPT4gJyM2NjYnLCBzdHJva2VXaWR0aDogKGMsIHIsIHopID0+IDAuMiAqIHogfSlcblxuICAgICAgICByZXR1cm4gW3MsIHNzdCwgbmV3IExlZ29Ub3BTdHlsZSh7IGNvbERhcms6IG9wdHMuY29sRGFyaywgY29sQnJpZ2h0OiBvcHRzLmNvbEJyaWdodCB9KV1cbiAgICB9XG59XG5cbi8qKlxuICogQSBzdHlsZSB0byBkcmF3IHRvcCBjaXJjbGUgb2YgbGVnbyBicmlja3MuXG4gKi9cbmNsYXNzIExlZ29Ub3BTdHlsZSBleHRlbmRzIFN0eWxlIHtcbiAgICAvKiogQHBhcmFtIHtvYmplY3R8dW5kZWZpbmVkfSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuICAgICAgICB0aGlzLmNvbERhcmsgPSBvcHRzLmNvbERhcmsgfHwgJyMzMzMnXG4gICAgICAgIHRoaXMuY29sQnJpZ2h0ID0gb3B0cy5jb2xCcmlnaHQgfHwgJyNhYWEnXG4gICAgfVxuXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByKSB7XG4gICAgICAgIC8vZmlsdGVyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXG5cbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lV2lkdGggPSAwLjYgKiBnZW9DYW52YXMudmlldy56XG5cbiAgICAgICAgLy9kYXJrIHBhcnRcbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sRGFya1xuICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmFyYyhjLnggKyByICogMC41LCBjLnkgKyByICogMC41LCByICogMC41NSAqIDAuNSwgTWF0aC5QSSAvIDQsIC1NYXRoLlBJICogKDMgLyA0KSwgdHJ1ZSlcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYnJpZ2h0IHBhcnRcbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sQnJpZ2h0XG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYXJjKGMueCArIHIgKiAwLjUsIGMueSArIHIgKiAwLjUsIHIgKiAwLjU1ICogMC41LCBNYXRoLlBJIC8gNCwgLU1hdGguUEkgKiAoMyAvIDQpLCBmYWxzZSlcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlKClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xuXG4vKipcbiAqIEBtb2R1bGUgc3R5bGVcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIE1vc2FpY1N0eWxlIGV4dGVuZHMgU3R5bGUge1xuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlciwgb2JqZWN0KTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiBcIiNFQTZCQUNcIikgLy8oYyxyLHosdnMpID0+IHt9XG5cbiAgICAgICAgLyoqIFRoZSBtb3NhaWMgZmFjdG9yLCB3aXRoaW4gWzAsMC41XS4gU2V0IHRvIDAgZm9yIG5vIG1vc2FpYyBlZmZlY3QuIFNldCB0byAwLjUgZm9yIHN0cm9uZyBtb3NhaWMgZWZmZWN0LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm1vc2FpY0ZhY3RvciA9IG9wdHMubW9zYWljRmFjdG9yIHx8IDAuMTVcblxuICAgICAgICAvKiogVGhlIG1vc2FpYyBzaGFkb3cgZmFjdG9yLCB3aXRoaW4gWzAsMC41XS4gU2V0IHRvIDAgZm9yIG5vIG1vc2FpYyBzaGFkb3cuIFNldCB0byAwLjUgZm9yIHN0cm9uZyBtb3NhaWMgc2hhZG93LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnNoYWRvd0ZhY3RvciA9IG9wdHMuc2hhZG93RmFjdG9yIHx8IDAuMlxuXG4gICAgICAgIC8qKiBUaGUgbW9zYWljIHNoYWRvdyBjb2xvci5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5zaGFkb3dDb2xvciA9IG9wdHMuc2hhZG93Q29sb3IgfHwgJyM1NTUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XG5cbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL1xuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxuXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcbiAgICAgICAgY29uc3Qgdmlld1NjYWxlID0gdGhpcy52aWV3U2NhbGUgPyB0aGlzLnZpZXdTY2FsZShjZWxscywgcmVzb2x1dGlvbiwgeikgOiB1bmRlZmluZWRcblxuICAgICAgICAvL3NldCBzdHJva2Ugc3R5bGUsIGZvciBzaGFkb3dcbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc2hhZG93Q29sb3JcbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lV2lkdGggPSB0aGlzLnNoYWRvd0ZhY3RvciAqIHJlc29sdXRpb25cbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lSm9pbiA9ICdyb3VuZCdcbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lQ2FwID0gJ2J1dHQnXG5cbiAgICAgICAgLy9mdW5jdGlvbiB0byBjb21wdXRlIHBvc2l0aW9uIG1vc2FpYyBlZmZlY3RcbiAgICAgICAgY29uc3QgZCA9IHJlc29sdXRpb24gKiB0aGlzLm1vc2FpY0ZhY3RvclxuICAgICAgICBjb25zdCBtb3NhaWMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBNYXRoLnJhbmRvbSgpICogZCwgeTogTWF0aC5yYW5kb20oKSAqIGQgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xuICAgICAgICAgICAgLy9zZXQgZmlsbCBjb2xvclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3IoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFjb2wgfHwgY29sID09PSAnbm9uZScpIGNvbnRpbnVlXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGxTdHlsZSA9IGNvbFxuXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGNlbGwsIHJlc29sdXRpb24sIHopXG5cbiAgICAgICAgICAgIC8vY29tcHV0ZSBwb3NpdGlvbiBtb3NhaWMgZWZmZWN0XG4gICAgICAgICAgICBjb25zdCBsbCA9IG1vc2FpYygpLFxuICAgICAgICAgICAgICAgIHVsID0gbW9zYWljKCksXG4gICAgICAgICAgICAgICAgbHIgPSBtb3NhaWMoKSxcbiAgICAgICAgICAgICAgICB1ciA9IG1vc2FpYygpXG5cbiAgICAgICAgICAgIC8vc3Ryb2tlXG4gICAgICAgICAgICBpZiAodGhpcy5zaGFkb3dGYWN0b3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGNlbGwueCArIG9mZnNldC5keCArIGxsLngsIGNlbGwueSArIG9mZnNldC5keSArIGxsLnkpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgcmVzb2x1dGlvbiAtIGxyLngsIGNlbGwueSArIG9mZnNldC5keSArIGxyLnkpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgcmVzb2x1dGlvbiAtIHVyLngsIGNlbGwueSArIG9mZnNldC5keSArIHJlc29sdXRpb24gLSB1ci55KVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9maWxsXG5cbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGNlbGwueCArIG9mZnNldC5keCArIGxsLngsIGNlbGwueSArIG9mZnNldC5keSArIGxsLnkpXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjZWxsLnggKyBvZmZzZXQuZHggKyByZXNvbHV0aW9uIC0gbHIueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgbHIueSlcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGNlbGwueCArIG9mZnNldC5keCArIHJlc29sdXRpb24gLSB1ci54LCBjZWxsLnkgKyBvZmZzZXQuZHkgKyByZXNvbHV0aW9uIC0gdXIueSlcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGNlbGwueCArIG9mZnNldC5keCArIHVsLngsIGNlbGwueSArIG9mZnNldC5keSArIHJlc29sdXRpb24gLSB1bC55KVxuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHJlc29sdXRpb246IHJlc29sdXRpb24sIHo6IHosIHZpZXdTY2FsZTogdmlld1NjYWxlIH0pXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXG5cbi8qKlxuICogQG1vZHVsZSBzdHlsZVxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgTmluamFTdGFyU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIGNlbGwuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKCgpID0+IFwiI0VBNkJBQ1wiKSAvLyhjLHIseix2cykgPT4ge31cblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgYSBjZWxsLCB3aXRoaW4gWzAsMV06XG4gICAgICAgICAqICAtIDAsIG5vdGhpbmcgc2hvd25cbiAgICAgICAgICogIC0gMSwgZW50aXJlIHNxdWFyZVxuICAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnNpemUgPSBvcHRzLnNpemUgfHwgKChjZWxsLCByZXNvbHV0aW9uKSA9PiByZXNvbHV0aW9uKSAvLyhjLHIseix2cykgPT4ge31cblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNoYXBlLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkNlbGwpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5zaGFwZSA9IG9wdHMuc2hhcGUgfHwgKCgpID0+ICdvJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XG5cbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL1xuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxuXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcbiAgICAgICAgY29uc3Qgdmlld1NjYWxlID0gdGhpcy52aWV3U2NhbGUgPyB0aGlzLnZpZXdTY2FsZShjZWxscywgcmVzb2x1dGlvbiwgeikgOiB1bmRlZmluZWRcblxuICAgICAgICBjb25zdCByMiA9IHJlc29sdXRpb24gKiAwLjVcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xuICAgICAgICAgICAgLy9jb2xvclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3IoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFjb2wgfHwgY29sID09PSAnbm9uZScpIGNvbnRpbnVlXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGxTdHlsZSA9IGNvbFxuXG4gICAgICAgICAgICAvL3NpemUgLSBpbiBnZW8gdW5pdFxuICAgICAgICAgICAgbGV0IGsgPSB0aGlzLnNpemUoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKVxuICAgICAgICAgICAgayA9IGsgPCAwID8gMCA6IGsgPiAxID8gMSA6IGtcbiAgICAgICAgICAgIGNvbnN0IHNHMiA9IGsgKiByMlxuXG4gICAgICAgICAgICAvL3NoYXBlXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuc2hhcGUgPyB0aGlzLnNoYXBlKGNlbGwpIDogJ28nXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdub25lJykgY29udGludWVcblxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XG4gICAgICAgICAgICAvL1RPRE8gdXNlXG4gICAgICAgICAgICAvL2NvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGNlbGwsIHIsIHopXG5cbiAgICAgICAgICAgIC8vY2VudGVyIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBjeCA9IGNlbGwueCArIHIyXG4gICAgICAgICAgICBjb25zdCBjeSA9IGNlbGwueSArIHIyXG5cbiAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGN4LCBjeSArIHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGN4ICsgc0cyLCBjeSArIHNHMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjeCArIHIyLCBjeSlcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjeCArIHNHMiwgY3kgLSBzRzIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oY3gsIGN5IC0gcjIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oY3ggLSBzRzIsIGN5IC0gc0cyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGN4IC0gcjIsIGN5KVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGN4IC0gc0cyLCBjeSArIHNHMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGwoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ28nKSB7XG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGN4LCBjeSArIHNHMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjeCArIHIyLCBjeSArIHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGN4ICsgc0cyLCBjeSlcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjeCArIHIyLCBjeSAtIHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGN4LCBjeSAtIHNHMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjeCAtIHIyLCBjeSAtIHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGN4IC0gc0cyLCBjeSlcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjeCAtIHIyLCBjeSArIHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbCgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzaGFwZTonICsgc2hhcGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByZXNvbHV0aW9uOiByZXNvbHV0aW9uLCB6OiB6LCB2aWV3U2NhbGU6IHZpZXdTY2FsZSB9KVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xuXG4vKipcbiAqIEBtb2R1bGUgc3R5bGVcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFBpbGxhclN0eWxlIGV4dGVuZHMgU3R5bGUge1xuXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgaGVpZ2h0IG9mIHRoZSBsaW5lIHJlcHJlc2VudGluZyBhIGNlbGwsIGluIGdlbyB1bml0XG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodFxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIGxpbmUgcmVwcmVzZW50aW5nIGEgY2VsbC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKCkgPT4gXCIjYzA4YzU5XCIpIC8vKGMscix6LHZzKSA9PiB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgd2lkdGggb2YgdGhlIGxpbmUgcmVwcmVzZW50aW5nIGEgY2VsbCwgaW4gZ2VvIHVuaXRcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKGNlbGwsIHJlc29sdXRpb24pID0+IDAuNSAqIHJlc29sdXRpb24pXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB3aWR0aCBvZiB0aGUgbGluZSByZXByZXNlbnRpbmcgYSBjZWxsLCBpbiBnZW8gdW5pdFxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsb2JqZWN0KTpib29sZWFufSAqL1xuICAgICAgICB0aGlzLnNpbXBsZSA9IG9wdHMuc2ltcGxlIHx8ICgoKSA9PiBmYWxzZSlcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy52aWV3SGVpZ2h0RmFjdG9yID0gb3B0cy52aWV3SGVpZ2h0RmFjdG9yIHx8IDEuNVxuICAgICAgICAvLzAsMCBpcyB0aGUgY2VudGVyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnZpZXdTWCA9IG9wdHMudmlld1NYID09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLnZpZXdTWFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy52aWV3U1kgPSBvcHRzLnZpZXdTWSA9PSB1bmRlZmluZWQgPyAtMC41IDogb3B0cy52aWV3U1lcblxuICAgICAgICAvL1RPRE8gcmVwbGFjZSB3aXRoIHN1biBsb2NhdGlvbiA/XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnNoYWRvd0RpcmVjdGlvbiA9XG4gICAgICAgICAgICBvcHRzLnNoYWRvd0RpcmVjdGlvbiA9PSB1bmRlZmluZWQgPyAoLTQwLjMgKiBNYXRoLlBJKSAvIDE4MC4wIDogb3B0cy5zaGFkb3dEaXJlY3Rpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc2hhZG93RmFjdG9yID0gb3B0cy5zaGFkb3dGYWN0b3IgfHwgMC4zXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnNoYWRvd0NvbG9yID0gb3B0cy5zaGFkb3dDb2xvciB8fCAnIzAwMDAwMDMzJ1xuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLm91dGxpbmVDb2wgPSBvcHRzLm91dGxpbmVDb2wgfHwgJyNGRkZGRkYnXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm91dGxpbmVXaWR0aFBpeCA9IG9wdHMub3V0bGluZVdpZHRoUGl4ID09IHVuZGVmaW5lZCA/IDAuNSA6IG9wdHMub3V0bGluZVdpZHRoUGl4XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBjZWxscyBhcyBzZWdtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb25cbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcblxuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IHogPSBnZW9DYW52YXMudmlldy56XG5cbiAgICAgICAgLy9nZXQgdmlldyBzY2FsZVxuICAgICAgICBjb25zdCB2aWV3U2NhbGUgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vZ2V0IHZpZXcgY2VudGVyIGdlbyBwb3NpdGlvblxuICAgICAgICBjb25zdCBjdnggPSBnZW9DYW52YXMudmlldy54ICsgdGhpcy52aWV3U1ggKiBnZW9DYW52YXMudyAqIHpcbiAgICAgICAgY29uc3QgY3Z5ID0gZ2VvQ2FudmFzLnZpZXcueSArIHRoaXMudmlld1NZICogZ2VvQ2FudmFzLmggKiB6XG4gICAgICAgIC8vZ2V0IHZpZXcgaGVpZ2h0XG4gICAgICAgIGNvbnN0IEggPSB0aGlzLnZpZXdIZWlnaHRGYWN0b3IgKiAoZ2VvQ2FudmFzLncgKyBnZW9DYW52YXMuaCkgKiAwLjUgKiB6XG5cbiAgICAgICAgLy9zb3J0IGNlbGxzIGJ5IHkgYW5kIHhcbiAgICAgICAgLy9jb25zdCBkaXN0VG9WaWV3Q2VudGVyID0gKGMpID0+IHsgY29uc3QgZHggPSBjdnggLSBjLngsIGR5ID0gY3Z5IC0gYy55OyByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSB9XG4gICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gMTAwMDAwMDAwICogKGMyLnkgLSBjMS55KSArIGMxLnggLSBjMi54KVxuXG4gICAgICAgIC8vZ2V0IHNpbXBsZSBpbmZvcm1hdGlvblxuICAgICAgICBjb25zdCBzaW1wbGUgPSB0aGlzLnNpbXBsZShyZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpXG5cbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lQ2FwID0gc2ltcGxlID8gJ2J1dHQnIDogJ3JvdW5kJ1xuXG4gICAgICAgIC8vZHJhdyBzaGFkb3dzXG4gICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnNoYWRvd0NvbG9yXG4gICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbFN0eWxlID0gdGhpcy5zaGFkb3dDb2xvclxuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIGNlbGxzKSB7XG4gICAgICAgICAgICAvL3dpZHRoXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICBjb25zdCB3RyA9IHRoaXMud2lkdGggPyB0aGlzLndpZHRoKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghd0cgfHwgd0cgPCAwKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL2hlaWdodFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgY29uc3QgaEcgPSB0aGlzLmhlaWdodCA/IHRoaXMuaGVpZ2h0KGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghaEcgfHwgaEcgPCAwKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgICAgIC8vVE9ETyB1c2UgdGhhdFxuICAgICAgICAgICAgLy9jb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjLCByZXNvbHV0aW9uLCB6KVxuXG4gICAgICAgICAgICAvL3NldCB3aWR0aFxuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lV2lkdGggPSB3R1xuXG4gICAgICAgICAgICAvL2NvbXB1dGUgY2VsbCBjZW50ZXIgcG9zdGl0aW9uXG4gICAgICAgICAgICBjb25zdCBjeCA9IGNlbGwueCArIHJlc29sdXRpb24gLyAyXG4gICAgICAgICAgICBjb25zdCBjeSA9IGNlbGwueSArIHJlc29sdXRpb24gLyAyXG4gICAgICAgICAgICBjb25zdCBscyA9IGhHICogdGhpcy5zaGFkb3dGYWN0b3JcblxuICAgICAgICAgICAgLy9kcmF3IHNlZ21lbnRcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGN4LCBjeSlcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGN4ICsgbHMgKiBNYXRoLmNvcyh0aGlzLnNoYWRvd0RpcmVjdGlvbiksIGN5ICsgbHMgKiBNYXRoLnNpbih0aGlzLnNoYWRvd0RpcmVjdGlvbikpXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZSgpXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBpZiAodGhpcy5zaW1wbGUpIHtcbiAgICAgICAgICAgICAgICAvL2RyYXcgYmFzZSBjaXJjbGVcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY2cuY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgY3gsIGN5LFxuICAgICAgICAgICAgICAgICAgICB3RyAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvL2NnLmN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbCgpO1xuICAgICAgICAgICAgfSovXG4gICAgICAgIH1cblxuICAgICAgICAvL2RyYXcgcGlsbGFyc1xuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIGNlbGxzKSB7XG4gICAgICAgICAgICAvL2NvbG9yXG4gICAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yID8gdGhpcy5jb2xvcihjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoIWNvbCkgY29udGludWVcblxuICAgICAgICAgICAgLy93aWR0aFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgY29uc3Qgd0cgPSB0aGlzLndpZHRoID8gdGhpcy53aWR0aChjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoIXdHIHx8IHdHIDwgMCkgY29udGludWVcblxuICAgICAgICAgICAgLy9oZWlnaHRcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIGNvbnN0IGhHID0gdGhpcy5oZWlnaHQgPyB0aGlzLmhlaWdodChjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoIWhHIHx8IGhHIDwgMCkgY29udGludWVcblxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XG4gICAgICAgICAgICAvL1RPRE8gdXNlIHRoYXRcbiAgICAgICAgICAgIC8vY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoYywgcmVzb2x1dGlvbiwgeilcblxuICAgICAgICAgICAgLy9jb21wdXRlIGNlbGwgY2VudGVyIHBvc3RpdGlvblxuICAgICAgICAgICAgY29uc3QgY3ggPSBjZWxsLnggKyByZXNvbHV0aW9uIC8gMlxuICAgICAgICAgICAgY29uc3QgY3kgPSBjZWxsLnkgKyByZXNvbHV0aW9uIC8gMlxuXG4gICAgICAgICAgICAvL2NvbXB1dGUgYW5nbGVcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gY3ggLSBjdngsXG4gICAgICAgICAgICAgICAgZHkgPSBjeSAtIGN2eVxuICAgICAgICAgICAgY29uc3QgYSA9IE1hdGguYXRhbjIoZHksIGR4KVxuICAgICAgICAgICAgY29uc3QgRCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbiAgICAgICAgICAgIGNvbnN0IGQgPSAoRCAqIGhHKSAvIChIIC0gaEcpXG5cbiAgICAgICAgICAgIGlmIChzaW1wbGUpIHtcbiAgICAgICAgICAgICAgICAvL2RyYXcgc2VnbWVudFxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVXaWR0aCA9IHdHXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGN4LCBjeSlcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjeCArIGQgKiBNYXRoLmNvcyhhKSwgY3kgKyBkICogTWF0aC5zaW4oYSkpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2UoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2RyYXcgYmFja2dyb3VuZCBzZWdtZW50XG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMub3V0bGluZUNvbFxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVdpZHRoID0gd0cgKyAyICogdGhpcy5vdXRsaW5lV2lkdGhQaXggKiB6XG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGN4LCBjeSlcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjeCArIGQgKiBNYXRoLmNvcyhhKSwgY3kgKyBkICogTWF0aC5zaW4oYSkpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2UoKVxuXG4gICAgICAgICAgICAgICAgLy9kcmF3IHNlZ21lbnRcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZVN0eWxlID0gY29sXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lV2lkdGggPSB3R1xuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4Lm1vdmVUbyhjeCwgY3kpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oY3ggKyBkICogTWF0aC5jb3MoYSksIGN5ICsgZCAqIE1hdGguc2luKGEpKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlKClcblxuICAgICAgICAgICAgICAgIC8vZHJhdyB0b3AgY2lyY2xlXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMub3V0bGluZUNvbFxuICAgICAgICAgICAgICAgIC8vY2cuY3R4LmZpbGxTdHlsZSA9IFwiI2MwOGM1OVwiXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lV2lkdGggPSB0aGlzLm91dGxpbmVXaWR0aFBpeCAqIHpcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5hcmMoY3ggKyBkICogTWF0aC5jb3MoYSksIGN5ICsgZCAqIE1hdGguc2luKGEpLCB3RyAqIDAuNSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlKClcbiAgICAgICAgICAgICAgICAvL2NnLmN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2luIGNhc2UuLi5cbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lQ2FwID0gJ2J1dHQnXG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgdmlld1NjYWxlOiB2aWV3U2NhbGUgfSlcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vY29yZS9TdHlsZS5qcydcblxuLyoqXG4gKiBBIHN0eWxlIHdoZXJlIGVhY2ggY2VsbCBpcyByZXByZXNlbnRlZCBieSBhIHNlZ21lbnQgd2hvc2UgbGVuZ3RoLCB3aWR0aCwgY29sb3IgYW5kIG9yaWVudGF0aW9uIGNhbiB2YXJ5IGFjY29yZGluZyB0byBzdGF0aXN0aWNhbCB2YWx1ZXMuXG4gKlxuICogQG1vZHVsZSBzdHlsZVxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgU2VnbWVudFN0eWxlIGV4dGVuZHMgU3R5bGUge1xuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsIHNlZ21lbnQuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKCgpID0+IFwiI0VBNkJBQ1wiKSAvLyhjLHIseix2cykgPT4ge31cblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHdpZHRoIG9mIHRoZSBzZWdtZW50IHJlcHJlc2VudGluZyBhIGNlbGwsIGluIGdlbyB1bml0XG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdHMud2lkdGggfHwgKChjZWxsLCByZXNvbHV0aW9uKSA9PiByZXNvbHV0aW9uICogMC4xKSAgLy8oYyxyLHosdnMpID0+IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBsZW5ndGggb2YgdGhlIHNlZ21lbnQgcmVwcmVzZW50aW5nIGEgY2VsbCwgaW4gZ2VvIHVuaXRcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmxlbmd0aCA9IG9wdHMubGVuZ3RoIHx8ICgoY2VsbCwgcmVzb2x1dGlvbikgPT4gcmVzb2x1dGlvbiAqIDAuOSkgIC8vKGMscix6LHZzKSA9PiB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgb3JpZW50YXRpb24gKGluIGRlZ3JlZXMpIG9mIHRoZSBzZWdtZW50IHJlcHJlc2VudGluZyBhIGNlbGwuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IG9wdHMub3JpZW50YXRpb24gfHwgKCgpID0+IDE4MCAqIE1hdGgucmFuZG9tKCkpIC8vKGMscix6LHZzKSA9PiB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgY2VsbHMgYXMgc2VnbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XG5cbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL1xuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxuXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcbiAgICAgICAgY29uc3Qgdmlld1NjYWxlID0gdGhpcy52aWV3U2NhbGUgPyB0aGlzLnZpZXdTY2FsZShjZWxscywgcmVzb2x1dGlvbiwgeikgOiB1bmRlZmluZWRcblxuICAgICAgICAvL1xuICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVDYXAgPSAnYnV0dCdcblxuICAgICAgICAvL2NvbnZlcnNpb24gZmFjdG9yIGRlZ3JlZSAtPiByYWRpYW5cbiAgICAgICAgY29uc3QgZiA9IE1hdGguUEkgLyAxODBcblxuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIGNlbGxzKSB7XG4gICAgICAgICAgICAvL2NvbG9yXG4gICAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yID8gdGhpcy5jb2xvcihjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoIWNvbCkgY29udGludWVcblxuICAgICAgICAgICAgLy93aWR0aFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgY29uc3Qgd0cgPSB0aGlzLndpZHRoID8gdGhpcy53aWR0aChjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoIXdHIHx8IHdHIDwgMCkgY29udGludWVcblxuICAgICAgICAgICAgLy9sZW5ndGhcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIGNvbnN0IGxHID0gdGhpcy5sZW5ndGggPyB0aGlzLmxlbmd0aChjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoIWxHIHx8IGxHIDwgMCkgY29udGludWVcblxuICAgICAgICAgICAgLy9vcmllbnRhdGlvbiAoaW4gcmFkaWFuKVxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICBjb25zdCBvciA9IHRoaXMub3JpZW50YXRpb24oY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSAqIGZcbiAgICAgICAgICAgIGlmIChvciA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKG9yKSkgY29udGludWVcblxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjZWxsLCByZXNvbHV0aW9uLCB6KVxuXG4gICAgICAgICAgICAvL3NldCBjb2xvciBhbmQgd2lkdGhcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVdpZHRoID0gd0dcblxuICAgICAgICAgICAgLy9jb21wdXRlIHNlZ21lbnQgY2VudGVyIHBvc3RpdGlvblxuICAgICAgICAgICAgY29uc3QgY3ggPSBjZWxsLnggKyByZXNvbHV0aW9uIC8gMiArIG9mZnNldC5keFxuICAgICAgICAgICAgY29uc3QgY3kgPSBjZWxsLnkgKyByZXNvbHV0aW9uIC8gMiArIG9mZnNldC5keVxuXG4gICAgICAgICAgICAvL2NvbXB1dGUgc2VnbWVudCBkaXJlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGR4ID0gMC41ICogTWF0aC5jb3Mob3IpICogbEdcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gMC41ICogTWF0aC5zaW4ob3IpICogbEdcblxuICAgICAgICAgICAgLy9kcmF3IHNlZ21lbnRcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGN4IC0gZHgsIGN5IC0gZHkpXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjeCArIGR4LCBjeSArIGR5KVxuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyB2aWV3U2NhbGU6IHZpZXdTY2FsZSwgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgY2VsbHM6IGNlbGxzIH0pXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXG5cbi8qKlxuICogQSB2ZXJ5IGdlbmVyaWMgc3R5bGUgdGhhdCBzaG93cyBncmlkIGNlbGxzIHdpdGggc3BlY2lmaWMgY29sb3IsIHNpemUgYW5kIHNoYXBlLlxuICogSXQgY2FuIGJlIHVzZWQgdG8gc2hvdyB2YXJpYWJsZXMgYXMgY2VsbCBjb2xvcnMsIGNlbGwgc2l6ZSwgY2VsbCBzaGFwZSwgb3IgYW55IGNvbWJpbmF0aW9uIG9mIHRoZSB0aHJlZSB2aXN1YWwgdmFyaWFibGVzLlxuICpcbiAqIEBtb2R1bGUgc3R5bGVcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFNoYXBlQ29sb3JTaXplU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIGNlbGwuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKCgpID0+IFwiI0VBNkJBQ1wiKSAvLyhjLHIseix2cykgPT4ge31cblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgYSBjZWxsIGluIGdlb2dyYXBoaWNhbCB1bml0LlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlciwgb2JqZWN0KTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZSB8fCAoKGNlbGwsIHJlc29sdXRpb24pID0+IHJlc29sdXRpb24pIC8vKGMscix6LHZzKSA9PiB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2hhcGUgb2YgYSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0LmpzXCIpLkNlbGwsbnVtYmVyLCBudW1iZXIsb2JqZWN0KTppbXBvcnQoXCIuLi9jb3JlL1N0eWxlLmpzXCIpLlNoYXBlfSAqL1xuICAgICAgICB0aGlzLnNoYXBlID0gb3B0cy5zaGFwZSB8fCAoKCkgPT4gXCJzcXVhcmVcIikgLy8oYyxyLHosdnMpID0+IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBjZWxscyBhcyBzcXVhcmVzLCB3aXRoIHZhcmlvdXMgY29sb3JzIGFuZCBzaXplcy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XG5cbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL3pvb21cbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcblxuICAgICAgICAvL2dldCB2aWV3IHNjYWxlXG4gICAgICAgIGNvbnN0IHZpZXdTY2FsZSA9IHRoaXMudmlld1NjYWxlID8gdGhpcy52aWV3U2NhbGUoY2VsbHMsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXG5cbiAgICAgICAgY29uc3QgcjIgPSByZXNvbHV0aW9uICogMC41XG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgIC8vY29sb3JcbiAgICAgICAgICAgIGxldCBjb2wgPSB0aGlzLmNvbG9yID8gdGhpcy5jb2xvcihjLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogXCJibGFja1wiXG4gICAgICAgICAgICBpZiAoIWNvbCB8fCBjb2wgPT09ICdub25lJykgY29udGludWVcblxuICAgICAgICAgICAgLy9zaXplXG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zaXplID8gdGhpcy5zaXplKGMsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiByZXNvbHV0aW9uXG4gICAgICAgICAgICBpZiAoIXNpemUpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vc2hhcGVcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5zaGFwZSA/IHRoaXMuc2hhcGUoYywgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6ICdzcXVhcmUnXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdub25lJykgY29udGludWVcblxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjLCByZXNvbHV0aW9uLCB6KVxuXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGxTdHlsZSA9IGNvbFxuICAgICAgICAgICAgaWYgKHNoYXBlID09PSAnc3F1YXJlJykge1xuICAgICAgICAgICAgICAgIC8vZHJhdyBzcXVhcmVcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gcmVzb2x1dGlvbiAqICgxIC0gc2l6ZSAvIHJlc29sdXRpb24pICogMC41XG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsUmVjdChjLnggKyBkICsgb2Zmc2V0LmR4LCBjLnkgKyBkICsgb2Zmc2V0LmR5LCBzaXplLCBzaXplKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICAvL2RyYXcgY2lyY2xlXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYXJjKGMueCArIHIyICsgb2Zmc2V0LmR4LCBjLnkgKyByMiArIG9mZnNldC5keSwgc2l6ZSAqIDAuNSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbCgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAnZG9udXQnKSB7XG4gICAgICAgICAgICAgICAgLy9kcmF3IGRvbnV0XG4gICAgICAgICAgICAgICAgY29uc3QgeGMgPSBjLnggKyByMiArIG9mZnNldC5keCxcbiAgICAgICAgICAgICAgICAgICAgeWMgPSBjLnkgKyByMiArIG9mZnNldC5keVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4Lm1vdmVUbyh4YywgeWMpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5hcmMoeGMsIHljLCByMiwgMCwgMiAqIE1hdGguUEkpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5hcmMoeGMsIHljLCAoMSAtIHNpemUgLyByZXNvbHV0aW9uKSAqIHIyLCAwLCAyICogTWF0aC5QSSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmNsb3NlUGF0aCgpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5maWxsKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdkaWFtb25kJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMyID0gc2l6ZSAqIDAuNVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4Lm1vdmVUbyhjLnggKyByMiAtIHMyLCBjLnkgKyByMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjLnggKyByMiwgYy55ICsgcjIgKyBzMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjLnggKyByMiArIHMyLCBjLnkgKyByMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjLnggKyByMiwgYy55ICsgcjIgLSBzMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGwoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3RyaWFuZ2xlX3VwJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRyMiA9IChzaXplIC0gcmVzb2x1dGlvbikgLyAyXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGMueCAtIGRyMiwgYy55IC0gZHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGMueCArIHIyLCBjLnkgKyByZXNvbHV0aW9uICsgZHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGMueCArIHJlc29sdXRpb24gKyBkcjIsIGMueSAtIGRyMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGwoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3RyaWFuZ2xlX2Rvd24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHIyID0gKHNpemUgLSByZXNvbHV0aW9uKSAvIDJcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5tb3ZlVG8oYy54IC0gZHIyLCBjLnkgKyByZXNvbHV0aW9uICsgZHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGMueCArIHIyLCBjLnkgLSBkcjIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54ICsgcmVzb2x1dGlvbiArIGRyMiwgYy55ICsgcmVzb2x1dGlvbiArIGRyMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGwoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3RyaWFuZ2xlX2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHIyID0gKHNpemUgLSByZXNvbHV0aW9uKSAvIDJcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5tb3ZlVG8oYy54ICsgcmVzb2x1dGlvbiArIGRyMiwgYy55ICsgcmVzb2x1dGlvbiArIGRyMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjLnggLSBkcjIsIGMueSArIHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGMueCArIHJlc29sdXRpb24gKyBkcjIsIGMueSAtIGRyMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGwoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3RyaWFuZ2xlX3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRyMiA9IChzaXplIC0gcmVzb2x1dGlvbikgLyAyXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKGMueCAtIGRyMiwgYy55IC0gZHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGMueCArIHJlc29sdXRpb24gKyBkcjIsIGMueSArIHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGMueCAtIGRyMiwgYy55ICsgcmVzb2x1dGlvbiArIGRyMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGwoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2hhcGU6JyArIHNoYXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyB2aWV3U2NhbGU6IHZpZXdTY2FsZSwgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgY2VsbHM6IGNlbGxzIH0pXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTaWRlU3R5bGUgfSBmcm9tICcuL1NpZGVTdHlsZS5qcydcblxuLyoqXG4gKiBBIHN0eWxlIHRvIHNob3cgdGhlIHNpZGVzIG9mIGdyaWQgY2VsbHMgYmFzZWQgb24gdGhlaXIgZGlmZmVyZW50IGNhdGVnb3JpZXMuXG4gKlxuICogQG1vZHVsZSBzdHlsZVxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgU2lkZUNhdGVnb3J5U3R5bGUgZXh0ZW5kcyBTaWRlU3R5bGUge1xuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNhdGVnb3J5IGNvZGUgb2YgYSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlcik6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNvZGUgPSBvcHRzLmNvZGVcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpY3Rpb25hcnkgKHN0cmluZyAtPiBjb2xvcikgd2hpY2ggZ2l2ZSB0aGUgY29sb3Igb2YgZWFjaCBjYXRlZ29yeS5cbiAgICAgICAgICogQHR5cGUge29iamVjdH0gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3JcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb25cbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcblxuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IHogPSBnZW9DYW52YXMudmlldy56XG5cbiAgICAgICAgLy9idWlsZCBzaWRlc1xuXG4gICAgICAgIC8qKiAgQHR5cGUge0FycmF5LjxpbXBvcnQoJy4vU2lkZVN0eWxlLmpzJykuU2lkZT59ICovXG4gICAgICAgIGNvbnN0IHNpZGVzID0gU2lkZVN0eWxlLmJ1aWxkU2lkZXMoY2VsbHMsIHJlc29sdXRpb24pXG4gICAgICAgIGlmIChzaWRlcy5sZW5ndGggPT0gMCkgcmV0dXJuXG5cbiAgICAgICAgLy9nZXQgc2lkZSB2aWV3IHNjYWxlXG4gICAgICAgIGNvbnN0IHZpZXdTY2FsZSA9IHRoaXMudmlld1NjYWxlID8gdGhpcy52aWV3U2NhbGUoc2lkZXMsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXG5cbiAgICAgICAgLy9kcmF3IHNpZGVzXG5cbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lQ2FwID0gJ2J1dHQnXG4gICAgICAgIGZvciAobGV0IHNpZGUgb2Ygc2lkZXMpIHtcblxuICAgICAgICAgICAgLy9nZXQgY2F0ZWdvcnkgY29kZXMgZm9yIGJvdGggY2VsbHNcbiAgICAgICAgICAgIGNvbnN0IGNvZGUxID0gc2lkZS5jMSA/IHRoaXMuY29kZShzaWRlLmMxLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgY29uc3QgY29kZTIgPSBzaWRlLmMyID8gdGhpcy5jb2RlKHNpZGUuYzIsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoY29kZTEgPT0gY29kZTIpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vd2lkdGhcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIGNvbnN0IHdHID0gdGhpcy53aWR0aCA/IHRoaXMud2lkdGgoc2lkZSwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCF3RyB8fCB3RyA8PSAwKSBjb250aW51ZVxuICAgICAgICAgICAgY29uc3QgdzIgPSB3RyAqIDAuNVxuXG4gICAgICAgICAgICAvL3NldCB3aWR0aFxuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lV2lkdGggPSB3R1xuXG4gICAgICAgICAgICAvL2RyYXcgc2VnbWVudCB3aXRoIGNvcnJlY3Qgb3JpZW50YXRpb25cbiAgICAgICAgICAgIGlmIChzaWRlLm9yID09PSAnaCcpIHtcbiAgICAgICAgICAgICAgICAvL3RvcCBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3JbY29kZTJdXG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKHNpZGUueCwgc2lkZS55ICsgdzIpXG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKHNpZGUueCArIHJlc29sdXRpb24sIHNpZGUueSArIHcyKVxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9ib3R0b20gbGluZVxuICAgICAgICAgICAgICAgIGlmIChjb2RlMSkge1xuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yW2NvZGUxXVxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4Lm1vdmVUbyhzaWRlLngsIHNpZGUueSAtIHcyKVxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhzaWRlLnggKyByZXNvbHV0aW9uLCBzaWRlLnkgLSB3MilcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2UoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9yaWdodCBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3JbY29kZTJdXG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKHNpZGUueCArIHcyLCBzaWRlLnkpXG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKHNpZGUueCArIHcyLCBzaWRlLnkgKyByZXNvbHV0aW9uKVxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9sZWZ0IGxpbmVcbiAgICAgICAgICAgICAgICBpZiAoY29kZTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcltjb2RlMV1cbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5tb3ZlVG8oc2lkZS54IC0gdzIsIHNpZGUueSlcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oc2lkZS54IC0gdzIsIHNpZGUueSArIHJlc29sdXRpb24pXG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByZXNvbHV0aW9uOiByZXNvbHV0aW9uLCB6OiB6LCB2aWV3U2NhbGU6IHZpZXdTY2FsZSB9KVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xuXG4vKiogQHR5cGVkZWYge3sgeDpudW1iZXIsIHk6bnVtYmVyLCBvcjpcInZcInxcImhcIiwgYzE6KGltcG9ydCgnLi4vY29yZS9EYXRhc2V0JykuQ2VsbCl8dW5kZWZpbmVkLCBjMjooaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQnKS5DZWxsKXx1bmRlZmluZWQgfX0gU2lkZSAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihBcnJheS48U2lkZT4sbnVtYmVyLCBudW1iZXIpOip9IFNpZGVWaWV3U2NhbGUgKi9cblxuLyoqXG4gKiBAbW9kdWxlIHN0eWxlXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWRlU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvciBvZiBhIGNlbGwgc2lkZS5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKFNpZGUsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKChzaWRlLCByZXNvbHV0aW9uLCB6LCBzaWRlVmlld1NjYWxlKSA9PiAnI0VBNkJBQycpXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB3aWR0aCBvZiBhIGNlbGwgc2lkZSwgaW4gZ2VvIHVuaXRcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKFNpZGUsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdHMud2lkdGggfHwgKChzaWRlLCByZXNvbHV0aW9uLCB6LCBzaWRlVmlld1NjYWxlKSA9PiByZXNvbHV0aW9uIC8gNSlcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGxlbmd0aCBvZiBhIGNlbGwgc2lkZSwgaW4gZ2VvIHVuaXRcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKFNpZGUsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5sZW5ndGggPSBvcHRzLmxlbmd0aCB8fCAoKHNpZGUsIHJlc29sdXRpb24sIHosIHNpZGVWaWV3U2NhbGUpID0+IHJlc29sdXRpb24pXG5cbiAgICAgICAgLyoqIFNldCB0byBBIG9yIHRydWUgc28gdGhhdCB0aGUgc2lkZSBpcyBkcmF3biBhcyBhIGRpYW1vbmQgKi9cbiAgICAgICAgdGhpcy5kaWFtb25kID0gb3B0cy5kaWFtb25kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xuICAgICAqL1xuICAgIGRyYXcoY2VsbHMsIGdlb0NhbnZhcywgcmVzb2x1dGlvbikge1xuXG4gICAgICAgIC8vZmlsdGVyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXG5cbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcblxuICAgICAgICAvL2J1aWxkIHNpZGVzXG5cbiAgICAgICAgLyoqICBAdHlwZSB7QXJyYXkuPFNpZGU+fSAqL1xuICAgICAgICBjb25zdCBzaWRlcyA9IFNpZGVTdHlsZS5idWlsZFNpZGVzKGNlbGxzLCByZXNvbHV0aW9uKVxuICAgICAgICBpZiAoc2lkZXMubGVuZ3RoID09IDApIHJldHVyblxuXG4gICAgICAgIC8vZ2V0IHNpZGUgdmlldyBzY2FsZVxuICAgICAgICBjb25zdCB2aWV3U2NhbGUgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKHNpZGVzLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vZHJhdyBzaWRlc1xuXG4gICAgICAgIGdlb0NhbnZhcy5jdHgubGluZUNhcCA9ICdidXR0J1xuICAgICAgICBjb25zdCByMiA9IHJlc29sdXRpb24gKiAwLjVcbiAgICAgICAgZm9yIChsZXQgc2lkZSBvZiBzaWRlcykge1xuXG4gICAgICAgICAgICAvL2NvbG9yXG4gICAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yID8gdGhpcy5jb2xvcihzaWRlLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoIWNvbCB8fCBjb2wgPT0gJ25vbmUnKSBjb250aW51ZVxuXG4gICAgICAgICAgICBpZiAodGhpcy5kaWFtb25kKSB7XG5cbiAgICAgICAgICAgICAgICAvL3NldCBjb2xvclxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbFN0eWxlID0gY29sXG5cbiAgICAgICAgICAgICAgICAvL2RyYXcgZGlhbW9uZFxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBzaWRlLngsIHkgPSBzaWRlLnlcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5tb3ZlVG8oeCAtIHIyLCB5KVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKHgsIHkgKyByMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyh4ICsgcjIsIHkpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oeCwgeSAtIHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguY2xvc2VQYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGwoKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy93aWR0aFxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgICAgICBjb25zdCB3RyA9IHRoaXMud2lkdGggPyB0aGlzLndpZHRoKHNpZGUsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBpZiAoIXdHIHx8IHdHIDw9IDApIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICAvL2xlbmd0aFxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgICAgICBjb25zdCBsRyA9IHRoaXMubGVuZ3RoID8gdGhpcy5sZW5ndGgoc2lkZSwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGlmICghbEcgfHwgbEcgPD0gMCkgY29udGludWVcbiAgICAgICAgICAgICAgICBjb25zdCBsRzIgPSBsRyAqIDAuNVxuXG4gICAgICAgICAgICAgICAgLy9zZXQgd2lkdGhcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVXaWR0aCA9IHdHXG4gICAgICAgICAgICAgICAgLy9zZXQgY29sb3JcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZVN0eWxlID0gY29sXG5cbiAgICAgICAgICAgICAgICAvL2RyYXcgc2VnbWVudCB3aXRoIGNvcnJlY3Qgb3JpZW50YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gc2lkZS54LCB5ID0gc2lkZS55XG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGlmIChzaWRlLm9yID09PSBcInZcIikge1xuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4Lm1vdmVUbyh4LCB5IC0gbEcyKVxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyh4LCB5ICsgbEcyKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubW92ZVRvKHggLSBsRzIsIHkpXG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKHggKyBsRzIsIHkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHJlc29sdXRpb246IHJlc29sdXRpb24sIHo6IHosIHZpZXdTY2FsZTogdmlld1NjYWxlIH0pXG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydCgnLi4vY29yZS9EYXRhc2V0JykuQ2VsbD59IGNlbGxzIFRoZSBjZWxscyB0byB1c2UgdG8gYnVpbGQgdGhlIHNpZGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBjZWxscyByZXNvbHV0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSB3aXRoSG9yaXpvbnRhbCBTZXQgdG8gdHJ1ZSB0byBidWlsZCBob3Jpem9udGFsIHNpZGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB3aXRoVmVydGljYWwgU2V0IHRvIHRydWUgdG8gYnVpbGQgdmVydGljYWwgc2lkZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNlbnRlciBTZXQgdG8gdHJ1ZSBzbyB0aGF0IHRoZSBzaWRlIGNvb3JkaW5hdGUgYXJlIHRob3NlIG9mIGl0cyBjZW50ZXIgcG9pbnQgcmF0aGVyIHRoYW4gaXRzIGxlZnQvYm90dG9tIHBvaW50ICh0aGUgc2lkZSB4LHkgY29vcmRpbmF0ZXMgYXJlIHRob3NlIG9mIHRoZSBsZWZ0IHBvaW50IGZvciBob3Jpem9udGFsIHNpZGVzLCBhbmQgb2YgdGhlIGJvdHRvbSBwb2ludCBmb3IgdmVydGljYWwgc2lkZXMpXG4gICAgICogQHJldHVybnMgeyBBcnJheS48U2lkZT4gfVxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZFNpZGVzKGNlbGxzLCByZXNvbHV0aW9uLCB3aXRoSG9yaXpvbnRhbCA9IHRydWUsIHdpdGhWZXJ0aWNhbCA9IHRydWUsIGNlbnRlciA9IHRydWUpIHtcbiAgICAgICAgLyoqIEB0eXBlIHsgQXJyYXkuPFNpZGU+IH0gKi9cbiAgICAgICAgY29uc3Qgc2lkZXMgPSBbXVxuXG4gICAgICAgIGNvbnN0IHIyID0gY2VudGVyID8gcmVzb2x1dGlvbiAvIDIgOiAwXG5cbiAgICAgICAgLy9tYWtlIGhvcml6b250YWwgc2lkZXNcbiAgICAgICAgLy9zb3J0IGNlbGxzIGJ5IHggYW5kIHlcbiAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiAoYzIueCA9PSBjMS54ID8gYzEueSAtIGMyLnkgOiBjMS54IC0gYzIueCkpXG4gICAgICAgIGxldCBjMSA9IGNlbGxzWzBdXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjMiA9IGNlbGxzW2ldXG5cbiAgICAgICAgICAgIGlmICgoYzEueSArIHJlc29sdXRpb24gPT0gYzIueSkgJiYgKGMxLnggPT0gYzIueCkpXG4gICAgICAgICAgICAgICAgLy9jZWxscyBpbiBzYW1lIGNvbHVtbiBhbmQgdG91Y2ggYWxvbmcgaG9yaXpvbnRhbCBzaWRlXG4gICAgICAgICAgICAgICAgLy9tYWtlIHNoYXJlZCBzaWRlXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9yOiAnaCcsXG4gICAgICAgICAgICAgICAgICAgIHg6IGMxLnggKyByMiwgeTogYzIueSxcbiAgICAgICAgICAgICAgICAgICAgYzE6IGMxLCBjMjogYzJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jZWxscyBkbyBub3QgdG91Y2ggYWxvbmcgaG9yaXpvbnRhbCBzaWRlXG4gICAgICAgICAgICAgICAgLy9tYWtlIHR3byBzaWRlczogdG9wIG9uZSBmb3IgYzEsIGJvdHRvbSBmb3IgYzJcbiAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3I6ICdoJyxcbiAgICAgICAgICAgICAgICAgICAgeDogYzEueCArIHIyLCB5OiBjMS55ICsgcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgYzE6IGMxLCBjMjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3I6ICdoJyxcbiAgICAgICAgICAgICAgICAgICAgeDogYzIueCArIHIyLCB5OiBjMi55LFxuICAgICAgICAgICAgICAgICAgICBjMTogdW5kZWZpbmVkLCBjMjogYzJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjMSA9IGMyXG4gICAgICAgIH1cblxuICAgICAgICAvL21ha2UgdmVydGljYWwgc2lkZXNcbiAgICAgICAgLy9zb3J0IGNlbGxzIGJ5IHkgYW5kIHhcbiAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiAoYzIueSA9PSBjMS55ID8gYzEueCAtIGMyLnggOiBjMS55IC0gYzIueSkpXG4gICAgICAgIGMxID0gY2VsbHNbMF1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGMyID0gY2VsbHNbaV1cblxuICAgICAgICAgICAgaWYgKChjMS54ICsgcmVzb2x1dGlvbiA9PSBjMi54KSAmJiAoYzEueSA9PSBjMi55KSlcbiAgICAgICAgICAgICAgICAvL2NlbGxzIGluIHNhbWUgcm93IGFuZCB0b3VjaCBhbG9uZyB2ZXJ0aWNhbCBzaWRlXG4gICAgICAgICAgICAgICAgLy9tYWtlIHNoYXJlZCBzaWRlXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9yOiAndicsXG4gICAgICAgICAgICAgICAgICAgIHg6IGMxLnggKyByZXNvbHV0aW9uLCB5OiBjMS55ICsgcjIsXG4gICAgICAgICAgICAgICAgICAgIGMxOiBjMSwgYzI6IGMyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY2VsbHMgZG8gbm90IHRvdWNoIGFsb25nIHZlcnRpY2FsIHNpZGVcbiAgICAgICAgICAgICAgICAvL21ha2UgdHdvIHNpZGVzOiByaWdodCBvbmUgZm9yIGMxLCBsZWZ0IGZvciBjMlxuICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcjogJ3YnLFxuICAgICAgICAgICAgICAgICAgICB4OiBjMS54ICsgcmVzb2x1dGlvbiwgeTogYzEueSArIHIyLFxuICAgICAgICAgICAgICAgICAgICBjMTogYzEsIGMyOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcjogJ3YnLFxuICAgICAgICAgICAgICAgICAgICB4OiBjMi54LCB5OiBjMi55ICsgcjIsXG4gICAgICAgICAgICAgICAgICAgIGMxOiB1bmRlZmluZWQsIGMyOiBjMlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGMxID0gYzJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lkZXNcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xuaW1wb3J0IHsgbWFrZVdlYkdMQ2FudmFzIH0gZnJvbSAnLi4vdXRpbHMvd2ViR0xVdGlscy5qcydcbmltcG9ydCB7IFdlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZCB9IGZyb20gJy4uL3V0aWxzL1dlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZC5qcydcblxuLyoqXG4gKiBTdHlsZSBiYXNlZCBvbiB3ZWJHTFxuICogVG8gc2hvdyBjZWxscyBhcyBjb2xvcmVkIHNxdWFyZXMsIGZyb20gY2F0ZWdvcmllcy5cbiAqIEFsbCBjZWxscyBhcmUgZHJhd24gYXMgc3F1YXJlcywgd2l0aCB0aGUgc2FtZSBzaXplXG4gKlxuICogQG1vZHVsZSBzdHlsZVxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgU3F1YXJlQ29sb3JDYXRlZ29yeVdlYkdMU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY2F0ZWdvcnkgY29kZSBvZiB0aGUgY2VsbCwgZm9yIGNvbG9yaW5nLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuY29kZSA9IG9wdHMuY29kZVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGljdGlvbmFyeSAoY29kZSAtPiBjb2xvcikgd2hpY2ggZ2l2ZXMgdGhlIGNvbG9yIG9mIGVhY2ggY2F0ZWdvcnkgY29kZS5cbiAgICAgICAgICogQHR5cGUge29iamVjdH0gKi9cbiAgICAgICAgb3B0cy5jb2xvciA9IG9wdHMuY29sb3IgfHwgdW5kZWZpbmVkXG5cbiAgICAgICAgLyoqIEB0eXBlIHsgQXJyYXkuPHN0cmluZz4gfSAqL1xuICAgICAgICBjb25zdCBjb2RlcyA9IE9iamVjdC5rZXlzKG9wdHMuY29sb3IpXG5cbiAgICAgICAgLyoqIEB0eXBlIHsgb2JqZWN0IH0gQHByaXZhdGUgKi9cbiAgICAgICAgdGhpcy5jYXRUb0kgPSB7fVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB0aGlzLmNhdFRvSVtjb2Rlc1tpXV0gPSBpICsgJydcblxuICAgICAgICAvKiogQHR5cGUgeyBBcnJheS48c3RyaW5nPiB9IEBwcml2YXRlICovXG4gICAgICAgIHRoaXMuY29sb3JzID0gW11cbiAgICAgICAgZm9yIChjb25zdCBjb2RlIG9mIGNvZGVzKVxuICAgICAgICAgICAgdGhpcy5jb2xvcnMucHVzaChvcHRzLmNvbG9yWycnICsgY29kZV0pXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIHRoZSBjZWxscywgaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuIEFsbCBjZWxscyBoYXZlIHRoZSBzYW1lIHNpemUuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZSAvLyAocmVzb2x1dGlvbiwgeikgPT4gLi4uXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHsgV2ViR0xTcXVhcmVDb2xvcmluZ0NhdEFkdmFuY2VkIH0gKi9cbiAgICAgICAgdGhpcy53Z3AgPSBuZXcgV2ViR0xTcXVhcmVDb2xvcmluZ0NhdEFkdmFuY2VkKHRoaXMuY29sb3JzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb25cbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcblxuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IHogPSBnZW9DYW52YXMudmlldy56XG5cbiAgICAgICAgLy9hZGQgdmVydGljZSBhbmQgZnJhZ21lbnQgZGF0YVxuICAgICAgICBjb25zdCByMiA9IHJlc29sdXRpb24gLyAyXG4gICAgICAgIGxldCBjLCBuYiA9IGNlbGxzLmxlbmd0aFxuICAgICAgICBjb25zdCB2ZXJ0aWNlc0J1ZmZlciA9IFtdXG4gICAgICAgIGNvbnN0IGlCdWZmZXIgPSBbXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIHtcbiAgICAgICAgICAgIGMgPSBjZWxsc1tpXVxuICAgICAgICAgICAgY29uc3QgY2F0ID0gdGhpcy5jb2RlKGMpXG4gICAgICAgICAgICBpZiAoY2F0ID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmV4cGVjdGVkIGNhdGVnb3J5OiAnICsgY2F0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgIGNvbnN0IGlfID0gdGhpcy5jYXRUb0lbY2F0XVxuICAgICAgICAgICAgaWYgKGlzTmFOKCtpXykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5leHBlY3RlZCBjYXRlZ29yeSBpbmRleDogJyArIGNhdCArICcgJyArIGlfKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZXJ0aWNlc0J1ZmZlci5wdXNoKGMueCArIHIyLCBjLnkgKyByMilcbiAgICAgICAgICAgIGlCdWZmZXIucHVzaCgraV8pXG4gICAgICAgIH1cblxuICAgICAgICAvL2NyZWF0ZSBjYW52YXMgYW5kIHdlYmdsIHJlbmRlcmVyXG4gICAgICAgIGNvbnN0IGN2V0dMID0gbWFrZVdlYkdMQ2FudmFzKGdlb0NhbnZhcy53ICsgJycsIGdlb0NhbnZhcy5oICsgJycpXG4gICAgICAgIGlmICghY3ZXR0wpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHdlYkdMJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy9kcmF3XG4gICAgICAgIGNvbnN0IHNpemVHZW8gPSB0aGlzLnNpemUgPyB0aGlzLnNpemUocmVzb2x1dGlvbiwgeikgOiByZXNvbHV0aW9uICsgMC4yICogelxuICAgICAgICB0aGlzLndncC5kcmF3KGN2V0dMLmdsLCB2ZXJ0aWNlc0J1ZmZlciwgaUJ1ZmZlciwgZ2VvQ2FudmFzLmdldFdlYkdMVHJhbnNmb3JtKCksIHNpemVHZW8gLyB6KVxuXG4gICAgICAgIC8vZHJhdyBpbiBjYW52YXMgZ2VvXG4gICAgICAgIGdlb0NhbnZhcy5pbml0Q2FudmFzVHJhbnNmb3JtKClcbiAgICAgICAgZ2VvQ2FudmFzLmN0eC5kcmF3SW1hZ2UoY3ZXR0wuY2FudmFzLCAwLCAwKVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHJlc29sdXRpb246IHJlc29sdXRpb24sIHo6IHogfSlcbiAgICB9XG59IiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXG5pbXBvcnQgeyBtYWtlV2ViR0xDYW52YXMgfSBmcm9tICcuLi91dGlscy93ZWJHTFV0aWxzLmpzJ1xuaW1wb3J0IHsgV2ViR0xTcXVhcmVDb2xvcmluZ0FkdmFuY2VkIH0gZnJvbSAnLi4vdXRpbHMvV2ViR0xTcXVhcmVDb2xvcmluZ0FkdmFuY2VkLmpzJ1xuXG4vKipcbiAqIFN0eWxlIGJhc2VkIG9uIHdlYkdMXG4gKiBUbyBzaG93IGNlbGxzIGFzIGNvbG9yZWQgc3F1YXJlcywgd2l0aCBjb21wdXRhdGlvbiBvZiB0aGUgY29sb3JzIG9uIEdQVSBzaWRlIChmYXN0ZXIgdGhhbiBKYXZhU2NyaXB0IHNpZGUpLlxuICogQWxscyBzcXVhcmVzIHdpdGggdGhlIHNhbWUgc2l6ZVxuICpcbiAqIEBtb2R1bGUgc3R5bGVcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFNxdWFyZUNvbG9yV2ViR0xTdHlsZSBleHRlbmRzIFN0eWxlIHtcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgdCB2YWx1ZSAod2l0aGluIFswLDFdKSBmb3IgYSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLG51bWJlcixudW1iZXIsb2JqZWN0KTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudEZ1biA9IG9wdHMudEZ1biAvLyhjLHIseix2cykgPT4ge31cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzdHJpYnV0aW9uIHN0cmV0Y2hpbmcgbWV0aG9kLlxuICAgICAgICAgKiBUaGUgc3RyZXRjaGluZyBpcyBwZXJmb3JtZWQgb24gR1BVIHNpZGUgKGZyYWdtZW50IHNoYWRlcikuXG4gICAgICAgICAqIEB0eXBlIHt7IGZ1bjpzdHJpbmcsIGFscGhhOm51bWJlciB9fSAqL1xuICAgICAgICB0aGlzLnN0cmV0Y2hpbmcgPSBvcHRzLnN0cmV0Y2hpbmdcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNhbXBsZSBvZiB0aGUgY29sb3IgcmFtcC5cbiAgICAgICAgICogVGhlIGNvbG9yIGlzIGNvbXB1dGVkIG9uIEdQVSBzaWRlIChmcmFnbWVudCBzaGFkZXIpIGJhc2VkIG9uIHRob3NlIHZhbHVlcyAobGluZWFyIGludGVycG9sYXRpb24pLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59ICovXG4gICAgICAgIHRoaXMuY29sb3JzID1cbiAgICAgICAgICAgIG9wdHMuY29sb3JzIHx8XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3JnYigxNTgsIDEsIDY2KScsXG4gICAgICAgICAgICAgICAgJ3JnYigyNDgsIDE0MiwgODMpJyxcbiAgICAgICAgICAgICAgICAncmdiKDI1MSwgMjQ4LCAxNzYpJyxcbiAgICAgICAgICAgICAgICAncmdiKDEzNywgMjA3LCAxNjUpJyxcbiAgICAgICAgICAgICAgICAncmdiKDk0LCA3OSwgMTYyKScsXG4gICAgICAgICAgICBdLnJldmVyc2UoKVxuICAgICAgICBpZiAob3B0cy5jb2xvcilcbiAgICAgICAgICAgIHRoaXMuY29sb3JzID0gW1xuICAgICAgICAgICAgICAgIG9wdHMuY29sb3IoMCksXG4gICAgICAgICAgICAgICAgb3B0cy5jb2xvcigwLjIpLFxuICAgICAgICAgICAgICAgIG9wdHMuY29sb3IoMC40KSxcbiAgICAgICAgICAgICAgICBvcHRzLmNvbG9yKDAuNiksXG4gICAgICAgICAgICAgICAgb3B0cy5jb2xvcigwLjgpLFxuICAgICAgICAgICAgICAgIG9wdHMuY29sb3IoMSksXG4gICAgICAgICAgICBdXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSB0aGUgb3BhY2l0eSBvZiB0aGUgc3R5bGUsIHdpdGhpbiBbMCwxXS5cbiAgICAgICAgICogSWYgdGhpcyBvcGFjaXR5IGlzIGRlZmluZWQsIHRoZSBpbmRpdmlkdWFsIGNvbG9yIG9wYWNpdHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcHRzLm9wYWNpdHkgLy8gKHIseikgPT4gLi4uXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIHRoZSBjZWxscywgaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuIEFsbCBjZWxscyBoYXZlIHRoZSBzYW1lIHNpemUuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZSAvLyAocmVzb2x1dGlvbiwgeikgPT4gLi4uXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0LmpzXCIpLkNlbGw+fSBjZWxsc1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuR2VvQ2FudmFzfSBnZW9DYW52YXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxuICAgICAqL1xuICAgIGRyYXcoY2VsbHMsIGdlb0NhbnZhcywgcmVzb2x1dGlvbikge1xuXG4gICAgICAgIC8vZmlsdGVyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXG5cbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcblxuICAgICAgICAvL2dldCB2aWV3IHNjYWxlXG4gICAgICAgIGNvbnN0IHZpZXdTY2FsZSA9IHRoaXMudmlld1NjYWxlID8gdGhpcy52aWV3U2NhbGUoY2VsbHMsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXG5cbiAgICAgICAgLy9jcmVhdGUgY2FudmFzIGFuZCB3ZWJnbCByZW5kZXJlclxuICAgICAgICAvL2ZvciBvcGFjaXR5IGNvbnRyb2wsIHNlZTogaHR0cHM6Ly93ZWJnbGZ1bmRhbWVudGFscy5vcmcvd2ViZ2wvbGVzc29ucy93ZWJnbC1hbmQtYWxwaGEuaHRtbFxuICAgICAgICBjb25zdCBjdldHTCA9IG1ha2VXZWJHTENhbnZhcyhcbiAgICAgICAgICAgIGdlb0NhbnZhcy53ICsgJycsXG4gICAgICAgICAgICBnZW9DYW52YXMuaCArICcnLFxuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ICE9IHVuZGVmaW5lZCA/IHsgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSB9IDogdW5kZWZpbmVkXG4gICAgICAgIClcbiAgICAgICAgaWYgKCFjdldHTCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gd2ViR0wnKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvL2FkZCB2ZXJ0aWNlIGFuZCBmcmFnbWVudCBkYXRhXG4gICAgICAgIGNvbnN0IHIyID0gcmVzb2x1dGlvbiAvIDJcbiAgICAgICAgY29uc3QgdmVydGljZXNCdWZmZXIgPSBbXVxuICAgICAgICBjb25zdCB0QnVmZmVyID0gW11cbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMudEZ1bihjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpXG4gICAgICAgICAgICBpZiAodCA9PSBudWxsIHx8IHQgPT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgICAgICAgdmVydGljZXNCdWZmZXIucHVzaChjZWxsLnggKyByMiwgY2VsbC55ICsgcjIpXG4gICAgICAgICAgICB0QnVmZmVyLnB1c2godCA+IDEgPyAxIDogdCA8IDAgPyAwIDogdClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29tcHV0ZSBwaXhlbCBzaXplXG4gICAgICAgIGNvbnN0IHNpemVHZW8gPSB0aGlzLnNpemUgPyB0aGlzLnNpemUocmVzb2x1dGlvbiwgeikgOiByZXNvbHV0aW9uICsgMC4yICogelxuXG4gICAgICAgIC8vY29tcHV0ZSBvcGFjaXR5XG4gICAgICAgIGNvbnN0IG9wID0gdGhpcy5vcGFjaXR5ID8gdGhpcy5vcGFjaXR5KHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXG5cbiAgICAgICAgLy9cbiAgICAgICAgY29uc3Qgd2dwID0gbmV3IFdlYkdMU3F1YXJlQ29sb3JpbmdBZHZhbmNlZChjdldHTC5nbCwgdGhpcy5jb2xvcnMsIHRoaXMuc3RyZXRjaGluZywgc2l6ZUdlbyAvIHosIG9wKVxuXG4gICAgICAgIC8vZHJhd1xuICAgICAgICB3Z3AuZHJhdyh2ZXJ0aWNlc0J1ZmZlciwgdEJ1ZmZlciwgZ2VvQ2FudmFzLmdldFdlYkdMVHJhbnNmb3JtKCkpXG5cbiAgICAgICAgLy9kcmF3IGluIGNhbnZhcyBnZW9cbiAgICAgICAgZ2VvQ2FudmFzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICBnZW9DYW52YXMuY3R4LmRyYXdJbWFnZShjdldHTC5jYW52YXMsIDAsIDApXG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgdmlld1NjYWxlOiB2aWV3U2NhbGUgfSlcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vY29yZS9TdHlsZS5qcydcblxuLyoqXG4gKiBAbW9kdWxlIHN0eWxlXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJva2VTdHlsZSBleHRlbmRzIFN0eWxlIHtcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvciBvZiB0aGUgY2VsbC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCxudW1iZXIsbnVtYmVyLG9iamVjdCk6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gb3B0cy5zdHJva2VDb2xvciB8fCAoKCkgPT4gXCIjNjY2XCIpIC8vKGMscix6LHZzKSA9PiB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2l6ZSBvZiBhIGNlbGwgaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsbnVtYmVyLG51bWJlcixvYmplY3QpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplIHx8ICgoY2VsbCwgcmVzb2x1dGlvbikgPT4gcmVzb2x1dGlvbikgLy8oYyxyLHosdnMpID0+IHt9XG5cbiAgICAgICAgLyoqIFRoZSBzdHJva2UgbGluZSB3aWR0aCBpbiBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCxudW1iZXIsbnVtYmVyLG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aCB8fCAoKGNlbGwsIHJlc29sdXRpb24sIHopID0+IHogKiAxLjUpIC8vKGMscix6LHZzKSA9PiB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2hhcGUgb2YgYSBjZWxsLlxuICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbCxudW1iZXIsbnVtYmVyLG9iamVjdCk6aW1wb3J0KFwiLi4vY29yZS9TdHlsZS5qc1wiKS5TaGFwZX0gKi9cbiAgICAgICAgdGhpcy5zaGFwZSA9IG9wdHMuc2hhcGUgfHwgKCgpID0+IFwic3F1YXJlXCIpIC8vKGMscix6LHZzKSA9PiB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgY2VsbHMgYXMgc3F1YXJlcywgd2l0aCB2YXJpb3VzIGNvbG9ycyBhbmQgc2l6ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb25cbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcblxuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IHogPSBnZW9DYW52YXMudmlldy56XG5cbiAgICAgICAgLy9nZXQgdmlldyBzY2FsZVxuICAgICAgICBjb25zdCB2aWV3U2NhbGUgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxuXG4gICAgICAgIGNvbnN0IHIyID0gcmVzb2x1dGlvbiAqIDAuNVxuICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XG5cbiAgICAgICAgICAgIC8vY29sb3JcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuc3Ryb2tlQ29sb3IgPyB0aGlzLnN0cm9rZUNvbG9yKGMsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2VTdHlsZSA9IGNvbFxuXG4gICAgICAgICAgICAvL3NpemUgLSBpbiBnZW8gdW5pdFxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZSA/IHRoaXMuc2l6ZShjLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogcmVzb2x1dGlvblxuXG4gICAgICAgICAgICAvL3dpZHRoXG4gICAgICAgICAgICBjb25zdCB3aSA9IHRoaXMuc3Ryb2tlV2lkdGggPyB0aGlzLnN0cm9rZVdpZHRoKGMsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiAxICogelxuICAgICAgICAgICAgaWYgKCF3aSB8fCB3aSA8PSAwKSBjb250aW51ZVxuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lV2lkdGggPSB3aVxuXG4gICAgICAgICAgICAvL3NoYXBlXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuc2hhcGUgPyB0aGlzLnNoYXBlKGMsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiAnc3F1YXJlJ1xuICAgICAgICAgICAgaWYgKHNoYXBlID09PSAnbm9uZScpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoYywgcmVzb2x1dGlvbiwgeilcblxuICAgICAgICAgICAgaWYgKHNoYXBlID09PSAnc3F1YXJlJykge1xuICAgICAgICAgICAgICAgIC8vZHJhdyBzcXVhcmVcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gcmVzb2x1dGlvbiAqICgxIC0gc2l6ZSAvIHJlc29sdXRpb24pICogMC41XG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgucmVjdChjLnggKyBkICsgb2Zmc2V0LmR4LCBjLnkgKyBkICsgb2Zmc2V0LmR5LCBzaXplLCBzaXplKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguc3Ryb2tlKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICAgICAgLy9kcmF3IGNpcmNsZVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmFyYyhjLnggKyByMiArIG9mZnNldC5keCwgYy55ICsgcjIgKyBvZmZzZXQuZHksIHNpemUgKiAwLjUsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSlcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAnZGlhbW9uZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzMiA9IHNpemUgKiAwLjVcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5tb3ZlVG8oYy54ICsgcjIgLSBzMiwgYy55ICsgcjIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54ICsgcjIsIGMueSArIHIyICsgczIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54ICsgcjIgKyBzMiwgYy55ICsgcjIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54ICsgcjIsIGMueSArIHIyIC0gczIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54ICsgcjIgLSBzMiwgYy55ICsgcjIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2UoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2RvbnV0Jykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAndHJpYW5nbGVfdXAnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHIyID0gKHNpemUgLSByZXNvbHV0aW9uKSAvIDJcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5tb3ZlVG8oYy54IC0gZHIyLCBjLnkgLSBkcjIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54ICsgcjIsIGMueSArIHJlc29sdXRpb24gKyBkcjIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54ICsgcmVzb2x1dGlvbiArIGRyMiwgYy55IC0gZHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguY2xvc2VQYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAndHJpYW5nbGVfZG93bicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkcjIgPSAoc2l6ZSAtIHJlc29sdXRpb24pIC8gMlxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4Lm1vdmVUbyhjLnggLSBkcjIsIGMueSArIHJlc29sdXRpb24gKyBkcjIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54ICsgcjIsIGMueSAtIGRyMilcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVUbyhjLnggKyByZXNvbHV0aW9uICsgZHIyLCBjLnkgKyByZXNvbHV0aW9uICsgZHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguY2xvc2VQYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAndHJpYW5nbGVfbGVmdCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkcjIgPSAoc2l6ZSAtIHJlc29sdXRpb24pIC8gMlxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4Lm1vdmVUbyhjLnggKyByZXNvbHV0aW9uICsgZHIyLCBjLnkgKyByZXNvbHV0aW9uICsgZHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHgubGluZVRvKGMueCAtIGRyMiwgYy55ICsgcjIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54ICsgcmVzb2x1dGlvbiArIGRyMiwgYy55IC0gZHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguY2xvc2VQYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAndHJpYW5nbGVfcmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHIyID0gKHNpemUgLSByZXNvbHV0aW9uKSAvIDJcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5tb3ZlVG8oYy54IC0gZHIyLCBjLnkgLSBkcjIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54ICsgcmVzb2x1dGlvbiArIGRyMiwgYy55ICsgcjIpXG4gICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54IC0gZHIyLCBjLnkgKyByZXNvbHV0aW9uICsgZHIyKVxuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguY2xvc2VQYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzaGFwZTonICsgc2hhcGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByZXNvbHV0aW9uOiByZXNvbHV0aW9uLCB6OiB6LCB2aWV3U2NhbGU6IHZpZXdTY2FsZSB9KVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU2lkZVN0eWxlIH0gZnJvbSAnLi9TaWRlU3R5bGUuanMnXG5pbXBvcnQgeyBTcXVhcmVDb2xvckNhdGVnb3J5V2ViR0xTdHlsZSB9IGZyb20gJy4vU3F1YXJlQ29sb3JDYXRlZ29yeVdlYkdMU3R5bGUuanMnXG5pbXBvcnQgeyBjbGFzc2lmaWVyIGFzIGNsRnVuLCBjb2xvckNsYXNzaWZpZXIgYXMgY2NsRnVuIH0gZnJvbSAnLi4vdXRpbHMvc2NhbGUuanMnXG5cbi8qKlxuICogQHNlZSBodHRwczovL21hbmlmb2xkLm5ldC9kb2MvbWZkOS9leGFtcGxlX190YW5ha2FfY29udG91cnMuaHRtXG4gKlxuICogQG1vZHVsZSBzdHlsZVxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgVGFuYWthU3R5bGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsKTpudW1iZXJ9IHZhbHVlIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgb2YgYSBjZWxsXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYnJlYWtzIFRoZSBicmVhayB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgVGhlIGNvbG9ycywgb25lIG1vcmUgdGhhbiB0aGUgYnJlYWsgdmFsdWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvU3R5bGVcIikuU3R5bGU+fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQodmFsdWUsIGJyZWFrcywgY29sb3JzLCBvcHRzID0ge30pIHtcblxuICAgICAgICAvL3NoYWRvdyBjb2xvcnNcbiAgICAgICAgb3B0cy5jb2xvckRhcmsgPSBvcHRzLmNvbG9yRGFyayB8fCAnIzExMSdcbiAgICAgICAgb3B0cy5jb2xvckJyaWdodCA9IG9wdHMuY29sb3JCcmlnaHQgfHwgJyNkZGQnXG5cbiAgICAgICAgLyoqIEB0eXBlIHsgZnVuY3Rpb24obnVtYmVyLCBudW1iZXIpOm51bWJlciB9ICovXG4gICAgICAgIG9wdHMud2lkdGggPSBvcHRzLndpZHRoIHx8ICgoc2lkZVZhbHVlLCByZXNvbHV0aW9uLCB6KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtaW5XRyA9IDEgKiB6XG4gICAgICAgICAgICBjb25zdCBtYXhXRyA9IDQgKiB6XG4gICAgICAgICAgICBjb25zdCBzdGVwID0gKG1heFdHIC0gbWluV0cpIC8gM1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKG1pbldHICsgKHNpZGVWYWx1ZSAtIDEpICogc3RlcCwgbWF4V0cpXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy9tYWtlIGNsYXNzaWZpZXJcbiAgICAgICAgY29uc3QgY2xhc3NpZmllciA9IGNsRnVuKGJyZWFrcylcbiAgICAgICAgLy9tYWtlIGNvbG9ycyB0YWJsZVxuICAgICAgICBjb25zdCBjb2xvcnNEaWN0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgaSsrKSBjb2xvcnNEaWN0W2kgKyBcIlwiXSA9IGNvbG9yc1tpXVxuXG4gICAgICAgIGNvbnN0IGNlbGxTdHlsZSA9IG5ldyBTcXVhcmVDb2xvckNhdGVnb3J5V2ViR0xTdHlsZSh7XG4gICAgICAgICAgICBjb2RlOiBjZWxsID0+IGNsYXNzaWZpZXIodmFsdWUoY2VsbCkpLFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yc0RpY3RcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBnZXRTaWRlVmFsdWUgPSAoc2lkZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2wxID0gc2lkZS5jMSA/IGNsYXNzaWZpZXIodmFsdWUoc2lkZS5jMSkpIDogLTFcbiAgICAgICAgICAgIGNvbnN0IGNsMiA9IHNpZGUuYzIgPyBjbGFzc2lmaWVyKHZhbHVlKHNpZGUuYzIpKSA6IC0xXG4gICAgICAgICAgICByZXR1cm4gY2wxIC0gY2wyXG4gICAgICAgIH1cblxuICAgICAgICAvKiogVGhlIHNpZGUgc3R5bGUsIGZvciB0aGUgc2hhZG93IGVmZmVjdCAqL1xuICAgICAgICBjb25zdCBzaWRlU3R5bGUgPSBuZXcgU2lkZVN0eWxlKHtcbiAgICAgICAgICAgIC8vd2hpdGUgb3IgYmxhY2ssIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvbiBhbmQgdmFsdWVcbiAgICAgICAgICAgIGNvbG9yOiAoc2lkZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRTaWRlVmFsdWUoc2lkZSlcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCkgcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKHNpZGUub3IgPT09ICd2JykgcmV0dXJuIHYgPCAwID8gb3B0cy5jb2xvckJyaWdodCA6IG9wdHMuY29sb3JEYXJrXG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgPCAwID8gb3B0cy5jb2xvckRhcmsgOiBvcHRzLmNvbG9yQnJpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy93aWR0aCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSwgdGhhdCBpcyB0aGUgbnVtYmVyIG9mIGNsYXNzZXMgb2YgZGlmZmVyZW5jZVxuICAgICAgICAgICAgd2lkdGg6IChzaWRlLCByZXNvbHV0aW9uLCB6KSA9PiBvcHRzLndpZHRoKE1hdGguYWJzKGdldFNpZGVWYWx1ZShzaWRlKSksIHJlc29sdXRpb24sIHopXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIFtjZWxsU3R5bGUsIHNpZGVTdHlsZV1cbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vY29yZS9TdHlsZS5qcydcblxuLyoqXG4gKiBAbW9kdWxlIHN0eWxlXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0U3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgdGV4dCBvZiBhIGNlbGwuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy50ZXh0ID0gb3B0cy50ZXh0IHx8ICgoKSA9PiAnWCcpIC8vKGMscix6LHZzKSA9PiB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIGNlbGwuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKCgpID0+IFwiYmxhY2tcIikgLy8oYyxyLHosdnMpID0+IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBmb250IHNpemUgb2YgYSBjZWxsIGluIGdlbyB1bml0LlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlcixvYmplY3QpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IG9wdHMuZm9udFNpemUgfHwgKChjZWxsLCByZXNvbHV0aW9uKSA9PiByZXNvbHV0aW9uKSAvLyhjLHIseix2cykgPT4ge31cblxuICAgICAgICAvKiogVGhlIHRleHQgZm9udCBmYW1pbHkuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gb3B0cy5mb250RmFtaWx5IHx8ICgoKSA9PiAnQXJpYWwnKVxuXG4gICAgICAgIC8qKiBUaGUgdGV4dCBmb250IHdlaWdodC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmZvbnRXZWlnaHQgPSBvcHRzLmZvbnRXZWlnaHQgfHwgKCgpID0+ICdib2xkJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGNlbGxzIGFzIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XG5cbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL1xuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxuXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcbiAgICAgICAgY29uc3Qgdmlld1NjYWxlID0gdGhpcy52aWV3U2NhbGUgPyB0aGlzLnZpZXdTY2FsZShjZWxscywgcmVzb2x1dGlvbiwgeikgOiB1bmRlZmluZWRcblxuICAgICAgICAvL2RyYXcgd2l0aCBIVE1MIGNhbnZhc1xuICAgICAgICAvL2luIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICBnZW9DYW52YXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xuICAgICAgICAgICAgLy9nZXQgY2VsbCB0ZXh0XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy50ZXh0ID8gdGhpcy50ZXh0KGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICh0ZXh0ID09IHVuZGVmaW5lZCB8fCB0ZXh0ID09IG51bGwgfHwgdGV4dCArICcnID09PSAnJykgY29udGludWVcblxuICAgICAgICAgICAgLy9jb2xvclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3IoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFjb2wpIGNvbnRpbnVlXG4gICAgICAgICAgICBnZW9DYW52YXMuY3R4LmZpbGxTdHlsZSA9IGNvbFxuXG4gICAgICAgICAgICAvL2ZvbnQgc2l6ZVxuICAgICAgICAgICAgLy9zaXplIC0gaW4gcGl4ZWwgdW5pdFxuICAgICAgICAgICAgY29uc3QgZm9udFNpemVQaXggPSB0aGlzLmZvbnRTaXplKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgLyB6XG4gICAgICAgICAgICBpZiAoIWZvbnRTaXplUGl4KSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL3NldCBmb250XG4gICAgICAgICAgICBjb25zdCBmb250RmFtaWx5ID0gdGhpcy5mb250RmFtaWx5ID8gdGhpcy5mb250RmFtaWx5KGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiAnQXJpYWwnXG4gICAgICAgICAgICBjb25zdCBmb250V2VpZ2h0ID0gdGhpcy5mb250V2VpZ2h0ID8gdGhpcy5mb250V2VpZ2h0KGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiAnYm9sZCdcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZm9udCA9IGZvbnRXZWlnaHQgKyAnICcgKyBmb250U2l6ZVBpeCArICdweCAnICsgZm9udEZhbWlseVxuXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGNlbGwsIHJlc29sdXRpb24sIHopXG5cbiAgICAgICAgICAgIC8vdGV4dCBwb3NpdGlvblxuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJ1xuICAgICAgICAgICAgY29uc3QgdHggPSBnZW9DYW52YXMuZ2VvVG9QaXhYKGNlbGwueCArIHJlc29sdXRpb24gKiAwLjUgKyBvZmZzZXQuZHgpXG4gICAgICAgICAgICBjb25zdCB0eSA9IGdlb0NhbnZhcy5nZW9Ub1BpeFkoY2VsbC55ICsgcmVzb2x1dGlvbiAqIDAuNSArIG9mZnNldC5keSkgKyBmb250U2l6ZVBpeCAqIDAuMyAvL2l0IHNob3VsZCBiZSAwLjUgYnV0IDAuMyBzZWVtcyB0byB3b3JrIGJldHRlclxuXG4gICAgICAgICAgICAvL2RyYXcgdGhlIHRleHRcbiAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguZmlsbFRleHQodGV4dCwgdHgsIHR5KVxuICAgICAgICB9XG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgdmlld1NjYWxlOiB2aWV3U2NhbGUgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCBhIGZ1bmN0aW9uIFswLDFdLT5zdHJpbmcgZm9yIGNoYXJhY3RlcnMgbGVnZW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFyc1xuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uKG51bWJlcik6bnVtYmVyKXx1bmRlZmluZWR9IHNjYWxlXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKG51bWJlcik6c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyB0ZXh0U2NhbGUoY2hhcnMsIHNjYWxlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG5iID0gY2hhcnMubGVuZ3RoXG4gICAgICAgIHJldHVybiAodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjYWxlKSB0ID0gc2NhbGUodClcbiAgICAgICAgICAgIGlmICh0ID09IDApIHJldHVybiBcIlwiXG4gICAgICAgICAgICBpZiAodCA+PSAxKSByZXR1cm4gY2hhcnNbbmIgLSAxXVxuICAgICAgICAgICAgcmV0dXJuIGNoYXJzW01hdGguZmxvb3IodCAqIG5iKV1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xuXG4vKiogQHR5cGVkZWYge1wiZmlyc3RcInxcImJvdHRvbVwifFwiY2VudGVyXCJ8XCJ0b3BcInxcImxhc3RcIn0gQW5jaG9yTW9kZVlFbnVtICovXG5cbi8qKlxuICogU2hvdyBjZWxsIGFzIHRpbWVzZXJpZXMgY2hhcnRcbiAqIENhbiBiZSB1c2VkIGZvciBzcGFya2xpbmUgbWFwIG9mIGh0dHBzOi8vZGF0YWdpc3RpcHMuaHlwb3RoZXNlcy5vcmcvNDg4XG4gKlxuICogQG1vZHVsZSBzdHlsZVxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgVGltZVNlcmllc1N0eWxlIGV4dGVuZHMgU3R5bGUge1xuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogVGhlIGNvbHVtbnMgb2YgdGhlIHRpbWUgc2VyaWVzLCBvcmRlcmVkIGluIGNocm9ub2xvZ2ljYWwgb3JkZXIuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn0gKi9cbiAgICAgICAgdGhpcy50cyA9IG9wdHMudHNcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiBzcGVjaWZ5aW5nIHdoZW4gYSB2YWx1ZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBcIm5vIGRhdGFcIiBhbmQgdGh1cyBub3QgaWdub3JlZC4gVGhlIGxpbmUgd2lsbCBoYXZlIGEgYnJlYWsgYXQgdGhlc2UgdmFsdWVzLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oc3RyaW5nKTpib29sZWFufSAqL1xuICAgICAgICB0aGlzLm5vRGF0YSA9IG9wdHMubm9EYXRhIHx8ICgodikgPT4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT0gXCJcIiB8fCB2ID09PSBudWxsIHx8IGlzTmFOKCt2KSlcblxuICAgICAgICAvL3hcbiAgICAgICAgLyoqIGluIGdlbyB1bml0XG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbCxudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMub2Zmc2V0WCA9IG9wdHMub2Zmc2V0WCB8fCAoKGMsIHIsIHopID0+IDApXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0LmpzXCIpLkNlbGwsbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKGMsIHIsIHopID0+IHIpXG5cbiAgICAgICAgLy95XG4gICAgICAgIC8qKiBpbiBnZW8gdW5pdFxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0LmpzXCIpLkNlbGwsbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm9mZnNldFkgPSBvcHRzLm9mZnNldFkgfHwgKChjLCByLCB6KSA9PiAwKVxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCAoKGMsIHIsIHopID0+IHIpXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0LmpzXCIpLkNlbGwsbnVtYmVyLG51bWJlcik6QW5jaG9yTW9kZVlFbnVtfSAqL1xuICAgICAgICB0aGlzLmFuY2hvck1vZGVZID0gb3B0cy5hbmNob3JNb2RlWSB8fCAoKGMsIHIsIHopID0+IFwiY2VudGVyXCIpXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB3aWR0aCBvZiB0aGUgbGluZSwgaW4gZ2VvIHVuaXRcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IG9wdHMubGluZVdpZHRoIHx8ICgodiwgciwgcywgeikgPT4gMS41ICogeilcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjaGFydC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKCkgPT4gXCJibGFja1wiKSAvLyhjLHIseix2cykgPT4ge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGNlbGxzIGFzIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XG5cbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL1xuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxuXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcbiAgICAgICAgY29uc3Qgdmlld1NjYWxlID0gdGhpcy52aWV3U2NhbGUgPyB0aGlzLnZpZXdTY2FsZShjZWxscywgcmVzb2x1dGlvbiwgeikgOiB1bmRlZmluZWRcblxuICAgICAgICAvL2NvbXB1dGUgY2VsbCBhbXBsaXR1ZGVcbiAgICAgICAgY29uc3QgZ2V0QW1wbGl0dWRlID0gYyA9PiB7XG4gICAgICAgICAgICBsZXQgbWluLCBtYXhcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNbdF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PSB1bmRlZmluZWQgfHwgdmFsIDwgbWluKSBtaW4gPSB2YWxcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09IHVuZGVmaW5lZCB8fCB2YWwgPiBtYXgpIG1heCA9IHZhbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pbiA9PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiBtYXggLSBtaW5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29tcHV0ZSBtYXggYW1wbGl0dWRlXG4gICAgICAgIGxldCBhbXBNYXhcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjZWxscykge1xuICAgICAgICAgICAgY29uc3QgYW1wID0gZ2V0QW1wbGl0dWRlKGMpXG4gICAgICAgICAgICBpZiAoYW1wID09IHVuZGVmaW5lZCkgY29udGludWVcbiAgICAgICAgICAgIGlmIChhbXBNYXggPT0gdW5kZWZpbmVkIHx8IGFtcCA+IGFtcE1heCkgYW1wTWF4ID0gYW1wXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbXBNYXgpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IG5iID0gdGhpcy50cy5sZW5ndGhcblxuICAgICAgICBnZW9DYW52YXMuY3R4LmxpbmVDYXAgPSBcImJ1dHRcIlxuICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XG5cbiAgICAgICAgICAgIC8vbGluZSB3aWR0aFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgY29uc3Qgd0cgPSB0aGlzLmxpbmVXaWR0aCA/IHRoaXMubGluZVdpZHRoKGMsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghd0cgfHwgd0cgPCAwKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL2xpbmUgY29sb3JcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IgPyB0aGlzLmNvbG9yKGMsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghY29sKSBjb250aW51ZVxuXG5cbiAgICAgICAgICAgIC8veFxuICAgICAgICAgICAgY29uc3Qgb2ZmWCA9IHRoaXMub2Zmc2V0WCA/IHRoaXMub2Zmc2V0WChjLCByZXNvbHV0aW9uLCB6KSA6IDBcbiAgICAgICAgICAgIGlmIChvZmZYID09IHVuZGVmaW5lZCB8fCBpc05hTihvZmZYKSkgY29udGludWVcbiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID8gdGhpcy53aWR0aChjLCByZXNvbHV0aW9uLCB6KSA6IHJlc29sdXRpb25cbiAgICAgICAgICAgIGlmICh3ID09IHVuZGVmaW5lZCB8fCBpc05hTih3KSkgY29udGludWVcblxuICAgICAgICAgICAgLy95XG4gICAgICAgICAgICBjb25zdCBvZmZZID0gdGhpcy5vZmZzZXRZID8gdGhpcy5vZmZzZXRZKGMsIHJlc29sdXRpb24sIHopIDogMFxuICAgICAgICAgICAgaWYgKG9mZlkgPT0gdW5kZWZpbmVkIHx8IGlzTmFOKG9mZlkpKSBjb250aW51ZVxuICAgICAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID8gdGhpcy5oZWlnaHQoYywgcmVzb2x1dGlvbiwgeikgOiByZXNvbHV0aW9uXG4gICAgICAgICAgICBpZiAoaCA9PSB1bmRlZmluZWQgfHwgaXNOYU4oaCkpIGNvbnRpbnVlXG4gICAgICAgICAgICBjb25zdCBhbmNoWSA9IHRoaXMuYW5jaG9yTW9kZVkgPyB0aGlzLmFuY2hvck1vZGVZKGMsIHJlc29sdXRpb24sIHopIDogXCJjZW50ZXJcIlxuICAgICAgICAgICAgaWYgKCFhbmNoWSkgY29udGludWVcblxuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lV2lkdGggPSB3R1xuICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5zdHJva2VTdHlsZSA9IGNvbFxuXG4gICAgICAgICAgICAvL2NvbXB1dGUgYW5jaG9yIFkgZmlndXJlc1xuICAgICAgICAgICAgbGV0IHZhbDAsIHkwXG4gICAgICAgICAgICBpZiAoYW5jaFkgPT09IFwiZmlyc3RcIikge1xuICAgICAgICAgICAgICAgIC8vZ2V0IGZpcnN0IHZhbHVlXG4gICAgICAgICAgICAgICAgdmFsMCA9IGNbdGhpcy50c1swXV1cbiAgICAgICAgICAgICAgICB5MCA9IDBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5jaFkgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgICAgICAgLy9nZXQgbGFzdCB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhbDAgPSBjW3RoaXMudHNbdGhpcy50cy5sZW5ndGggLSAxXV1cbiAgICAgICAgICAgICAgICB5MCA9IDBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5jaFkgPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICAgICAgICAvL2dldCBtaW5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gK2NbdF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsMCA9PSB1bmRlZmluZWQgfHwgdmFsIDwgdmFsMCkgdmFsMCA9IHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5MCA9IDBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5jaFkgPT09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICAvL2dldCBtYXhcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gK2NbdF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsMCA9PSB1bmRlZmluZWQgfHwgdmFsID4gdmFsMCkgdmFsMCA9IHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5MCA9IHJlc29sdXRpb25cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5jaFkgPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICAgICAgICAvL2dldCBtaW4gYW5kIG1heFxuICAgICAgICAgICAgICAgIGxldCBtaW4sIG1heFxuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBjW3RdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09IHVuZGVmaW5lZCkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA9PSB1bmRlZmluZWQgfHwgdmFsIDwgbWluKSBtaW4gPSB2YWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heCA9PSB1bmRlZmluZWQgfHwgdmFsID4gbWF4KSBtYXggPSB2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsMCA9ICgrbWF4ICsgK21pbikgKiAwLjVcbiAgICAgICAgICAgICAgICB5MCA9IHJlc29sdXRpb24gLyAyXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5leHBlY3RlZCBhbmNob3JNb2RlWTogXCIgKyBhbmNoWSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyovZHJhdyBsaW5lXG4gICAgICAgICAgICBpZiAodmFsMCA9PSB1bmRlZmluZWQgfHwgaXNOYU4odmFsMCkpIGNvbnRpbnVlXG4gICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGNvbnN0IHNYID0gdyAvIChuYiAtIDEpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBjW3RoaXMudHNbaV1dXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PSB1bmRlZmluZWQgfHwgaXNOYU4odmFsKSkgYnJlYWtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKGMueCArIGkgKiBzWCArIG9mZlgsIGMueSArIHkwICsgKHZhbCAtIHZhbDApICogaCAvIGFtcE1heCArIG9mZlkpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGMueCArIGkgKiBzWCArIG9mZlgsIGMueSArIHkwICsgKHZhbCAtIHZhbDApICogaCAvIGFtcE1heCArIG9mZlkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZy5jdHguc3Ryb2tlKCkqL1xuXG5cbiAgICAgICAgICAgIC8vZHJhdyBsaW5lLCBzZWdtZW50IGJ5IHNlZ21lbnRcbiAgICAgICAgICAgIGNvbnN0IHNYID0gdyAvIChuYiAtIDEpXG5cbiAgICAgICAgICAgIC8vaGFuZGxlIGZpcnN0IHBvaW50XG4gICAgICAgICAgICBsZXQgdjAgPSBjW3RoaXMudHNbMF1dXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9EYXRhKHYwKSkge1xuICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4Lm1vdmVUbyhjLnggKyBvZmZYLCBjLnkgKyB5MCArICh2MCAtIHZhbDApICogaCAvIGFtcE1heCArIG9mZlkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHYwLCBpc05hTih2MCkpXG5cbiAgICAgICAgICAgIGxldCB2MVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuYjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBjW3RoaXMudHNbaV1dXG5cbiAgICAgICAgICAgICAgICAvL2RyYXcgc2VnbWVudCBmcm9tIHYwIHRvIHYxXG5cbiAgICAgICAgICAgICAgICAvL2JvdGggcG9pbnRzICdubyBkYXRhJ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vRGF0YSh2MCkgJiYgdGhpcy5ub0RhdGEodjEpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9zZWNvbmQgcG9pbnQgJ25vIGRhdGEnXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5ub0RhdGEodjApICYmIHRoaXMubm9EYXRhKHYxKSkge1xuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuY3R4LnN0cm9rZSgpXG5cbiAgICAgICAgICAgICAgICAgICAgLy9maXJzdCBwb2ludCAnbm8gZGF0YSdcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubm9EYXRhKHYwKSAmJiAhdGhpcy5ub0RhdGEodjEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5tb3ZlVG8oYy54ICsgaSAqIHNYICsgb2ZmWCwgYy55ICsgeTAgKyAodjEgLSB2YWwwKSAqIGggLyBhbXBNYXggKyBvZmZZKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vYm90aCBwb2ludHMgaGF2ZSBkYXRhOiB0cmFjZSBsaW5lXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLmN0eC5saW5lVG8oYy54ICsgaSAqIHNYICsgb2ZmWCwgYy55ICsgeTAgKyAodjEgLSB2YWwwKSAqIGggLyBhbXBNYXggKyBvZmZZKVxuICAgICAgICAgICAgICAgICAgICAvL2lmIGl0IGlzIHRoZSBsYXN0IHBvaW50LCBzdHJva2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gbmIgLSAxKSBnZW9DYW52YXMuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHYwID0gdjFcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kLCBpZiBhbnlcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHJlc29sdXRpb246IHJlc29sdXRpb24sIHo6IHosIHZpZXdTY2FsZTogdmlld1NjYWxlIH0pXG4gICAgfVxuXG59XG5cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgaW5pdFNoYWRlclByb2dyYW0sIGNyZWF0ZVNoYWRlciB9IGZyb20gJy4vd2ViR0xVdGlscy5qcydcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnZDMtY29sb3InXG5cbi8qKlxuICogRXZlcnl0aGluZyB0byBlYXNpbHkgZHJhdyBjb2xvcmVkIHNxdWFyZXMgd2l0aCB3ZWJHTC5cbiAqIEFsbCB0aGUgc2FtZSBzaXplLCBidXQgZGlmZmVyZW50IGZpbGwgY29sb3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHTFNxdWFyZUNvbG9yaW5nIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdsLCBzaXplUGl4KSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbFxuICAgICAgICB0aGlzLnNpemVQaXggPSBzaXplUGl4IHx8IDEwLjBcblxuICAgICAgICB0aGlzLnByb2dyYW0gPSBpbml0U2hhZGVyUHJvZ3JhbShcbiAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgY3JlYXRlU2hhZGVyKFxuICAgICAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgICAgIGdsLlZFUlRFWF9TSEFERVIsXG4gICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgcG9zO1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCBzaXplUGl4O1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIG1hdDtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGNvbG9yO1xuICAgICAgICAgICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KG1hdCAqIHZlYzMocG9zLCAxLjApLCAxLjApO1xuICAgICAgICAgICAgICBnbF9Qb2ludFNpemUgPSBzaXplUGl4O1xuICAgICAgICAgICAgICB2Q29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBgXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY3JlYXRlU2hhZGVyKFxuICAgICAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgICAgICAgICB2b2lkIG1haW4odm9pZCkge1xuICAgICAgICAgICAgICAgIHZlYzQgdkNvbG9yXyA9IHZDb2xvciAvIDI1NS4wO1xuICAgICAgICAgICAgICAgIHZDb2xvcl9bM10gPSAyNTUuMCAqIHZDb2xvcl9bM107XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yXztcbiAgICAgICAgICAgIH1gXG4gICAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pXG5cbiAgICAgICAgLy9idWZmZXIgZGF0YVxuICAgICAgICB0aGlzLnZlcnRpY2VzQnVmZmVyID0gW11cbiAgICAgICAgdGhpcy5jb2xvcnNCdWZmZXIgPSBbXVxuICAgIH1cblxuICAgIC8qKiBBZGQgZGF0YSB0byB2ZXJ0aWNlcy9zaXplL2NvbG9yIGJ1ZmZlcnMgZm9yIGNvbG9yIHNxdWFyZXMgZHJhd2luZyAqL1xuICAgIGFkZFBvaW50RGF0YSh4QywgeUMsIGNvbCkge1xuICAgICAgICAvL2NvbnZlcnQgY29sb3JcbiAgICAgICAgY29uc3QgY2MgPSBjb2xvcihjb2wpXG4gICAgICAgIC8vY29uc3QgY2MgPSB7cjo0NSxnOjg3LGI6OTgsb3BhY2l0eTowLjl9XG4gICAgICAgIGlmICghY2MpIHJldHVyblxuXG4gICAgICAgIC8vdmVydGljZXNcbiAgICAgICAgdGhpcy52ZXJ0aWNlc0J1ZmZlci5wdXNoKHhDLCB5QylcbiAgICAgICAgLy9jb2xvclxuICAgICAgICB0aGlzLmNvbG9yc0J1ZmZlci5wdXNoKGNjLnIsIGNjLmcsIGNjLmIsIGNjLm9wYWNpdHkpXG4gICAgfVxuXG4gICAgYWRkUG9pbnREYXRhMih4QywgeUMsIHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgICAgICAgLy92ZXJ0aWNlc1xuICAgICAgICB0aGlzLnZlcnRpY2VzQnVmZmVyLnB1c2goeEMsIHlDKVxuICAgICAgICAvL2NvbG9yXG4gICAgICAgIHRoaXMuY29sb3JzQnVmZmVyLnB1c2gociwgZywgYiwgb3BhY2l0eSlcbiAgICB9XG5cbiAgICAvKiogICovXG4gICAgZHJhdyh0cmFuc2ZvTWF0KSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbFxuXG4gICAgICAgIC8vdmVydGljZSBkYXRhXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSlcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0aWNlc0J1ZmZlciksIGdsLlNUQVRJQ19EUkFXKVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ3BvcycpXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIDIsIC8vbnVtQ29tcG9uZW50c1xuICAgICAgICAgICAgZ2wuRkxPQVQsIC8vdHlwZVxuICAgICAgICAgICAgZmFsc2UsIC8vbm9ybWFsaXNlXG4gICAgICAgICAgICAwLCAvL3N0cmlkZVxuICAgICAgICAgICAgMCAvL29mZnNldFxuICAgICAgICApXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uKVxuXG4gICAgICAgIC8vY29sb3IgZGF0YVxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY29sb3JzQnVmZmVyKSwgZ2wuU1RBVElDX0RSQVcpXG4gICAgICAgIHZhciBjb2xvciA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2NvbG9yJylcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihjb2xvciwgNCwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKVxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvcilcblxuICAgICAgICAvL3NpemVQaXhcbiAgICAgICAgZ2wudW5pZm9ybTFmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICdzaXplUGl4JyksIDEuMCAqIHRoaXMuc2l6ZVBpeClcblxuICAgICAgICAvL3RyYW5zZm9ybWF0aW9uXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ21hdCcpLCBmYWxzZSwgbmV3IEZsb2F0MzJBcnJheSh0cmFuc2ZvTWF0KSlcblxuICAgICAgICAvLyBFbmFibGUgdGhlIGRlcHRoIHRlc3RcbiAgICAgICAgLy9nbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIC8vIENsZWFyIHRoZSBjb2xvciBidWZmZXIgYml0XG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXG4gICAgICAgIC8vIFNldCB0aGUgdmlldyBwb3J0XG4gICAgICAgIC8vZ2wudmlld3BvcnQoMCwgMCwgY2cudywgY2cuaCk7XG5cbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIHRoaXMudmVydGljZXNCdWZmZXIubGVuZ3RoIC8gMilcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IGluaXRTaGFkZXJQcm9ncmFtLCBjcmVhdGVTaGFkZXIgfSBmcm9tICcuL3dlYkdMVXRpbHMuanMnXG5pbXBvcnQgeyBjb2xvciB9IGZyb20gJ2QzLWNvbG9yJ1xuXG4vKipcbiAqIEV2ZXJ5dGhpbmcgdG8gZWFzaWx5IGRyYXcgY29sb3JlZCBzcXVhcmVzIHdpdGggd2ViR0wuXG4gKiBBbGwgdGhlIHNhbWUgc2l6ZSwgYnV0IGRpZmZlcmVudCBmaWxsIGNvbG9yLlxuICogVGhlIGNvbG9yIGludGVycG9sYXRpb24gaXMgY29tcHV0ZWQgaW4gdGhlIGZyYWdtZW50IHNoYWRlciBwcm9ncmFtLCBieSB0aGUgR1BVLCB0aHVzIGl0IGlzIGxlc3MgZmxleGlibGUgYnV0IGZhc3Rlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYkdMU3F1YXJlQ29sb3JpbmdBZHZhbmNlZCB7XG4gICAgLy9zZWU6XG4gICAgLy9odHRwczovL3dlYmdsZnVuZGFtZW50YWxzLm9yZy93ZWJnbC9sZXNzb25zL2ZyL3dlYmdsLXNoYWRlcnMtYW5kLWdsc2wuaHRtbCNsZXMtdW5pZm9ybXMtZGFucy1sZXMtc2hhZGVycy1kZS12ZXJ0ZXhcbiAgICAvL2h0dHBzOi8vdGhlYm9va29mc2hhZGVycy5jb20vZ2xvc3NhcnkvP3NlYXJjaD1taXhcbiAgICAvL2h0dHBzOi8vdGhlYm9va29mc2hhZGVycy5jb20vMDYvXG4gICAgLy9odHRwczovL3RoZWJvb2tvZnNoYWRlcnMuY29tL2dsb3NzYXJ5L1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGdsXG4gICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gY29sb3JzXG4gICAgICogQHBhcmFtIHt7ZnVuOnN0cmluZyxhbHBoYTpudW1iZXJ9fSBzdHJldGNoaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVQaXhcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGdsb2JhbE9wYWNpdHlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnbCwgY29sb3JzLCBzdHJldGNoaW5nLCBzaXplUGl4ID0gMTAsIGdsb2JhbE9wYWNpdHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9ICovXG4gICAgICAgIHRoaXMuZ2wgPSBnbFxuICAgICAgICAvL2dsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdHJ1ZSk7XG4gICAgICAgIC8vZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgIC8vZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFNoYWRlcn0gKi9cbiAgICAgICAgY29uc3QgdlNoYWRlciA9IGNyZWF0ZVNoYWRlcihcbiAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgZ2wuVkVSVEVYX1NIQURFUixcbiAgICAgICAgICAgIGBcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgcG9zO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHNpemVQaXg7XG4gICAgICAgIHVuaWZvcm0gbWF0MyBtYXQ7XG5cbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IHQ7XG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdnQ7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChtYXQgKiB2ZWMzKHBvcywgMS4wKSwgMS4wKTtcbiAgICAgICAgICBnbF9Qb2ludFNpemUgPSBzaXplUGl4O1xuICAgICAgICAgIHZ0ID0gdDtcbiAgICAgICAgfVxuICAgICAgYFxuICAgICAgICApXG5cbiAgICAgICAgLy9wcmVwYXJlIGZyYWdtZW50IHNoYWRlciBjb2RlXG4gICAgICAgIC8vZGVjbGFyZSB0aGUgdW5pZm9ybSBhbmQgb3RoZXIgdmFyaWFibGVzXG4gICAgICAgIGxldCBmc2hTdHJpbmcgPVxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbicgK1xuICAgICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdnQ7XFxuJyArXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBhbHBoYTtcXG4nICtcbiAgICAgICAgICAgICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gW11cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykgb3V0LnB1c2goJ3VuaWZvcm0gdmVjNCBjJyArIGkgKyAnO1xcbicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5qb2luKCcnKVxuICAgICAgICAgICAgfSkoKSArXG4gICAgICAgICAgICAvL3N0YXJ0IHRoZSBtYWluIGZ1bmN0aW9uLCBhcHBseSB0aGUgc3RyZXRjaGluZyBvZiB0XG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHtcXG4nXG5cbiAgICAgICAgaWYgKHN0cmV0Y2hpbmcpIHtcbiAgICAgICAgICAgIGlmIChzdHJldGNoaW5nLmZ1biA9PSAncG93JylcbiAgICAgICAgICAgICAgICAvL3NQb3cgPSAodCwgYWxwaGEgPSAzKSA9PiBNYXRoLnBvdyh0LCBhbHBoYSk7XG4gICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gcG93KHZ0LCBhbHBoYSk7XFxuJ1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZXRjaGluZy5mdW4gPT0gJ3Bvd0ludicpXG4gICAgICAgICAgICAgICAgLy9zUG93UmV2ID0gKHQsIGFscGhhID0gMykgPT4gMSAtIE1hdGgucG93KDEgLSB0LCAxIC8gYWxwaGEpO1xuICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgZmxvYXQgdCA9IDEuMC1wb3coMS4wLXZ0LCAxLjAvYWxwaGEpO1xcbidcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmV0Y2hpbmcuZnVuID09ICdleHAnKVxuICAgICAgICAgICAgICAgIC8vc0V4cCA9ICh0LCBhbHBoYSA9IDMpID0+IGFscGhhID09IDAgPyB0IDogKE1hdGguZXhwKHQgKiBhbHBoYSkgLSAxKSAvIChNYXRoLmV4cChhbHBoYSkgLSAxKTtcbiAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz1cbiAgICAgICAgICAgICAgICAgICAgc3RyZXRjaGluZy5hbHBoYSA9PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBmbG9hdCB0ID0gdnQ7YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnICAgZmxvYXQgdCA9IChleHAodnQgKiBhbHBoYSkgLSAxLjApIC8gKGV4cChhbHBoYSkgLSAxLjApO1xcbidcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmV0Y2hpbmcuZnVuID09ICdsb2cnKVxuICAgICAgICAgICAgICAgIC8vc0V4cFJldiA9ICh0LCBhbHBoYSA9IDMpID0+IGFscGhhID09IDAgPyB0IDogMSAtICgxIC8gYWxwaGEpICogTWF0aC5sb2coTWF0aC5leHAoYWxwaGEpICogKDEgLSB0KSArIHQpO1xuICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPVxuICAgICAgICAgICAgICAgICAgICBzdHJldGNoaW5nLmFscGhhID09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGZsb2F0IHQgPSB2dDtgXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICcgICBmbG9hdCB0ID0gMS4wIC0gKDEuMCAvIGFscGhhKSAqIGxvZyhleHAoYWxwaGEpICogKDEuMCAtIHZ0KSArIHZ0KTtcXG4nXG4gICAgICAgICAgICBlbHNlIGlmIChzdHJldGNoaW5nLmZ1biA9PSAnY2lyY2xlJykge1xuICAgICAgICAgICAgICAgIGlmIChzdHJldGNoaW5nLmFscGhhID09IDApXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKGFscGhhID09IDApIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGZsb2F0IHQgPSB2dDtcXG4nXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyZXRjaGluZy5hbHBoYSA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoYWxwaGEgPT0gMSkgcmV0dXJuIE1hdGguc3FydCgyICogdCAtIHQgKiB0KTtcbiAgICAgICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gc3FydCh2dCAqICgyLjAgLSB2dCkpO1xcbidcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBhID0gYWxwaGEgLyAoMSAtIGFscGhhKTtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gTWF0aC5zcXJ0KDEgLyAoYSAqIGEpICsgdCAqICgyIC8gYSArIDIgLSB0KSkgLSAxIC8gYTtcbiAgICAgICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAnICAgZmxvYXQgYSA9IGFscGhhIC8gKDEuMCAtIGFscGhhKTtcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgICBmbG9hdCB0ID0gc3FydCgxLjAgLyAoYSAqIGEpICsgdnQgKiAoIDIuMC9hICsgMi4wIC0gdnQgKSkgLSAxLjAgLyBhO1xcbidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmV0Y2hpbmcuZnVuID09ICdjaXJjbGVJbnYnKSB7XG4gICAgICAgICAgICAgICAgLy8gMSAtIHNDaXJjbGVMb3coMSAtIHQsIGFscGhhKVxuICAgICAgICAgICAgICAgIGlmIChzdHJldGNoaW5nLmFscGhhID09IDApXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKGFscGhhID09IDApIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGZsb2F0IHQgPSB2dDtcXG4nXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyZXRjaGluZy5hbHBoYSA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoYWxwaGEgPT0gMSkgcmV0dXJuIE1hdGguc3FydCgyICogdCAtIHQgKiB0KTtcbiAgICAgICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gMS4wIC0gc3FydCgoMS4wIC0gdnQpICogKDEuMCArIHZ0KSk7XFxuJ1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IGEgPSBhbHBoYSAvICgxIC0gYWxwaGEpO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBNYXRoLnNxcnQoMSAvIChhICogYSkgKyAoMiAqIHQpIC8gYSArIDIgKiB0IC0gdCAqIHQpIC0gMSAvIGE7XG4gICAgICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPVxuICAgICAgICAgICAgICAgICAgICAgICAgJyAgIGZsb2F0IGEgPSBhbHBoYSAvICgxLjAgLSBhbHBoYSk7XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICAgZmxvYXQgdCA9IDEuMCAtIHNxcnQoMS4wIC8gKGEgKiBhKSArICgxLjAtdnQpICogKCAyLjAvYSArIDEuMCArIHZ0ICkpICsgMS4wIC8gYTtcXG4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIHN0cmV0Y2hpbmcgZnVuY3Rpb24gY29kZTogJyArIHN0cmV0Y2hpbmcuZnVuKVxuICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgZmxvYXQgdCA9IHZ0O1xcbidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgZmxvYXQgdCA9IHZ0O1xcbidcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hvb3NlIGluaXRpYWwgYW5kIGZpbmFsIGNvbG9ycywgYW5kIGFkanVzdCB0IHZhbHVlXG4gICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID09IDEpIGZzaFN0cmluZyArPSAnICAgdmVjNCBjST1jMDtcXG4gICB2ZWM0IGNGPWMwO1xcbidcbiAgICAgICAgZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PSAyKSBmc2hTdHJpbmcgKz0gJyAgIHZlYzQgY0k9YzA7XFxuICAgdmVjNCBjRj1jMTtcXG4nXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmIgPSBjb2xvcnMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgY29uc3QgbmJzID0gbmIgKyAnLjAnXG4gICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIHZlYzQgY0k7XFxuJ1xuICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICB2ZWM0IGNGO1xcbidcbiAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgaWYodDwxLjAvJyArIG5icyArICcpIHsgY0k9YzA7IGNGPWMxOyB0PXQqJyArIG5icyArICc7IH1cXG4nXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IG5iOyBpKyspXG4gICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9XG4gICAgICAgICAgICAgICAgICAgICcgICBlbHNlIGlmKHQ8JyArXG4gICAgICAgICAgICAgICAgICAgIGkgK1xuICAgICAgICAgICAgICAgICAgICAnLjAvJyArXG4gICAgICAgICAgICAgICAgICAgIG5icyArXG4gICAgICAgICAgICAgICAgICAgICcpIHsgY0k9YycgK1xuICAgICAgICAgICAgICAgICAgICAoaSAtIDEpICtcbiAgICAgICAgICAgICAgICAgICAgJzsgY0Y9YycgK1xuICAgICAgICAgICAgICAgICAgICBpICtcbiAgICAgICAgICAgICAgICAgICAgJzsgdD0nICtcbiAgICAgICAgICAgICAgICAgICAgbmJzICtcbiAgICAgICAgICAgICAgICAgICAgJyp0LScgK1xuICAgICAgICAgICAgICAgICAgICAoaSAtIDEpICtcbiAgICAgICAgICAgICAgICAgICAgJy4wOyB9XFxuJ1xuICAgICAgICAgICAgZnNoU3RyaW5nICs9XG4gICAgICAgICAgICAgICAgJyAgIGVsc2UgeyBjST1jJyArIChuYiAtIDEpICsgJzsgY0Y9YycgKyBuYiArICc7IHQ9JyArIG5icyArICcqdC0nICsgKG5iIC0gMSkgKyAnLjA7IH1cXG4nXG4gICAgICAgIH1cblxuICAgICAgICAvL29uZSBzaW5nbGUgY29sb3JcbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT0gMSkgZnNoU3RyaW5nICs9ICcgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGMwWzBdLCBjMFsxXSwgYzBbMl0sIGMwWzNdKTt9XFxuJ1xuICAgICAgICAvL3NldCBpbnRlcnBvbGF0ZWQgY29sb3IsIGJldHdlZW4gaW5pdGlhbCBhbmQgZmluYWwgb25lXG4gICAgICAgIGVsc2UgZnNoU3RyaW5nICs9ICcgICBnbF9GcmFnQ29sb3IgPSBtaXgoY0ksIGNGLCB0KTt9XFxuJ1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coZnNoU3RyaW5nKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViR0xTaGFkZXJ9ICovXG4gICAgICAgIGNvbnN0IGZTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnNoU3RyaW5nKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViR0xQcm9ncmFtfSAqL1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBpbml0U2hhZGVyUHJvZ3JhbShnbCwgdlNoYWRlciwgZlNoYWRlcilcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pXG5cbiAgICAgICAgLy9zZXQgdW5pZm9ybXNcblxuICAgICAgICAvL3NpemVQaXhcbiAgICAgICAgLy9UT0RPOiBidWcgaGVyZS4gU2VlbXMgdG8gYmUgbGltaXRlZCB0byBzb21lIHRocmVzaG9sZCB2YWx1ZSAoYXJvdW5kIDI1MCkuXG4gICAgICAgIGdsLnVuaWZvcm0xZihnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnc2l6ZVBpeCcpLCAxLjAgKiBzaXplUGl4KVxuXG4gICAgICAgIC8vc3RyZXRjaGluZyBhbHBoYSBmYWN0b3JcbiAgICAgICAgZ2wudW5pZm9ybTFmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICdhbHBoYScpLCBzdHJldGNoaW5nID8gMS4wICogc3RyZXRjaGluZy5hbHBoYSA6IDAuMClcblxuICAgICAgICAvL2NvbG9yc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYyA9IGNvbG9yKGNvbG9yc1tpXSlcblxuICAgICAgICAgICAgbGV0IG9wYWNpdHkgPSBjLm9wYWNpdHlcbiAgICAgICAgICAgIGlmIChjLm9wYWNpdHkgPT0gMSAmJiBnbG9iYWxPcGFjaXR5ICE9IHVuZGVmaW5lZCkgb3BhY2l0eSA9IGdsb2JhbE9wYWNpdHlcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTRmdihnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnYycgKyBpKSwgW1xuICAgICAgICAgICAgICAgICtjLnIgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICArYy5nIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgK2MuYiAvIDI1NS4wLFxuICAgICAgICAgICAgICAgICtvcGFjaXR5LFxuICAgICAgICAgICAgXSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiAgKi9cbiAgICBkcmF3KHZlcnRpY2VzQnVmZmVyLCB0QnVmZmVyLCB0cmFuc2ZvTWF0KSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbFxuICAgICAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtXG5cbiAgICAgICAgLy92ZXJ0aWNlIGRhdGFcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGdsLmNyZWF0ZUJ1ZmZlcigpKVxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlc0J1ZmZlciksIGdsLlNUQVRJQ19EUkFXKVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3MnKVxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAyLCAvL251bUNvbXBvbmVudHNcbiAgICAgICAgICAgIGdsLkZMT0FULCAvL3R5cGVcbiAgICAgICAgICAgIGZhbHNlLCAvL25vcm1hbGlzZVxuICAgICAgICAgICAgMCwgLy9zdHJpZGVcbiAgICAgICAgICAgIDAgLy9vZmZzZXRcbiAgICAgICAgKVxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbilcblxuICAgICAgICAvL3QgZGF0YVxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHRCdWZmZXIpLCBnbC5TVEFUSUNfRFJBVylcbiAgICAgICAgY29uc3QgdCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICd0JylcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0LCAxLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHQpXG5cbiAgICAgICAgLy90cmFuc2Zvcm1hdGlvblxuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnbWF0JyksIGZhbHNlLCBuZXcgRmxvYXQzMkFycmF5KHRyYW5zZm9NYXQpKVxuXG4gICAgICAgIC8vIEVuYWJsZSB0aGUgZGVwdGggdGVzdFxuICAgICAgICAvL2dsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGNvbG9yIGJ1ZmZlciBiaXRcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVClcbiAgICAgICAgLy8gU2V0IHRoZSB2aWV3IHBvcnRcbiAgICAgICAgLy9nbC52aWV3cG9ydCgwLCAwLCBjZy53LCBjZy5oKTtcblxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgdmVydGljZXNCdWZmZXIubGVuZ3RoIC8gMilcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IGluaXRTaGFkZXJQcm9ncmFtLCBjcmVhdGVTaGFkZXIgfSBmcm9tICcuL3dlYkdMVXRpbHMuanMnXG5pbXBvcnQgeyBjb2xvciB9IGZyb20gJ2QzLWNvbG9yJ1xuXG4vKipcbiAqIEV2ZXJ5dGhpbmcgdG8gZWFzaWx5IGRyYXcgY29sb3JlZCBzcXVhcmVzIHdpdGggd2ViR0wuXG4gKiBBbGwgdGhlIHNhbWUgc2l6ZSwgYnV0IGRpZmZlcmVudCBmaWxsIGNvbG9yLlxuICogQ29sb3IgYmFzZWQgb24gY2F0ZWdvcmllcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29sb3JzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59ICovXG4gICAgICAgIHRoaXMuY29sb3JzID0gY29sb3JzXG5cbiAgICAgICAgLyoqIFZlY3RvciBzaGFkZXIgcHJvZ3JhbVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnZzaFN0cmluZyA9IGBcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgcG9zO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHNpemVQaXg7XG4gICAgICAgIHVuaWZvcm0gbWF0MyBtYXQ7XG5cbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGk7XG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdmk7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChtYXQgKiB2ZWMzKHBvcywgMS4wKSwgMS4wKTtcbiAgICAgICAgICBnbF9Qb2ludFNpemUgPSBzaXplUGl4O1xuICAgICAgICAgIHZpID0gaTtcbiAgICAgICAgfVxuICAgICAgICBgXG5cbiAgICAgICAgLy9wcmVwYXJlIGZyYWdtZW50IHNoYWRlciBjb2RlXG4gICAgICAgIC8vZGVjbGFyZSB0aGUgdW5pZm9ybSBhbmQgb3RoZXIgdmFyaWFibGVzXG4gICAgICAgIGNvbnN0IG91dCA9IFtdXG4gICAgICAgIG91dC5wdXNoKCdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIGZsb2F0IHZpO1xcbicpXG4gICAgICAgIC8vYWRkIGNvbG9yIHVuaWZvcm1zXG4gICAgICAgIG91dC5wdXNoKCd1bmlmb3JtIHZlYzQnKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSBvdXQucHVzaCgnLCcpXG4gICAgICAgICAgICBvdXQucHVzaCgnIGMnICsgaSlcbiAgICAgICAgfVxuICAgICAgICBvdXQucHVzaCgnO1xcbicpXG4gICAgICAgIC8vc3RhcnQgdGhlIG1haW4gZnVuY3Rpb25cbiAgICAgICAgb3V0LnB1c2goJ3ZvaWQgbWFpbih2b2lkKSB7XFxuJylcbiAgICAgICAgLy9jaG9vc2UgY29sb3IgaVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSBvdXQucHVzaCgnZWxzZSAnKVxuICAgICAgICAgICAgb3V0LnB1c2goJ2lmKHZpPT0nKVxuICAgICAgICAgICAgb3V0LnB1c2goaSlcbiAgICAgICAgICAgIG91dC5wdXNoKCcuMCkgZ2xfRnJhZ0NvbG9yID0gdmVjNChjJylcbiAgICAgICAgICAgIG91dC5wdXNoKGkpXG4gICAgICAgICAgICBvdXQucHVzaCgnWzBdLCBjJylcbiAgICAgICAgICAgIG91dC5wdXNoKGkpXG4gICAgICAgICAgICBvdXQucHVzaCgnWzFdLCBjJylcbiAgICAgICAgICAgIG91dC5wdXNoKGkpXG4gICAgICAgICAgICBvdXQucHVzaCgnWzJdLCBjJylcbiAgICAgICAgICAgIG91dC5wdXNoKGkpXG4gICAgICAgICAgICBvdXQucHVzaCgnWzNdKTtcXG4nKVxuICAgICAgICB9XG4gICAgICAgIG91dC5wdXNoKCdlbHNlIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTtcXG59JylcbiAgICAgICAgLyoqIEZyYWdtZW50IHNoYWRlciBwcm9ncmFtXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuZnNoU3RyaW5nID0gb3V0LmpvaW4oJycpXG4gICAgfVxuXG4gICAgLyoqICAqL1xuICAgIGRyYXcoZ2wsIHZlcnRpY2VzQnVmZmVyLCBpQnVmZmVyLCB0cmFuc2ZvTWF0LCBzaXplUGl4ID0gMTApIHtcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFNoYWRlcn0gKi9cbiAgICAgICAgY29uc3QgdlNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdGhpcy52c2hTdHJpbmcpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFNoYWRlcn0gKi9cbiAgICAgICAgY29uc3QgZlNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCB0aGlzLmZzaFN0cmluZylcblxuICAgICAgICAvKiogQHR5cGUge1dlYkdMUHJvZ3JhbX0gKi9cbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGluaXRTaGFkZXJQcm9ncmFtKGdsLCB2U2hhZGVyLCBmU2hhZGVyKVxuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pXG5cbiAgICAgICAgLy9zZXQgdW5pZm9ybXNcblxuICAgICAgICAvL3NpemVQaXhcbiAgICAgICAgZ2wudW5pZm9ybTFmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnc2l6ZVBpeCcpLCAxLjAgKiBzaXplUGl4KVxuXG4gICAgICAgIC8vY29sb3JzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb2xvcih0aGlzLmNvbG9yc1tpXSlcbiAgICAgICAgICAgIGdsLnVuaWZvcm00ZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdjJyArIGkpLCBbXG4gICAgICAgICAgICAgICAgK2MuciAvIDI1NS4wLFxuICAgICAgICAgICAgICAgICtjLmcgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICArYy5iIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgK2Mub3BhY2l0eSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH1cblxuICAgICAgICAvL3ZlcnRpY2UgZGF0YVxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzQnVmZmVyKSwgZ2wuU1RBVElDX0RSQVcpXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ3BvcycpXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIDIsIC8vbnVtQ29tcG9uZW50c1xuICAgICAgICAgICAgZ2wuRkxPQVQsIC8vdHlwZVxuICAgICAgICAgICAgZmFsc2UsIC8vbm9ybWFsaXNlXG4gICAgICAgICAgICAwLCAvL3N0cmlkZVxuICAgICAgICAgICAgMCAvL29mZnNldFxuICAgICAgICApXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uKVxuXG4gICAgICAgIC8vaSBkYXRhXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSlcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoaUJ1ZmZlciksIGdsLlNUQVRJQ19EUkFXKVxuICAgICAgICBjb25zdCBpID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2knKVxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGksIDEsIGdsLkZMT0FULCBmYWxzZSwgMCwgMClcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSlcblxuICAgICAgICAvL3RyYW5zZm9ybWF0aW9uXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdtYXQnKSwgZmFsc2UsIG5ldyBGbG9hdDMyQXJyYXkodHJhbnNmb01hdCkpXG5cbiAgICAgICAgLy8gRW5hYmxlIHRoZSBkZXB0aCB0ZXN0XG4gICAgICAgIC8vZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICAvLyBDbGVhciB0aGUgY29sb3IgYnVmZmVyIGJpdFxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKVxuICAgICAgICAvLyBTZXQgdGhlIHZpZXcgcG9ydFxuICAgICAgICAvL2dsLnZpZXdwb3J0KDAsIDAsIGNnLncsIGNnLmgpO1xuXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCB2ZXJ0aWNlc0J1ZmZlci5sZW5ndGggLyAyKVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgbG9hZEltYWdlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXG5cbi8vXG5cbi8qKlxuICogTG9hZCBjaGVybm9mZiBpbWFnZXNcbiAqIFNlZSBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2pnYWZmdXJpL2NoZXJub2ZmLWZhY2VzXG4gKiBAcGFyYW0ge29iamVjdH0gb3V0IFxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufHVuZGVmaW5lZH0gY2FsbGJhY2sgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRDaGVybm9mZkZhY2VzSW1hZ2VzKG91dCwgYmFzZVVSTCwgY2FsbGJhY2sgPSB1bmRlZmluZWQpIHtcbiAgICBvdXQgPSBvdXQgfHwge31cbiAgICBmb3IgKGxldCBzIG9mIFtcImZcIiwgXCJtXCJdKVxuICAgICAgICBmb3IgKGxldCBhIG9mIFtcInlcIiwgXCJtXCIsIFwib1wiXSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDI7IGkrKylcbiAgICAgICAgICAgICAgICBvdXRbcyArIGEgKyBpXSA9IGF3YWl0IGxvYWRJbWFnZShiYXNlVVJMICsgKHMgKyBhICsgaSkgKyBcIi5wbmdcIilcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKClcbiAgICByZXR1cm4gb3V0XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IGV4dGVudCwgbWF4IH0gZnJvbSBcImQzLWFycmF5XCJcbmltcG9ydCB7IHNjYWxlUXVhbnRpbGUgfSBmcm9tIFwiZDMtc2NhbGVcIlxuXG4vKipcbiAqIEEgc2NhbGUgaXMgc2ltcGx5IGEgZnVuY3Rpb24gdGhhdCBtYXAgYSBkb21haW4gdG8gYSByYW5nZS5cbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihudW1iZXIpOm51bWJlcn0gU2NhbGUgKi9cblxuLyoqXG4gKiBBIHNjYWxlIHdob3NlIHJhbmdlIGlzIGEgY29sb3IgKHN0cmluZykuXG4qIEB0eXBlZGVmIHtmdW5jdGlvbihudW1iZXIpOnN0cmluZ30gQ29sb3JTY2FsZSAqL1xuXG5cbi8qKlxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cblxuLyoqXG4gKiBHZW5lcmljIGZ1bmN0aW9uIGZvciB2aWV3IHNjYWxlIC0gY29udGludW91cyBvciBkaXNjcmV0ZVxuICogXG4gKiBAcGFyYW0ge3sgdmFsdWVGdW5jdGlvbjpmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbCk6bnVtYmVyLCBtaW5WYWx1ZT86bnVtYmVyLCBtaW5TaXplUGl4PzpudW1iZXIsIG1heFNpemVGYWN0b3I/Om51bWJlciwgcmFuZ2U/OltudW1iZXIsIG51bWJlcl0sIGRvbWFpbj86W251bWJlciwgbnVtYmVyXSwgc3RyZXRjaGluZz86ZnVuY3Rpb24obnVtYmVyKTpudW1iZXIsIGNsYXNzTnVtYmVyPzpudW1iZXJ9fSBvcHRzIFxuICogQHJldHVybnMge2Z1bmN0aW9uKEFycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD4pOlNjYWxlfVxuICovXG5leHBvcnQgY29uc3Qgdmlld1NjYWxlID0gKG9wdHMpID0+IHtcbiAgICBjb25zdCB2YWx1ZUZ1bmN0aW9uID0gb3B0cy52YWx1ZUZ1bmN0aW9uXG4gICAgY29uc3QgbWluVmFsdWUgPSBvcHRzLm1pblZhbHVlIHx8IDBcbiAgICBjb25zdCBtaW5TaXplUGl4ID0gb3B0cy5taW5TaXplUGl4IHx8IDBcbiAgICBjb25zdCBtYXhTaXplRmFjdG9yID0gb3B0cy5tYXhTaXplRmFjdG9yIHx8IDFcbiAgICBjb25zdCBzdHJldGNoaW5nID0gb3B0cy5zdHJldGNoaW5nXG4gICAgY29uc3QgcmFuZ2VfID0gb3B0cy5yYW5nZVxuICAgIGNvbnN0IGRvbWFpbl8gPSBvcHRzLmRvbWFpblxuICAgIGNvbnN0IGNsYXNzTnVtYmVyID0gb3B0cy5jbGFzc051bWJlclxuICAgIHJldHVybiAoY2VsbHMsIHJlc29sdXRpb24sIHopID0+IHtcbiAgICAgICAgY29uc3QgZG9tYWluID0gZG9tYWluXyB8fCBbbWluVmFsdWUsIG1heChjZWxscywgdmFsdWVGdW5jdGlvbildXG4gICAgICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VfIHx8IFttaW5TaXplUGl4ICogeiwgcmVzb2x1dGlvbiAqIG1heFNpemVGYWN0b3JdXG4gICAgICAgIGNvbnN0IGRvbWFpblNpemUgPSBkb21haW5bMV0gLSBkb21haW5bMF0sIGRvbWFpbk1pbiA9IGRvbWFpblswXVxuICAgICAgICBjb25zdCByYW5nZVNpemUgPSByYW5nZVsxXSAtIHJhbmdlWzBdLCByYW5nZU1pbiA9IHJhbmdlWzBdXG4gICAgICAgIHJldHVybiB0ID0+IHtcbiAgICAgICAgICAgIC8vc2NhbGUgdG8gWzAsMV1cbiAgICAgICAgICAgIHQgPSAodCAtIGRvbWFpbk1pbikgLyBkb21haW5TaXplXG4gICAgICAgICAgICAvL3N0cmV0Y2hcbiAgICAgICAgICAgIGlmIChzdHJldGNoaW5nKSB0ID0gc3RyZXRjaGluZyh0KVxuICAgICAgICAgICAgLy9jbGFzc2lmeVxuICAgICAgICAgICAgaWYgKGNsYXNzTnVtYmVyKSB0ID0gdCA9PSAxID8gMSA6IE1hdGguZmxvb3IodCAqIChjbGFzc051bWJlcikpIC8gKGNsYXNzTnVtYmVyIC0gMSlcbiAgICAgICAgICAgIC8vc2NhbGUgdG8gcmFuZ2VcbiAgICAgICAgICAgIHJldHVybiByYW5nZU1pbiArIHQgKiByYW5nZVNpemVcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8qKlxuICogR2VuZXJpYyBmdW5jdGlvbiBmb3IgdmlldyBzY2FsZSAtIHF1YW50aWxlXG4gKiBcbiAqIEBwYXJhbSB7eyB2YWx1ZUZ1bmN0aW9uOmZ1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5DZWxsKTpudW1iZXIsIGNsYXNzTnVtYmVyPzpudW1iZXIsIG1pblNpemVQaXg/Om51bWJlciwgbWF4U2l6ZUZhY3Rvcj86bnVtYmVyIH19IG9wdHMgXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oQXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5DZWxsPik6U2NhbGV9XG4gKi9cbmV4cG9ydCBjb25zdCB2aWV3U2NhbGVRdWFudGlsZSA9IChvcHRzKSA9PiB7XG4gICAgY29uc3QgdmFsdWVGdW5jdGlvbiA9IG9wdHMudmFsdWVGdW5jdGlvblxuICAgIGNvbnN0IGNsYXNzTnVtYmVyID0gb3B0cy5jbGFzc051bWJlciB8fCAxMlxuICAgIGNvbnN0IG1pblNpemVQaXggPSBvcHRzLm1pblNpemVQaXggfHwgMVxuICAgIGNvbnN0IG1heFNpemVGYWN0b3IgPSBvcHRzLm1heFNpemVGYWN0b3IgfHwgMVxuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVRdWFudGlsZSgpXG4gICAgcmV0dXJuIChjZWxscywgcmVzb2x1dGlvbiwgeikgPT4ge1xuICAgICAgICBzY2FsZS5kb21haW4oY2VsbHMubWFwKHZhbHVlRnVuY3Rpb24pKVxuICAgICAgICBjb25zdCBtaW5TaXplR2VvID0gbWluU2l6ZVBpeCAqIHosIG1heFNpemVHZW8gPSByZXNvbHV0aW9uICogbWF4U2l6ZUZhY3RvclxuICAgICAgICBzY2FsZS5yYW5nZShBcnJheS5mcm9tKHsgbGVuZ3RoOiBjbGFzc051bWJlciB9LCAoXywgaSkgPT4gbWluU2l6ZUdlbyArIGkgKiAobWF4U2l6ZUdlbyAtIG1pblNpemVHZW8pIC8gKGNsYXNzTnVtYmVyIC0gMSkpKVxuICAgICAgICBzY2FsZS5icmVha3MgPSBzY2FsZS5xdWFudGlsZXMoKVxuICAgICAgICBzY2FsZS52YWx1ZXMgPSBzY2FsZS5yYW5nZSgpXG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG59XG5cblxuXG5cblxuXG4vKipcbiAqIEdlbmVyaWMgZnVuY3Rpb24gZm9yIGNvbG9yIHZpZXcgc2NhbGUgLSBjb250aW51b3VzIG9yIGRpc2NyZXRlXG4gKiBcbiAqIEBwYXJhbSB7eyB2YWx1ZUZ1bmN0aW9uOmZ1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5DZWxsKTpudW1iZXIsIGNvbG9yU2NhbGU/OmZ1bmN0aW9uKG51bWJlcik6c3RyaW5nLCBjb2xvcnM/OkFycmF5LjxzdHJpbmc+LCBzdHJldGNoaW5nPzpmdW5jdGlvbihudW1iZXIpOm51bWJlciB9fSBvcHRzIFxuICogQHJldHVybnMge2Z1bmN0aW9uKEFycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD4pOkNvbG9yU2NhbGV9XG4gKi9cbmV4cG9ydCBjb25zdCB2aWV3U2NhbGVDb2xvciA9IChvcHRzKSA9PiB7XG4gICAgY29uc3QgdmFsdWVGdW5jdGlvbiA9IG9wdHMudmFsdWVGdW5jdGlvblxuICAgIGNvbnN0IHN0cmV0Y2hpbmcgPSBvcHRzLnN0cmV0Y2hpbmdcbiAgICBsZXQgY29sb3JTY2FsZSA9IG9wdHMuY29sb3JTY2FsZSB8fCAoKCkgPT4gXCJwdXJwbGVcIilcblxuICAgIC8vZGlzY3JldGUgY29sb3JzIGNhc2U6IGJ1aWxkIGNvbnRpbnVvdXMgY29sb3Igc2NhbGUgZnJvbSBkaXNjcmV0ZSBvbmVzLlxuICAgIGNvbnN0IG5iQ2xhc3MgPSBvcHRzLmNvbG9ycz8ubGVuZ3RoXG4gICAgaWYgKG9wdHMuY29sb3JzICYmIG5iQ2xhc3MpXG4gICAgICAgIGNvbG9yU2NhbGUgPSB0ID0+IG9wdHMuY29sb3JzW3QgPT0gMSA/IG5iQ2xhc3MgLSAxIDogTWF0aC5mbG9vcih0ICogbmJDbGFzcyldXG5cbiAgICByZXR1cm4gKGNlbGxzKSA9PiB7XG4gICAgICAgIGlmIChjZWxscy5sZW5ndGggPT0gMCB8fCAhY2VsbHMpIHJldHVyblxuICAgICAgICAvKiogQHR5cGUge1t1bmRlZmluZWQsIHVuZGVmaW5lZF0gfCBbbnVtYmVyLCBudW1iZXJdfSAqL1xuICAgICAgICBjb25zdCBkb21haW4gPSBleHRlbnQoY2VsbHMsIHZhbHVlRnVuY3Rpb24pXG4gICAgICAgIGlmIChkb21haW5bMF0gPT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICAgICAgY29uc3QgZG9tYWluU2l6ZSA9IGRvbWFpblsxXSAtIGRvbWFpblswXVxuICAgICAgICBjb25zdCBzY2FsZSA9IHQgPT4ge1xuICAgICAgICAgICAgLy9zY2FsZSB0byBbMCwxXVxuICAgICAgICAgICAgdCA9ICh0IC0gZG9tYWluWzBdKSAvIGRvbWFpblNpemVcbiAgICAgICAgICAgIC8vc3RyZXRjaFxuICAgICAgICAgICAgaWYgKHN0cmV0Y2hpbmcpIHQgPSBzdHJldGNoaW5nKHQpXG4gICAgICAgICAgICByZXR1cm4gY29sb3JTY2FsZSh0KVxuICAgICAgICB9XG4gICAgICAgIC8vZnVuY3Rpb24gdGhhdCByZXR1cm4gdGhlIGRvbWFpbiB2YWx1ZSBmcm9tIHRoZSBbMCwxXSByYW5nZS5cbiAgICAgICAgc2NhbGUuaW52ZXJ0ID0gdCA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZXRjaGluZykgdCA9IHN0cmV0Y2hpbmcuaW52ZXJ0KHQpXG4gICAgICAgICAgICByZXR1cm4gZG9tYWluWzBdICsgdCAqIGRvbWFpblNpemVcbiAgICAgICAgfVxuICAgICAgICAvL2Rpc2NyZXRlIGNvbG9yczogcmV0dXJuIHRoZSBicmVha3NcbiAgICAgICAgaWYgKG9wdHMuY29sb3JzICYmIG5iQ2xhc3MpIHtcbiAgICAgICAgICAgIHNjYWxlLmJyZWFrcyA9IFtdXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5iQ2xhc3M7IGkrKylcbiAgICAgICAgICAgICAgICBzY2FsZS5icmVha3MucHVzaChzY2FsZS5pbnZlcnQoaSAvIG5iQ2xhc3MpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbn1cblxuXG5cblxuXG4vKipcbiAqIEdlbmVyaWMgZnVuY3Rpb24gZm9yIGNvbG9yIHZpZXcgc2NhbGUgLSBxdWFudGlsZVxuICogXG4gKiBAcGFyYW0ge3sgdmFsdWVGdW5jdGlvbjpmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbCk6bnVtYmVyLCBjbGFzc051bWJlcj86bnVtYmVyLCBjb2xvcnM/OkFycmF5LjxzdHJpbmc+LCBjb2xvclNjYWxlPzpmdW5jdGlvbihudW1iZXIpOnN0cmluZyB9fSBvcHRzIFxuICogQHJldHVybnMge2Z1bmN0aW9uKEFycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD4pOkNvbG9yU2NhbGV9XG4gKi9cbmV4cG9ydCBjb25zdCB2aWV3U2NhbGVDb2xvclF1YW50aWxlID0gKG9wdHMpID0+IHtcbiAgICBjb25zdCB2YWx1ZUZ1bmN0aW9uID0gb3B0cy52YWx1ZUZ1bmN0aW9uXG4gICAgY29uc3QgY2xhc3NOdW1iZXIgPSBvcHRzLmNsYXNzTnVtYmVyIHx8IDEyXG5cbiAgICBsZXQgY29sb3JzID0gb3B0cy5jb2xvcnNcbiAgICBpZiAob3B0cy5jb2xvclNjYWxlKSBjb2xvcnMgPSBkaXNjcmV0ZUNvbG9ycyhvcHRzLmNvbG9yU2NhbGUsIGNsYXNzTnVtYmVyKVxuICAgIGNvbG9ycyA9IGNvbG9ycyB8fCBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjbGFzc051bWJlciB9LCAoXywgaSkgPT4gXCJyZ2IoXCIgKyBNYXRoLmZsb29yKDI1NSAqIGkgLyAoY2xhc3NOdW1iZXIgLSAxKSkgKyBcIiwxNTAsMTUwKVwiKVxuXG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZVF1YW50aWxlKCkucmFuZ2UoY29sb3JzKVxuICAgIHJldHVybiAoY2VsbHMpID0+IHtcbiAgICAgICAgc2NhbGUuZG9tYWluKGNlbGxzLm1hcCh2YWx1ZUZ1bmN0aW9uKSk7XG4gICAgICAgIHNjYWxlLmJyZWFrcyA9IHNjYWxlLnF1YW50aWxlcygpXG4gICAgICAgIHNjYWxlLmNvbG9ycyA9IGNvbG9yc1xuICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxufVxuXG5cblxuXG4vKipcbiAqIENvbWJpbmUgdmlldyBzY2FsZSBmdW5jdGlvbnNcbiAqIFxuICogQHBhcmFtIHsqfSBvYmogXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbmV4cG9ydCBjb25zdCB2aWV3U2NhbGVDb21iaW5hdGlvbiA9IChvYmopID0+IHtcbiAgICAvL29iajogcHJvcCBhbmQgYSBmdW5jdGlvbiB0byBjYWxsXG4gICAgcmV0dXJuIChjZWxscywgcmVzb2x1dGlvbiwgeikgPT4ge1xuICAgICAgICBjb25zdCBvdXQgPSB7fVxuICAgICAgICBmb3IgKGNvbnN0IHAgaW4gb2JqKSB7IG91dFtwXSA9IG9ialtwXShjZWxscywgcmVzb2x1dGlvbiwgeikgfVxuICAgICAgICByZXR1cm4gb3V0XG4gICAgfVxufVxuXG5cblxuXG5cblxuLyoqXG4gKiBSZXR1cm4gYSBjbGFzc2lmaWVyIGZ1bmN0aW9uIGZyb20gYnJlYWsgdmFsdWVzLlxuICogVGhlIGNsYXNzaWZpZXIgZnVuY3Rpb24gcmV0dXJucyB0aGUgY2xhc3MgaWQgKGZyb20gMCB0byBicmVha3MubGVuZ3RoKSBmcm9tIGEgdmFsdWUgdG8gY2xhc3NpZml5LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYnJlYWtzIHRoZSBicmVha3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzaWZpZXIoYnJlYWtzKSB7XG4gICAgY29uc3QgYmwgPSBicmVha3MubGVuZ3RoXG4gICAgY29uc3QgY2xhc3NpZmllciA9IHZhbHVlID0+IHtcbiAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgIHdoaWxlIChpIDwgYmwpIHtcbiAgICAgICAgICAgIGNvbnN0IGJyZWFrXyA9IGJyZWFrc1tpXVxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IGJyZWFrXykgcmV0dXJuIGlcbiAgICAgICAgICAgIGkrK1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpXG4gICAgfVxuICAgIGNsYXNzaWZpZXIuYnJlYWtzID0gYnJlYWtzXG4gICAgcmV0dXJuIGNsYXNzaWZpZXJcbn1cblxuXG5cbi8qKlxuICogUmV0dXJuIGEgY29sb3IgY2xhc3NpZmllciBmdW5jdGlvbiBmcm9tIGJyZWFrIHZhbHVlcy5cbiAqIFRoZSBjbGFzc2lmaWVyIGZ1bmN0aW9uIHJldHVybnMgdGhlIGNvbG9yIGZyb20gYSB2YWx1ZSB0byBjbGFzc2lmaXkuXG4gKiBUaGVyZSBzaG91bGQgYmUgb25lIGNvbG9yIG1vcmUgdGhhbiBicmVhayB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBicmVha3MgdGhlIGJyZWFrc1xuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIHRoZSBjb2xvcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yQ2xhc3NpZmllcihicmVha3MsIGNvbG9ycykge1xuICAgIGNvbnN0IGNsYXNzaWZpZXJfID0gY2xhc3NpZmllcihicmVha3MpXG4gICAgY29uc3QgY29sb3JDbGFzc2lmaWVyID0gdmFsdWUgPT4gY29sb3JzW2NsYXNzaWZpZXJfKHZhbHVlKV1cbiAgICBjb2xvckNsYXNzaWZpZXIuYnJlYWtzID0gYnJlYWtzXG4gICAgY29sb3JDbGFzc2lmaWVyLmNvbG9ycyA9IGNvbG9yc1xuICAgIHJldHVybiBjb2xvckNsYXNzaWZpZXJcbn1cblxuLyoqXG4gKiBNYWtlIGFycmF5IG9mIGNvbG9ycyBmcm9tIGEgY29sb3JTY2FsZS5cbiAqIEl0IGlzIGEga2luZCBvZiBzYW1wbGluZywgb3IgdW4taW50ZXJwb2xhdGlvblxuICogXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6c3RyaW5nfSBjb2xvclNjYWxlIFxuICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzY3JldGVDb2xvcnMoY29sb3JTY2FsZSwgbmIpIHtcbiAgICBpZiAobmIgPT0gMSkgcmV0dXJuIFtjb2xvclNjYWxlKDAuNSldXG4gICAgY29uc3Qgb3V0ID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspXG4gICAgICAgIG91dC5wdXNoKGNvbG9yU2NhbGUoaSAvIChuYiAtIDEpKSlcbiAgICByZXR1cm4gb3V0XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cblxuLy9UT0RPIGludmVydCBmb3IgY2lyY3VsYXJcbi8vVE9ETyB1c2UgTWF0aC5zcXJ0XG4vL1RPRE8gdmFsaWRhdGVcblxuXG4vKipcbiAqIFNvbWUgZnVuY3Rpb24gWzAsMV0tPlswLDFdIHRvIHN0cmV0Y2ggcmFuZ2Ugb2YgdmFsdWVzLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXVyb3N0YXQvZ3JpZHZpei9ibG9iL21hc3Rlci9kb2NzL3JlZmVyZW5jZS5tZCNzdHJldGNoaW5nXG4gKiBAc2VlIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AamdhZmZ1cmkvc3RyZXRjaGluZ1xuICovXG5cbi8vaWRlbnRpdHkgZnVuY3Rpb25cbmNvbnN0IGlkZW50aXR5ID0gdCA9PiB0XG5pZGVudGl0eS5pbnZlcnQgPSBpZGVudGl0eVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJhc2UgXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBleHBvbmVudGlhbFNjYWxlID0gKGJhc2UgPSAzKSA9PiB7XG4gICAgaWYgKGJhc2UgPT0gMCkgcmV0dXJuIGlkZW50aXR5XG4gICAgY29uc3QgYSA9IChNYXRoLmV4cChiYXNlKSAtIDEpXG4gICAgY29uc3QgZiA9IHQgPT4gKE1hdGguZXhwKHQgKiBiYXNlKSAtIDEpIC8gYVxuICAgIGYuaW52ZXJ0ID0gdCA9PiBNYXRoLmxvZyhhICogdCArIDEpIC8gYmFzZVxuICAgIHJldHVybiBmXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJhc2UgXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBsb2dhcml0aG1pY1NjYWxlID0gKGJhc2UgPSAzKSA9PiB7XG4gICAgaWYgKGJhc2UgPT0gMCkgcmV0dXJuIGlkZW50aXR5XG4gICAgY29uc3QgYSA9IE1hdGguZXhwKGJhc2UpLCBiID0gMSAtIGFcbiAgICBjb25zdCBmID0gdCA9PiAxIC0gTWF0aC5sb2coYSArIHQgKiBiKSAvIGJhc2VcbiAgICBmLmludmVydCA9IHQgPT4gKE1hdGguZXhwKCgxIC0gdCkgKiBiYXNlKSAtIGEpIC8gYlxuICAgIHJldHVybiBmXG59XG5cblxuXG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnQgXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBwb3dlclNjYWxlID0gKGV4cG9uZW50ID0gMykgPT4ge1xuICAgIGlmIChleHBvbmVudCA9PSAxKSByZXR1cm4gaWRlbnRpdHlcbiAgICAvL1RPRE8gaWYgKGV4cG9uZW50ID09IDAuNSkgcmV0dXJuIE1hdGguc3FydFxuICAgIGNvbnN0IGYgPSB0ID0+IE1hdGgucG93KHQsIGV4cG9uZW50KVxuICAgIGNvbnN0IGEgPSAxIC8gZXhwb25lbnRcbiAgICBmLmludmVydCA9IHQgPT4gTWF0aC5wb3codCwgYSlcbiAgICByZXR1cm4gZlxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudCBcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihudW1iZXIpOm51bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHBvd2VySW52ZXJzZVNjYWxlID0gKGV4cG9uZW50ID0gMykgPT4ge1xuICAgIGlmIChleHBvbmVudCA9PSAxKSByZXR1cm4gaWRlbnRpdHlcbiAgICAvL1RPRE8gaWYgKGV4cG9uZW50ID09IDIpIHJldHVybiB0ID0+IDEgLSBNYXRoLnNxcnQoMSAtIHQpXG4gICAgY29uc3QgYSA9IDEgLyBleHBvbmVudFxuICAgIGNvbnN0IGYgPSB0ID0+IDEgLSBNYXRoLnBvdygxIC0gdCwgYSlcbiAgICBmLmludmVydCA9IHQgPT4gMSAtIE1hdGgucG93KDEgLSB0LCBleHBvbmVudClcbiAgICByZXR1cm4gZlxufVxuXG5cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaXJjdWxhcml0eSBcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihudW1iZXIpOm51bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNpcmN1bGFyU2NhbGUgPSAoY2lyY3VsYXJpdHkgPSAwLjgpID0+IHtcbiAgICBpZiAoY2lyY3VsYXJpdHkgPT0gMCkgcmV0dXJuIGlkZW50aXR5XG4gICAgaWYgKGNpcmN1bGFyaXR5ID09IDEpIHJldHVybiB0ID0+IE1hdGguc3FydCh0ICogKDIgLSB0KSlcbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYSA9IGNpcmN1bGFyaXR5IC8gKDEgLSBjaXJjdWxhcml0eSlcbiAgICAgICAgcmV0dXJuIHQgPT4gTWF0aC5zcXJ0KDEgLyAoYSAqIGEpICsgdCAqICgyIC8gYSArIDIgLSB0KSkgLSAxIC8gYVxuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gY2lyY3VsYXJpdHkgXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjaXJjdWxhckludmVyc2VTY2FsZSA9IChjaXJjdWxhcml0eSA9IDAuOCkgPT4ge1xuICAgIGlmIChjaXJjdWxhcml0eSA9PSAwKSByZXR1cm4gaWRlbnRpdHlcbiAgICBjb25zdCBmID0gY2lyY3VsYXJTY2FsZShjaXJjdWxhcml0eSlcbiAgICByZXR1cm4gdCA9PiAxIC0gZigxIC0gdClcbn1cblxuXG5cblxuXG4vL3Rlc3Rcbi8qXG5jb25zdCB0ZXN0ID0gKGYsIGZ1biwgYSwgZXJyID0gMWUtMTIpID0+IHtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8PSAxOyB0ICs9IDEgLyA1MCkge1xuICAgICAgICBjb25zdCBlciA9IHQgLSBmLmludmVydChmKHQpKVxuICAgICAgICBpZiAoTWF0aC5hYnMoZXIpIDwgZXJyKSBjb250aW51ZVxuICAgICAgICBjb25zb2xlLmxvZyhmdW4sIGEsIGVyKVxuICAgIH1cbn1cblxuZm9yIChsZXQgZnVuIG9mIFtwb3dlclNjYWxlLCBwb3dlckludmVyc2VTY2FsZV0pXG4gICAgZm9yIChsZXQgZXhwID0gLTMwOyBleHAgPD0gNTA7IGV4cCArPSAxKSB7XG4gICAgICAgIGlmIChleHAgPT0gMCkgY29udGludWVcbiAgICAgICAgY29uc3QgZiA9IGZ1bihleHApXG4gICAgICAgIHRlc3QoZiwgZnVuLCBleHApXG4gICAgfVxuXG5cbmZvciAobGV0IGZ1biBvZiBbZXhwb25lbnRpYWxTY2FsZSwgbG9nYXJpdGhtaWNTY2FsZV0pXG4gICAgZm9yIChsZXQgYmFzZSA9IC0yMDsgYmFzZSA8PSAyMDsgYmFzZSArPSAxKSB7XG4gICAgICAgIC8vaWYgKGV4cCA9PSAwKSBjb250aW51ZVxuICAgICAgICBjb25zdCBmID0gZnVuKGJhc2UpXG4gICAgICAgIHRlc3QoZiwgZnVuLCBiYXNlLCAxZS0xMClcbiAgICB9XG4qLyIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgaW50ZXJwb2xhdGVMYWIgfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIlxuXG5cblxuZXhwb3J0IGNvbnN0IHRyaXZhcmlhdGVDbGFzc2lmaWVyID0gKHByb3BlcnRpZXMsIHRvdGFsRnVuY3Rpb24sIG9wdHMgPSB7fSkgPT4ge1xuXG4gICAgLy90aGUgdGhyZWUgcHJvcGVydGllc1xuICAgIGNvbnN0IHAwID0gcHJvcGVydGllc1swXSwgcDEgPSBwcm9wZXJ0aWVzWzFdLCBwMiA9IHByb3BlcnRpZXNbMl1cblxuICAgIC8vdGhlIGNsYXNzaWZpZXIgY2VudGVyIHBvaW50LiBzdW0gbXVzdCBiZSBlcXVhbCB0byAxXG4gICAgY29uc3QgW2MwLCBjMSwgYzJdID0gb3B0cy5jZW50ZXIgfHwgWzEgLyAzLCAxIC8gMywgMSAvIDNdXG5cbiAgICAvL3BhcmFtZXRlciB0byBkZWNpZGUgd2V0aGVyIHRvIHVzZSBtaXhlZCBjbGFzc2VzIG0wLCBtMSwgbTIuXG4gICAgY29uc3Qgd2l0aE1peGVkQ2xhc3NlcyA9IG9wdHMud2l0aE1peGVkQ2xhc3NlcyAhPSB1bmRlZmluZWQgPyBvcHRzLndpdGhNaXhlZENsYXNzZXMgOiB0cnVlXG5cbiAgICAvL3BhcmFtZXJ0ZXIgZGVjaWRlIHdldGhlciB0byB1c2UgYSBjZW50cmFsIGNsYXNzLCBhbmQgdGhlIHNpemUgb2YgdGhpcyBjZW50cmFsIGNsYXNzLlxuICAgIC8vc2V0IHRvIDAgb3IgdW5kZWZpbmVkIGZvciBub3Qgc2hvd2luZyBhbnkgY2VudHJhbCBjbGFzcy4gU2V0IHRvIDEgZm9yIGEgY2VudHJhbCBjbGFzcyB0aGF0IGNvbnRhaW5zIHRoZSBtaXggY2xhc3Nlc1xuICAgIGNvbnN0IGNjID0gb3B0cy5jZW50ZXJDb2VmZmljaWVudCA/IDEgLSBvcHRzLmNlbnRlckNvZWZmaWNpZW50IDogdW5kZWZpbmVkXG5cbiAgICAvL3RoZSBvdXRwdXQgY2xhc3NpZmllciBtZXRob2RcbiAgICBjb25zdCBmdW4gPSBjID0+IHtcbiAgICAgICAgLy9nZXQgdG90YWxcbiAgICAgICAgY29uc3QgdG90ID0gdG90YWxGdW5jdGlvbihjKVxuICAgICAgICBpZiAoIXRvdCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAvL2NvbXB1dGUgc2hhcmVzXG4gICAgICAgIGNvbnN0IFtzMCwgczEsIHMyXSA9IFsrY1twMF0gLyB0b3QsICtjW3AxXSAvIHRvdCwgK2NbcDJdIC8gdG90XVxuXG4gICAgICAgIC8vY2xhc3MgMFxuICAgICAgICBpZiAoczAgPj0gYzAgJiYgczEgPD0gYzEgJiYgczIgPD0gYzIpIHtcbiAgICAgICAgICAgIC8vY2VudHJhbCBjbGFzcyBuZWFyIGNsYXNzIDBcbiAgICAgICAgICAgIGlmIChjYyAhPSB1bmRlZmluZWQgJiYgKHMyIC0gYzIpICogKGMxIC0gY2MgKiBjMSkgPj0gKHMxIC0gY2MgKiBjMSkgKiAoY2MgKiBjMiAtIGMyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjZW50ZXJcIlxuICAgICAgICAgICAgcmV0dXJuIFwiMFwiXG4gICAgICAgIH1cbiAgICAgICAgLy9jbGFzcyAxXG4gICAgICAgIGlmIChzMCA8PSBjMCAmJiBzMSA+PSBjMSAmJiBzMiA8PSBjMikge1xuICAgICAgICAgICAgLy9jZW50cmFsIGNsYXNzIG5lYXIgY2xhc3MgMVxuICAgICAgICAgICAgaWYgKGNjICE9IHVuZGVmaW5lZCAmJiAoczIgLSBjMikgKiAoYzAgLSBjYyAqIGMwKSA+PSAoczAgLSBjYyAqIGMwKSAqIChjYyAqIGMyIC0gYzIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImNlbnRlclwiXG4gICAgICAgICAgICByZXR1cm4gXCIxXCJcbiAgICAgICAgfVxuICAgICAgICAvL2NsYXNzIDJcbiAgICAgICAgaWYgKHMwIDw9IGMwICYmIHMxIDw9IGMxICYmIHMyID49IGMyKSB7XG4gICAgICAgICAgICAvL2NlbnRyYWwgY2xhc3MgbmVhciBjbGFzcyAyXG4gICAgICAgICAgICBpZiAoY2MgIT0gdW5kZWZpbmVkICYmIChzMSAtIGMxKSAqIChjMCAtIGNjICogYzApID49IChzMCAtIGNjICogYzApICogKGNjICogYzEgLSBjMSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY2VudGVyXCJcbiAgICAgICAgICAgIHJldHVybiBcIjJcIlxuICAgICAgICB9XG4gICAgICAgIC8vbWlkZGxlIGNsYXNzIDAgLSBpbnRlcnNlY3Rpb24gY2xhc3MgMSBhbmQgMlxuICAgICAgICBpZiAoczAgPD0gYzAgJiYgczEgPj0gYzEgJiYgczIgPj0gYzIpIHtcbiAgICAgICAgICAgIC8vY2VudHJhbCBjbGFzc1xuICAgICAgICAgICAgaWYgKGNjICE9IHVuZGVmaW5lZCAmJiBzMCA+IGNjICogYzApIHJldHVybiBcImNlbnRlclwiXG4gICAgICAgICAgICBpZiAod2l0aE1peGVkQ2xhc3NlcykgcmV0dXJuIFwibTBcIlxuICAgICAgICAgICAgcmV0dXJuIHMxID4gczIgPyBcIjFcIiA6IFwiMlwiXG4gICAgICAgIH1cbiAgICAgICAgLy9taWRkbGUgY2xhc3MgMSAtIGludGVyc2VjdGlvbiBjbGFzcyAwIGFuZCAxXG4gICAgICAgIGlmIChzMCA+PSBjMCAmJiBzMSA8PSBjMSAmJiBzMiA+PSBjMikge1xuICAgICAgICAgICAgLy9jZW50cmFsIGNsYXNzXG4gICAgICAgICAgICBpZiAoY2MgIT0gdW5kZWZpbmVkICYmIHMxID4gY2MgKiBjMSkgcmV0dXJuIFwiY2VudGVyXCJcbiAgICAgICAgICAgIGlmICh3aXRoTWl4ZWRDbGFzc2VzKSByZXR1cm4gXCJtMVwiXG4gICAgICAgICAgICByZXR1cm4gczAgPiBzMiA/IFwiMFwiIDogXCIyXCJcbiAgICAgICAgfVxuICAgICAgICAvL21pZGRsZSBjbGFzcyAyIC0gaW50ZXJzZWN0aW9uIGNsYXNzIDAgYW5kIDFcbiAgICAgICAgaWYgKHMwID49IGMwICYmIHMxID49IGMxICYmIHMyIDw9IGMyKSB7XG4gICAgICAgICAgICAvL2NlbnRyYWwgY2xhc3NcbiAgICAgICAgICAgIGlmIChjYyAhPSB1bmRlZmluZWQgJiYgczIgPiBjYyAqIGMyKSByZXR1cm4gXCJjZW50ZXJcIlxuICAgICAgICAgICAgaWYgKHdpdGhNaXhlZENsYXNzZXMpIHJldHVybiBcIm0yXCJcbiAgICAgICAgICAgIHJldHVybiBzMSA+IHMwID8gXCIxXCIgOiBcIjBcIlxuICAgICAgICB9XG4gICAgICAgIC8vc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgcmV0dXJuIFwidW5rbm93blwiXG4gICAgfVxuXG4gICAgLy9hdHRhY2ggaW5mb3JtYXRpb24gdG8gb3V0cHV0IGZ1bmN0aW9uXG4gICAgZnVuLmNlbnRlciA9IFtjMCwgYzEsIGMyXVxuICAgIGZ1bi5jZW50ZXJDb2VmZmljaWVudCA9IG9wdHMuY2VudGVyQ29lZmZpY2llbnRcblxuICAgIHJldHVybiBmdW5cbn1cblxuXG5cbmV4cG9ydCBjb25zdCB0cml2YXJpYXRlQ29sb3JDbGFzc2lmaWVyID0gKHByb3BlcnRpZXMsIHRvdGFsRnVuY3Rpb24sIGNvbG9ycywgb3B0cyA9IHt9KSA9PiB7XG5cbiAgICAvL3RoZSB0aHJlZSBjb2xvcnNcbiAgICBjb25zdCBbY29sb3IwLCBjb2xvcjEsIGNvbG9yMl0gPSBjb2xvcnMgfHwgW1wicmVkXCIsIFwiZ3JlZW5cIiwgXCJibHVlXCJdXG5cbiAgICAvL3RoZSBjb2xvciBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uXG4gICAgY29uc3QgY29sb3JJbnRlcnBvbGF0aW9uID0gb3B0cy5jb2xvckludGVycG9sYXRpb24gfHwgaW50ZXJwb2xhdGVMYWJcblxuICAgIC8vcGFyYW1ldGVyIHRvIGRlY2lkZSB3ZXRoZXIgdG8gdXNlIG1peGVkIGNsYXNzZXMuXG4gICAgY29uc3Qgd2l0aE1peGVkQ2xhc3NlcyA9IG9wdHMud2l0aE1peGVkQ2xhc3NlcyAhPSB1bmRlZmluZWQgPyBvcHRzLndpdGhNaXhlZENsYXNzZXMgOiB0cnVlXG4gICAgLy9odHRwczovL2QzanMub3JnL2QzLWludGVycG9sYXRlL2NvbG9yXG4gICAgY29uc3QgbWl4Q29sb3JGdW5jdGlvbiA9IChjb2xvcjEsIGNvbG9yMikgPT4gY29sb3JJbnRlcnBvbGF0aW9uKGNvbG9yMSwgY29sb3IyKSgwLjUpXG4gICAgLy90aGUgY29sb3JzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1peGVkIGNsYXNzZXNcbiAgICBjb25zdCBbbWl4Q29sb3IwLCBtaXhDb2xvcjEsIG1peENvbG9yMl0gPSBvcHRzLm1peGVkQ29sb3JzIHx8IHdpdGhNaXhlZENsYXNzZXMgPyBbbWl4Q29sb3JGdW5jdGlvbihjb2xvcjEsIGNvbG9yMiksIG1peENvbG9yRnVuY3Rpb24oY29sb3IwLCBjb2xvcjIpLCBtaXhDb2xvckZ1bmN0aW9uKGNvbG9yMCwgY29sb3IxKV0gOiBbXVxuXG4gICAgLy90aGUgY2VudHJhbCBjb2xvciwgdXNlZCBmb3IgdGhlIGNlbnRyYWwgY2xhc3MsIGlmIGFueS4gVGhlIGNlbnRyYWwgY2xhc3MgaXMgdGhlIGNsYXNzIG9mIHJlbGF0aXZlbHkgYmFsYW5jZWQgdmFsdWVzLCBhcm91bmQgdGhlIGNlbnRlciBwb2ludFxuICAgIGNvbnN0IGNlbnRlckNvbG9yID0gb3B0cy5jZW50ZXJDb2xvciB8fCBjb2xvckludGVycG9sYXRpb24obWl4Q29sb3JGdW5jdGlvbihjb2xvcjAsIGNvbG9yMSksIGNvbG9yMikoMC4zMzMpXG5cbiAgICAvL21ha2UgY2xhc3NpZmllclxuICAgIGNvbnN0IGNsYXNzaWZpZXIgPSB0cml2YXJpYXRlQ2xhc3NpZmllcihwcm9wZXJ0aWVzLCB0b3RhbEZ1bmN0aW9uLCBvcHRzKVxuXG4gICAgLy90aGUgb3V0cHV0IGNvbG9yIGNsYXNzaWZpZXIgbWV0aG9kXG4gICAgY29uc3QgZnVuID0gYyA9PiB7XG4gICAgICAgIGNvbnN0IGNsYSA9IGNsYXNzaWZpZXIoYylcbiAgICAgICAgaWYgKGNsYSA9PSBcIjBcIikgcmV0dXJuIGNvbG9yMFxuICAgICAgICBpZiAoY2xhID09IFwiMVwiKSByZXR1cm4gY29sb3IxXG4gICAgICAgIGlmIChjbGEgPT0gXCIyXCIpIHJldHVybiBjb2xvcjJcbiAgICAgICAgaWYgKGNsYSA9PSBcIm0wXCIpIHJldHVybiBtaXhDb2xvcjBcbiAgICAgICAgaWYgKGNsYSA9PSBcIm0xXCIpIHJldHVybiBtaXhDb2xvcjFcbiAgICAgICAgaWYgKGNsYSA9PSBcIm0yXCIpIHJldHVybiBtaXhDb2xvcjJcbiAgICAgICAgaWYgKGNsYSA9PSBcImNlbnRlclwiKSByZXR1cm4gY2VudGVyQ29sb3JcbiAgICAgICAgcmV0dXJuIG9wdHMuZGVmYXVsdENvbG9yIHx8IFwiYmxhY2tcIlxuICAgIH1cbiAgICBmdW4uY2VudGVyID0gY2xhc3NpZmllci5jZW50ZXJcbiAgICBmdW4uY2VudGVyQ29lZmZpY2llbnQgPSBvcHRzLmNlbnRlckNvZWZmaWNpZW50XG4gICAgZnVuLmNvbG9ycyA9IFtjb2xvcjAsIGNvbG9yMSwgY29sb3IyXVxuICAgIGZ1bi5taXhDb2xvcnMgPSBbbWl4Q29sb3IwLCBtaXhDb2xvcjEsIG1peENvbG9yMl1cbiAgICBmdW4uY2VudGVyQ29sb3IgPSBjZW50ZXJDb2xvclxuXG4gICAgcmV0dXJuIGZ1blxufVxuXG5cblxuXG5cblxuLypcbmNvbnN0IG9yZGVyZWRJbmRleGVzRGVjID0gYXJyID0+IFsuLi5hcnIua2V5cygpXS5zb3J0KChhLCBiKSA9PiBhcnJbYl0gLSBhcnJbYV0pO1xuY29uc3Qgb3JkZXJlZEluZGV4ZXNJbmMgPSBhcnIgPT4gWy4uLmFyci5rZXlzKCldLnNvcnQoKGEsIGIpID0+IGFyclthXSAtIGFycltiXSk7XG5cbmV4cG9ydCBjb25zdCB0cml2YXJpYXRlQ2xhc3NpZmllciA9IChwcm9wZXJ0aWVzLCB0b3RhbEZ1bmN0aW9uLCBvcHRzID0ge30pID0+IHtcbiAgICBjb25zdCBsb3dUaHJlc2hvbGQgPSBvcHRzLmxvd1RocmVzaG9sZCB8fCBbMSAvIDMsIDEgLyAzLCAxIC8gM11cbiAgICBjb25zdCBoaWdoVGhyZXNob2xkID0gb3B0cy5oaWdoVGhyZXNob2xkIHx8IFsyIC8gMywgMiAvIDMsIDIgLyAzXVxuICAgIGNvbnN0IGNvbG9ycyA9IG9wdHMuY29sb3JzIHx8IFtcInJlZFwiLCBcImdyZWVuXCIsIFwiYmx1ZVwiXVxuICAgIGNvbnN0IGNvbG9ySW50ZXJwb2xhdGlvbiA9IG9wdHMuY29sb3JJbnRlcnBvbGF0aW9uIHx8IGludGVycG9sYXRlTGFiXG5cbiAgICAvL2h0dHBzOi8vZDNqcy5vcmcvZDMtaW50ZXJwb2xhdGUvY29sb3JcbiAgICBjb25zdCBtaWRkbGVDb2xvckZ1bmN0aW9uID0gKGNvbG9yMSwgY29sb3IyKSA9PiBjb2xvckludGVycG9sYXRpb24oY29sb3IxLCBjb2xvcjIpKDAuNSlcbiAgICBjb25zdCBtaWRkbGVDb2xvcnMgPSBvcHRzLm1pZGRsZUNvbG9ycyB8fCBbbWlkZGxlQ29sb3JGdW5jdGlvbihjb2xvcnNbMV0sIGNvbG9yc1syXSksIG1pZGRsZUNvbG9yRnVuY3Rpb24oY29sb3JzWzBdLCBjb2xvcnNbMl0pLCBtaWRkbGVDb2xvckZ1bmN0aW9uKGNvbG9yc1swXSwgY29sb3JzWzFdKV1cbiAgICBjb25zdCBjZW50ZXJDb2xvciA9IG9wdHMuY2VudGVyQ29sb3IgfHwgY29sb3JJbnRlcnBvbGF0aW9uKG1pZGRsZUNvbG9yc1syXSwgY29sb3JzWzJdKSgwLjMzMylcblxuICAgIGNvbnN0IGhpZ2hfID0gb3JkZXJlZEluZGV4ZXNEZWMoaGlnaFRocmVzaG9sZClcbiAgICBjb25zdCBsb3dfID0gb3JkZXJlZEluZGV4ZXNJbmMobG93VGhyZXNob2xkKVxuXG4gICAgY29uc3QgcDAgPSBwcm9wZXJ0aWVzWzBdLCBwMSA9IHByb3BlcnRpZXNbMV0sIHAyID0gcHJvcGVydGllc1syXVxuICAgIGNvbnN0IGZ1biA9IGMgPT4ge1xuICAgICAgICAvL2dldCB0b3RhbFxuICAgICAgICBjb25zdCB0b3QgPSB0b3RhbEZ1bmN0aW9uKGMpXG4gICAgICAgIGlmICghdG90KSByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIC8vY29tcHV0ZSBzaGFyZXNcbiAgICAgICAgY29uc3Qgc2hhcmVzID0gWytjW3AwXSAvIHRvdCwgK2NbcDFdIC8gdG90LCArY1twMl0gLyB0b3RdXG4gICAgICAgIC8vcmV0dXJuIGNvbG9yc1xuICAgICAgICAvL3N0YXJ0IGZpcnN0IHdpdGggdGhlIGV4dHJlbWUgaGlnaCAodHJpYW5nbGVzKTogZnJvbSB0aGUgbGFyZ2VyIHZhbHVlIChzbWFsbCB0cmlhbmdsZSkgdG8gdGhlIGxvd2VyIHZhbHVlIChsYXJnZSB0cmlhbmdsZSlcbiAgICAgICAgZm9yIChsZXQgaSBvZiBoaWdoXykgaWYgKHNoYXJlc1tpXSA+IGhpZ2hUaHJlc2hvbGRbaV0pIHJldHVybiBjb2xvcnNbaV1cbiAgICAgICAgLy90aGVuIGRyYXcgdGhlIGV4dHJlbWUgbG93ICh0cmFwZXppdW1zKTogZnJvbSB0aGUgbG93ZXIgdmFsdWUgKHNtYWxsIHRyYXBleml1bXMpIHRvIHRoZSBsYXJnZXIgdmFsdWVzIChsYXJnZSB0cmFwZXppdW0pXG4gICAgICAgIGZvciAobGV0IGkgb2YgbG93XykgaWYgKHNoYXJlc1tpXSA8IGxvd1RocmVzaG9sZFtpXSkgcmV0dXJuIG1pZGRsZUNvbG9yc1tpXVxuICAgICAgICAvL2Vsc2UgY2VudHJhbCBjb2xvclxuICAgICAgICByZXR1cm4gY2VudGVyQ29sb3JcbiAgICB9XG4gICAgZnVuLmxvd1RocmVzaG9sZCA9IGxvd1RocmVzaG9sZFxuICAgIGZ1bi5oaWdoVGhyZXNob2xkID0gaGlnaFRocmVzaG9sZFxuICAgIGZ1bi5jb2xvcnMgPSBjb2xvcnNcbiAgICBmdW4ubWlkZGxlQ29sb3JzID0gbWlkZGxlQ29sb3JzXG4gICAgZnVuLmNlbnRlckNvbG9yID0gY2VudGVyQ29sb3JcbiAgICBmdW4ubG93SW5kZXggPSBsb3dfXG4gICAgZnVuLmhpZ2hJbmRleCA9IGhpZ2hfXG4gICAgcmV0dXJuIGZ1blxufVxuKi9cblxuLypcbmV4cG9ydCBjb25zdCB0cml2YXJpYXRlQ2xhc3NpZmllcjMgPSAocHJvcGVydGllcywgdG90YWxGdW5jdGlvbiwgb3B0cyA9IHt9KSA9PiB7XG4gICAgY29uc3QgW2EwMSwgYTEyLCBhMjBdID0gb3B0cy50aHJlc2hvbGRzIHx8IFsxLzMsIDEvMywgMS8zXVxuICAgIGNvbnN0IFtjMCwgYzEsIGMyXSA9IG9wdHMuY29sb3JzIHx8IFtcInJlZFwiLCBcImdyZWVuXCIsIFwiYmx1ZVwiXVxuICAgIGNvbnN0IGNlbnRlckNvbG9yID0gb3B0cy5jZW50ZXJDb2xvciB8fCBcImdyYXlcIlxuXG4gICAgY29uc3QgZmZmID0gYSA9PiBhID09IDEgPyBJbmZpbml0eSA6IGEgLyAoMSAtIGEpXG4gICAgY29uc3QgYzAxID0gZmZmKGEwMSksIGMxMiA9IGZmZihhMTIpLCBjMjAgPSBmZmYoYTIwKVxuXG4gICAgY29uc3QgcDAgPSBwcm9wZXJ0aWVzWzBdLCBwMSA9IHByb3BlcnRpZXNbMV0sIHAyID0gcHJvcGVydGllc1syXVxuICAgIGNvbnN0IGZ1biA9IGMgPT4ge1xuICAgICAgICAvL2dldCB0b3RhbFxuICAgICAgICBjb25zdCB0b3QgPSB0b3RhbEZ1bmN0aW9uKGMpXG4gICAgICAgIGlmICghdG90KSByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIC8vY29tcHV0ZSBzaGFyZXNcbiAgICAgICAgY29uc3QgW3MwLCBzMSwgczJdID0gWytjW3AwXSAvIHRvdCwgK2NbcDFdIC8gdG90LCArY1twMl0gLyB0b3RdXG4gICAgICAgIC8vcmV0dXJuIGNvbG9yc1xuICAgICAgICBpZiAoczAgKiBjMDEgPiBzMSAmJiBzMCA+IHMyICogYzIwKSByZXR1cm4gYzBcbiAgICAgICAgZWxzZSBpZiAoczEgPiBzMCAqIGMwMSAmJiBzMSAqIGMxMiA+IHMyKSByZXR1cm4gYzFcbiAgICAgICAgZWxzZSBpZiAoczIgKiBjMjAgPiBzMCAmJiBzMiA+IHMxICogYzEyKSByZXR1cm4gYzJcbiAgICAgICAgZWxzZSByZXR1cm4gY2VudGVyQ29sb3JcbiAgICB9XG4gICAgZnVuLmNvbG9ycyA9IFtjMCwgYzEsIGMyXVxuICAgIGZ1bi5jZW50ZXJDb2xvciA9IGNlbnRlckNvbG9yXG4gICAgcmV0dXJuIGZ1blxufVxuKi9cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBHZXQgdGhlIGNsYXNzIGlkIGZyb20gYSB2YWx1ZSBhbmQgY2xhc3MgYnJlYWsgdmFsdWVzXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHYgdGhlIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBicmVha3MgdGhlIGJyZWFrc1xuICogQHJldHVybnMgVGhlIGNsYXNzIGlkLCBmcm9tIDAgdG8gYnJlYWtzLmxlbmd0aFxuICogQGRlcHJlY2F0ZWQgdXNlIGdldENsYXNzaWZpZXIgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3ModiwgYnJlYWtzKSB7XG4gICAgaWYgKCFicmVha3MpIHJldHVyblxuICAgIGlmIChicmVha3MubGVuZ3RoID09IDApIHJldHVybiAwXG4gICAgaWYgKHYgPD0gYnJlYWtzWzBdKSByZXR1cm4gMFxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYnJlYWtzLmxlbmd0aDsgaSsrKSBpZiAoYnJlYWtzW2kgLSAxXSA8IHYgJiYgdiA8PSBicmVha3NbaV0pIHJldHVybiBpXG4gICAgcmV0dXJuIGJyZWFrcy5sZW5ndGhcbn1cblxuXG5cbi8vdGFrZSAnbmljZScgdmFsdWUgKHBvd2VyIG9mIHRlbiwgb3IgbXVsdGlwbGUpXG5leHBvcnQgZnVuY3Rpb24gbmljZSh2LCBtdWx0aXBsZXMgPSBbOCwgNiwgNSwgNCwgMi41LCAyXSkge1xuICAgIC8vY29tcHV0ZSBiaWdnZXIgcG93ZXIgb2YgdGVuIGJlbG93XG4gICAgY29uc3Qgdl8gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZzEwKHYpKSlcbiAgICBmb3IgKGxldCBtdWx0aXBsZSBvZiBtdWx0aXBsZXMpXG4gICAgICAgIGlmICh2XyAqIG11bHRpcGxlIDw9IHYpIHJldHVybiB2XyAqIG11bHRpcGxlXG4gICAgcmV0dXJuIHZfXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRJbWFnZShzcmMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHsgcmVzb2x2ZShpbWcpOyB9O1xuICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmVqZWN0KG5ldyBFcnJvcignRXJyb3IgbG9hZGluZyBpbWFnZScpKTsgfTtcbiAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICB9KTtcbn1cblxuXG5cbi8qXG5leHBvcnQgbGV0IG1vbml0b3IgPSBmYWxzZVxuXG5sZXQgcHJldmlvdXNEYXRlXG5leHBvcnQgZnVuY3Rpb24gbW9uaXRvckR1cmF0aW9uKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBub3dEYXRlID0gRGF0ZS5ub3coKVxuXG4gICAgLy9maXJzdCBjYWxsXG4gICAgaWYgKCFwcmV2aW91c0RhdGUpIHtcbiAgICAgICAgcHJldmlvdXNEYXRlID0gbm93RGF0ZVxuICAgICAgICBjb25zb2xlLmxvZyhwcmV2aW91c0RhdGUsIG1lc3NhZ2UpXG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGQgPSBub3dEYXRlIC0gcHJldmlvdXNEYXRlXG4gICAgcHJldmlvdXNEYXRlID0gbm93RGF0ZVxuICAgIGNvbnNvbGUubG9nKGQsIG1lc3NhZ2UpXG59XG4qL1xuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aFxuICogQHBhcmFtIHtzdHJpbmd9IGhlaWdodFxuICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAqIEByZXR1cm5zIHt7Y2FudmFzOkhUTUxDYW52YXNFbGVtZW50LCBnbDpXZWJHTFJlbmRlcmluZ0NvbnRleHR9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVdlYkdMQ2FudmFzKHdpZHRoLCBoZWlnaHQsIG9wdHM9e30pIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpXG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KVxuICAgIC8qKiBAdHlwZSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSAqL1xuICAgIGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgb3B0cylcbiAgICBpZiAoIWdsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0wuIFlvdXIgYnJvd3NlciBvciBtYWNoaW5lIG1heSBub3Qgc3VwcG9ydCBpdC4nKVxuICAgIH1cbiAgICByZXR1cm4geyBjYW52YXM6IGNhbnZhcywgZ2w6IGdsIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgc2hhZGVyIHByb2dyYW0sIHNvIFdlYkdMIGtub3dzIGhvdyB0byBkcmF3IG91ciBkYXRhXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXG4gKiBAcGFyYW0gIHsuLi5XZWJHTFNoYWRlcn0gc2hhZGVyc1xuICogQHJldHVybnMge1dlYkdMUHJvZ3JhbX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRTaGFkZXJQcm9ncmFtKGdsLCAuLi5zaGFkZXJzKSB7XG4gICAgLyoqIEB0eXBlIHtXZWJHTFByb2dyYW18bnVsbH0gKi9cbiAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpXG4gICAgaWYgKHByb2dyYW0gPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHdlYkdMIHByb2dyYW0nKVxuICAgIGZvciAoY29uc3Qgc2hhZGVyIG9mIHNoYWRlcnMpIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBzaGFkZXIpXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSlcbiAgICBpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHJldHVybiBwcm9ncmFtXG4gICAgdGhyb3cgbmV3IEVycm9yKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pIHx8ICdDYW5ub3QgY3JlYXRlIHdlYkdMIHByb2dyYW0gKDIpJylcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2hhZGVyIG9mIHRoZSBnaXZlbiB0eXBlLCB1cGxvYWRzIHRoZSBzb3VyY2UgYW5kIGNvbXBpbGVzIGl0LlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqIEBwYXJhbSAgey4uLnN0cmluZ30gc291cmNlc1xuICogQHJldHVybnMge1dlYkdMU2hhZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2hhZGVyKGdsLCB0eXBlLCAuLi5zb3VyY2VzKSB7XG4gICAgLyoqIEB0eXBlIHtXZWJHTFNoYWRlcnxudWxsfSAqL1xuICAgIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKVxuICAgIGlmIChzaGFkZXIgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHdlYkdMIHNoYWRlcicpXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlcy5qb2luKCdcXG4nKSlcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcilcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSByZXR1cm4gc2hhZGVyXG4gICAgdGhyb3cgbmV3IEVycm9yKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSB8fCAnQ2Fubm90IGNyZWF0ZSB3ZWJHTCBzaGFkZXIgKDIpJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB3ZWJHTCBpcyBzdXBwb3J0ZWRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrV2ViR0xTdXBwb3J0KCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgIHJldHVybiAhISghIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQgJiZcbiAgICAgICAgICAgIChjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJykpKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBpc0xpc3RMaWtlLCBpc01hcExpa2UgfSBmcm9tICcuL3NjaGVtYS5qcydcblxuLyoqXG4gKiBEcmVtZWwtYXNzZW1ibHkgb2YgYXJyYXlzIG9mIHZhbHVlcyBpbnRvIGxpc3RzXG4gKlxuICogUmVjb25zdHJ1Y3RzIGEgY29tcGxleCBuZXN0ZWQgc3RydWN0dXJlIGZyb20gZmxhdCBhcnJheXMgb2YgZGVmaW5pdGlvbiBhbmQgcmVwZXRpdGlvbiBsZXZlbHMsXG4gKiBhY2NvcmRpbmcgdG8gRHJlbWVsIGVuY29kaW5nLlxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuZC50cycpLkRlY29kZWRBcnJheX0gRGVjb2RlZEFycmF5XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzLmQudHMnKS5GaWVsZFJlcGV0aXRpb25UeXBlfSBGaWVsZFJlcGV0aXRpb25UeXBlXG4gKiBAcGFyYW0ge251bWJlcltdIHwgdW5kZWZpbmVkfSBkZWZpbml0aW9uTGV2ZWxzXG4gKiBAcGFyYW0ge251bWJlcltdfSByZXBldGl0aW9uTGV2ZWxzXG4gKiBAcGFyYW0ge0RlY29kZWRBcnJheX0gdmFsdWVzXG4gKiBAcGFyYW0geyhGaWVsZFJlcGV0aXRpb25UeXBlIHwgdW5kZWZpbmVkKVtdfSByZXBldGl0aW9uUGF0aFxuICogQHBhcmFtIHtudW1iZXJ9IG1heERlZmluaXRpb25MZXZlbCBkZWZpbml0aW9uIGxldmVsIHRoYXQgY29ycmVzcG9uZHMgdG8gbm9uLW51bGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSZXBldGl0aW9uTGV2ZWwgcmVwZXRpdGlvbiBsZXZlbCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgbmV3IHJvd1xuICogQHJldHVybnMge0RlY29kZWRBcnJheX0gYXJyYXkgb2YgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlbWJsZUxpc3RzKFxuICBkZWZpbml0aW9uTGV2ZWxzLCByZXBldGl0aW9uTGV2ZWxzLCB2YWx1ZXMsIHJlcGV0aXRpb25QYXRoLCBtYXhEZWZpbml0aW9uTGV2ZWwsIG1heFJlcGV0aXRpb25MZXZlbFxuKSB7XG4gIGNvbnN0IG4gPSBkZWZpbml0aW9uTGV2ZWxzPy5sZW5ndGggfHwgcmVwZXRpdGlvbkxldmVscy5sZW5ndGhcbiAgbGV0IHZhbHVlSW5kZXggPSAwXG4gIC8qKiBAdHlwZSB7YW55W119ICovXG4gIGNvbnN0IG91dHB1dCA9IFtdXG5cbiAgLy8gVHJhY2sgc3RhdGUgb2YgbmVzdGVkIHN0cnVjdHVyZXNcbiAgY29uc3QgY29udGFpbmVyU3RhY2sgPSBbb3V0cHV0XVxuICBsZXQgY3VycmVudENvbnRhaW5lciA9IG91dHB1dFxuICBsZXQgY3VycmVudERlcHRoID0gMCAvLyBzY2hlbWEgZGVwdGhcbiAgbGV0IGN1cnJlbnREZWZMZXZlbCA9IDAgLy8gbGlzdCBkZXB0aFxuICBsZXQgY3VycmVudFJlcExldmVsID0gMFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYXNzZXJ0KGN1cnJlbnREZWZMZXZlbCA9PT0gY29udGFpbmVyU3RhY2subGVuZ3RoIC0gMSlcbiAgICBjb25zdCBkZWYgPSBkZWZpbml0aW9uTGV2ZWxzPy5sZW5ndGggPyBkZWZpbml0aW9uTGV2ZWxzW2ldIDogbWF4RGVmaW5pdGlvbkxldmVsXG4gICAgY29uc3QgcmVwID0gcmVwZXRpdGlvbkxldmVsc1tpXVxuXG4gICAgLy8gUG9wIHVwIHRvIHN0YXJ0IG9mIHJlcCBsZXZlbFxuICAgIHdoaWxlIChjdXJyZW50RGVwdGggJiYgKHJlcCA8IGN1cnJlbnRSZXBMZXZlbCB8fCByZXBldGl0aW9uUGF0aFtjdXJyZW50RGVwdGhdICE9PSAnUkVQRUFURUQnKSkge1xuICAgICAgaWYgKHJlcGV0aXRpb25QYXRoW2N1cnJlbnREZXB0aF0gIT09ICdSRVFVSVJFRCcpIHtcbiAgICAgICAgY29udGFpbmVyU3RhY2sucG9wKClcbiAgICAgICAgY3VycmVudERlZkxldmVsLS1cbiAgICAgIH1cbiAgICAgIGlmIChyZXBldGl0aW9uUGF0aFtjdXJyZW50RGVwdGhdID09PSAnUkVQRUFURUQnKSBjdXJyZW50UmVwTGV2ZWwtLVxuICAgICAgY3VycmVudERlcHRoLS1cbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB3b24ndCBiZSBlbXB0eVxuICAgIGN1cnJlbnRDb250YWluZXIgPSBjb250YWluZXJTdGFjay5hdCgtMSlcblxuICAgIC8vIEdvIGRlZXBlciB0byBlbmQgb2YgZGVmaW5pdGlvbiBsZXZlbFxuICAgIHdoaWxlIChcbiAgICAgIChjdXJyZW50RGVwdGggPCByZXBldGl0aW9uUGF0aC5sZW5ndGggLSAyIHx8IHJlcGV0aXRpb25QYXRoW2N1cnJlbnREZXB0aCArIDFdID09PSAnUkVQRUFURUQnKSAmJlxuICAgICAgKGN1cnJlbnREZWZMZXZlbCA8IGRlZiB8fCByZXBldGl0aW9uUGF0aFtjdXJyZW50RGVwdGggKyAxXSA9PT0gJ1JFUVVJUkVEJylcbiAgICApIHtcbiAgICAgIGN1cnJlbnREZXB0aCsrXG4gICAgICBpZiAocmVwZXRpdGlvblBhdGhbY3VycmVudERlcHRoXSAhPT0gJ1JFUVVJUkVEJykge1xuICAgICAgICAvKiogQHR5cGUge2FueVtdfSAqL1xuICAgICAgICBjb25zdCBuZXdMaXN0ID0gW11cbiAgICAgICAgY3VycmVudENvbnRhaW5lci5wdXNoKG5ld0xpc3QpXG4gICAgICAgIGN1cnJlbnRDb250YWluZXIgPSBuZXdMaXN0XG4gICAgICAgIGNvbnRhaW5lclN0YWNrLnB1c2gobmV3TGlzdClcbiAgICAgICAgY3VycmVudERlZkxldmVsKytcbiAgICAgIH1cbiAgICAgIGlmIChyZXBldGl0aW9uUGF0aFtjdXJyZW50RGVwdGhdID09PSAnUkVQRUFURUQnKSBjdXJyZW50UmVwTGV2ZWwrK1xuICAgIH1cblxuICAgIC8vIEFkZCB2YWx1ZSBvciBudWxsIGJhc2VkIG9uIGRlZmluaXRpb24gbGV2ZWxcbiAgICBpZiAoZGVmID09PSBtYXhEZWZpbml0aW9uTGV2ZWwpIHtcbiAgICAgIC8vIGFzc2VydChjdXJyZW50RGVwdGggPT09IG1heERlZmluaXRpb25MZXZlbCB8fCBjdXJyZW50RGVwdGggPT09IHJlcGV0aXRpb25QYXRoLmxlbmd0aCAtIDIpXG4gICAgICBjdXJyZW50Q29udGFpbmVyLnB1c2godmFsdWVzW3ZhbHVlSW5kZXgrK10pXG4gICAgfSBlbHNlIGlmIChjdXJyZW50RGVwdGggPT09IHJlcGV0aXRpb25QYXRoLmxlbmd0aCAtIDIpIHtcbiAgICAgIGN1cnJlbnRDb250YWluZXIucHVzaChudWxsKVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q29udGFpbmVyLnB1c2goW10pXG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGVkZ2UgY2FzZXMgZm9yIGVtcHR5IGlucHV0cyBvciBzaW5nbGUtbGV2ZWwgZGF0YVxuICBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCAmJiBtYXhSZXBldGl0aW9uTGV2ZWwgPT09IDApIHtcbiAgICAgIHJldHVybiB2YWx1ZXMgLy8gZmxhdCBsaXN0XG4gICAgfVxuICAgIC8vIHJldHVybiBtYXggZGVmaW5pdGlvbiBsZXZlbCBvZiBuZXN0ZWQgbGlzdHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heERlZmluaXRpb25MZXZlbDsgaSsrKSB7XG4gICAgICAvKiogQHR5cGUge2FueVtdfSAqL1xuICAgICAgY29uc3QgbmV3TGlzdCA9IFtdXG4gICAgICBjdXJyZW50Q29udGFpbmVyLnB1c2gobmV3TGlzdClcbiAgICAgIGN1cnJlbnRDb250YWluZXIgPSBuZXdMaXN0XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG4vKipcbiAqIEFzc2VtYmxlIGEgbmVzdGVkIHN0cnVjdHVyZSBmcm9tIHN1YmNvbHVtbiBkYXRhLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9wYXJxdWV0LWZvcm1hdC9ibG9iL2FwYWNoZS1wYXJxdWV0LWZvcm1hdC0yLjEwLjAvTG9naWNhbFR5cGVzLm1kI25lc3RlZC10eXBlc1xuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuZC50cycpLlNjaGVtYVRyZWV9IFNjaGVtYVRyZWVcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgYW55W10+fSBzdWJjb2x1bW5EYXRhXG4gKiBAcGFyYW0ge1NjaGVtYVRyZWV9IHNjaGVtYSB0b3AtbGV2ZWwgc2NoZW1hIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGhdIGRlcHRoIG9mIG5lc3RlZCBzdHJ1Y3R1cmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VtYmxlTmVzdGVkKHN1YmNvbHVtbkRhdGEsIHNjaGVtYSwgZGVwdGggPSAwKSB7XG4gIGNvbnN0IHBhdGggPSBzY2hlbWEucGF0aC5qb2luKCcuJylcbiAgY29uc3Qgb3B0aW9uYWwgPSBzY2hlbWEuZWxlbWVudC5yZXBldGl0aW9uX3R5cGUgPT09ICdPUFRJT05BTCdcbiAgY29uc3QgbmV4dERlcHRoID0gb3B0aW9uYWwgPyBkZXB0aCArIDEgOiBkZXB0aFxuXG4gIGlmIChpc0xpc3RMaWtlKHNjaGVtYSkpIHtcbiAgICBsZXQgc3VibGlzdCA9IHNjaGVtYS5jaGlsZHJlblswXVxuICAgIGxldCBzdWJEZXB0aCA9IG5leHREZXB0aFxuICAgIGlmIChzdWJsaXN0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgc3VibGlzdCA9IHN1Ymxpc3QuY2hpbGRyZW5bMF1cbiAgICAgIHN1YkRlcHRoKytcbiAgICB9XG4gICAgYXNzZW1ibGVOZXN0ZWQoc3ViY29sdW1uRGF0YSwgc3VibGlzdCwgc3ViRGVwdGgpXG5cbiAgICBjb25zdCBzdWJjb2x1bW4gPSBzdWJsaXN0LnBhdGguam9pbignLicpXG4gICAgY29uc3QgdmFsdWVzID0gc3ViY29sdW1uRGF0YS5nZXQoc3ViY29sdW1uKVxuICAgIGlmICghdmFsdWVzKSB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgbGlzdC1saWtlIGNvbHVtbiBtaXNzaW5nIHZhbHVlcycpXG4gICAgaWYgKG9wdGlvbmFsKSBmbGF0dGVuQXREZXB0aCh2YWx1ZXMsIGRlcHRoKVxuICAgIHN1YmNvbHVtbkRhdGEuc2V0KHBhdGgsIHZhbHVlcylcbiAgICBzdWJjb2x1bW5EYXRhLmRlbGV0ZShzdWJjb2x1bW4pXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoaXNNYXBMaWtlKHNjaGVtYSkpIHtcbiAgICBjb25zdCBtYXBOYW1lID0gc2NoZW1hLmNoaWxkcmVuWzBdLmVsZW1lbnQubmFtZVxuXG4gICAgLy8gQXNzZW1ibGUga2V5cyBhbmQgdmFsdWVzXG4gICAgYXNzZW1ibGVOZXN0ZWQoc3ViY29sdW1uRGF0YSwgc2NoZW1hLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLCBuZXh0RGVwdGggKyAxKVxuICAgIGFzc2VtYmxlTmVzdGVkKHN1YmNvbHVtbkRhdGEsIHNjaGVtYS5jaGlsZHJlblswXS5jaGlsZHJlblsxXSwgbmV4dERlcHRoICsgMSlcblxuICAgIGNvbnN0IGtleXMgPSBzdWJjb2x1bW5EYXRhLmdldChgJHtwYXRofS4ke21hcE5hbWV9LmtleWApXG4gICAgY29uc3QgdmFsdWVzID0gc3ViY29sdW1uRGF0YS5nZXQoYCR7cGF0aH0uJHttYXBOYW1lfS52YWx1ZWApXG5cbiAgICBpZiAoIWtleXMpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBtYXAtbGlrZSBjb2x1bW4gbWlzc2luZyBrZXlzJylcbiAgICBpZiAoIXZhbHVlcykgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IG1hcC1saWtlIGNvbHVtbiBtaXNzaW5nIHZhbHVlcycpXG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgbWFwLWxpa2UgY29sdW1uIGtleS92YWx1ZSBsZW5ndGggbWlzbWF0Y2gnKVxuICAgIH1cblxuICAgIGNvbnN0IG91dCA9IGFzc2VtYmxlTWFwcyhrZXlzLCB2YWx1ZXMsIG5leHREZXB0aClcbiAgICBpZiAob3B0aW9uYWwpIGZsYXR0ZW5BdERlcHRoKG91dCwgZGVwdGgpXG5cbiAgICBzdWJjb2x1bW5EYXRhLmRlbGV0ZShgJHtwYXRofS4ke21hcE5hbWV9LmtleWApXG4gICAgc3ViY29sdW1uRGF0YS5kZWxldGUoYCR7cGF0aH0uJHttYXBOYW1lfS52YWx1ZWApXG4gICAgc3ViY29sdW1uRGF0YS5zZXQocGF0aCwgb3V0KVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gU3RydWN0LWxpa2UgY29sdW1uXG4gIGlmIChzY2hlbWEuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgLy8gY29uc3RydWN0IGEgbWV0YSBzdHJ1Y3QgYW5kIHRoZW4gaW52ZXJ0XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqL1xuICAgIGNvbnN0IHN0cnVjdCA9IHt9XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBzY2hlbWEuY2hpbGRyZW4pIHtcbiAgICAgIGFzc2VtYmxlTmVzdGVkKHN1YmNvbHVtbkRhdGEsIGNoaWxkLCBuZXh0RGVwdGgpXG4gICAgICBjb25zdCBjaGlsZERhdGEgPSBzdWJjb2x1bW5EYXRhLmdldChjaGlsZC5wYXRoLmpvaW4oJy4nKSlcbiAgICAgIGlmICghY2hpbGREYXRhKSB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgc3RydWN0LWxpa2UgY29sdW1uIG1pc3NpbmcgY2hpbGQgZGF0YScpXG4gICAgICBzdHJ1Y3RbY2hpbGQuZWxlbWVudC5uYW1lXSA9IGNoaWxkRGF0YVxuICAgIH1cbiAgICAvLyByZW1vdmUgY2hpbGRyZW5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHNjaGVtYS5jaGlsZHJlbikge1xuICAgICAgc3ViY29sdW1uRGF0YS5kZWxldGUoY2hpbGQucGF0aC5qb2luKCcuJykpXG4gICAgfVxuICAgIC8vIGludmVydCBzdHJ1Y3QgYnkgZGVwdGhcbiAgICBjb25zdCBpbnZlcnREZXB0aCA9IHNjaGVtYS5lbGVtZW50LnJlcGV0aXRpb25fdHlwZSA9PT0gJ1JFUVVJUkVEJyA/IGRlcHRoIDogZGVwdGggKyAxXG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBpbnZlcnRTdHJ1Y3Qoc3RydWN0LCBpbnZlcnREZXB0aClcbiAgICBpZiAob3B0aW9uYWwpIGZsYXR0ZW5BdERlcHRoKGludmVydGVkLCBkZXB0aClcbiAgICBzdWJjb2x1bW5EYXRhLnNldChwYXRoLCBpbnZlcnRlZClcbiAgfVxuICAvLyBhc3NlcnQoc2NoZW1hLmVsZW1lbnQucmVwZXRpdGlvbl90eXBlICE9PSAnUkVQRUFURUQnKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55W119IGFyclxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5BdERlcHRoKGFyciwgZGVwdGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZGVwdGgpIHtcbiAgICAgIGZsYXR0ZW5BdERlcHRoKGFycltpXSwgZGVwdGggLSAxKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcnJbaV0gPSBhcnJbaV1bMF1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueVtdfSBrZXlzXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aFxuICogQHJldHVybnMge2FueVtdfVxuICovXG5mdW5jdGlvbiBhc3NlbWJsZU1hcHMoa2V5cywgdmFsdWVzLCBkZXB0aCkge1xuICBjb25zdCBvdXQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZGVwdGgpIHtcbiAgICAgIG91dC5wdXNoKGFzc2VtYmxlTWFwcyhrZXlzW2ldLCB2YWx1ZXNbaV0sIGRlcHRoIC0gMSkpIC8vIGdvIGRlZXBlclxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5c1tpXSkge1xuICAgICAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovXG4gICAgICAgIGNvbnN0IG9iaiA9IHt9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldW2pdXG4gICAgICAgICAgb2JqW2tleXNbaV1bal1dID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIG91dC5wdXNoKG9iailcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dC5wdXNoKHVuZGVmaW5lZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEludmVydCBhIHN0cnVjdC1saWtlIG9iamVjdCBieSBkZXB0aC5cbiAqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueVtdPn0gc3RydWN0XG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGhcbiAqIEByZXR1cm5zIHthbnlbXX1cbiAqL1xuZnVuY3Rpb24gaW52ZXJ0U3RydWN0KHN0cnVjdCwgZGVwdGgpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHN0cnVjdClcbiAgY29uc3QgbGVuZ3RoID0gc3RydWN0W2tleXNbMF1dPy5sZW5ndGhcbiAgY29uc3Qgb3V0ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgICBjb25zdCBvYmogPSB7fVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIG9ialtrZXldID0gc3RydWN0W2tleV1baV1cbiAgICB9XG4gICAgaWYgKGRlcHRoKSB7XG4gICAgICBvdXQucHVzaChpbnZlcnRTdHJ1Y3Qob2JqLCBkZXB0aCAtIDEpKSAvLyBkZWVwZXJcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0LnB1c2gob2JqKVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJpbXBvcnQgeyBhc3NlbWJsZUxpc3RzIH0gZnJvbSAnLi9hc3NlbWJsZS5qcydcbmltcG9ydCB7IGNvbnZlcnQsIGRlcmVmZXJlbmNlRGljdGlvbmFyeSB9IGZyb20gJy4vY29udmVydC5qcydcbmltcG9ydCB7IHJlYWREYXRhUGFnZSwgcmVhZERpY3Rpb25hcnlQYWdlIH0gZnJvbSAnLi9kYXRhcGFnZS5qcydcbmltcG9ydCB7IHJlYWREYXRhUGFnZVYyIH0gZnJvbSAnLi9kYXRhcGFnZVYyLmpzJ1xuaW1wb3J0IHsgcGFycXVldEhlYWRlciB9IGZyb20gJy4vaGVhZGVyLmpzJ1xuaW1wb3J0IHsgZ2V0TWF4RGVmaW5pdGlvbkxldmVsLCBnZXRNYXhSZXBldGl0aW9uTGV2ZWwgfSBmcm9tICcuL3NjaGVtYS5qcydcbmltcG9ydCB7IHNuYXBweVVuY29tcHJlc3MgfSBmcm9tICcuL3NuYXBweS5qcydcbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gJy4vdXRpbHMuanMnXG5cbi8qKlxuICogUGFyc2UgY29sdW1uIGRhdGEgZnJvbSBhIGJ1ZmZlci5cbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzLmpzJykuQ29sdW1uTWV0YURhdGF9IENvbHVtbk1ldGFEYXRhXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzLmpzJykuRGVjb2RlZEFycmF5fSBEZWNvZGVkQXJyYXlcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzLmpzJykuRGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy5qcycpLlJvd0dyb3VwfSByb3dHcm91cCByb3cgZ3JvdXAgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Q29sdW1uTWV0YURhdGF9IGNvbHVtbk1ldGFkYXRhIGNvbHVtbiBtZXRhZGF0YVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5TY2hlbWFUcmVlW119IHNjaGVtYVBhdGggc2NoZW1hIHBhdGggZm9yIHRoZSBjb2x1bW5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2h5cGFycXVldC5qcycpLlBhcnF1ZXRSZWFkT3B0aW9uc30gb3B0aW9ucyByZWFkIG9wdGlvbnNcbiAqIEByZXR1cm5zIHthbnlbXX0gYXJyYXkgb2YgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkQ29sdW1uKHJlYWRlciwgcm93R3JvdXAsIGNvbHVtbk1ldGFkYXRhLCBzY2hlbWFQYXRoLCB7IGNvbXByZXNzb3JzLCB1dGY4IH0pIHtcbiAgY29uc3QgeyBlbGVtZW50IH0gPSBzY2hlbWFQYXRoW3NjaGVtYVBhdGgubGVuZ3RoIC0gMV1cbiAgLyoqIEB0eXBlIHtEZWNvZGVkQXJyYXkgfCB1bmRlZmluZWR9ICovXG4gIGxldCBkaWN0aW9uYXJ5ID0gdW5kZWZpbmVkXG4gIGxldCBzZWVuID0gMFxuICAvKiogQHR5cGUge2FueVtdfSAqL1xuICBjb25zdCByb3dEYXRhID0gW11cblxuICB3aGlsZSAoc2VlbiA8IHJvd0dyb3VwLm51bV9yb3dzKSB7XG4gICAgLy8gcGFyc2UgY29sdW1uIGhlYWRlclxuICAgIGNvbnN0IGhlYWRlciA9IHBhcnF1ZXRIZWFkZXIocmVhZGVyKVxuICAgIC8vIGFzc2VydChoZWFkZXIuY29tcHJlc3NlZF9wYWdlX3NpemUgIT09IHVuZGVmaW5lZClcblxuICAgIC8vIHJlYWQgY29tcHJlc3NlZF9wYWdlX3NpemUgYnl0ZXMgc3RhcnRpbmcgYXQgb2Zmc2V0XG4gICAgY29uc3QgY29tcHJlc3NlZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICByZWFkZXIudmlldy5idWZmZXIsIHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0LCBoZWFkZXIuY29tcHJlc3NlZF9wYWdlX3NpemVcbiAgICApXG5cbiAgICAvLyBwYXJzZSBwYWdlIGRhdGEgYnkgdHlwZVxuICAgIC8qKiBAdHlwZSB7RGVjb2RlZEFycmF5fSAqL1xuICAgIGxldCB2YWx1ZXNcbiAgICBpZiAoaGVhZGVyLnR5cGUgPT09ICdEQVRBX1BBR0UnKSB7XG4gICAgICBjb25zdCBkYXBoID0gaGVhZGVyLmRhdGFfcGFnZV9oZWFkZXJcbiAgICAgIGlmICghZGFwaCkgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGRhdGEgcGFnZSBoZWFkZXIgaXMgdW5kZWZpbmVkJylcblxuICAgICAgY29uc3QgcGFnZSA9IGRlY29tcHJlc3NQYWdlKGNvbXByZXNzZWRCeXRlcywgTnVtYmVyKGhlYWRlci51bmNvbXByZXNzZWRfcGFnZV9zaXplKSwgY29sdW1uTWV0YWRhdGEuY29kZWMsIGNvbXByZXNzb3JzKVxuICAgICAgY29uc3QgeyBkZWZpbml0aW9uTGV2ZWxzLCByZXBldGl0aW9uTGV2ZWxzLCBkYXRhUGFnZSB9ID0gcmVhZERhdGFQYWdlKHBhZ2UsIGRhcGgsIHNjaGVtYVBhdGgsIGNvbHVtbk1ldGFkYXRhKVxuICAgICAgc2VlbiArPSBkYXBoLm51bV92YWx1ZXNcbiAgICAgIC8vIGFzc2VydCghZGFwaC5zdGF0aXN0aWNzIHx8IGRhcGguc3RhdGlzdGljcy5udWxsX2NvdW50ID09PSBCaWdJbnQoZGFwaC5udW1fdmFsdWVzIC0gZGF0YVBhZ2UubGVuZ3RoKSlcblxuICAgICAgLy8gY29uc3RydWN0IG91dHB1dCB2YWx1ZXM6IHNraXAgbnVsbHMgYW5kIGNvbnN0cnVjdCBsaXN0c1xuICAgICAgdmFsdWVzID0gZGVyZWZlcmVuY2VEaWN0aW9uYXJ5KGRpY3Rpb25hcnksIGRhdGFQYWdlKVxuICAgICAgdmFsdWVzID0gY29udmVydCh2YWx1ZXMsIGVsZW1lbnQsIHV0ZjgpXG4gICAgICBpZiAocmVwZXRpdGlvbkxldmVscy5sZW5ndGggfHwgZGVmaW5pdGlvbkxldmVscz8ubGVuZ3RoKSB7XG4gICAgICAgIC8vIFVzZSByZXBldGl0aW9uIGxldmVscyB0byBjb25zdHJ1Y3QgbGlzdHNcbiAgICAgICAgY29uc3QgbWF4RGVmaW5pdGlvbkxldmVsID0gZ2V0TWF4RGVmaW5pdGlvbkxldmVsKHNjaGVtYVBhdGgpXG4gICAgICAgIGNvbnN0IG1heFJlcGV0aXRpb25MZXZlbCA9IGdldE1heFJlcGV0aXRpb25MZXZlbChzY2hlbWFQYXRoKVxuICAgICAgICBjb25zdCByZXBldGl0aW9uUGF0aCA9IHNjaGVtYVBhdGgubWFwKCh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC5yZXBldGl0aW9uX3R5cGUpXG4gICAgICAgIHZhbHVlcyA9IGFzc2VtYmxlTGlzdHMoXG4gICAgICAgICAgZGVmaW5pdGlvbkxldmVscywgcmVwZXRpdGlvbkxldmVscywgdmFsdWVzLCByZXBldGl0aW9uUGF0aCwgbWF4RGVmaW5pdGlvbkxldmVsLCBtYXhSZXBldGl0aW9uTGV2ZWxcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd3JhcCBuZXN0ZWQgZmxhdCBkYXRhIGJ5IGRlcHRoXG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgc2NoZW1hUGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChzY2hlbWFQYXRoW2ldLmVsZW1lbnQucmVwZXRpdGlvbl90eXBlICE9PSAnUkVRVUlSRUQnKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBBcnJheS5mcm9tKHZhbHVlcywgZSA9PiBbZV0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhc3NlcnQoQmlnSW50KHZhbHVlcy5sZW5ndGgpID09PSByb3dHcm91cC5udW1fcm93cylcbiAgICAgIGNvbmNhdChyb3dEYXRhLCB2YWx1ZXMpXG4gICAgfSBlbHNlIGlmIChoZWFkZXIudHlwZSA9PT0gJ0RBVEFfUEFHRV9WMicpIHtcbiAgICAgIGNvbnN0IGRhcGgyID0gaGVhZGVyLmRhdGFfcGFnZV9oZWFkZXJfdjJcbiAgICAgIGlmICghZGFwaDIpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBkYXRhIHBhZ2UgaGVhZGVyIHYyIGlzIHVuZGVmaW5lZCcpXG5cbiAgICAgIGNvbnN0IHsgZGVmaW5pdGlvbkxldmVscywgcmVwZXRpdGlvbkxldmVscywgZGF0YVBhZ2UgfSA9IHJlYWREYXRhUGFnZVYyKFxuICAgICAgICBjb21wcmVzc2VkQnl0ZXMsIGhlYWRlciwgc2NoZW1hUGF0aCwgY29sdW1uTWV0YWRhdGEsIGNvbXByZXNzb3JzXG4gICAgICApXG4gICAgICBzZWVuICs9IGRhcGgyLm51bV92YWx1ZXNcblxuICAgICAgdmFsdWVzID0gZGVyZWZlcmVuY2VEaWN0aW9uYXJ5KGRpY3Rpb25hcnksIGRhdGFQYWdlKVxuICAgICAgdmFsdWVzID0gY29udmVydCh2YWx1ZXMsIGVsZW1lbnQsIHV0ZjgpXG4gICAgICBpZiAocmVwZXRpdGlvbkxldmVscy5sZW5ndGggfHwgZGVmaW5pdGlvbkxldmVscz8ubGVuZ3RoKSB7XG4gICAgICAgIC8vIFVzZSByZXBldGl0aW9uIGxldmVscyB0byBjb25zdHJ1Y3QgbGlzdHNcbiAgICAgICAgY29uc3QgbWF4RGVmaW5pdGlvbkxldmVsID0gZ2V0TWF4RGVmaW5pdGlvbkxldmVsKHNjaGVtYVBhdGgpXG4gICAgICAgIGNvbnN0IG1heFJlcGV0aXRpb25MZXZlbCA9IGdldE1heFJlcGV0aXRpb25MZXZlbChzY2hlbWFQYXRoKVxuICAgICAgICBjb25zdCByZXBldGl0aW9uUGF0aCA9IHNjaGVtYVBhdGgubWFwKCh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC5yZXBldGl0aW9uX3R5cGUpXG4gICAgICAgIHZhbHVlcyA9IGFzc2VtYmxlTGlzdHMoXG4gICAgICAgICAgZGVmaW5pdGlvbkxldmVscywgcmVwZXRpdGlvbkxldmVscywgdmFsdWVzLCByZXBldGl0aW9uUGF0aCwgbWF4RGVmaW5pdGlvbkxldmVsLCBtYXhSZXBldGl0aW9uTGV2ZWxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgY29uY2F0KHJvd0RhdGEsIHZhbHVlcylcbiAgICB9IGVsc2UgaWYgKGhlYWRlci50eXBlID09PSAnRElDVElPTkFSWV9QQUdFJykge1xuICAgICAgY29uc3QgZGlwaCA9IGhlYWRlci5kaWN0aW9uYXJ5X3BhZ2VfaGVhZGVyXG4gICAgICBpZiAoIWRpcGgpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBkaWN0aW9uYXJ5IHBhZ2UgaGVhZGVyIGlzIHVuZGVmaW5lZCcpXG5cbiAgICAgIGNvbnN0IHBhZ2UgPSBkZWNvbXByZXNzUGFnZShcbiAgICAgICAgY29tcHJlc3NlZEJ5dGVzLCBOdW1iZXIoaGVhZGVyLnVuY29tcHJlc3NlZF9wYWdlX3NpemUpLCBjb2x1bW5NZXRhZGF0YS5jb2RlYywgY29tcHJlc3NvcnNcbiAgICAgIClcbiAgICAgIGRpY3Rpb25hcnkgPSByZWFkRGljdGlvbmFyeVBhZ2UocGFnZSwgZGlwaCwgY29sdW1uTWV0YWRhdGEsIGVsZW1lbnQudHlwZV9sZW5ndGgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcGFycXVldCB1bnN1cHBvcnRlZCBwYWdlIHR5cGU6ICR7aGVhZGVyLnR5cGV9YClcbiAgICB9XG4gICAgcmVhZGVyLm9mZnNldCArPSBoZWFkZXIuY29tcHJlc3NlZF9wYWdlX3NpemVcbiAgfVxuICBpZiAocm93RGF0YS5sZW5ndGggIT09IE51bWJlcihyb3dHcm91cC5udW1fcm93cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnF1ZXQgcm93IGRhdGEgbGVuZ3RoICR7cm93RGF0YS5sZW5ndGh9IGRvZXMgbm90IG1hdGNoIHJvdyBncm91cCBsZW5ndGggJHtyb3dHcm91cC5udW1fcm93c319YClcbiAgfVxuICByZXR1cm4gcm93RGF0YVxufVxuXG4vKipcbiAqIEZpbmQgdGhlIHN0YXJ0IGJ5dGUgb2Zmc2V0IGZvciBhIGNvbHVtbiBjaHVuay5cbiAqXG4gKiBAcGFyYW0ge0NvbHVtbk1ldGFEYXRhfSBjb2x1bW5NZXRhZGF0YVxuICogQHJldHVybnMge251bWJlcn0gYnl0ZSBvZmZzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbHVtbk9mZnNldCh7IGRpY3Rpb25hcnlfcGFnZV9vZmZzZXQsIGRhdGFfcGFnZV9vZmZzZXQgfSkge1xuICBsZXQgY29sdW1uT2Zmc2V0ID0gZGljdGlvbmFyeV9wYWdlX29mZnNldFxuICBpZiAoIWRpY3Rpb25hcnlfcGFnZV9vZmZzZXQgfHwgZGF0YV9wYWdlX29mZnNldCA8IGRpY3Rpb25hcnlfcGFnZV9vZmZzZXQpIHtcbiAgICBjb2x1bW5PZmZzZXQgPSBkYXRhX3BhZ2Vfb2Zmc2V0XG4gIH1cbiAgcmV0dXJuIE51bWJlcihjb2x1bW5PZmZzZXQpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBjb21wcmVzc2VkQnl0ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSB1bmNvbXByZXNzZWRfcGFnZV9zaXplXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy5qcycpLkNvbXByZXNzaW9uQ29kZWN9IGNvZGVjXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy5qcycpLkNvbXByZXNzb3JzIHwgdW5kZWZpbmVkfSBjb21wcmVzc29yc1xuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvbXByZXNzUGFnZShjb21wcmVzc2VkQnl0ZXMsIHVuY29tcHJlc3NlZF9wYWdlX3NpemUsIGNvZGVjLCBjb21wcmVzc29ycykge1xuICAvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovXG4gIGxldCBwYWdlXG4gIGNvbnN0IGN1c3RvbURlY29tcHJlc3NvciA9IGNvbXByZXNzb3JzPy5bY29kZWNdXG4gIGlmIChjb2RlYyA9PT0gJ1VOQ09NUFJFU1NFRCcpIHtcbiAgICBwYWdlID0gY29tcHJlc3NlZEJ5dGVzXG4gIH0gZWxzZSBpZiAoY3VzdG9tRGVjb21wcmVzc29yKSB7XG4gICAgcGFnZSA9IGN1c3RvbURlY29tcHJlc3Nvcihjb21wcmVzc2VkQnl0ZXMsIHVuY29tcHJlc3NlZF9wYWdlX3NpemUpXG4gIH0gZWxzZSBpZiAoY29kZWMgPT09ICdTTkFQUFknKSB7XG4gICAgcGFnZSA9IG5ldyBVaW50OEFycmF5KHVuY29tcHJlc3NlZF9wYWdlX3NpemUpXG4gICAgc25hcHB5VW5jb21wcmVzcyhjb21wcmVzc2VkQnl0ZXMsIHBhZ2UpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYXJxdWV0IHVuc3VwcG9ydGVkIGNvbXByZXNzaW9uIGNvZGVjOiAke2NvZGVjfWApXG4gIH1cbiAgaWYgKHBhZ2U/Lmxlbmd0aCAhPT0gdW5jb21wcmVzc2VkX3BhZ2Vfc2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFycXVldCBkZWNvbXByZXNzZWQgcGFnZSBsZW5ndGggJHtwYWdlPy5sZW5ndGh9IGRvZXMgbm90IG1hdGNoIGhlYWRlciAke3VuY29tcHJlc3NlZF9wYWdlX3NpemV9YClcbiAgfVxuICByZXR1cm4gcGFnZVxufVxuIiwiLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzLmpzJykuUGFycXVldFR5cGVbXX1cbiAqL1xuZXhwb3J0IGNvbnN0IFBhcnF1ZXRUeXBlID0gW1xuICAnQk9PTEVBTicsXG4gICdJTlQzMicsXG4gICdJTlQ2NCcsXG4gICdJTlQ5NicsIC8vIGRlcHJlY2F0ZWRcbiAgJ0ZMT0FUJyxcbiAgJ0RPVUJMRScsXG4gICdCWVRFX0FSUkFZJyxcbiAgJ0ZJWEVEX0xFTl9CWVRFX0FSUkFZJyxcbl1cblxuZXhwb3J0IGNvbnN0IEVuY29kaW5nID0gW1xuICAnUExBSU4nLFxuICB1bmRlZmluZWQsXG4gICdQTEFJTl9ESUNUSU9OQVJZJyxcbiAgJ1JMRScsXG4gICdCSVRfUEFDS0VEJywgLy8gZGVwcmVjYXRlZFxuICAnREVMVEFfQklOQVJZX1BBQ0tFRCcsXG4gICdERUxUQV9MRU5HVEhfQllURV9BUlJBWScsXG4gICdERUxUQV9CWVRFX0FSUkFZJyxcbiAgJ1JMRV9ESUNUSU9OQVJZJyxcbiAgJ0JZVEVfU1RSRUFNX1NQTElUJyxcbl1cblxuZXhwb3J0IGNvbnN0IEZpZWxkUmVwZXRpdGlvblR5cGUgPSBbXG4gICdSRVFVSVJFRCcsXG4gICdPUFRJT05BTCcsXG4gICdSRVBFQVRFRCcsXG5dXG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi90eXBlcy5qcycpLkNvbnZlcnRlZFR5cGVbXX1cbiAqL1xuZXhwb3J0IGNvbnN0IENvbnZlcnRlZFR5cGUgPSBbXG4gICdVVEY4JyxcbiAgJ01BUCcsXG4gICdNQVBfS0VZX1ZBTFVFJyxcbiAgJ0xJU1QnLFxuICAnRU5VTScsXG4gICdERUNJTUFMJyxcbiAgJ0RBVEUnLFxuICAnVElNRV9NSUxMSVMnLFxuICAnVElNRV9NSUNST1MnLFxuICAnVElNRVNUQU1QX01JTExJUycsXG4gICdUSU1FU1RBTVBfTUlDUk9TJyxcbiAgJ1VJTlRfOCcsXG4gICdVSU5UXzE2JyxcbiAgJ1VJTlRfMzInLFxuICAnVUlOVF82NCcsXG4gICdJTlRfOCcsXG4gICdJTlRfMTYnLFxuICAnSU5UXzMyJyxcbiAgJ0lOVF82NCcsXG4gICdKU09OJyxcbiAgJ0JTT04nLFxuICAnSU5URVJWQUwnLFxuXVxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5Mb2dpY2FsVHlwZVR5cGVbXX1cbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ2ljYWxUeXBlVHlwZSA9IFtcbiAgJ05VTEwnLFxuICAnU1RSSU5HJyxcbiAgJ01BUCcsXG4gICdMSVNUJyxcbiAgJ0VOVU0nLFxuICAnREVDSU1BTCcsXG4gICdEQVRFJyxcbiAgJ1RJTUUnLFxuICAnVElNRVNUQU1QJyxcbiAgJ0lOVEVSVkFMJyxcbiAgJ0lOVEVHRVInLFxuICAnTlVMTCcsXG4gICdKU09OJyxcbiAgJ0JTT04nLFxuICAnVVVJRCcsXG5dXG5cbmV4cG9ydCBjb25zdCBDb21wcmVzc2lvbkNvZGVjID0gW1xuICAnVU5DT01QUkVTU0VEJyxcbiAgJ1NOQVBQWScsXG4gICdHWklQJyxcbiAgJ0xaTycsXG4gICdCUk9UTEknLFxuICAnTFo0JyxcbiAgJ1pTVEQnLFxuICAnTFo0X1JBVycsXG5dXG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi90eXBlcy5qcycpLlBhZ2VUeXBlW119XG4gKi9cbmV4cG9ydCBjb25zdCBQYWdlVHlwZSA9IFtcbiAgJ0RBVEFfUEFHRScsXG4gICdJTkRFWF9QQUdFJyxcbiAgJ0RJQ1RJT05BUllfUEFHRScsXG4gICdEQVRBX1BBR0VfVjInLFxuXVxuIiwiY29uc3QgZGF5TWlsbGlzID0gODY0MDAwMDAgLy8gMSBkYXkgaW4gbWlsbGlzZWNvbmRzXG5cbi8qKlxuICogQ29udmVydCBrbm93biB0eXBlcyBmcm9tIHByaW1pdGl2ZSB0byByaWNoLlxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5EZWNvZGVkQXJyYXl9IERlY29kZWRBcnJheVxuICogQHBhcmFtIHtEZWNvZGVkQXJyYXl9IGRhdGEgc2VyaWVzIG9mIHByaW1pdGl2ZSB0eXBlc1xuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5TY2hlbWFFbGVtZW50fSBzY2hlbWFFbGVtZW50IHNjaGVtYSBlbGVtZW50IGZvciB0aGUgZGF0YVxuICogQHBhcmFtIHtib29sZWFuIHwgdW5kZWZpbmVkfSB1dGY4IGRlY29kZSBieXRlcyBhcyB1dGY4P1xuICogQHJldHVybnMge0RlY29kZWRBcnJheX0gc2VyaWVzIG9mIHJpY2ggdHlwZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnQoZGF0YSwgc2NoZW1hRWxlbWVudCwgdXRmOCA9IHRydWUpIHtcbiAgY29uc3QgY3R5cGUgPSBzY2hlbWFFbGVtZW50LmNvbnZlcnRlZF90eXBlXG4gIGlmIChjdHlwZSA9PT0gJ0RFQ0lNQUwnKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2hlbWFFbGVtZW50LnNjYWxlIHx8IDBcbiAgICBjb25zdCBmYWN0b3IgPSBNYXRoLnBvdygxMCwgLXNjYWxlKVxuICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShkYXRhLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRhdGFbMF0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGFycltpXSA9IHBhcnNlRGVjaW1hbChkYXRhW2ldKSAqIGZhY3RvclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyW2ldID0gTnVtYmVyKGRhdGFbaV0pICogZmFjdG9yXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuICBpZiAoY3R5cGUgPT09IHVuZGVmaW5lZCAmJiBzY2hlbWFFbGVtZW50LnR5cGUgPT09ICdJTlQ5NicpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShkYXRhKS5tYXAocGFyc2VJbnQ5NkRhdGUpXG4gIH1cbiAgaWYgKGN0eXBlID09PSAnREFURScpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycltpXSA9IG5ldyBEYXRlKGRhdGFbaV0gKiBkYXlNaWxsaXMpXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuICBpZiAoY3R5cGUgPT09ICdUSU1FU1RBTVBfTUlMTElTJykge1xuICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShkYXRhLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyW2ldID0gbmV3IERhdGUoTnVtYmVyKGRhdGFbaV0pKVxuICAgIH1cbiAgICByZXR1cm4gYXJyXG4gIH1cbiAgaWYgKGN0eXBlID09PSAnVElNRVNUQU1QX01JQ1JPUycpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycltpXSA9IG5ldyBEYXRlKE51bWJlcihkYXRhW2ldIC8gMTAwMG4pKVxuICAgIH1cbiAgICByZXR1cm4gYXJyXG4gIH1cbiAgaWYgKGN0eXBlID09PSAnSlNPTicpIHtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgICByZXR1cm4gZGF0YS5tYXAodiA9PiBKU09OLnBhcnNlKGRlY29kZXIuZGVjb2RlKHYpKSlcbiAgfVxuICBpZiAoY3R5cGUgPT09ICdCU09OJykge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFycXVldCBic29uIG5vdCBzdXBwb3J0ZWQnKVxuICB9XG4gIGlmIChjdHlwZSA9PT0gJ0lOVEVSVkFMJykge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFycXVldCBpbnRlcnZhbCBub3Qgc3VwcG9ydGVkJylcbiAgfVxuICBpZiAoY3R5cGUgPT09ICdVVEY4JyB8fCB1dGY4ICYmIHNjaGVtYUVsZW1lbnQudHlwZSA9PT0gJ0JZVEVfQVJSQVknKSB7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4gICAgY29uc3QgYXJyID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJbaV0gPSBkYXRhW2ldICYmIGRlY29kZXIuZGVjb2RlKGRhdGFbaV0pXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuICBpZiAoY3R5cGUgPT09ICdVSU5UXzY0Jykge1xuICAgIGNvbnN0IGFyciA9IG5ldyBCaWdVaW50NjRBcnJheShkYXRhLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyW2ldID0gQmlnSW50KGRhdGFbaV0pXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuICBjb25zdCBsb2dpY2FsVHlwZSA9IHNjaGVtYUVsZW1lbnQubG9naWNhbF90eXBlPy50eXBlXG4gIGlmIChsb2dpY2FsVHlwZSA9PT0gJ0ZMT0FUMTYnKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZGF0YSkubWFwKHBhcnNlRmxvYXQxNilcbiAgfVxuICBpZiAobG9naWNhbFR5cGUgPT09ICdUSU1FU1RBTVAnKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJbaV0gPSBuZXcgRGF0ZShOdW1iZXIoZGF0YVtpXSkpXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGVjaW1hbChieXRlcykge1xuICAvLyBUT0RPOiBoYW5kbGUgc2lnbmVkXG4gIGxldCB2YWx1ZSA9IDBcbiAgZm9yIChjb25zdCBieXRlIG9mIGJ5dGVzKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSA8PCA4IHwgYnl0ZVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YmlnaW50fSB2YWx1ZVxuICogQHJldHVybnMge0RhdGV9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW50OTZEYXRlKHZhbHVlKSB7XG4gIGNvbnN0IGRheXMgPSBOdW1iZXIoKHZhbHVlID4+IDY0bikgLSAyNDQwNTg4bilcbiAgY29uc3QgbmFubyA9IE51bWJlcigodmFsdWUgJiAweGZmZmZmZmZmZmZmZmZmZmZuKSAvIDEwMDAwMDBuKVxuICBjb25zdCBtaWxsaXMgPSBkYXlzICogZGF5TWlsbGlzICsgbmFub1xuICByZXR1cm4gbmV3IERhdGUobWlsbGlzKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheSB8IHVuZGVmaW5lZH0gYnl0ZXNcbiAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZsb2F0MTYoYnl0ZXMpIHtcbiAgaWYgKCFieXRlcykgcmV0dXJuIHVuZGVmaW5lZFxuICBjb25zdCBpbnQxNiA9IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXVxuICBjb25zdCBzaWduID0gaW50MTYgPj4gMTUgPyAtMSA6IDFcbiAgY29uc3QgZXhwID0gaW50MTYgPj4gMTAgJiAweDFmXG4gIGNvbnN0IGZyYWMgPSBpbnQxNiAmIDB4M2ZmXG4gIGlmIChleHAgPT09IDApIHJldHVybiBzaWduICogTWF0aC5wb3coMiwgLTE0KSAqIChmcmFjIC8gMTAyNCkgLy8gc3Vibm9ybWFsc1xuICBpZiAoZXhwID09PSAweDFmKSByZXR1cm4gZnJhYyA/IE5hTiA6IHNpZ24gKiBJbmZpbml0eVxuICByZXR1cm4gc2lnbiAqIE1hdGgucG93KDIsIGV4cCAtIDE1KSAqICgxICsgZnJhYyAvIDEwMjQpXG59XG5cbi8qKlxuICogTWFwIGRhdGEgdG8gZGljdGlvbmFyeSB2YWx1ZXMgaW4gcGxhY2UuXG4gKlxuICogQHBhcmFtIHtEZWNvZGVkQXJyYXkgfCB1bmRlZmluZWR9IGRpY3Rpb25hcnlcbiAqIEBwYXJhbSB7RGVjb2RlZEFycmF5fSBkYXRhUGFnZVxuICogQHJldHVybnMge0RlY29kZWRBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcmVmZXJlbmNlRGljdGlvbmFyeShkaWN0aW9uYXJ5LCBkYXRhUGFnZSkge1xuICBsZXQgb3V0cHV0ID0gZGF0YVBhZ2VcbiAgaWYgKGRpY3Rpb25hcnkpIHtcbiAgICBpZiAoZGF0YVBhZ2UgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmICEoZGljdGlvbmFyeSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAvLyB1cGdyYWRlIGRhdGFQYWdlIHRvIG1hdGNoIGRpY3Rpb25hcnkgdHlwZVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBub3QgbXkgZmF1bHQgdHlwZXNjcmlwdCBkb2Vzbid0IHVuZGVyc3RhbmQgY29uc3RydWN0b3JzXG4gICAgICBvdXRwdXQgPSBuZXcgZGljdGlvbmFyeS5jb25zdHJ1Y3RvcihkYXRhUGFnZS5sZW5ndGgpXG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVBhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dHB1dFtpXSA9IGRpY3Rpb25hcnlbZGF0YVBhZ2VbaV1dXG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXRcbn1cbiIsImltcG9ydCB7IGJpdFdpZHRoLCBieXRlU3RyZWFtU3BsaXQsIHJlYWRSbGVCaXRQYWNrZWRIeWJyaWQgfSBmcm9tICcuL2VuY29kaW5nLmpzJ1xuaW1wb3J0IHsgcmVhZFBsYWluIH0gZnJvbSAnLi9wbGFpbi5qcydcbmltcG9ydCB7IGdldE1heERlZmluaXRpb25MZXZlbCwgZ2V0TWF4UmVwZXRpdGlvbkxldmVsIH0gZnJvbSAnLi9zY2hlbWEuanMnXG5cbi8qKlxuICogUmVhZCBhIGRhdGEgcGFnZSBmcm9tIHVuY29tcHJlc3NlZCByZWFkZXIuXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5EYXRhUGFnZX0gRGF0YVBhZ2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuQ29sdW1uTWV0YURhdGF9IENvbHVtbk1ldGFEYXRhXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkRhdGFQYWdlSGVhZGVyfSBEYXRhUGFnZUhlYWRlclxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5TY2hlbWFUcmVlfSBTY2hlbWFUcmVlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkRlY29kZWRBcnJheX0gRGVjb2RlZEFycmF5XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzIHJhdyBwYWdlIGRhdGEgKHNob3VsZCBhbHJlYWR5IGJlIGRlY29tcHJlc3NlZClcbiAqIEBwYXJhbSB7RGF0YVBhZ2VIZWFkZXJ9IGRhcGggZGF0YSBwYWdlIGhlYWRlclxuICogQHBhcmFtIHtTY2hlbWFUcmVlW119IHNjaGVtYVBhdGhcbiAqIEBwYXJhbSB7Q29sdW1uTWV0YURhdGF9IGNvbHVtbk1ldGFkYXRhXG4gKiBAcmV0dXJucyB7RGF0YVBhZ2V9IGRlZmluaXRpb24gbGV2ZWxzLCByZXBldGl0aW9uIGxldmVscywgYW5kIGFycmF5IG9mIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZERhdGFQYWdlKGJ5dGVzLCBkYXBoLCBzY2hlbWFQYXRoLCB7IHR5cGUgfSkge1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aClcbiAgY29uc3QgcmVhZGVyID0geyB2aWV3LCBvZmZzZXQ6IDAgfVxuICAvKiogQHR5cGUge0RlY29kZWRBcnJheX0gKi9cbiAgbGV0IGRhdGFQYWdlXG5cbiAgLy8gcmVwZXRpdGlvbiBhbmQgZGVmaW5pdGlvbiBsZXZlbHNcbiAgY29uc3QgcmVwZXRpdGlvbkxldmVscyA9IHJlYWRSZXBldGl0aW9uTGV2ZWxzKHJlYWRlciwgZGFwaCwgc2NoZW1hUGF0aClcbiAgY29uc3QgeyBkZWZpbml0aW9uTGV2ZWxzLCBudW1OdWxscyB9ID0gcmVhZERlZmluaXRpb25MZXZlbHMocmVhZGVyLCBkYXBoLCBzY2hlbWFQYXRoKVxuXG4gIC8vIHJlYWQgdmFsdWVzIGJhc2VkIG9uIGVuY29kaW5nXG4gIGNvbnN0IG5WYWx1ZXMgPSBkYXBoLm51bV92YWx1ZXMgLSBudW1OdWxsc1xuICBpZiAoZGFwaC5lbmNvZGluZyA9PT0gJ1BMQUlOJykge1xuICAgIGNvbnN0IHsgdHlwZV9sZW5ndGggfSA9IHNjaGVtYVBhdGhbc2NoZW1hUGF0aC5sZW5ndGggLSAxXS5lbGVtZW50XG4gICAgZGF0YVBhZ2UgPSByZWFkUGxhaW4ocmVhZGVyLCB0eXBlLCBuVmFsdWVzLCB0eXBlX2xlbmd0aClcbiAgfSBlbHNlIGlmIChcbiAgICBkYXBoLmVuY29kaW5nID09PSAnUExBSU5fRElDVElPTkFSWScgfHxcbiAgICBkYXBoLmVuY29kaW5nID09PSAnUkxFX0RJQ1RJT05BUlknIHx8XG4gICAgZGFwaC5lbmNvZGluZyA9PT0gJ1JMRSdcbiAgKSB7XG4gICAgY29uc3QgYml0V2lkdGggPSB0eXBlID09PSAnQk9PTEVBTicgPyAxIDogdmlldy5nZXRVaW50OChyZWFkZXIub2Zmc2V0KyspXG4gICAgaWYgKGJpdFdpZHRoKSB7XG4gICAgICBkYXRhUGFnZSA9IG5ldyBBcnJheShuVmFsdWVzKVxuICAgICAgcmVhZFJsZUJpdFBhY2tlZEh5YnJpZChyZWFkZXIsIGJpdFdpZHRoLCB2aWV3LmJ5dGVMZW5ndGggLSByZWFkZXIub2Zmc2V0LCBkYXRhUGFnZSlcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YVBhZ2UgPSBuZXcgVWludDhBcnJheShuVmFsdWVzKSAvLyBuVmFsdWUgemVyb2VzXG4gICAgfVxuICB9IGVsc2UgaWYgKGRhcGguZW5jb2RpbmcgPT09ICdCWVRFX1NUUkVBTV9TUExJVCcpIHtcbiAgICBjb25zdCB7IHR5cGVfbGVuZ3RoIH0gPSBzY2hlbWFQYXRoW3NjaGVtYVBhdGgubGVuZ3RoIC0gMV0uZWxlbWVudFxuICAgIGRhdGFQYWdlID0gYnl0ZVN0cmVhbVNwbGl0KHJlYWRlciwgblZhbHVlcywgdHlwZSwgdHlwZV9sZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYXJxdWV0IHVuc3VwcG9ydGVkIGVuY29kaW5nOiAke2RhcGguZW5jb2Rpbmd9YClcbiAgfVxuXG4gIHJldHVybiB7IGRlZmluaXRpb25MZXZlbHMsIHJlcGV0aXRpb25MZXZlbHMsIGRhdGFQYWdlIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzIHJhdyBwYWdlIGRhdGFcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkRpY3Rpb25hcnlQYWdlSGVhZGVyfSBkaXBoIGRpY3Rpb25hcnkgcGFnZSBoZWFkZXJcbiAqIEBwYXJhbSB7Q29sdW1uTWV0YURhdGF9IGNvbHVtbk1ldGFkYXRhXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gdHlwZUxlbmd0aCAtIHR5cGVfbGVuZ3RoIGZyb20gc2NoZW1hXG4gKiBAcmV0dXJucyB7RGVjb2RlZEFycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZERpY3Rpb25hcnlQYWdlKGJ5dGVzLCBkaXBoLCBjb2x1bW5NZXRhZGF0YSwgdHlwZUxlbmd0aCkge1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aClcbiAgY29uc3QgcmVhZGVyID0geyB2aWV3LCBvZmZzZXQ6IDAgfVxuICByZXR1cm4gcmVhZFBsYWluKHJlYWRlciwgY29sdW1uTWV0YWRhdGEudHlwZSwgZGlwaC5udW1fdmFsdWVzLCB0eXBlTGVuZ3RoKVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuRGF0YVJlYWRlcn0gRGF0YVJlYWRlclxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgZGF0YSB2aWV3IGZvciB0aGUgcGFnZVxuICogQHBhcmFtIHtEYXRhUGFnZUhlYWRlcn0gZGFwaCBkYXRhIHBhZ2UgaGVhZGVyXG4gKiBAcGFyYW0ge1NjaGVtYVRyZWVbXX0gc2NoZW1hUGF0aFxuICogQHJldHVybnMge2FueVtdfSByZXBldGl0aW9uIGxldmVscyBhbmQgbnVtYmVyIG9mIGJ5dGVzIHJlYWRcbiAqL1xuZnVuY3Rpb24gcmVhZFJlcGV0aXRpb25MZXZlbHMocmVhZGVyLCBkYXBoLCBzY2hlbWFQYXRoKSB7XG4gIGlmIChzY2hlbWFQYXRoLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBtYXhSZXBldGl0aW9uTGV2ZWwgPSBnZXRNYXhSZXBldGl0aW9uTGV2ZWwoc2NoZW1hUGF0aClcbiAgICBpZiAobWF4UmVwZXRpdGlvbkxldmVsKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkoZGFwaC5udW1fdmFsdWVzKVxuICAgICAgcmVhZFJsZUJpdFBhY2tlZEh5YnJpZChyZWFkZXIsIGJpdFdpZHRoKG1heFJlcGV0aXRpb25MZXZlbCksIDAsIHZhbHVlcylcbiAgICAgIHJldHVybiB2YWx1ZXNcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdXG59XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgZGF0YSB2aWV3IGZvciB0aGUgcGFnZVxuICogQHBhcmFtIHtEYXRhUGFnZUhlYWRlcn0gZGFwaCBkYXRhIHBhZ2UgaGVhZGVyXG4gKiBAcGFyYW0ge1NjaGVtYVRyZWVbXX0gc2NoZW1hUGF0aFxuICogQHJldHVybnMge3sgZGVmaW5pdGlvbkxldmVsczogbnVtYmVyW10sIG51bU51bGxzOiBudW1iZXIgfX0gZGVmaW5pdGlvbiBsZXZlbHNcbiAqL1xuZnVuY3Rpb24gcmVhZERlZmluaXRpb25MZXZlbHMocmVhZGVyLCBkYXBoLCBzY2hlbWFQYXRoKSB7XG4gIGNvbnN0IG1heERlZmluaXRpb25MZXZlbCA9IGdldE1heERlZmluaXRpb25MZXZlbChzY2hlbWFQYXRoKVxuICBpZiAoIW1heERlZmluaXRpb25MZXZlbCkgcmV0dXJuIHsgZGVmaW5pdGlvbkxldmVsczogW10sIG51bU51bGxzOiAwIH1cblxuICBjb25zdCBkZWZpbml0aW9uTGV2ZWxzID0gbmV3IEFycmF5KGRhcGgubnVtX3ZhbHVlcylcbiAgcmVhZFJsZUJpdFBhY2tlZEh5YnJpZChyZWFkZXIsIGJpdFdpZHRoKG1heERlZmluaXRpb25MZXZlbCksIDAsIGRlZmluaXRpb25MZXZlbHMpXG5cbiAgLy8gY291bnQgbnVsbHNcbiAgbGV0IG51bU51bGxzID0gZGFwaC5udW1fdmFsdWVzXG4gIGZvciAoY29uc3QgZGVmIG9mIGRlZmluaXRpb25MZXZlbHMpIHtcbiAgICBpZiAoZGVmID09PSBtYXhEZWZpbml0aW9uTGV2ZWwpIG51bU51bGxzLS1cbiAgfVxuICBpZiAobnVtTnVsbHMgPT09IDApIGRlZmluaXRpb25MZXZlbHMubGVuZ3RoID0gMFxuXG4gIHJldHVybiB7IGRlZmluaXRpb25MZXZlbHMsIG51bU51bGxzIH1cbn1cbiIsImltcG9ydCB7IGRlY29tcHJlc3NQYWdlIH0gZnJvbSAnLi9jb2x1bW4uanMnXG5pbXBvcnQgeyBkZWx0YUJpbmFyeVVucGFjaywgZGVsdGFCeXRlQXJyYXksIGRlbHRhTGVuZ3RoQnl0ZUFycmF5IH0gZnJvbSAnLi9kZWx0YS5qcydcbmltcG9ydCB7IGJpdFdpZHRoLCBieXRlU3RyZWFtU3BsaXQsIHJlYWRSbGVCaXRQYWNrZWRIeWJyaWQgfSBmcm9tICcuL2VuY29kaW5nLmpzJ1xuaW1wb3J0IHsgcmVhZFBsYWluIH0gZnJvbSAnLi9wbGFpbi5qcydcbmltcG9ydCB7IGdldE1heERlZmluaXRpb25MZXZlbCwgZ2V0TWF4UmVwZXRpdGlvbkxldmVsIH0gZnJvbSAnLi9zY2hlbWEuanMnXG5cbi8qKlxuICogUmVhZCBhIGRhdGEgcGFnZSBmcm9tIHRoZSBnaXZlbiBVaW50OEFycmF5LlxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuRGF0YVBhZ2V9IERhdGFQYWdlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkNvbHVtbk1ldGFEYXRhfSBDb2x1bW5NZXRhRGF0YVxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5Db21wcmVzc29yc30gQ29tcHJlc3NvcnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuRGF0YVBhZ2VIZWFkZXJWMn0gRGF0YVBhZ2VIZWFkZXJWMlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5TY2hlbWFUcmVlfSBTY2hlbWFUcmVlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbXByZXNzZWRCeXRlcyByYXcgcGFnZSBkYXRhXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5QYWdlSGVhZGVyfSBwaCBwYWdlIGhlYWRlclxuICogQHBhcmFtIHtTY2hlbWFUcmVlW119IHNjaGVtYVBhdGhcbiAqIEBwYXJhbSB7Q29sdW1uTWV0YURhdGF9IGNvbHVtbk1ldGFkYXRhXG4gKiBAcGFyYW0ge0NvbXByZXNzb3JzIHwgdW5kZWZpbmVkfSBjb21wcmVzc29yc1xuICogQHJldHVybnMge0RhdGFQYWdlfSBkZWZpbml0aW9uIGxldmVscywgcmVwZXRpdGlvbiBsZXZlbHMsIGFuZCBhcnJheSBvZiB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWREYXRhUGFnZVYyKGNvbXByZXNzZWRCeXRlcywgcGgsIHNjaGVtYVBhdGgsIGNvbHVtbk1ldGFkYXRhLCBjb21wcmVzc29ycykge1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGNvbXByZXNzZWRCeXRlcy5idWZmZXIsIGNvbXByZXNzZWRCeXRlcy5ieXRlT2Zmc2V0LCBjb21wcmVzc2VkQnl0ZXMuYnl0ZUxlbmd0aClcbiAgY29uc3QgcmVhZGVyID0geyB2aWV3LCBvZmZzZXQ6IDAgfVxuICBjb25zdCB7IGNvZGVjLCB0eXBlIH0gPSBjb2x1bW5NZXRhZGF0YVxuICBjb25zdCBkYXBoMiA9IHBoLmRhdGFfcGFnZV9oZWFkZXJfdjJcbiAgaWYgKCFkYXBoMikgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGRhdGEgcGFnZSBoZWFkZXIgdjIgaXMgdW5kZWZpbmVkJylcblxuICAvLyByZXBldGl0aW9uIGxldmVsc1xuICBjb25zdCByZXBldGl0aW9uTGV2ZWxzID0gcmVhZFJlcGV0aXRpb25MZXZlbHNWMihyZWFkZXIsIGRhcGgyLCBzY2hlbWFQYXRoKVxuICByZWFkZXIub2Zmc2V0ID0gZGFwaDIucmVwZXRpdGlvbl9sZXZlbHNfYnl0ZV9sZW5ndGggLy8gcmVhZFZhckludCgpID0+IGxlbiBmb3IgYm9vbGVhbiB2Mj9cblxuICAvLyBkZWZpbml0aW9uIGxldmVsc1xuICBjb25zdCBkZWZpbml0aW9uTGV2ZWxzID0gcmVhZERlZmluaXRpb25MZXZlbHNWMihyZWFkZXIsIGRhcGgyLCBzY2hlbWFQYXRoKVxuICAvLyBhc3NlcnQocmVhZGVyLm9mZnNldCA9PT0gZGFwaDIucmVwZXRpdGlvbl9sZXZlbHNfYnl0ZV9sZW5ndGggKyBkYXBoMi5kZWZpbml0aW9uX2xldmVsc19ieXRlX2xlbmd0aClcblxuICBjb25zdCB1bmNvbXByZXNzZWRQYWdlU2l6ZSA9IHBoLnVuY29tcHJlc3NlZF9wYWdlX3NpemUgLSBkYXBoMi5kZWZpbml0aW9uX2xldmVsc19ieXRlX2xlbmd0aCAtIGRhcGgyLnJlcGV0aXRpb25fbGV2ZWxzX2J5dGVfbGVuZ3RoXG5cbiAgbGV0IHBhZ2UgPSBjb21wcmVzc2VkQnl0ZXMuc3ViYXJyYXkocmVhZGVyLm9mZnNldClcbiAgaWYgKGRhcGgyLmlzX2NvbXByZXNzZWQgIT09IGZhbHNlKSB7XG4gICAgcGFnZSA9IGRlY29tcHJlc3NQYWdlKHBhZ2UsIHVuY29tcHJlc3NlZFBhZ2VTaXplLCBjb2RlYywgY29tcHJlc3NvcnMpXG4gIH1cbiAgY29uc3QgcGFnZVZpZXcgPSBuZXcgRGF0YVZpZXcocGFnZS5idWZmZXIsIHBhZ2UuYnl0ZU9mZnNldCwgcGFnZS5ieXRlTGVuZ3RoKVxuICBjb25zdCBwYWdlUmVhZGVyID0geyB2aWV3OiBwYWdlVmlldywgb2Zmc2V0OiAwIH1cblxuICAvLyByZWFkIHZhbHVlcyBiYXNlZCBvbiBlbmNvZGluZ1xuICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlcy5kLnRzJykuRGVjb2RlZEFycmF5fSAqL1xuICBsZXQgZGF0YVBhZ2VcbiAgY29uc3QgblZhbHVlcyA9IGRhcGgyLm51bV92YWx1ZXMgLSBkYXBoMi5udW1fbnVsbHNcbiAgaWYgKGRhcGgyLmVuY29kaW5nID09PSAnUExBSU4nKSB7XG4gICAgY29uc3QgeyB0eXBlX2xlbmd0aCB9ID0gc2NoZW1hUGF0aFtzY2hlbWFQYXRoLmxlbmd0aCAtIDFdLmVsZW1lbnRcbiAgICBkYXRhUGFnZSA9IHJlYWRQbGFpbihwYWdlUmVhZGVyLCB0eXBlLCBuVmFsdWVzLCB0eXBlX2xlbmd0aClcbiAgfSBlbHNlIGlmIChkYXBoMi5lbmNvZGluZyA9PT0gJ1JMRScpIHtcbiAgICAvLyBhc3NlcnQoY29sdW1uTWV0YWRhdGEudHlwZSA9PT0gJ0JPT0xFQU4nKVxuICAgIGRhdGFQYWdlID0gbmV3IEFycmF5KG5WYWx1ZXMpXG4gICAgcmVhZFJsZUJpdFBhY2tlZEh5YnJpZChwYWdlUmVhZGVyLCAxLCAwLCBkYXRhUGFnZSlcbiAgICBkYXRhUGFnZSA9IGRhdGFQYWdlLm1hcCh4ID0+ICEheClcbiAgfSBlbHNlIGlmIChcbiAgICBkYXBoMi5lbmNvZGluZyA9PT0gJ1BMQUlOX0RJQ1RJT05BUlknIHx8XG4gICAgZGFwaDIuZW5jb2RpbmcgPT09ICdSTEVfRElDVElPTkFSWSdcbiAgKSB7XG4gICAgY29uc3QgYml0V2lkdGggPSBwYWdlVmlldy5nZXRVaW50OChwYWdlUmVhZGVyLm9mZnNldCsrKVxuICAgIGRhdGFQYWdlID0gbmV3IEFycmF5KG5WYWx1ZXMpXG4gICAgcmVhZFJsZUJpdFBhY2tlZEh5YnJpZChwYWdlUmVhZGVyLCBiaXRXaWR0aCwgdW5jb21wcmVzc2VkUGFnZVNpemUgLSAxLCBkYXRhUGFnZSlcbiAgfSBlbHNlIGlmIChkYXBoMi5lbmNvZGluZyA9PT0gJ0RFTFRBX0JJTkFSWV9QQUNLRUQnKSB7XG4gICAgY29uc3QgaW50MzIgPSB0eXBlID09PSAnSU5UMzInXG4gICAgZGF0YVBhZ2UgPSBpbnQzMiA/IG5ldyBJbnQzMkFycmF5KG5WYWx1ZXMpIDogbmV3IEJpZ0ludDY0QXJyYXkoblZhbHVlcylcbiAgICBkZWx0YUJpbmFyeVVucGFjayhwYWdlUmVhZGVyLCBuVmFsdWVzLCBkYXRhUGFnZSlcbiAgfSBlbHNlIGlmIChkYXBoMi5lbmNvZGluZyA9PT0gJ0RFTFRBX0xFTkdUSF9CWVRFX0FSUkFZJykge1xuICAgIGRhdGFQYWdlID0gbmV3IEFycmF5KG5WYWx1ZXMpXG4gICAgZGVsdGFMZW5ndGhCeXRlQXJyYXkocGFnZVJlYWRlciwgblZhbHVlcywgZGF0YVBhZ2UpXG4gIH0gZWxzZSBpZiAoZGFwaDIuZW5jb2RpbmcgPT09ICdERUxUQV9CWVRFX0FSUkFZJykge1xuICAgIGRhdGFQYWdlID0gbmV3IEFycmF5KG5WYWx1ZXMpXG4gICAgZGVsdGFCeXRlQXJyYXkocGFnZVJlYWRlciwgblZhbHVlcywgZGF0YVBhZ2UpXG4gIH0gZWxzZSBpZiAoZGFwaDIuZW5jb2RpbmcgPT09ICdCWVRFX1NUUkVBTV9TUExJVCcpIHtcbiAgICBjb25zdCB7IHR5cGVfbGVuZ3RoIH0gPSBzY2hlbWFQYXRoW3NjaGVtYVBhdGgubGVuZ3RoIC0gMV0uZWxlbWVudFxuICAgIGRhdGFQYWdlID0gYnl0ZVN0cmVhbVNwbGl0KHJlYWRlciwgblZhbHVlcywgdHlwZSwgdHlwZV9sZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYXJxdWV0IHVuc3VwcG9ydGVkIGVuY29kaW5nOiAke2RhcGgyLmVuY29kaW5nfWApXG4gIH1cblxuICByZXR1cm4geyBkZWZpbml0aW9uTGV2ZWxzLCByZXBldGl0aW9uTGV2ZWxzLCBkYXRhUGFnZSB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5EYXRhUmVhZGVyfSBEYXRhUmVhZGVyXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHBhcmFtIHtEYXRhUGFnZUhlYWRlclYyfSBkYXBoMiBkYXRhIHBhZ2UgaGVhZGVyIHYyXG4gKiBAcGFyYW0ge1NjaGVtYVRyZWVbXX0gc2NoZW1hUGF0aFxuICogQHJldHVybnMge2FueVtdfSByZXBldGl0aW9uIGxldmVsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZFJlcGV0aXRpb25MZXZlbHNWMihyZWFkZXIsIGRhcGgyLCBzY2hlbWFQYXRoKSB7XG4gIGNvbnN0IG1heFJlcGV0aXRpb25MZXZlbCA9IGdldE1heFJlcGV0aXRpb25MZXZlbChzY2hlbWFQYXRoKVxuICBpZiAoIW1heFJlcGV0aXRpb25MZXZlbCkgcmV0dXJuIFtdXG5cbiAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KGRhcGgyLm51bV92YWx1ZXMpXG4gIHJlYWRSbGVCaXRQYWNrZWRIeWJyaWQoXG4gICAgcmVhZGVyLCBiaXRXaWR0aChtYXhSZXBldGl0aW9uTGV2ZWwpLCBkYXBoMi5yZXBldGl0aW9uX2xldmVsc19ieXRlX2xlbmd0aCwgdmFsdWVzXG4gIClcbiAgcmV0dXJuIHZhbHVlc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge0RhdGFQYWdlSGVhZGVyVjJ9IGRhcGgyIGRhdGEgcGFnZSBoZWFkZXIgdjJcbiAqIEBwYXJhbSB7U2NoZW1hVHJlZVtdfSBzY2hlbWFQYXRoXG4gKiBAcmV0dXJucyB7bnVtYmVyW10gfCB1bmRlZmluZWR9IGRlZmluaXRpb24gbGV2ZWxzXG4gKi9cbmZ1bmN0aW9uIHJlYWREZWZpbml0aW9uTGV2ZWxzVjIocmVhZGVyLCBkYXBoMiwgc2NoZW1hUGF0aCkge1xuICBjb25zdCBtYXhEZWZpbml0aW9uTGV2ZWwgPSBnZXRNYXhEZWZpbml0aW9uTGV2ZWwoc2NoZW1hUGF0aClcbiAgaWYgKG1heERlZmluaXRpb25MZXZlbCkge1xuICAgIC8vIFYyIHdlIGtub3cgdGhlIGxlbmd0aFxuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShkYXBoMi5udW1fdmFsdWVzKVxuICAgIHJlYWRSbGVCaXRQYWNrZWRIeWJyaWQocmVhZGVyLCBiaXRXaWR0aChtYXhEZWZpbml0aW9uTGV2ZWwpLCBkYXBoMi5kZWZpbml0aW9uX2xldmVsc19ieXRlX2xlbmd0aCwgdmFsdWVzKVxuICAgIHJldHVybiB2YWx1ZXNcbiAgfVxufVxuIiwiaW1wb3J0IHsgcmVhZFZhckludCwgcmVhZFppZ1phZ0JpZ0ludCB9IGZyb20gJy4vdGhyaWZ0LmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuZC50cycpLkRhdGFSZWFkZXJ9IERhdGFSZWFkZXJcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnQgbnVtYmVyIG9mIHZhbHVlcyB0byByZWFkXG4gKiBAcGFyYW0ge0ludDMyQXJyYXkgfCBCaWdJbnQ2NEFycmF5fSBvdXRwdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbHRhQmluYXJ5VW5wYWNrKHJlYWRlciwgY291bnQsIG91dHB1dCkge1xuICBjb25zdCBpbnQzMiA9IG91dHB1dCBpbnN0YW5jZW9mIEludDMyQXJyYXlcbiAgY29uc3QgYmxvY2tTaXplID0gcmVhZFZhckludChyZWFkZXIpXG4gIGNvbnN0IG1pbmlibG9ja1BlckJsb2NrID0gcmVhZFZhckludChyZWFkZXIpXG4gIHJlYWRWYXJJbnQocmVhZGVyKSAvLyBhc3NlcnQoPT09IGNvdW50KVxuICBsZXQgdmFsdWUgPSByZWFkWmlnWmFnQmlnSW50KHJlYWRlcikgLy8gZmlyc3QgdmFsdWVcbiAgbGV0IG91dHB1dEluZGV4ID0gMFxuICBvdXRwdXRbb3V0cHV0SW5kZXgrK10gPSBpbnQzMiA/IE51bWJlcih2YWx1ZSkgOiB2YWx1ZVxuXG4gIGNvbnN0IHZhbHVlc1Blck1pbmlibG9jayA9IGJsb2NrU2l6ZSAvIG1pbmlibG9ja1BlckJsb2NrXG5cbiAgd2hpbGUgKG91dHB1dEluZGV4IDwgY291bnQpIHtcbiAgICAvLyBuZXcgYmxvY2tcbiAgICBjb25zdCBtaW5EZWx0YSA9IHJlYWRaaWdaYWdCaWdJbnQocmVhZGVyKVxuICAgIGNvbnN0IGJpdFdpZHRocyA9IG5ldyBVaW50OEFycmF5KG1pbmlibG9ja1BlckJsb2NrKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluaWJsb2NrUGVyQmxvY2s7IGkrKykge1xuICAgICAgYml0V2lkdGhzW2ldID0gcmVhZGVyLnZpZXcuZ2V0VWludDgocmVhZGVyLm9mZnNldCsrKVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluaWJsb2NrUGVyQmxvY2sgJiYgb3V0cHV0SW5kZXggPCBjb3VudDsgaSsrKSB7XG4gICAgICAvLyBuZXcgbWluaWJsb2NrXG4gICAgICBjb25zdCBiaXRXaWR0aCA9IEJpZ0ludChiaXRXaWR0aHNbaV0pXG4gICAgICBpZiAoYml0V2lkdGgpIHtcbiAgICAgICAgbGV0IGJpdHBhY2tQb3MgPSAwblxuICAgICAgICBsZXQgbWluaWJsb2NrQ291bnQgPSB2YWx1ZXNQZXJNaW5pYmxvY2tcbiAgICAgICAgY29uc3QgbWFzayA9ICgxbiA8PCBiaXRXaWR0aCkgLSAxblxuICAgICAgICB3aGlsZSAobWluaWJsb2NrQ291bnQgJiYgb3V0cHV0SW5kZXggPCBjb3VudCkge1xuICAgICAgICAgIGxldCBiaXRzID0gQmlnSW50KHJlYWRlci52aWV3LmdldFVpbnQ4KHJlYWRlci5vZmZzZXQpKSA+PiBiaXRwYWNrUG9zICYgbWFzayAvLyBUT0RPOiBkb24ndCByZS1yZWFkIHZhbHVlIGV2ZXJ5IHRpbWVcbiAgICAgICAgICBiaXRwYWNrUG9zICs9IGJpdFdpZHRoXG4gICAgICAgICAgd2hpbGUgKGJpdHBhY2tQb3MgPj0gOCkge1xuICAgICAgICAgICAgYml0cGFja1BvcyAtPSA4blxuICAgICAgICAgICAgcmVhZGVyLm9mZnNldCsrXG4gICAgICAgICAgICBpZiAoYml0cGFja1Bvcykge1xuICAgICAgICAgICAgICBiaXRzIHw9IEJpZ0ludChyZWFkZXIudmlldy5nZXRVaW50OChyZWFkZXIub2Zmc2V0KSkgPDwgYml0V2lkdGggLSBiaXRwYWNrUG9zICYgbWFza1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWx0YSA9IG1pbkRlbHRhICsgYml0c1xuICAgICAgICAgIHZhbHVlICs9IGRlbHRhXG4gICAgICAgICAgb3V0cHV0W291dHB1dEluZGV4KytdID0gaW50MzIgPyBOdW1iZXIodmFsdWUpIDogdmFsdWVcbiAgICAgICAgICBtaW5pYmxvY2tDb3VudC0tXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbmlibG9ja0NvdW50KSB7XG4gICAgICAgICAgLy8gY29uc3VtZSBsZWZ0b3ZlciBtaW5pYmxvY2tcbiAgICAgICAgICByZWFkZXIub2Zmc2V0ICs9IE1hdGguY2VpbCgobWluaWJsb2NrQ291bnQgKiBOdW1iZXIoYml0V2lkdGgpICsgTnVtYmVyKGJpdHBhY2tQb3MpKSAvIDgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzUGVyTWluaWJsb2NrICYmIG91dHB1dEluZGV4IDwgY291bnQ7IGorKykge1xuICAgICAgICAgIHZhbHVlICs9IG1pbkRlbHRhXG4gICAgICAgICAgb3V0cHV0W291dHB1dEluZGV4KytdID0gaW50MzIgPyBOdW1iZXIodmFsdWUpIDogdmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBvdXRwdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbHRhTGVuZ3RoQnl0ZUFycmF5KHJlYWRlciwgY291bnQsIG91dHB1dCkge1xuICBjb25zdCBsZW5ndGhzID0gbmV3IEludDMyQXJyYXkoY291bnQpXG4gIGRlbHRhQmluYXJ5VW5wYWNrKHJlYWRlciwgY291bnQsIGxlbmd0aHMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIG91dHB1dFtpXSA9IG5ldyBVaW50OEFycmF5KHJlYWRlci52aWV3LmJ1ZmZlciwgcmVhZGVyLnZpZXcuYnl0ZU9mZnNldCArIHJlYWRlci5vZmZzZXQsIGxlbmd0aHNbaV0pXG4gICAgcmVhZGVyLm9mZnNldCArPSBsZW5ndGhzW2ldXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXlbXX0gb3V0cHV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWx0YUJ5dGVBcnJheShyZWFkZXIsIGNvdW50LCBvdXRwdXQpIHtcbiAgY29uc3QgcHJlZml4RGF0YSA9IG5ldyBJbnQzMkFycmF5KGNvdW50KVxuICBkZWx0YUJpbmFyeVVucGFjayhyZWFkZXIsIGNvdW50LCBwcmVmaXhEYXRhKVxuICBjb25zdCBzdWZmaXhEYXRhID0gbmV3IEludDMyQXJyYXkoY291bnQpXG4gIGRlbHRhQmluYXJ5VW5wYWNrKHJlYWRlciwgY291bnQsIHN1ZmZpeERhdGEpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgc3VmZml4ID0gbmV3IFVpbnQ4QXJyYXkocmVhZGVyLnZpZXcuYnVmZmVyLCByZWFkZXIudmlldy5ieXRlT2Zmc2V0ICsgcmVhZGVyLm9mZnNldCwgc3VmZml4RGF0YVtpXSlcbiAgICBpZiAocHJlZml4RGF0YVtpXSkge1xuICAgICAgLy8gY29weSBmcm9tIHByZXZpb3VzIHZhbHVlXG4gICAgICBvdXRwdXRbaV0gPSBuZXcgVWludDhBcnJheShwcmVmaXhEYXRhW2ldICsgc3VmZml4RGF0YVtpXSlcbiAgICAgIG91dHB1dFtpXS5zZXQob3V0cHV0W2kgLSAxXS5zdWJhcnJheSgwLCBwcmVmaXhEYXRhW2ldKSlcbiAgICAgIG91dHB1dFtpXS5zZXQoc3VmZml4LCBwcmVmaXhEYXRhW2ldKVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRbaV0gPSBzdWZmaXhcbiAgICB9XG4gICAgcmVhZGVyLm9mZnNldCArPSBzdWZmaXhEYXRhW2ldXG4gIH1cbn1cbiIsImltcG9ydCB7IHJlYWRWYXJJbnQgfSBmcm9tICcuL3RocmlmdC5qcydcblxuLyoqXG4gKiBNaW5pbXVtIGJpdHMgbmVlZGVkIHRvIHN0b3JlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdFdpZHRoKHZhbHVlKSB7XG4gIHJldHVybiAzMiAtIE1hdGguY2x6MzIodmFsdWUpXG59XG5cbi8qKlxuICogUmVhZCB2YWx1ZXMgZnJvbSBhIHJ1bi1sZW5ndGggZW5jb2RlZC9iaXQtcGFja2VkIGh5YnJpZCBlbmNvZGluZy5cbiAqXG4gKiBJZiBsZW5ndGggaXMgemVybywgdGhlbiByZWFkIGludDMyIGxlbmd0aCBhdCB0aGUgc3RhcnQuXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5EYXRhUmVhZGVyfSBEYXRhUmVhZGVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkRlY29kZWRBcnJheX0gRGVjb2RlZEFycmF5XG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gd2lkdGggb2YgZWFjaCBiaXQtcGFja2VkIGdyb3VwXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIC0gbGVuZ3RoIG9mIHRoZSBlbmNvZGVkIGRhdGFcbiAqIEBwYXJhbSB7RGVjb2RlZEFycmF5fSBvdXRwdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRSbGVCaXRQYWNrZWRIeWJyaWQocmVhZGVyLCB3aWR0aCwgbGVuZ3RoLCBvdXRwdXQpIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICAvLyBsZW5ndGggPSByZWFkZXIudmlldy5nZXRVaW50MzIocmVhZGVyLm9mZnNldCwgdHJ1ZSlcbiAgICByZWFkZXIub2Zmc2V0ICs9IDRcbiAgfVxuICBsZXQgc2VlbiA9IDBcbiAgd2hpbGUgKHNlZW4gPCBvdXRwdXQubGVuZ3RoKSB7XG4gICAgY29uc3QgaGVhZGVyID0gcmVhZFZhckludChyZWFkZXIpXG4gICAgaWYgKGhlYWRlciAmIDEpIHtcbiAgICAgIC8vIGJpdC1wYWNrZWRcbiAgICAgIHNlZW4gPSByZWFkQml0UGFja2VkKHJlYWRlciwgaGVhZGVyLCB3aWR0aCwgb3V0cHV0LCBzZWVuKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBybGVcbiAgICAgIGNvbnN0IGNvdW50ID0gaGVhZGVyID4+PiAxXG4gICAgICByZWFkUmxlKHJlYWRlciwgY291bnQsIHdpZHRoLCBvdXRwdXQsIHNlZW4pXG4gICAgICBzZWVuICs9IGNvdW50XG4gICAgfVxuICB9XG4gIC8vIGFzc2VydChyZWFkZXIub2Zmc2V0IC0gc3RhcnRPZmZzZXQgPT09IGxlbmd0aClcbn1cblxuLyoqXG4gKiBSdW4tbGVuZ3RoIGVuY29kaW5nOiByZWFkIHZhbHVlIHdpdGggYml0V2lkdGggYW5kIHJlcGVhdCBpdCBjb3VudCB0aW1lcy5cbiAqXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge251bWJlcn0gYml0V2lkdGhcbiAqIEBwYXJhbSB7RGVjb2RlZEFycmF5fSBvdXRwdXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWVuXG4gKi9cbmZ1bmN0aW9uIHJlYWRSbGUocmVhZGVyLCBjb3VudCwgYml0V2lkdGgsIG91dHB1dCwgc2Vlbikge1xuICBjb25zdCB3aWR0aCA9IGJpdFdpZHRoICsgNyA+PiAzXG4gIGxldCB2YWx1ZSA9IDBcbiAgaWYgKHdpZHRoID09PSAxKSB7XG4gICAgdmFsdWUgPSByZWFkZXIudmlldy5nZXRVaW50OChyZWFkZXIub2Zmc2V0KVxuICAgIC8vIGFzc2VydCh2YWx1ZSA8IDEgPDwgYml0V2lkdGgpXG4gIH0gZWxzZSBpZiAod2lkdGggPT09IDIpIHtcbiAgICB2YWx1ZSA9IHJlYWRlci52aWV3LmdldFVpbnQxNihyZWFkZXIub2Zmc2V0LCB0cnVlKVxuICB9IGVsc2UgaWYgKHdpZHRoID09PSA0KSB7XG4gICAgdmFsdWUgPSByZWFkZXIudmlldy5nZXRVaW50MzIocmVhZGVyLm9mZnNldCwgdHJ1ZSlcbiAgfSBlbHNlIGlmICh3aWR0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFycXVldCBpbnZhbGlkIHJsZSB3aWR0aCAke3dpZHRofWApXG4gIH1cbiAgcmVhZGVyLm9mZnNldCArPSB3aWR0aFxuXG4gIC8vIHJlcGVhdCB2YWx1ZSBjb3VudCB0aW1lc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICBvdXRwdXRbc2VlbiArIGldID0gdmFsdWVcbiAgfVxufVxuXG4vKipcbiAqIFJlYWQgYSBiaXQtcGFja2VkIHJ1biBvZiB0aGUgcmxlL2JpdHBhY2sgaHlicmlkLlxuICogU3VwcG9ydHMgd2lkdGggPiA4IChjcm9zc2luZyBieXRlcykuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWFkZXIgLSBiaXQtcGFjayBoZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRXaWR0aFxuICogQHBhcmFtIHtEZWNvZGVkQXJyYXl9IG91dHB1dFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZW5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRvdGFsIG91dHB1dCB2YWx1ZXMgc28gZmFyXG4gKi9cbmZ1bmN0aW9uIHJlYWRCaXRQYWNrZWQocmVhZGVyLCBoZWFkZXIsIGJpdFdpZHRoLCBvdXRwdXQsIHNlZW4pIHtcbiAgbGV0IGNvdW50ID0gaGVhZGVyID4+IDEgPDwgMyAvLyB2YWx1ZXMgdG8gcmVhZFxuICBjb25zdCBtYXNrID0gKDEgPDwgYml0V2lkdGgpIC0gMVxuXG4gIGxldCBkYXRhID0gMFxuICBpZiAocmVhZGVyLm9mZnNldCA8IHJlYWRlci52aWV3LmJ5dGVMZW5ndGgpIHtcbiAgICBkYXRhID0gcmVhZGVyLnZpZXcuZ2V0VWludDgocmVhZGVyLm9mZnNldCsrKVxuICB9IGVsc2UgaWYgKG1hc2spIHtcbiAgICAvLyBzb21ldGltZXMgb3V0LW9mLWJvdW5kcyByZWFkcyBhcmUgbWFza2VkIG91dFxuICAgIHRocm93IG5ldyBFcnJvcihgcGFycXVldCBiaXRwYWNrIG9mZnNldCAke3JlYWRlci5vZmZzZXR9IG91dCBvZiByYW5nZWApXG4gIH1cbiAgbGV0IGxlZnQgPSA4XG4gIGxldCByaWdodCA9IDBcblxuICAvLyByZWFkIHZhbHVlc1xuICB3aGlsZSAoY291bnQpIHtcbiAgICAvLyBpZiB3ZSBoYXZlIGNyb3NzZWQgYSBieXRlIGJvdW5kYXJ5LCBzaGlmdCB0aGUgZGF0YVxuICAgIGlmIChyaWdodCA+IDgpIHtcbiAgICAgIHJpZ2h0IC09IDhcbiAgICAgIGxlZnQgLT0gOFxuICAgICAgZGF0YSA+Pj0gOFxuICAgIH0gZWxzZSBpZiAobGVmdCAtIHJpZ2h0IDwgYml0V2lkdGgpIHtcbiAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYml0V2lkdGggbnVtYmVyIG9mIGJpdHMgdG8gcmVhZCwgcmVhZCBuZXh0IGJ5dGVcbiAgICAgIGRhdGEgfD0gcmVhZGVyLnZpZXcuZ2V0VWludDgocmVhZGVyLm9mZnNldCkgPDwgbGVmdFxuICAgICAgcmVhZGVyLm9mZnNldCsrXG4gICAgICBsZWZ0ICs9IDhcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNlZW4gPCBvdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgIC8vIGVtaXQgdmFsdWVcbiAgICAgICAgb3V0cHV0W3NlZW4rK10gPSBkYXRhID4+IHJpZ2h0ICYgbWFza1xuICAgICAgfVxuICAgICAgY291bnQtLVxuICAgICAgcmlnaHQgKz0gYml0V2lkdGhcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VlblxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuUGFycXVldFR5cGV9IFBhcnF1ZXRUeXBlXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge1BhcnF1ZXRUeXBlfSB0eXBlXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gdHlwZUxlbmd0aFxuICogQHJldHVybnMge0RlY29kZWRBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTdHJlYW1TcGxpdChyZWFkZXIsIGNvdW50LCB0eXBlLCB0eXBlTGVuZ3RoKSB7XG4gIGNvbnN0IHdpZHRoID0gYnl0ZVdpZHRoKHR5cGUsIHR5cGVMZW5ndGgpXG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQgKiB3aWR0aClcbiAgZm9yIChsZXQgYiA9IDA7IGIgPCB3aWR0aDsgYisrKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBieXRlc1tpICogd2lkdGggKyBiXSA9IHJlYWRlci52aWV3LmdldFVpbnQ4KHJlYWRlci5vZmZzZXQrKylcbiAgICB9XG4gIH1cbiAgLy8gaW50ZXJwcmV0IGJ5dGVzIGFzIHR5cGVkIGFycmF5XG4gIGlmICh0eXBlID09PSAnRkxPQVQnKSByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShieXRlcy5idWZmZXIpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdET1VCTEUnKSByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShieXRlcy5idWZmZXIpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdJTlQzMicpIHJldHVybiBuZXcgSW50MzJBcnJheShieXRlcy5idWZmZXIpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdJTlQ2NCcpIHJldHVybiBuZXcgQmlnSW50NjRBcnJheShieXRlcy5idWZmZXIpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdGSVhFRF9MRU5fQllURV9BUlJBWScpIHtcbiAgICAvLyBzcGxpdCBpbnRvIGFycmF5cyBvZiB0eXBlTGVuZ3RoXG4gICAgY29uc3Qgc3BsaXQgPSBuZXcgQXJyYXkoY291bnQpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBzcGxpdFtpXSA9IGJ5dGVzLnN1YmFycmF5KGkgKiB3aWR0aCwgKGkgKyAxKSAqIHdpZHRoKVxuICAgIH1cbiAgICByZXR1cm4gc3BsaXRcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYHBhcnF1ZXQgYnl0ZV9zdHJlYW1fc3BsaXQgdW5zdXBwb3J0ZWQgdHlwZTogJHt0eXBlfWApXG59XG5cbi8qKlxuICogQHBhcmFtIHtQYXJxdWV0VHlwZX0gdHlwZVxuICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHR5cGVMZW5ndGhcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGJ5dGVXaWR0aCh0eXBlLCB0eXBlTGVuZ3RoKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlICdJTlQzMic6XG4gIGNhc2UgJ0ZMT0FUJzpcbiAgICByZXR1cm4gNFxuICBjYXNlICdJTlQ2NCc6XG4gIGNhc2UgJ0RPVUJMRSc6XG4gICAgcmV0dXJuIDhcbiAgY2FzZSAnRklYRURfTEVOX0JZVEVfQVJSQVknOlxuICAgIGlmICghdHlwZUxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGJ5dGVXaWR0aCBtaXNzaW5nIHR5cGVfbGVuZ3RoJylcbiAgICByZXR1cm4gdHlwZUxlbmd0aFxuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihgcGFycXVldCB1bnN1cHBvcnRlZCB0eXBlOiAke3R5cGV9YClcbiAgfVxufVxuIiwiaW1wb3J0IHsgRW5jb2RpbmcsIFBhZ2VUeXBlIH0gZnJvbSAnLi9jb25zdGFudHMuanMnXG5pbXBvcnQgeyBkZXNlcmlhbGl6ZVRDb21wYWN0UHJvdG9jb2wgfSBmcm9tICcuL3RocmlmdC5qcydcblxuLyoqXG4gKiBSZWFkIHBhcnF1ZXQgaGVhZGVyIGZyb20gYSBidWZmZXIuXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5EYXRhUmVhZGVyfSBEYXRhUmVhZGVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLlBhZ2VIZWFkZXJ9IFBhZ2VIZWFkZXJcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIC0gcGFycXVldCBmaWxlIHJlYWRlclxuICogQHJldHVybnMge1BhZ2VIZWFkZXJ9IG1ldGFkYXRhIG9iamVjdCBhbmQgYnl0ZXMgcmVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFycXVldEhlYWRlcihyZWFkZXIpIHtcbiAgY29uc3QgaGVhZGVyID0gZGVzZXJpYWxpemVUQ29tcGFjdFByb3RvY29sKHJlYWRlcilcblxuICAvLyBQYXJzZSBwYXJxdWV0IGhlYWRlciBmcm9tIHRocmlmdCBkYXRhXG4gIGNvbnN0IHR5cGUgPSBQYWdlVHlwZVtoZWFkZXIuZmllbGRfMV1cbiAgY29uc3QgdW5jb21wcmVzc2VkX3BhZ2Vfc2l6ZSA9IGhlYWRlci5maWVsZF8yXG4gIGNvbnN0IGNvbXByZXNzZWRfcGFnZV9zaXplID0gaGVhZGVyLmZpZWxkXzNcbiAgY29uc3QgY3JjID0gaGVhZGVyLmZpZWxkXzRcbiAgY29uc3QgZGF0YV9wYWdlX2hlYWRlciA9IGhlYWRlci5maWVsZF81ICYmIHtcbiAgICBudW1fdmFsdWVzOiBoZWFkZXIuZmllbGRfNS5maWVsZF8xLFxuICAgIGVuY29kaW5nOiBFbmNvZGluZ1toZWFkZXIuZmllbGRfNS5maWVsZF8yXSxcbiAgICBkZWZpbml0aW9uX2xldmVsX2VuY29kaW5nOiBFbmNvZGluZ1toZWFkZXIuZmllbGRfNS5maWVsZF8zXSxcbiAgICByZXBldGl0aW9uX2xldmVsX2VuY29kaW5nOiBFbmNvZGluZ1toZWFkZXIuZmllbGRfNS5maWVsZF80XSxcbiAgICBzdGF0aXN0aWNzOiBoZWFkZXIuZmllbGRfNS5maWVsZF81ICYmIHtcbiAgICAgIG1heDogaGVhZGVyLmZpZWxkXzUuZmllbGRfNS5maWVsZF8xLFxuICAgICAgbWluOiBoZWFkZXIuZmllbGRfNS5maWVsZF81LmZpZWxkXzIsXG4gICAgICBudWxsX2NvdW50OiBoZWFkZXIuZmllbGRfNS5maWVsZF81LmZpZWxkXzMsXG4gICAgICBkaXN0aW5jdF9jb3VudDogaGVhZGVyLmZpZWxkXzUuZmllbGRfNS5maWVsZF80LFxuICAgICAgbWF4X3ZhbHVlOiBoZWFkZXIuZmllbGRfNS5maWVsZF81LmZpZWxkXzUsXG4gICAgICBtaW5fdmFsdWU6IGhlYWRlci5maWVsZF81LmZpZWxkXzUuZmllbGRfNixcbiAgICB9LFxuICB9XG4gIGNvbnN0IGluZGV4X3BhZ2VfaGVhZGVyID0gaGVhZGVyLmZpZWxkXzZcbiAgY29uc3QgZGljdGlvbmFyeV9wYWdlX2hlYWRlciA9IGhlYWRlci5maWVsZF83ICYmIHtcbiAgICBudW1fdmFsdWVzOiBoZWFkZXIuZmllbGRfNy5maWVsZF8xLFxuICAgIGVuY29kaW5nOiBFbmNvZGluZ1toZWFkZXIuZmllbGRfNy5maWVsZF8yXSxcbiAgICBpc19zb3J0ZWQ6IGhlYWRlci5maWVsZF83LmZpZWxkXzMsXG4gIH1cbiAgY29uc3QgZGF0YV9wYWdlX2hlYWRlcl92MiA9IGhlYWRlci5maWVsZF84ICYmIHtcbiAgICBudW1fdmFsdWVzOiBoZWFkZXIuZmllbGRfOC5maWVsZF8xLFxuICAgIG51bV9udWxsczogaGVhZGVyLmZpZWxkXzguZmllbGRfMixcbiAgICBudW1fcm93czogaGVhZGVyLmZpZWxkXzguZmllbGRfMyxcbiAgICBlbmNvZGluZzogRW5jb2RpbmdbaGVhZGVyLmZpZWxkXzguZmllbGRfNF0sXG4gICAgZGVmaW5pdGlvbl9sZXZlbHNfYnl0ZV9sZW5ndGg6IGhlYWRlci5maWVsZF84LmZpZWxkXzUsXG4gICAgcmVwZXRpdGlvbl9sZXZlbHNfYnl0ZV9sZW5ndGg6IGhlYWRlci5maWVsZF84LmZpZWxkXzYsXG4gICAgaXNfY29tcHJlc3NlZDogaGVhZGVyLmZpZWxkXzguZmllbGRfNyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGhlYWRlci5maWVsZF84LmZpZWxkXzcsIC8vIGRlZmF1bHQgdHJ1ZVxuICAgIHN0YXRpc3RpY3M6IGhlYWRlci5maWVsZF84LmZpZWxkXzgsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgdW5jb21wcmVzc2VkX3BhZ2Vfc2l6ZSxcbiAgICBjb21wcmVzc2VkX3BhZ2Vfc2l6ZSxcbiAgICBjcmMsXG4gICAgZGF0YV9wYWdlX2hlYWRlcixcbiAgICBpbmRleF9wYWdlX2hlYWRlcixcbiAgICBkaWN0aW9uYXJ5X3BhZ2VfaGVhZGVyLFxuICAgIGRhdGFfcGFnZV9oZWFkZXJfdjIsXG4gIH1cbn1cbiIsImltcG9ydCB7IHBhcnF1ZXRNZXRhZGF0YSwgcGFycXVldE1ldGFkYXRhQXN5bmMsIHBhcnF1ZXRTY2hlbWEgfSBmcm9tICcuL21ldGFkYXRhLmpzJ1xuZXhwb3J0IHsgcGFycXVldE1ldGFkYXRhLCBwYXJxdWV0TWV0YWRhdGFBc3luYywgcGFycXVldFNjaGVtYSB9XG5cbmltcG9ydCB7IHBhcnF1ZXRSZWFkIH0gZnJvbSAnLi9yZWFkLmpzJ1xuZXhwb3J0IHsgcGFycXVldFJlYWQgfVxuXG5pbXBvcnQgeyBzbmFwcHlVbmNvbXByZXNzIH0gZnJvbSAnLi9zbmFwcHkuanMnXG5leHBvcnQgeyBzbmFwcHlVbmNvbXByZXNzIH1cblxuaW1wb3J0IHsgdG9Kc29uIH0gZnJvbSAnLi91dGlscy5qcydcbmV4cG9ydCB7IHRvSnNvbiB9XG4iLCJpbXBvcnQgeyBDb21wcmVzc2lvbkNvZGVjLCBDb252ZXJ0ZWRUeXBlLCBFbmNvZGluZywgRmllbGRSZXBldGl0aW9uVHlwZSwgUGFnZVR5cGUsIFBhcnF1ZXRUeXBlIH0gZnJvbSAnLi9jb25zdGFudHMuanMnXG5pbXBvcnQgeyBwYXJzZUZsb2F0MTYgfSBmcm9tICcuL2NvbnZlcnQuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFQYXRoIH0gZnJvbSAnLi9zY2hlbWEuanMnXG5pbXBvcnQgeyBkZXNlcmlhbGl6ZVRDb21wYWN0UHJvdG9jb2wgfSBmcm9tICcuL3RocmlmdC5qcydcblxuLyoqXG4gKiBSZWFkIHBhcnF1ZXQgbWV0YWRhdGEgZnJvbSBhbiBhc3luYyBidWZmZXIuXG4gKlxuICogQW4gQXN5bmNCdWZmZXIgaXMgbGlrZSBhbiBBcnJheUJ1ZmZlciwgYnV0IHRoZSBzbGljZXMgYXJlIGxvYWRlZFxuICogYXN5bmNocm9ub3VzbHksIHBvc3NpYmx5IG92ZXIgdGhlIG5ldHdvcmsuXG4gKlxuICogWW91IG11c3QgcHJvdmlkZSB0aGUgYnl0ZUxlbmd0aCBvZiB0aGUgYnVmZmVyLCB0eXBpY2FsbHkgZnJvbSBhIEhFQUQgcmVxdWVzdC5cbiAqXG4gKiBJbiB0aGVvcnksIHlvdSBjb3VsZCB1c2Ugc3VmZml4LXJhbmdlIHJlcXVlc3RzIHRvIGZldGNoIHRoZSBlbmQgb2YgdGhlIGZpbGUsXG4gKiBhbmQgc2F2ZSBhIHJvdW5kIHRyaXAuIEJ1dCBpbiBwcmFjdGljZSwgdGhpcyBkb2Vzbid0IHdvcmsgYmVjYXVzZSBjaHJvbWVcbiAqIGRlZW1zIHN1ZmZpeC1yYW5nZSByZXF1ZXN0cyBhcyBhIG5vdC1zYWZlLWxpc3RlZCBoZWFkZXIsIGFuZCB3aWxsIHJlcXVpcmVcbiAqIGEgcHJlLWZsaWdodC4gU28gdGhlIGJ5dGVMZW5ndGggaXMgcmVxdWlyZWQuXG4gKlxuICogVG8gbWFrZSB0aGlzIGVmZmljaWVudCwgd2UgaW5pdGlhbGx5IHJlcXVlc3QgdGhlIGxhc3QgNTEya2Igb2YgdGhlIGZpbGUsXG4gKiB3aGljaCBpcyBsaWtlbHkgdG8gY29udGFpbiB0aGUgbWV0YWRhdGEuIElmIHRoZSBtZXRhZGF0YSBsZW5ndGggZXhjZWVkcyB0aGVcbiAqIGluaXRpYWwgZmV0Y2gsIDUxMmtiLCB3ZSByZXF1ZXN0IHRoZSByZXN0IG9mIHRoZSBtZXRhZGF0YSBmcm9tIHRoZSBBc3luY0J1ZmZlci5cbiAqXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBlaXRoZXIgbWFrZSBvbmUgNTEya2IgaW5pdGlhbCByZXF1ZXN0IGZvciB0aGUgbWV0YWRhdGEsXG4gKiBvciBhIHNlY29uZCByZXF1ZXN0IGZvciB1cCB0byB0aGUgbWV0YWRhdGEgc2l6ZS5cbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkFzeW5jQnVmZmVyfSBBc3luY0J1ZmZlclxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5GaWxlTWV0YURhdGF9IEZpbGVNZXRhRGF0YVxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5TY2hlbWFFbGVtZW50fSBTY2hlbWFFbGVtZW50XG4gKiBAcGFyYW0ge0FzeW5jQnVmZmVyfSBhc3luY0J1ZmZlciBwYXJxdWV0IGZpbGUgY29udGVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbml0aWFsRmV0Y2hTaXplIGluaXRpYWwgZmV0Y2ggc2l6ZSBpbiBieXRlc1xuICogQHJldHVybnMge1Byb21pc2U8RmlsZU1ldGFEYXRhPn0gcGFycXVldCBtZXRhZGF0YSBvYmplY3RcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnF1ZXRNZXRhZGF0YUFzeW5jKGFzeW5jQnVmZmVyLCBpbml0aWFsRmV0Y2hTaXplID0gMSA8PCAxOSAvKiA1MTJrYiAqLykge1xuICBpZiAoIWFzeW5jQnVmZmVyKSB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgZmlsZSBpcyByZXF1aXJlZCcpXG4gIGlmICghKGFzeW5jQnVmZmVyLmJ5dGVMZW5ndGggPj0gMCkpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBmaWxlIGJ5dGVMZW5ndGggaXMgcmVxdWlyZWQnKVxuXG4gIC8vIGZldGNoIGxhc3QgYnl0ZXMgKGZvb3Rlcikgb2YgdGhlIGZpbGVcbiAgY29uc3QgZm9vdGVyT2Zmc2V0ID0gTWF0aC5tYXgoMCwgYXN5bmNCdWZmZXIuYnl0ZUxlbmd0aCAtIGluaXRpYWxGZXRjaFNpemUpXG4gIGNvbnN0IGZvb3RlckJ1ZmZlciA9IGF3YWl0IGFzeW5jQnVmZmVyLnNsaWNlKGZvb3Rlck9mZnNldCwgYXN5bmNCdWZmZXIuYnl0ZUxlbmd0aClcblxuICAvLyBDaGVjayBmb3IgcGFycXVldCBtYWdpYyBudW1iZXIgXCJQQVIxXCJcbiAgY29uc3QgZm9vdGVyVmlldyA9IG5ldyBEYXRhVmlldyhmb290ZXJCdWZmZXIpXG4gIGlmIChmb290ZXJWaWV3LmdldFVpbnQzMihmb290ZXJCdWZmZXIuYnl0ZUxlbmd0aCAtIDQsIHRydWUpICE9PSAweDMxNTI0MTUwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGZpbGUgaW52YWxpZCAoZm9vdGVyICE9IFBBUjEpJylcbiAgfVxuXG4gIC8vIFBhcnF1ZXQgZmlsZXMgc3RvcmUgbWV0YWRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZVxuICAvLyBNZXRhZGF0YSBsZW5ndGggaXMgNCBieXRlcyBiZWZvcmUgdGhlIGxhc3QgUEFSMVxuICBjb25zdCBtZXRhZGF0YUxlbmd0aCA9IGZvb3RlclZpZXcuZ2V0VWludDMyKGZvb3RlckJ1ZmZlci5ieXRlTGVuZ3RoIC0gOCwgdHJ1ZSlcbiAgaWYgKG1ldGFkYXRhTGVuZ3RoID4gYXN5bmNCdWZmZXIuYnl0ZUxlbmd0aCAtIDgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnF1ZXQgbWV0YWRhdGEgbGVuZ3RoICR7bWV0YWRhdGFMZW5ndGh9IGV4Y2VlZHMgYXZhaWxhYmxlIGJ1ZmZlciAke2FzeW5jQnVmZmVyLmJ5dGVMZW5ndGggLSA4fWApXG4gIH1cblxuICAvLyBjaGVjayBpZiBtZXRhZGF0YSBzaXplIGZpdHMgaW5zaWRlIHRoZSBpbml0aWFsIGZldGNoXG4gIGlmIChtZXRhZGF0YUxlbmd0aCArIDggPiBpbml0aWFsRmV0Y2hTaXplKSB7XG4gICAgLy8gZmV0Y2ggdGhlIHJlc3Qgb2YgdGhlIG1ldGFkYXRhXG4gICAgY29uc3QgbWV0YWRhdGFPZmZzZXQgPSBhc3luY0J1ZmZlci5ieXRlTGVuZ3RoIC0gbWV0YWRhdGFMZW5ndGggLSA4XG4gICAgY29uc3QgbWV0YWRhdGFCdWZmZXIgPSBhd2FpdCBhc3luY0J1ZmZlci5zbGljZShtZXRhZGF0YU9mZnNldCwgZm9vdGVyT2Zmc2V0KVxuICAgIC8vIGNvbWJpbmUgaW5pdGlhbCBmZXRjaCB3aXRoIHRoZSBuZXcgc2xpY2VcbiAgICBjb25zdCBjb21iaW5lZEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihtZXRhZGF0YUxlbmd0aCArIDgpXG4gICAgY29uc3QgY29tYmluZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoY29tYmluZWRCdWZmZXIpXG4gICAgY29tYmluZWRWaWV3LnNldChuZXcgVWludDhBcnJheShtZXRhZGF0YUJ1ZmZlcikpXG4gICAgY29tYmluZWRWaWV3LnNldChuZXcgVWludDhBcnJheShmb290ZXJCdWZmZXIpLCBmb290ZXJPZmZzZXQgLSBtZXRhZGF0YU9mZnNldClcbiAgICByZXR1cm4gcGFycXVldE1ldGFkYXRhKGNvbWJpbmVkQnVmZmVyKVxuICB9IGVsc2Uge1xuICAgIC8vIHBhcnNlIG1ldGFkYXRhIGZyb20gdGhlIGZvb3RlclxuICAgIHJldHVybiBwYXJxdWV0TWV0YWRhdGEoZm9vdGVyQnVmZmVyKVxuICB9XG59XG5cbi8qKlxuICogUmVhZCBwYXJxdWV0IG1ldGFkYXRhIGZyb20gYSBidWZmZXIgc3luY2hyb25vdXNseS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBwYXJxdWV0IGZpbGUgY29udGVudHNcbiAqIEByZXR1cm5zIHtGaWxlTWV0YURhdGF9IHBhcnF1ZXQgbWV0YWRhdGEgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJxdWV0TWV0YWRhdGEoYXJyYXlCdWZmZXIpIHtcbiAgaWYgKCFhcnJheUJ1ZmZlcikgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGZpbGUgaXMgcmVxdWlyZWQnKVxuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKVxuXG4gIC8vIFZhbGlkYXRlIGZvb3RlciBtYWdpYyBudW1iZXIgXCJQQVIxXCJcbiAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA8IDgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgZmlsZSBpcyB0b28gc2hvcnQnKVxuICB9XG4gIGlmICh2aWV3LmdldFVpbnQzMih2aWV3LmJ5dGVMZW5ndGggLSA0LCB0cnVlKSAhPT0gMHgzMTUyNDE1MCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFycXVldCBmaWxlIGludmFsaWQgKGZvb3RlciAhPSBQQVIxKScpXG4gIH1cblxuICAvLyBQYXJxdWV0IGZpbGVzIHN0b3JlIG1ldGFkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGVcbiAgLy8gTWV0YWRhdGEgbGVuZ3RoIGlzIDQgYnl0ZXMgYmVmb3JlIHRoZSBsYXN0IFBBUjFcbiAgY29uc3QgbWV0YWRhdGFMZW5ndGhPZmZzZXQgPSB2aWV3LmJ5dGVMZW5ndGggLSA4XG4gIGNvbnN0IG1ldGFkYXRhTGVuZ3RoID0gdmlldy5nZXRVaW50MzIobWV0YWRhdGFMZW5ndGhPZmZzZXQsIHRydWUpXG4gIGlmIChtZXRhZGF0YUxlbmd0aCA+IHZpZXcuYnl0ZUxlbmd0aCAtIDgpIHtcbiAgICAvLyB7bWV0YWRhdGF9LCBtZXRhZGF0YV9sZW5ndGgsIFBBUjFcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnF1ZXQgbWV0YWRhdGEgbGVuZ3RoICR7bWV0YWRhdGFMZW5ndGh9IGV4Y2VlZHMgYXZhaWxhYmxlIGJ1ZmZlciAke3ZpZXcuYnl0ZUxlbmd0aCAtIDh9YClcbiAgfVxuXG4gIGNvbnN0IG1ldGFkYXRhT2Zmc2V0ID0gbWV0YWRhdGFMZW5ndGhPZmZzZXQgLSBtZXRhZGF0YUxlbmd0aFxuICBjb25zdCByZWFkZXIgPSB7IHZpZXcsIG9mZnNldDogbWV0YWRhdGFPZmZzZXQgfVxuICBjb25zdCBtZXRhZGF0YSA9IGRlc2VyaWFsaXplVENvbXBhY3RQcm90b2NvbChyZWFkZXIpXG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICBmdW5jdGlvbiBkZWNvZGUoLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiBkZWNvZGVyLmRlY29kZSh2YWx1ZSlcbiAgfVxuXG4gIC8vIFBhcnNlIG1ldGFkYXRhIGZyb20gdGhyaWZ0IGRhdGFcbiAgY29uc3QgdmVyc2lvbiA9IG1ldGFkYXRhLmZpZWxkXzFcbiAgLyoqIEB0eXBlIHtTY2hlbWFFbGVtZW50W119ICovXG4gIGNvbnN0IHNjaGVtYSA9IG1ldGFkYXRhLmZpZWxkXzIubWFwKCgvKiogQHR5cGUge2FueX0gKi8gZmllbGQpID0+ICh7XG4gICAgdHlwZTogUGFycXVldFR5cGVbZmllbGQuZmllbGRfMV0sXG4gICAgdHlwZV9sZW5ndGg6IGZpZWxkLmZpZWxkXzIsXG4gICAgcmVwZXRpdGlvbl90eXBlOiBGaWVsZFJlcGV0aXRpb25UeXBlW2ZpZWxkLmZpZWxkXzNdLFxuICAgIG5hbWU6IGRlY29kZShmaWVsZC5maWVsZF80KSxcbiAgICBudW1fY2hpbGRyZW46IGZpZWxkLmZpZWxkXzUsXG4gICAgY29udmVydGVkX3R5cGU6IENvbnZlcnRlZFR5cGVbZmllbGQuZmllbGRfNl0sXG4gICAgc2NhbGU6IGZpZWxkLmZpZWxkXzcsXG4gICAgcHJlY2lzaW9uOiBmaWVsZC5maWVsZF84LFxuICAgIGZpZWxkX2lkOiBmaWVsZC5maWVsZF85LFxuICAgIGxvZ2ljYWxfdHlwZTogbG9naWNhbFR5cGUoZmllbGQuZmllbGRfMTApLFxuICB9KSlcbiAgLy8gc2NoZW1hIGVsZW1lbnQgcGVyIGNvbHVtbiBpbmRleFxuICBjb25zdCBjb2x1bW5TY2hlbWEgPSBzY2hlbWEuZmlsdGVyKGUgPT4gZS50eXBlKVxuICBjb25zdCBudW1fcm93cyA9IG1ldGFkYXRhLmZpZWxkXzNcbiAgY29uc3Qgcm93X2dyb3VwcyA9IG1ldGFkYXRhLmZpZWxkXzQubWFwKCgvKiogQHR5cGUge2FueX0gKi8gcm93R3JvdXApID0+ICh7XG4gICAgY29sdW1uczogcm93R3JvdXAuZmllbGRfMS5tYXAoKC8qKiBAdHlwZSB7YW55fSAqLyBjb2x1bW4sIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBjb2x1bW5JbmRleCkgPT4gKHtcbiAgICAgIGZpbGVfcGF0aDogZGVjb2RlKGNvbHVtbi5maWVsZF8xKSxcbiAgICAgIGZpbGVfb2Zmc2V0OiBjb2x1bW4uZmllbGRfMixcbiAgICAgIG1ldGFfZGF0YTogY29sdW1uLmZpZWxkXzMgJiYge1xuICAgICAgICB0eXBlOiBQYXJxdWV0VHlwZVtjb2x1bW4uZmllbGRfMy5maWVsZF8xXSxcbiAgICAgICAgZW5jb2RpbmdzOiBjb2x1bW4uZmllbGRfMy5maWVsZF8yPy5tYXAoKC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBlKSA9PiBFbmNvZGluZ1tlXSksXG4gICAgICAgIHBhdGhfaW5fc2NoZW1hOiBjb2x1bW4uZmllbGRfMy5maWVsZF8zLm1hcChkZWNvZGUpLFxuICAgICAgICBjb2RlYzogQ29tcHJlc3Npb25Db2RlY1tjb2x1bW4uZmllbGRfMy5maWVsZF80XSxcbiAgICAgICAgbnVtX3ZhbHVlczogY29sdW1uLmZpZWxkXzMuZmllbGRfNSxcbiAgICAgICAgdG90YWxfdW5jb21wcmVzc2VkX3NpemU6IGNvbHVtbi5maWVsZF8zLmZpZWxkXzYsXG4gICAgICAgIHRvdGFsX2NvbXByZXNzZWRfc2l6ZTogY29sdW1uLmZpZWxkXzMuZmllbGRfNyxcbiAgICAgICAga2V5X3ZhbHVlX21ldGFkYXRhOiBjb2x1bW4uZmllbGRfMy5maWVsZF84LFxuICAgICAgICBkYXRhX3BhZ2Vfb2Zmc2V0OiBjb2x1bW4uZmllbGRfMy5maWVsZF85LFxuICAgICAgICBpbmRleF9wYWdlX29mZnNldDogY29sdW1uLmZpZWxkXzMuZmllbGRfMTAsXG4gICAgICAgIGRpY3Rpb25hcnlfcGFnZV9vZmZzZXQ6IGNvbHVtbi5maWVsZF8zLmZpZWxkXzExLFxuICAgICAgICBzdGF0aXN0aWNzOiBjb2x1bW5TdGF0cyhjb2x1bW4uZmllbGRfMy5maWVsZF8xMiwgY29sdW1uU2NoZW1hW2NvbHVtbkluZGV4XSksXG4gICAgICAgIGVuY29kaW5nX3N0YXRzOiBjb2x1bW4uZmllbGRfMy5maWVsZF8xMz8ubWFwKCgvKiogQHR5cGUge2FueX0gKi8gZW5jb2RpbmdTdGF0KSA9PiAoe1xuICAgICAgICAgIHBhZ2VfdHlwZTogUGFnZVR5cGVbZW5jb2RpbmdTdGF0LmZpZWxkXzFdLFxuICAgICAgICAgIGVuY29kaW5nOiBFbmNvZGluZ1tlbmNvZGluZ1N0YXQuZmllbGRfMl0sXG4gICAgICAgICAgY291bnQ6IGVuY29kaW5nU3RhdC5maWVsZF8zLFxuICAgICAgICB9KSksXG4gICAgICAgIGJsb29tX2ZpbHRlcl9vZmZzZXQ6IGNvbHVtbi5maWVsZF8zLmZpZWxkXzE0LFxuICAgICAgICBibG9vbV9maWx0ZXJfbGVuZ3RoOiBjb2x1bW4uZmllbGRfMy5maWVsZF8xNSxcbiAgICAgICAgc2l6ZV9zdGF0aXN0aWNzOiBjb2x1bW4uZmllbGRfMy5maWVsZF8xNiAmJiB7XG4gICAgICAgICAgdW5lbmNvZGVkX2J5dGVfYXJyYXlfZGF0YV9ieXRlczogY29sdW1uLmZpZWxkXzMuZmllbGRfMTYuZmllbGRfMSxcbiAgICAgICAgICByZXBldGl0aW9uX2xldmVsX2hpc3RvZ3JhbTogY29sdW1uLmZpZWxkXzMuZmllbGRfMTYuZmllbGRfMixcbiAgICAgICAgICBkZWZpbml0aW9uX2xldmVsX2hpc3RvZ3JhbTogY29sdW1uLmZpZWxkXzMuZmllbGRfMTYuZmllbGRfMyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBvZmZzZXRfaW5kZXhfb2Zmc2V0OiBjb2x1bW4uZmllbGRfNCxcbiAgICAgIG9mZnNldF9pbmRleF9sZW5ndGg6IGNvbHVtbi5maWVsZF81LFxuICAgICAgY29sdW1uX2luZGV4X29mZnNldDogY29sdW1uLmZpZWxkXzYsXG4gICAgICBjb2x1bW5faW5kZXhfbGVuZ3RoOiBjb2x1bW4uZmllbGRfNyxcbiAgICAgIGNyeXB0b19tZXRhZGF0YTogY29sdW1uLmZpZWxkXzcsXG4gICAgICBlbmNyeXB0ZWRfY29sdW1uX21ldGFkYXRhOiBjb2x1bW4uZmllbGRfOCxcbiAgICB9KSksXG4gICAgdG90YWxfYnl0ZV9zaXplOiByb3dHcm91cC5maWVsZF8yLFxuICAgIG51bV9yb3dzOiByb3dHcm91cC5maWVsZF8zLFxuICAgIHNvcnRpbmdfY29sdW1uczogcm93R3JvdXAuZmllbGRfND8ubWFwKCgvKiogQHR5cGUge2FueX0gKi8gc29ydGluZ0NvbHVtbikgPT4gKHtcbiAgICAgIGNvbHVtbl9pZHg6IHNvcnRpbmdDb2x1bW4uZmllbGRfMSxcbiAgICAgIGRlc2NlbmRpbmc6IHNvcnRpbmdDb2x1bW4uZmllbGRfMixcbiAgICAgIG51bGxzX2ZpcnN0OiBzb3J0aW5nQ29sdW1uLmZpZWxkXzMsXG4gICAgfSkpLFxuICAgIGZpbGVfb2Zmc2V0OiByb3dHcm91cC5maWVsZF81LFxuICAgIHRvdGFsX2NvbXByZXNzZWRfc2l6ZTogcm93R3JvdXAuZmllbGRfNixcbiAgICBvcmRpbmFsOiByb3dHcm91cC5maWVsZF83LFxuICB9KSlcbiAgY29uc3Qga2V5X3ZhbHVlX21ldGFkYXRhID0gbWV0YWRhdGEuZmllbGRfNT8ubWFwKCgvKiogQHR5cGUge2FueX0gKi8ga2V5VmFsdWUpID0+ICh7XG4gICAga2V5OiBkZWNvZGUoa2V5VmFsdWUuZmllbGRfMSksXG4gICAgdmFsdWU6IGRlY29kZShrZXlWYWx1ZS5maWVsZF8yKSxcbiAgfSkpXG4gIGNvbnN0IGNyZWF0ZWRfYnkgPSBkZWNvZGUobWV0YWRhdGEuZmllbGRfNilcblxuICByZXR1cm4ge1xuICAgIHZlcnNpb24sXG4gICAgc2NoZW1hLFxuICAgIG51bV9yb3dzLFxuICAgIHJvd19ncm91cHMsXG4gICAga2V5X3ZhbHVlX21ldGFkYXRhLFxuICAgIGNyZWF0ZWRfYnksXG4gICAgbWV0YWRhdGFfbGVuZ3RoOiBtZXRhZGF0YUxlbmd0aCxcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiBhIHRyZWUgb2Ygc2NoZW1hIGVsZW1lbnRzIGZyb20gcGFycXVldCBtZXRhZGF0YS5cbiAqXG4gKiBAcGFyYW0ge0ZpbGVNZXRhRGF0YX0gbWV0YWRhdGEgcGFycXVldCBtZXRhZGF0YSBvYmplY3RcbiAqIEByZXR1cm5zIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuU2NoZW1hVHJlZX0gdHJlZSBvZiBzY2hlbWEgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnF1ZXRTY2hlbWEobWV0YWRhdGEpIHtcbiAgcmV0dXJuIGdldFNjaGVtYVBhdGgobWV0YWRhdGEuc2NoZW1hLCBbXSlbMF1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gbG9naWNhbFR5cGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuTG9naWNhbFR5cGUgfCB1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGxvZ2ljYWxUeXBlKGxvZ2ljYWxUeXBlKSB7XG4gIGlmIChsb2dpY2FsVHlwZT8uZmllbGRfMSkgcmV0dXJuIHsgdHlwZTogJ1NUUklORycgfVxuICBpZiAobG9naWNhbFR5cGU/LmZpZWxkXzIpIHJldHVybiB7IHR5cGU6ICdNQVAnIH1cbiAgaWYgKGxvZ2ljYWxUeXBlPy5maWVsZF8zKSByZXR1cm4geyB0eXBlOiAnTElTVCcgfVxuICBpZiAobG9naWNhbFR5cGU/LmZpZWxkXzQpIHJldHVybiB7IHR5cGU6ICdFTlVNJyB9XG4gIGlmIChsb2dpY2FsVHlwZT8uZmllbGRfNSkgcmV0dXJuIHtcbiAgICB0eXBlOiAnREVDSU1BTCcsXG4gICAgc2NhbGU6IGxvZ2ljYWxUeXBlLmZpZWxkXzUuZmllbGRfMSxcbiAgICBwcmVjaXNpb246IGxvZ2ljYWxUeXBlLmZpZWxkXzUuZmllbGRfMixcbiAgfVxuICBpZiAobG9naWNhbFR5cGU/LmZpZWxkXzYpIHJldHVybiB7IHR5cGU6ICdEQVRFJyB9XG4gIGlmIChsb2dpY2FsVHlwZT8uZmllbGRfNykgcmV0dXJuIHtcbiAgICB0eXBlOiAnVElNRScsXG4gICAgaXNBZGp1c3RlZFRvVVRDOiBsb2dpY2FsVHlwZS5maWVsZF83LmZpZWxkXzEsXG4gICAgdW5pdDogbG9naWNhbFR5cGUuZmllbGRfNy5maWVsZF8yLFxuICB9XG4gIGlmIChsb2dpY2FsVHlwZT8uZmllbGRfOCkgcmV0dXJuIHtcbiAgICB0eXBlOiAnVElNRVNUQU1QJyxcbiAgICBpc0FkanVzdGVkVG9VVEM6IGxvZ2ljYWxUeXBlLmZpZWxkXzguZmllbGRfMSxcbiAgICB1bml0OiBsb2dpY2FsVHlwZS5maWVsZF84LmZpZWxkXzIsXG4gIH1cbiAgaWYgKGxvZ2ljYWxUeXBlPy5maWVsZF8xMCkgcmV0dXJuIHtcbiAgICB0eXBlOiAnSU5URUdFUicsXG4gICAgYml0V2lkdGg6IGxvZ2ljYWxUeXBlLmZpZWxkXzEwLmZpZWxkXzEsXG4gICAgaXNTaWduZWQ6IGxvZ2ljYWxUeXBlLmZpZWxkXzEwLmZpZWxkXzIsXG4gIH1cbiAgaWYgKGxvZ2ljYWxUeXBlPy5maWVsZF8xMSkgcmV0dXJuIHsgdHlwZTogJ05VTEwnIH1cbiAgaWYgKGxvZ2ljYWxUeXBlPy5maWVsZF8xMikgcmV0dXJuIHsgdHlwZTogJ0pTT04nIH1cbiAgaWYgKGxvZ2ljYWxUeXBlPy5maWVsZF8xMykgcmV0dXJuIHsgdHlwZTogJ0JTT04nIH1cbiAgaWYgKGxvZ2ljYWxUeXBlPy5maWVsZF8xNCkgcmV0dXJuIHsgdHlwZTogJ1VVSUQnIH1cbiAgaWYgKGxvZ2ljYWxUeXBlPy5maWVsZF8xNSkgcmV0dXJuIHsgdHlwZTogJ0ZMT0FUMTYnIH1cbiAgcmV0dXJuIGxvZ2ljYWxUeXBlXG59XG5cbi8qKlxuICogQ29udmVydCBjb2x1bW4gc3RhdGlzdGljcyBiYXNlZCBvbiBjb2x1bW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gc3RhdHNcbiAqIEBwYXJhbSB7U2NoZW1hRWxlbWVudH0gc2NoZW1hXG4gKiBAcmV0dXJucyB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLlN0YXRpc3RpY3N9XG4gKi9cbmZ1bmN0aW9uIGNvbHVtblN0YXRzKHN0YXRzLCBzY2hlbWEpIHtcbiAgY29uc3QgeyB0eXBlLCBsb2dpY2FsX3R5cGUgfSA9IHNjaGVtYVxuICBmdW5jdGlvbiBjb252ZXJ0KC8qKiBAdHlwZSB7VWludDhBcnJheX0gKi8gdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHZhbHVlXG4gICAgaWYgKHR5cGUgPT09ICdCT09MRUFOJykgcmV0dXJuIHZhbHVlWzBdID09PSAxXG4gICAgaWYgKHR5cGUgPT09ICdCWVRFX0FSUkFZJykgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSlcbiAgICBpZiAodHlwZSA9PT0gJ0lOVDMyJykge1xuICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyh2YWx1ZS5idWZmZXIsIHZhbHVlLmJ5dGVPZmZzZXQsIHZhbHVlLmJ5dGVMZW5ndGgpXG4gICAgICByZXR1cm4gdmlldy5nZXRJbnQzMigwLCB0cnVlKVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ0lOVDY0Jykge1xuICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyh2YWx1ZS5idWZmZXIsIHZhbHVlLmJ5dGVPZmZzZXQsIHZhbHVlLmJ5dGVMZW5ndGgpXG4gICAgICByZXR1cm4gdmlldy5nZXRCaWdJbnQ2NCgwLCB0cnVlKVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ0ZMT0FUJykge1xuICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyh2YWx1ZS5idWZmZXIsIHZhbHVlLmJ5dGVPZmZzZXQsIHZhbHVlLmJ5dGVMZW5ndGgpXG4gICAgICByZXR1cm4gdmlldy5nZXRGbG9hdDMyKDAsIHRydWUpXG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnRE9VQkxFJykge1xuICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyh2YWx1ZS5idWZmZXIsIHZhbHVlLmJ5dGVPZmZzZXQsIHZhbHVlLmJ5dGVMZW5ndGgpXG4gICAgICByZXR1cm4gdmlldy5nZXRGbG9hdDY0KDAsIHRydWUpXG4gICAgfVxuICAgIGlmIChsb2dpY2FsX3R5cGU/LnR5cGUgPT09ICdGTE9BVDE2Jykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQxNih2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgcmV0dXJuIHN0YXRzICYmIHtcbiAgICBtYXg6IGNvbnZlcnQoc3RhdHMuZmllbGRfMSksXG4gICAgbWluOiBjb252ZXJ0KHN0YXRzLmZpZWxkXzIpLFxuICAgIG51bGxfY291bnQ6IHN0YXRzLmZpZWxkXzMsXG4gICAgZGlzdGluY3RfY291bnQ6IHN0YXRzLmZpZWxkXzQsXG4gICAgbWF4X3ZhbHVlOiBjb252ZXJ0KHN0YXRzLmZpZWxkXzUpLFxuICAgIG1pbl92YWx1ZTogY29udmVydChzdGF0cy5maWVsZF82KSxcbiAgICBpc19tYXhfdmFsdWVfZXhhY3Q6IHN0YXRzLmZpZWxkXzcsXG4gICAgaXNfbWluX3ZhbHVlX2V4YWN0OiBzdGF0cy5maWVsZF84LFxuICB9XG59XG4iLCIvKipcbiAqIFJlYWQgYGNvdW50YCB2YWx1ZXMgb2YgdGhlIGdpdmVuIHR5cGUgZnJvbSB0aGUgcmVhZGVyLnZpZXcuXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5EYXRhUmVhZGVyfSBEYXRhUmVhZGVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkRlY29kZWRBcnJheX0gRGVjb2RlZEFycmF5XG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLlBhcnF1ZXRUeXBlfSBQYXJxdWV0VHlwZVxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgLSBidWZmZXIgdG8gcmVhZCBkYXRhIGZyb21cbiAqIEBwYXJhbSB7UGFycXVldFR5cGV9IHR5cGUgLSBwYXJxdWV0IHR5cGUgb2YgdGhlIGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiB2YWx1ZXMgdG8gcmVhZFxuICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpeGVkTGVuZ3RoIC0gbGVuZ3RoIG9mIGVhY2ggZml4ZWQgbGVuZ3RoIGJ5dGUgYXJyYXlcbiAqIEByZXR1cm5zIHtEZWNvZGVkQXJyYXl9IGFycmF5IG9mIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZFBsYWluKHJlYWRlciwgdHlwZSwgY291bnQsIGZpeGVkTGVuZ3RoKSB7XG4gIGlmIChjb3VudCA9PT0gMCkgcmV0dXJuIFtdXG4gIGlmICh0eXBlID09PSAnQk9PTEVBTicpIHtcbiAgICByZXR1cm4gcmVhZFBsYWluQm9vbGVhbihyZWFkZXIsIGNvdW50KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdJTlQzMicpIHtcbiAgICByZXR1cm4gcmVhZFBsYWluSW50MzIocmVhZGVyLCBjb3VudClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnSU5UNjQnKSB7XG4gICAgcmV0dXJuIHJlYWRQbGFpbkludDY0KHJlYWRlciwgY291bnQpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0lOVDk2Jykge1xuICAgIHJldHVybiByZWFkUGxhaW5JbnQ5NihyZWFkZXIsIGNvdW50KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdGTE9BVCcpIHtcbiAgICByZXR1cm4gcmVhZFBsYWluRmxvYXQocmVhZGVyLCBjb3VudClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnRE9VQkxFJykge1xuICAgIHJldHVybiByZWFkUGxhaW5Eb3VibGUocmVhZGVyLCBjb3VudClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnQllURV9BUlJBWScpIHtcbiAgICByZXR1cm4gcmVhZFBsYWluQnl0ZUFycmF5KHJlYWRlciwgY291bnQpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0ZJWEVEX0xFTl9CWVRFX0FSUkFZJykge1xuICAgIGlmICghZml4ZWRMZW5ndGgpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBtaXNzaW5nIGZpeGVkIGxlbmd0aCcpXG4gICAgcmV0dXJuIHJlYWRQbGFpbkJ5dGVBcnJheUZpeGVkKHJlYWRlciwgY291bnQsIGZpeGVkTGVuZ3RoKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFycXVldCB1bmhhbmRsZWQgdHlwZTogJHt0eXBlfWApXG4gIH1cbn1cblxuLyoqXG4gKiBSZWFkIGBjb3VudGAgYm9vbGVhbiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHJldHVybnMge2Jvb2xlYW5bXX1cbiAqL1xuZnVuY3Rpb24gcmVhZFBsYWluQm9vbGVhbihyZWFkZXIsIGNvdW50KSB7XG4gIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShjb3VudClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgY29uc3QgYnl0ZU9mZnNldCA9IHJlYWRlci5vZmZzZXQgKyAoaSAvIDggfCAwKVxuICAgIGNvbnN0IGJpdE9mZnNldCA9IGkgJSA4XG4gICAgY29uc3QgYnl0ZSA9IHJlYWRlci52aWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQpXG4gICAgdmFsdWVzW2ldID0gKGJ5dGUgJiAxIDw8IGJpdE9mZnNldCkgIT09IDBcbiAgfVxuICByZWFkZXIub2Zmc2V0ICs9IE1hdGguY2VpbChjb3VudCAvIDgpXG4gIHJldHVybiB2YWx1ZXNcbn1cblxuLyoqXG4gKiBSZWFkIGBjb3VudGAgaW50MzIgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEByZXR1cm5zIHtJbnQzMkFycmF5fVxuICovXG5mdW5jdGlvbiByZWFkUGxhaW5JbnQzMihyZWFkZXIsIGNvdW50KSB7XG4gIGNvbnN0IHZhbHVlcyA9IChyZWFkZXIudmlldy5ieXRlT2Zmc2V0ICsgcmVhZGVyLm9mZnNldCkgJSA0XG4gICAgPyBuZXcgSW50MzJBcnJheShhbGlnbihyZWFkZXIudmlldy5idWZmZXIsIHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0LCBjb3VudCAqIDQpKVxuICAgIDogbmV3IEludDMyQXJyYXkocmVhZGVyLnZpZXcuYnVmZmVyLCByZWFkZXIudmlldy5ieXRlT2Zmc2V0ICsgcmVhZGVyLm9mZnNldCwgY291bnQpXG4gIHJlYWRlci5vZmZzZXQgKz0gY291bnQgKiA0XG4gIHJldHVybiB2YWx1ZXNcbn1cblxuLyoqXG4gKiBSZWFkIGBjb3VudGAgaW50NjQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEByZXR1cm5zIHtCaWdJbnQ2NEFycmF5fVxuICovXG5mdW5jdGlvbiByZWFkUGxhaW5JbnQ2NChyZWFkZXIsIGNvdW50KSB7XG4gIGNvbnN0IHZhbHVlcyA9IChyZWFkZXIudmlldy5ieXRlT2Zmc2V0ICsgcmVhZGVyLm9mZnNldCkgJSA4XG4gICAgPyBuZXcgQmlnSW50NjRBcnJheShhbGlnbihyZWFkZXIudmlldy5idWZmZXIsIHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0LCBjb3VudCAqIDgpKVxuICAgIDogbmV3IEJpZ0ludDY0QXJyYXkocmVhZGVyLnZpZXcuYnVmZmVyLCByZWFkZXIudmlldy5ieXRlT2Zmc2V0ICsgcmVhZGVyLm9mZnNldCwgY291bnQpXG4gIHJlYWRlci5vZmZzZXQgKz0gY291bnQgKiA4XG4gIHJldHVybiB2YWx1ZXNcbn1cblxuLyoqXG4gKiBSZWFkIGBjb3VudGAgaW50OTYgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEByZXR1cm5zIHtiaWdpbnRbXX1cbiAqL1xuZnVuY3Rpb24gcmVhZFBsYWluSW50OTYocmVhZGVyLCBjb3VudCkge1xuICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkoY291bnQpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIGNvbnN0IGxvdyA9IHJlYWRlci52aWV3LmdldEJpZ0ludDY0KHJlYWRlci5vZmZzZXQgKyBpICogMTIsIHRydWUpXG4gICAgY29uc3QgaGlnaCA9IHJlYWRlci52aWV3LmdldEludDMyKHJlYWRlci5vZmZzZXQgKyBpICogMTIgKyA4LCB0cnVlKVxuICAgIHZhbHVlc1tpXSA9IEJpZ0ludChoaWdoKSA8PCA2NG4gfCBsb3dcbiAgfVxuICByZWFkZXIub2Zmc2V0ICs9IGNvdW50ICogMTJcbiAgcmV0dXJuIHZhbHVlc1xufVxuXG4vKipcbiAqIFJlYWQgYGNvdW50YCBmbG9hdCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHJldHVybnMge0Zsb2F0MzJBcnJheX1cbiAqL1xuZnVuY3Rpb24gcmVhZFBsYWluRmxvYXQocmVhZGVyLCBjb3VudCkge1xuICBjb25zdCB2YWx1ZXMgPSAocmVhZGVyLnZpZXcuYnl0ZU9mZnNldCArIHJlYWRlci5vZmZzZXQpICUgNFxuICAgID8gbmV3IEZsb2F0MzJBcnJheShhbGlnbihyZWFkZXIudmlldy5idWZmZXIsIHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0LCBjb3VudCAqIDQpKVxuICAgIDogbmV3IEZsb2F0MzJBcnJheShyZWFkZXIudmlldy5idWZmZXIsIHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0LCBjb3VudClcbiAgcmVhZGVyLm9mZnNldCArPSBjb3VudCAqIDRcbiAgcmV0dXJuIHZhbHVlc1xufVxuXG4vKipcbiAqIFJlYWQgYGNvdW50YCBkb3VibGUgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEByZXR1cm5zIHtGbG9hdDY0QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHJlYWRQbGFpbkRvdWJsZShyZWFkZXIsIGNvdW50KSB7XG4gIGNvbnN0IHZhbHVlcyA9IChyZWFkZXIudmlldy5ieXRlT2Zmc2V0ICsgcmVhZGVyLm9mZnNldCkgJSA4XG4gICAgPyBuZXcgRmxvYXQ2NEFycmF5KGFsaWduKHJlYWRlci52aWV3LmJ1ZmZlciwgcmVhZGVyLnZpZXcuYnl0ZU9mZnNldCArIHJlYWRlci5vZmZzZXQsIGNvdW50ICogOCkpXG4gICAgOiBuZXcgRmxvYXQ2NEFycmF5KHJlYWRlci52aWV3LmJ1ZmZlciwgcmVhZGVyLnZpZXcuYnl0ZU9mZnNldCArIHJlYWRlci5vZmZzZXQsIGNvdW50KVxuICByZWFkZXIub2Zmc2V0ICs9IGNvdW50ICogOFxuICByZXR1cm4gdmFsdWVzXG59XG5cbi8qKlxuICogUmVhZCBgY291bnRgIGJ5dGUgYXJyYXkgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5W119XG4gKi9cbmZ1bmN0aW9uIHJlYWRQbGFpbkJ5dGVBcnJheShyZWFkZXIsIGNvdW50KSB7XG4gIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShjb3VudClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gcmVhZGVyLnZpZXcuZ2V0SW50MzIocmVhZGVyLm9mZnNldCwgdHJ1ZSlcbiAgICByZWFkZXIub2Zmc2V0ICs9IDRcbiAgICB2YWx1ZXNbaV0gPSBuZXcgVWludDhBcnJheShyZWFkZXIudmlldy5idWZmZXIsIHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0LCBsZW5ndGgpXG4gICAgcmVhZGVyLm9mZnNldCArPSBsZW5ndGhcbiAgfVxuICByZXR1cm4gdmFsdWVzXG59XG5cbi8qKlxuICogUmVhZCBhIGZpeGVkIGxlbmd0aCBieXRlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaXhlZExlbmd0aFxuICogQHJldHVybnMge1VpbnQ4QXJyYXlbXX1cbiAqL1xuZnVuY3Rpb24gcmVhZFBsYWluQnl0ZUFycmF5Rml4ZWQocmVhZGVyLCBjb3VudCwgZml4ZWRMZW5ndGgpIHtcbiAgLy8gYXNzZXJ0KHJlYWRlci52aWV3LmJ5dGVMZW5ndGggLSByZWFkZXIub2Zmc2V0ID49IGNvdW50ICogZml4ZWRMZW5ndGgpXG4gIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShjb3VudClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgdmFsdWVzW2ldID0gbmV3IFVpbnQ4QXJyYXkocmVhZGVyLnZpZXcuYnVmZmVyLCByZWFkZXIudmlldy5ieXRlT2Zmc2V0ICsgcmVhZGVyLm9mZnNldCwgZml4ZWRMZW5ndGgpXG4gICAgcmVhZGVyLm9mZnNldCArPSBmaXhlZExlbmd0aFxuICB9XG4gIHJldHVybiB2YWx1ZXNcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYnVmZmVyIHdpdGggdGhlIG9mZnNldCBhbmQgc2l6ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGFsaWduKGJ1ZmZlciwgb2Zmc2V0LCBzaXplKSB7XG4gIGNvbnN0IGFsaWduZWQgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSlcbiAgbmV3IFVpbnQ4QXJyYXkoYWxpZ25lZCkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBzaXplKSlcbiAgcmV0dXJuIGFsaWduZWRcbn1cbiIsIlxuaW1wb3J0IHsgYXNzZW1ibGVOZXN0ZWQgfSBmcm9tICcuL2Fzc2VtYmxlLmpzJ1xuaW1wb3J0IHsgZ2V0Q29sdW1uT2Zmc2V0LCByZWFkQ29sdW1uIH0gZnJvbSAnLi9jb2x1bW4uanMnXG5pbXBvcnQgeyBwYXJxdWV0TWV0YWRhdGFBc3luYyB9IGZyb20gJy4vbWV0YWRhdGEuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFQYXRoIH0gZnJvbSAnLi9zY2hlbWEuanMnXG5pbXBvcnQgeyBjb25jYXQgfSBmcm9tICcuL3V0aWxzLmpzJ1xuXG4vKipcbiAqIFJlYWQgcGFycXVldCBkYXRhIHJvd3MgZnJvbSBhIGZpbGUtbGlrZSBvYmplY3QuXG4gKiBSZWFkcyB0aGUgbWluaW1hbCBudW1iZXIgb2Ygcm93IGdyb3VwcyBhbmQgY29sdW1ucyB0byBzYXRpc2Z5IHRoZSByZXF1ZXN0LlxuICpcbiAqIFJldHVybnMgYSB2b2lkIHByb21pc2Ugd2hlbiBjb21wbGV0ZSwgYW5kIHRvIHRocm93IGVycm9ycy5cbiAqIERhdGEgaXMgcmV0dXJuZWQgaW4gb25Db21wbGV0ZSwgbm90IHRoZSByZXR1cm4gcHJvbWlzZSwgYmVjYXVzZVxuICogaWYgb25Db21wbGV0ZSBpcyB1bmRlZmluZWQsIHdlIHBhcnNlIHRoZSBkYXRhLCBhbmQgZW1pdCBjaHVua3MsIGJ1dCBza2lwXG4gKiBjb21wdXRpbmcgdGhlIHJvdyB2aWV3IGRpcmVjdGx5LiBUaGlzIHNhdmVzIG9uIGFsbG9jYXRpb24gaWYgdGhlIGNhbGxlclxuICogd2FudHMgdG8gY2FjaGUgdGhlIGZ1bGwgY2h1bmtzLCBhbmQgbWFrZSB0aGVpciBvd24gdmlldyBvZiB0aGUgZGF0YSBmcm9tXG4gKiB0aGUgY2h1bmtzLlxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vaHlwYXJxdWV0LmpzJykuQ29sdW1uRGF0YX0gQ29sdW1uRGF0YVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcy5qcycpLkNvbXByZXNzb3JzfSBDb21wcmVzc29yc1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcy5qcycpLkFzeW5jQnVmZmVyfSBBc3luY0J1ZmZlclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcy5qcycpLkZpbGVNZXRhRGF0YX0gRmlsZU1ldGFEYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyByZWFkIG9wdGlvbnNcbiAqIEBwYXJhbSB7QXN5bmNCdWZmZXJ9IG9wdGlvbnMuZmlsZSBmaWxlLWxpa2Ugb2JqZWN0IGNvbnRhaW5pbmcgcGFycXVldCBkYXRhXG4gKiBAcGFyYW0ge0ZpbGVNZXRhRGF0YX0gW29wdGlvbnMubWV0YWRhdGFdIHBhcnF1ZXQgZmlsZSBtZXRhZGF0YVxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMuY29sdW1uc10gY29sdW1ucyB0byByZWFkLCBhbGwgY29sdW1ucyBpZiB1bmRlZmluZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yb3dTdGFydF0gZmlyc3QgcmVxdWVzdGVkIHJvdyBpbmRleCAoaW5jbHVzaXZlKVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvd0VuZF0gbGFzdCByZXF1ZXN0ZWQgcm93IGluZGV4IChleGNsdXNpdmUpXG4gKiBAcGFyYW0geyhjaHVuazogQ29sdW1uRGF0YSkgPT4gdm9pZH0gW29wdGlvbnMub25DaHVua10gY2FsbGVkIHdoZW4gYSBjb2x1bW4gY2h1bmsgaXMgcGFyc2VkLiBjaHVua3MgbWF5IGluY2x1ZGUgcm93IGRhdGEgb3V0c2lkZSB0aGUgcmVxdWVzdGVkIHJhbmdlLlxuICogQHBhcmFtIHsocm93czogYW55W11bXSkgPT4gdm9pZH0gW29wdGlvbnMub25Db21wbGV0ZV0gY2FsbGVkIHdoZW4gYWxsIHJlcXVlc3RlZCByb3dzIGFuZCBjb2x1bW5zIGFyZSBwYXJzZWRcbiAqIEBwYXJhbSB7Q29tcHJlc3NvcnN9IFtvcHRpb25zLmNvbXByZXNzb3JzXSBjdXN0b20gZGVjb21wcmVzc29yc1xuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IHJlc29sdmVzIHdoZW4gYWxsIHJlcXVlc3RlZCByb3dzIGFuZCBjb2x1bW5zIGFyZSBwYXJzZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnF1ZXRSZWFkKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLmZpbGUpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBmaWxlIGlzIHJlcXVpcmVkJylcblxuICAvLyBsb2FkIG1ldGFkYXRhIGlmIG5vdCBwcm92aWRlZFxuICBvcHRpb25zLm1ldGFkYXRhIHx8PSBhd2FpdCBwYXJxdWV0TWV0YWRhdGFBc3luYyhvcHRpb25zLmZpbGUpXG4gIGlmICghb3B0aW9ucy5tZXRhZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IG1ldGFkYXRhIG5vdCBmb3VuZCcpXG5cbiAgY29uc3QgeyBtZXRhZGF0YSwgb25Db21wbGV0ZSwgcm93RW5kIH0gPSBvcHRpb25zXG4gIGNvbnN0IHJvd1N0YXJ0ID0gb3B0aW9ucy5yb3dTdGFydCB8fCAwXG4gIC8qKiBAdHlwZSB7YW55W11bXX0gKi9cbiAgY29uc3Qgcm93RGF0YSA9IFtdXG5cbiAgLy8gZmluZCB3aGljaCByb3cgZ3JvdXBzIHRvIHJlYWRcbiAgbGV0IGdyb3VwU3RhcnQgPSAwIC8vIGZpcnN0IHJvdyBpbmRleCBvZiB0aGUgY3VycmVudCBncm91cFxuICBmb3IgKGNvbnN0IHJvd0dyb3VwIG9mIG1ldGFkYXRhLnJvd19ncm91cHMpIHtcbiAgICAvLyBudW1iZXIgb2Ygcm93cyBpbiB0aGlzIHJvdyBncm91cFxuICAgIGNvbnN0IGdyb3VwUm93cyA9IE51bWJlcihyb3dHcm91cC5udW1fcm93cylcbiAgICAvLyBpZiByb3cgZ3JvdXAgb3ZlcmxhcHMgd2l0aCByb3cgcmFuZ2UsIHJlYWQgaXRcbiAgICBpZiAoZ3JvdXBTdGFydCArIGdyb3VwUm93cyA+PSByb3dTdGFydCAmJiAocm93RW5kID09PSB1bmRlZmluZWQgfHwgZ3JvdXBTdGFydCA8IHJvd0VuZCkpIHtcbiAgICAgIC8vIHJlYWQgcm93IGdyb3VwXG4gICAgICBjb25zdCBncm91cERhdGEgPSBhd2FpdCByZWFkUm93R3JvdXAob3B0aW9ucywgcm93R3JvdXAsIGdyb3VwU3RhcnQpXG4gICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICAvLyBmaWx0ZXIgdG8gcm93cyBpbiByYW5nZVxuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHJvd1N0YXJ0IC0gZ3JvdXBTdGFydCwgMClcbiAgICAgICAgY29uc3QgZW5kID0gcm93RW5kID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByb3dFbmQgLSBncm91cFN0YXJ0XG4gICAgICAgIGNvbmNhdChyb3dEYXRhLCBncm91cERhdGEuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gICAgICB9XG4gICAgfVxuICAgIGdyb3VwU3RhcnQgKz0gZ3JvdXBSb3dzXG4gIH1cblxuICBpZiAob25Db21wbGV0ZSkgb25Db21wbGV0ZShyb3dEYXRhKVxufVxuXG4vKipcbiAqIFJlYWQgYSByb3cgZ3JvdXAgZnJvbSBhIGZpbGUtbGlrZSBvYmplY3QuXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcy5qcycpLlJvd0dyb3VwfSBSb3dHcm91cFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgcmVhZCBvcHRpb25zXG4gKiBAcGFyYW0ge0FzeW5jQnVmZmVyfSBvcHRpb25zLmZpbGUgZmlsZS1saWtlIG9iamVjdCBjb250YWluaW5nIHBhcnF1ZXQgZGF0YVxuICogQHBhcmFtIHtGaWxlTWV0YURhdGF9IFtvcHRpb25zLm1ldGFkYXRhXSBwYXJxdWV0IGZpbGUgbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLmNvbHVtbnNdIGNvbHVtbnMgdG8gcmVhZCwgYWxsIGNvbHVtbnMgaWYgdW5kZWZpbmVkXG4gKiBAcGFyYW0geyhjaHVuazogQ29sdW1uRGF0YSkgPT4gdm9pZH0gW29wdGlvbnMub25DaHVua10gY2FsbGVkIHdoZW4gYSBjb2x1bW4gY2h1bmsgaXMgcGFyc2VkLiBjaHVua3MgbWF5IGluY2x1ZGUgcm93IGRhdGEgb3V0c2lkZSB0aGUgcmVxdWVzdGVkIHJhbmdlLlxuICogQHBhcmFtIHsocm93czogYW55W11bXSkgPT4gdm9pZH0gW29wdGlvbnMub25Db21wbGV0ZV0gY2FsbGVkIHdoZW4gYWxsIHJlcXVlc3RlZCByb3dzIGFuZCBjb2x1bW5zIGFyZSBwYXJzZWRcbiAqIEBwYXJhbSB7Q29tcHJlc3NvcnN9IFtvcHRpb25zLmNvbXByZXNzb3JzXVxuICogQHBhcmFtIHtSb3dHcm91cH0gcm93R3JvdXAgcm93IGdyb3VwIHRvIHJlYWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBncm91cFN0YXJ0IHJvdyBpbmRleCBvZiB0aGUgZmlyc3Qgcm93IGluIHRoZSBncm91cFxuICogQHJldHVybnMge1Byb21pc2U8YW55W11bXT59IHJlc29sdmVzIHRvIHJvdyBkYXRhXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRSb3dHcm91cChvcHRpb25zLCByb3dHcm91cCwgZ3JvdXBTdGFydCkge1xuICBjb25zdCB7IGZpbGUsIG1ldGFkYXRhLCBjb2x1bW5zIH0gPSBvcHRpb25zXG4gIGlmICghbWV0YWRhdGEpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBtZXRhZGF0YSBub3QgZm91bmQnKVxuXG4gIC8vIGxvb3AgdGhyb3VnaCBtZXRhZGF0YSB0byBmaW5kIG1pbi9tYXggYnl0ZXMgdG8gcmVhZFxuICBsZXQgW2dyb3VwU3RhcnRCeXRlLCBncm91cEVuZEJ5dGVdID0gW2ZpbGUuYnl0ZUxlbmd0aCwgMF1cbiAgcm93R3JvdXAuY29sdW1ucy5mb3JFYWNoKCh7IG1ldGFfZGF0YTogY29sdW1uTWV0YWRhdGEgfSkgPT4ge1xuICAgIGlmICghY29sdW1uTWV0YWRhdGEpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBjb2x1bW4gbWV0YWRhdGEgaXMgdW5kZWZpbmVkJylcbiAgICAvLyBza2lwIGNvbHVtbnMgdGhhdCBhcmUgbm90IHJlcXVlc3RlZFxuICAgIGlmIChjb2x1bW5zICYmICFjb2x1bW5zLmluY2x1ZGVzKGNvbHVtbk1ldGFkYXRhLnBhdGhfaW5fc2NoZW1hWzBdKSkgcmV0dXJuXG5cbiAgICBjb25zdCBzdGFydEJ5dGUgPSBnZXRDb2x1bW5PZmZzZXQoY29sdW1uTWV0YWRhdGEpXG4gICAgY29uc3QgZW5kQnl0ZSA9IHN0YXJ0Qnl0ZSArIE51bWJlcihjb2x1bW5NZXRhZGF0YS50b3RhbF9jb21wcmVzc2VkX3NpemUpXG4gICAgZ3JvdXBTdGFydEJ5dGUgPSBNYXRoLm1pbihncm91cFN0YXJ0Qnl0ZSwgc3RhcnRCeXRlKVxuICAgIGdyb3VwRW5kQnl0ZSA9IE1hdGgubWF4KGdyb3VwRW5kQnl0ZSwgZW5kQnl0ZSlcbiAgfSlcbiAgaWYgKGdyb3VwU3RhcnRCeXRlID49IGdyb3VwRW5kQnl0ZSAmJiBjb2x1bW5zPy5sZW5ndGgpIHtcbiAgICAvLyBUT0RPOiBzaG91bGQgdGhyb3cgaWYgYW55IGNvbHVtbiBpcyBtaXNzaW5nXG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYXJxdWV0IGNvbHVtbnMgbm90IGZvdW5kOiAke2NvbHVtbnMuam9pbignLCAnKX1gKVxuICB9XG4gIC8vIGlmIHJvdyBncm91cCBzaXplIGlzIGxlc3MgdGhhbiAzMm1iLCBwcmUtbG9hZCBpbiBvbmUgcmVhZFxuICBsZXQgZ3JvdXBCdWZmZXJcbiAgaWYgKGdyb3VwRW5kQnl0ZSAtIGdyb3VwU3RhcnRCeXRlIDw9IDEgPDwgMjUpIHtcbiAgICAvLyBwcmUtbG9hZCByb3cgZ3JvdXAgYnl0ZSBkYXRhIGluIG9uZSBiaWcgcmVhZCxcbiAgICAvLyBvdGhlcndpc2UgcmVhZCBjb2x1bW4gZGF0YSBpbmRpdmlkdWFsbHlcbiAgICBncm91cEJ1ZmZlciA9IGF3YWl0IGZpbGUuc2xpY2UoZ3JvdXBTdGFydEJ5dGUsIGdyb3VwRW5kQnl0ZSlcbiAgfVxuXG4gIC8qKiBAdHlwZSB7YW55W11bXX0gKi9cbiAgY29uc3QgZ3JvdXBDb2x1bW5EYXRhID0gW11cbiAgY29uc3QgcHJvbWlzZXMgPSBbXVxuICAvLyBUb3AtbGV2ZWwgY29sdW1ucyB0byBhc3NlbWJsZVxuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBnZXRTY2hlbWFQYXRoKG1ldGFkYXRhLnNjaGVtYSwgW10pWzBdXG4gIGNvbnN0IHN1YmNvbHVtbk5hbWVzID0gbmV3IE1hcChjaGlsZHJlbi5tYXAoY2hpbGQgPT4gW2NoaWxkLmVsZW1lbnQubmFtZSwgZ2V0U3ViY29sdW1ucyhjaGlsZCldKSlcbiAgY29uc3Qgc3ViY29sdW1uRGF0YSA9IG5ldyBNYXAoKSAvLyBjb2x1bW5zIHRvIGFzc2VtYmxlIGFzIG1hcHNcbiAgLy8gcmVhZCBjb2x1bW4gZGF0YVxuICBmb3IgKGxldCBjb2x1bW5JbmRleCA9IDA7IGNvbHVtbkluZGV4IDwgcm93R3JvdXAuY29sdW1ucy5sZW5ndGg7IGNvbHVtbkluZGV4KyspIHtcbiAgICBjb25zdCBjb2x1bW5NZXRhZGF0YSA9IHJvd0dyb3VwLmNvbHVtbnNbY29sdW1uSW5kZXhdLm1ldGFfZGF0YVxuICAgIGlmICghY29sdW1uTWV0YWRhdGEpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBjb2x1bW4gbWV0YWRhdGEgaXMgdW5kZWZpbmVkJylcblxuICAgIC8vIHNraXAgY29sdW1ucyB0aGF0IGFyZSBub3QgcmVxdWVzdGVkXG4gICAgY29uc3QgY29sdW1uTmFtZSA9IGNvbHVtbk1ldGFkYXRhLnBhdGhfaW5fc2NoZW1hWzBdXG4gICAgaWYgKGNvbHVtbnMgJiYgIWNvbHVtbnMuaW5jbHVkZXMoY29sdW1uTmFtZSkpIGNvbnRpbnVlXG5cbiAgICBjb25zdCBjb2x1bW5TdGFydEJ5dGUgPSBnZXRDb2x1bW5PZmZzZXQoY29sdW1uTWV0YWRhdGEpXG4gICAgY29uc3QgY29sdW1uRW5kQnl0ZSA9IGNvbHVtblN0YXJ0Qnl0ZSArIE51bWJlcihjb2x1bW5NZXRhZGF0YS50b3RhbF9jb21wcmVzc2VkX3NpemUpXG4gICAgY29uc3QgY29sdW1uQnl0ZXMgPSBjb2x1bW5FbmRCeXRlIC0gY29sdW1uU3RhcnRCeXRlXG5cbiAgICAvLyBza2lwIGNvbHVtbnMgbGFyZ2VyIHRoYW4gMWdiXG4gICAgLy8gVE9ETzogc3RyZWFtIHByb2Nlc3MgdGhlIGRhdGEsIHJldHVybmluZyBvbmx5IHRoZSByZXF1ZXN0ZWQgcm93c1xuICAgIGlmIChjb2x1bW5CeXRlcyA+IDEgPDwgMzApIHtcbiAgICAgIGNvbnNvbGUud2FybihgcGFycXVldCBza2lwcGluZyBodWdlIGNvbHVtbiBcIiR7Y29sdW1uTWV0YWRhdGEucGF0aF9pbl9zY2hlbWF9XCIgJHtjb2x1bW5CeXRlcy50b0xvY2FsZVN0cmluZygpfSBieXRlc2ApXG4gICAgICAvLyBUT0RPOiBzZXQgY29sdW1uIHRvIG5ldyBFcnJvcigncGFycXVldCBjb2x1bW4gdG9vIGxhcmdlJylcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gdXNlIHByZS1sb2FkZWQgcm93IGdyb3VwIGJ5dGUgZGF0YSBpZiBhdmFpbGFibGUsIGVsc2UgcmVhZCBjb2x1bW4gZGF0YVxuICAgIC8qKiBAdHlwZSB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59ICovXG4gICAgbGV0IGJ1ZmZlclxuICAgIGxldCBidWZmZXJPZmZzZXQgPSAwXG4gICAgaWYgKGdyb3VwQnVmZmVyKSB7XG4gICAgICBidWZmZXIgPSBQcm9taXNlLnJlc29sdmUoZ3JvdXBCdWZmZXIpXG4gICAgICBidWZmZXJPZmZzZXQgPSBjb2x1bW5TdGFydEJ5dGUgLSBncm91cFN0YXJ0Qnl0ZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3cmFwIGF3YWl0YWJsZSB0byBlbnN1cmUgaXQncyBhIHByb21pc2VcbiAgICAgIGJ1ZmZlciA9IFByb21pc2UucmVzb2x2ZShmaWxlLnNsaWNlKGNvbHVtblN0YXJ0Qnl0ZSwgY29sdW1uRW5kQnl0ZSkpXG4gICAgfVxuXG4gICAgLy8gcmVhZCBjb2x1bW4gZGF0YSBhc3luY1xuICAgIHByb21pc2VzLnB1c2goYnVmZmVyLnRoZW4oYXJyYXlCdWZmZXIgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGdldFNjaGVtYVBhdGgobWV0YWRhdGEuc2NoZW1hLCBjb2x1bW5NZXRhZGF0YS5wYXRoX2luX3NjaGVtYSlcbiAgICAgIGNvbnN0IHJlYWRlciA9IHsgdmlldzogbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKSwgb2Zmc2V0OiBidWZmZXJPZmZzZXQgfVxuICAgICAgLyoqIEB0eXBlIHthbnlbXSB8IHVuZGVmaW5lZH0gKi9cbiAgICAgIGxldCBjb2x1bW5EYXRhID0gcmVhZENvbHVtbihyZWFkZXIsIHJvd0dyb3VwLCBjb2x1bW5NZXRhZGF0YSwgc2NoZW1hUGF0aCwgb3B0aW9ucylcbiAgICAgIC8vIGFzc2VydChjb2x1bW5EYXRhLmxlbmd0aCA9PT0gTnVtYmVyKHJvd0dyb3VwLm51bV9yb3dzKVxuXG4gICAgICAvLyBUT0RPOiBmYXN0IHBhdGggZm9yIG5vbi1uZXN0ZWQgY29sdW1uc1xuICAgICAgLy8gU2F2ZSBjb2x1bW4gZGF0YSBmb3IgYXNzZW1ibHlcbiAgICAgIGNvbnN0IHN1YmNvbHVtbiA9IGNvbHVtbk1ldGFkYXRhLnBhdGhfaW5fc2NoZW1hLmpvaW4oJy4nKVxuICAgICAgc3ViY29sdW1uRGF0YS5zZXQoc3ViY29sdW1uLCBjb2x1bW5EYXRhKVxuICAgICAgY29sdW1uRGF0YSA9IHVuZGVmaW5lZFxuXG4gICAgICBjb25zdCBzdWJjb2x1bW5zID0gc3ViY29sdW1uTmFtZXMuZ2V0KGNvbHVtbk5hbWUpXG4gICAgICBpZiAoc3ViY29sdW1ucz8uZXZlcnkobmFtZSA9PiBzdWJjb2x1bW5EYXRhLmhhcyhuYW1lKSkpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbGwgZGF0YSBuZWVkZWQgdG8gYXNzZW1ibGUgYSB0b3AgbGV2ZWwgY29sdW1uXG4gICAgICAgIGFzc2VtYmxlTmVzdGVkKHN1YmNvbHVtbkRhdGEsIHNjaGVtYVBhdGhbMV0pXG4gICAgICAgIGNvbHVtbkRhdGEgPSBzdWJjb2x1bW5EYXRhLmdldChjb2x1bW5OYW1lKVxuICAgICAgICBpZiAoIWNvbHVtbkRhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnF1ZXQgY29sdW1uIGRhdGEgbm90IGFzc2VtYmxlZDogJHtjb2x1bW5OYW1lfWApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZG8gbm90IGVtaXQgY29sdW1uIGRhdGEgdW50aWwgc3RydWN0cyBhcmUgZnVsbHkgcGFyc2VkXG4gICAgICBpZiAoIWNvbHVtbkRhdGEpIHJldHVyblxuICAgICAgLy8gbm90aWZ5IGNhbGxlciBvZiBjb2x1bW4gZGF0YVxuICAgICAgb3B0aW9ucy5vbkNodW5rPy4oe1xuICAgICAgICBjb2x1bW5OYW1lLFxuICAgICAgICBjb2x1bW5EYXRhLFxuICAgICAgICByb3dTdGFydDogZ3JvdXBTdGFydCxcbiAgICAgICAgcm93RW5kOiBncm91cFN0YXJ0ICsgY29sdW1uRGF0YS5sZW5ndGgsXG4gICAgICB9KVxuICAgICAgLy8gc2F2ZSBjb2x1bW4gZGF0YSBvbmx5IGlmIG9uQ29tcGxldGUgaXMgZGVmaW5lZFxuICAgICAgaWYgKG9wdGlvbnMub25Db21wbGV0ZSkgZ3JvdXBDb2x1bW5EYXRhLnB1c2goY29sdW1uRGF0YSlcbiAgICB9KSlcbiAgfVxuICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgaWYgKG9wdGlvbnMub25Db21wbGV0ZSkge1xuICAgIC8vIHRyYW5zcG9zZSBjb2x1bW5zIGludG8gcm93c1xuICAgIHJldHVybiBncm91cENvbHVtbkRhdGFbMF0ubWFwKChfLCByb3cpID0+IGdyb3VwQ29sdW1uRGF0YS5tYXAoY29sID0+IGNvbFtyb3ddKSlcbiAgfVxuICByZXR1cm4gW11cbn1cblxuXG4vKipcbiAqIFJldHVybiBhIGxpc3Qgb2Ygc3ViLWNvbHVtbnMgbmVlZGVkIHRvIGNvbnN0cnVjdCBhIHRvcC1sZXZlbCBjb2x1bW4uXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5TY2hlbWFUcmVlfSBzY2hlbWFcbiAqIEBwYXJhbSB7c3RyaW5nW119IG91dHB1dFxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG5mdW5jdGlvbiBnZXRTdWJjb2x1bW5zKHNjaGVtYSwgb3V0cHV0ID0gW10pIHtcbiAgaWYgKHNjaGVtYS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHNjaGVtYS5jaGlsZHJlbikge1xuICAgICAgZ2V0U3ViY29sdW1ucyhjaGlsZCwgb3V0cHV0KVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQucHVzaChzY2hlbWEucGF0aC5qb2luKCcuJykpXG4gIH1cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwiLyoqXG4gKiBCdWlsZCBhIHRyZWUgZnJvbSB0aGUgc2NoZW1hIGVsZW1lbnRzLlxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5TY2hlbWFFbGVtZW50fSBTY2hlbWFFbGVtZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzLmpzJykuU2NoZW1hVHJlZX0gU2NoZW1hVHJlZVxuICogQHBhcmFtIHtTY2hlbWFFbGVtZW50W119IHNjaGVtYVxuICogQHBhcmFtIHtudW1iZXJ9IHJvb3RJbmRleCBpbmRleCBvZiB0aGUgcm9vdCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoIHBhdGggdG8gdGhlIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtTY2hlbWFUcmVlfSB0cmVlIG9mIHNjaGVtYSBlbGVtZW50c1xuICovXG5mdW5jdGlvbiBzY2hlbWFUcmVlKHNjaGVtYSwgcm9vdEluZGV4LCBwYXRoKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBzY2hlbWFbcm9vdEluZGV4XVxuICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gIGxldCBjb3VudCA9IDFcblxuICAvLyBSZWFkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNoaWxkcmVuXG4gIGlmIChlbGVtZW50Lm51bV9jaGlsZHJlbikge1xuICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggPCBlbGVtZW50Lm51bV9jaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGRFbGVtZW50ID0gc2NoZW1hW3Jvb3RJbmRleCArIGNvdW50XVxuICAgICAgY29uc3QgY2hpbGQgPSBzY2hlbWFUcmVlKHNjaGVtYSwgcm9vdEluZGV4ICsgY291bnQsIFsuLi5wYXRoLCBjaGlsZEVsZW1lbnQubmFtZV0pXG4gICAgICBjb3VudCArPSBjaGlsZC5jb3VudFxuICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZClcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBjb3VudCwgZWxlbWVudCwgY2hpbGRyZW4sIHBhdGggfVxufVxuXG4vKipcbiAqIEdldCBzY2hlbWEgZWxlbWVudHMgZnJvbSB0aGUgcm9vdCB0byB0aGUgZ2l2ZW4gZWxlbWVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hRWxlbWVudFtdfSBzY2hlbWFcbiAqIEBwYXJhbSB7c3RyaW5nW119IG5hbWUgcGF0aCB0byB0aGUgZWxlbWVudFxuICogQHJldHVybnMge1NjaGVtYVRyZWVbXX0gbGlzdCBvZiBzY2hlbWEgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYVBhdGgoc2NoZW1hLCBuYW1lKSB7XG4gIGxldCB0cmVlID0gc2NoZW1hVHJlZShzY2hlbWEsIDAsIFtdKVxuICBjb25zdCBwYXRoID0gW3RyZWVdXG4gIGZvciAoY29uc3QgcGFydCBvZiBuYW1lKSB7XG4gICAgY29uc3QgY2hpbGQgPSB0cmVlLmNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQuZWxlbWVudC5uYW1lID09PSBwYXJ0KVxuICAgIGlmICghY2hpbGQpIHRocm93IG5ldyBFcnJvcihgcGFycXVldCBzY2hlbWEgZWxlbWVudCBub3QgZm91bmQ6ICR7bmFtZX1gKVxuICAgIHBhdGgucHVzaChjaGlsZClcbiAgICB0cmVlID0gY2hpbGRcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG4vKipcbiAqIEdldCB0aGUgbWF4IHJlcGV0aXRpb24gbGV2ZWwgZm9yIGEgZ2l2ZW4gc2NoZW1hIHBhdGguXG4gKlxuICogQHBhcmFtIHtTY2hlbWFUcmVlW119IHNjaGVtYVBhdGhcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1heCByZXBldGl0aW9uIGxldmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXhSZXBldGl0aW9uTGV2ZWwoc2NoZW1hUGF0aCkge1xuICBsZXQgbWF4TGV2ZWwgPSAwXG4gIGZvciAoY29uc3QgeyBlbGVtZW50IH0gb2Ygc2NoZW1hUGF0aCkge1xuICAgIGlmIChlbGVtZW50LnJlcGV0aXRpb25fdHlwZSA9PT0gJ1JFUEVBVEVEJykge1xuICAgICAgbWF4TGV2ZWwrK1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4TGV2ZWxcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1heCBkZWZpbml0aW9uIGxldmVsIGZvciBhIGdpdmVuIHNjaGVtYSBwYXRoLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hVHJlZVtdfSBzY2hlbWFQYXRoXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtYXggZGVmaW5pdGlvbiBsZXZlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4RGVmaW5pdGlvbkxldmVsKHNjaGVtYVBhdGgpIHtcbiAgbGV0IG1heExldmVsID0gMFxuICBmb3IgKGNvbnN0IHsgZWxlbWVudCB9IG9mIHNjaGVtYVBhdGguc2xpY2UoMSkpIHtcbiAgICBpZiAoZWxlbWVudC5yZXBldGl0aW9uX3R5cGUgIT09ICdSRVFVSVJFRCcpIHtcbiAgICAgIG1heExldmVsKytcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heExldmVsXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjb2x1bW4gaXMgbGlzdC1saWtlLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hVHJlZX0gc2NoZW1hXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBsaXN0LWxpa2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTGlzdExpa2Uoc2NoZW1hKSB7XG4gIGlmICghc2NoZW1hKSByZXR1cm4gZmFsc2VcbiAgaWYgKHNjaGVtYS5lbGVtZW50LmNvbnZlcnRlZF90eXBlICE9PSAnTElTVCcpIHJldHVybiBmYWxzZVxuICBpZiAoc2NoZW1hLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBzY2hlbWEuY2hpbGRyZW5bMF1cbiAgaWYgKGZpcnN0Q2hpbGQuY2hpbGRyZW4ubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlXG4gIGlmIChmaXJzdENoaWxkLmVsZW1lbnQucmVwZXRpdGlvbl90eXBlICE9PSAnUkVQRUFURUQnKSByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY29sdW1uIGlzIG1hcC1saWtlLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hVHJlZX0gc2NoZW1hXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBtYXAtbGlrZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNNYXBMaWtlKHNjaGVtYSkge1xuICBpZiAoIXNjaGVtYSkgcmV0dXJuIGZhbHNlXG4gIGlmIChzY2hlbWEuZWxlbWVudC5jb252ZXJ0ZWRfdHlwZSAhPT0gJ01BUCcpIHJldHVybiBmYWxzZVxuICBpZiAoc2NoZW1hLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBzY2hlbWEuY2hpbGRyZW5bMF1cbiAgaWYgKGZpcnN0Q2hpbGQuY2hpbGRyZW4ubGVuZ3RoICE9PSAyKSByZXR1cm4gZmFsc2VcbiAgaWYgKGZpcnN0Q2hpbGQuZWxlbWVudC5yZXBldGl0aW9uX3R5cGUgIT09ICdSRVBFQVRFRCcpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGtleUNoaWxkID0gZmlyc3RDaGlsZC5jaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLmVsZW1lbnQubmFtZSA9PT0gJ2tleScpXG4gIGlmIChrZXlDaGlsZD8uZWxlbWVudC5yZXBldGl0aW9uX3R5cGUgPT09ICdSRVBFQVRFRCcpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IHZhbHVlQ2hpbGQgPSBmaXJzdENoaWxkLmNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQuZWxlbWVudC5uYW1lID09PSAndmFsdWUnKVxuICBpZiAodmFsdWVDaGlsZD8uZWxlbWVudC5yZXBldGl0aW9uX3R5cGUgPT09ICdSRVBFQVRFRCcpIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogQ29weXJpZ2h0IChjKSAyMDE2IFpoaXBlbmcgSmlhXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemhpcGVuZy1qaWEvc25hcHB5anNcbiAqL1xuXG5jb25zdCBXT1JEX01BU0sgPSBbMCwgMHhmZiwgMHhmZmZmLCAweGZmZmZmZiwgMHhmZmZmZmZmZl1cblxuLyoqXG4gKiBDb3B5IGJ5dGVzIGZyb20gb25lIGFycmF5IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGZyb21BcnJheSBzb3VyY2UgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tUG9zIHNvdXJjZSBwb3NpdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fSB0b0FycmF5IGRlc3RpbmF0aW9uIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gdG9Qb3MgZGVzdGluYXRpb24gcG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggbnVtYmVyIG9mIGJ5dGVzIHRvIGNvcHlcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBjb3B5Qnl0ZXMoZnJvbUFycmF5LCBmcm9tUG9zLCB0b0FycmF5LCB0b1BvcywgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB0b0FycmF5W3RvUG9zICsgaV0gPSBmcm9tQXJyYXlbZnJvbVBvcyArIGldXG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5IGJ5dGVzIHdpdGhpbiBhbiBhcnJheVxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJyYXkgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBzb3VyY2UgcG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgb2Zmc2V0IGJhY2sgZnJvbSBjdXJyZW50IHBvc2l0aW9uIHRvIHJlYWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggbnVtYmVyIG9mIGJ5dGVzIHRvIGNvcHlcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBzZWxmQ29weUJ5dGVzKGFycmF5LCBwb3MsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtwb3MgKyBpXSA9IGFycmF5W3BvcyAtIG9mZnNldCArIGldXG4gIH1cbn1cblxuLyoqXG4gKiBEZWNvbXByZXNzIHNuYXBweSBkYXRhLlxuICogQWNjZXB0cyBhbiBvdXRwdXQgYnVmZmVyIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBuZXcgYnVmZmVyIGZvciBlYWNoIGNhbGwuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dCBjb21wcmVzc2VkIGRhdGFcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gb3V0cHV0IG91dHB1dCBidWZmZXJcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc25hcHB5VW5jb21wcmVzcyhpbnB1dCwgb3V0cHV0KSB7XG4gIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXQuYnl0ZUxlbmd0aFxuICBjb25zdCBvdXRwdXRMZW5ndGggPSBvdXRwdXQuYnl0ZUxlbmd0aFxuICBsZXQgcG9zID0gMFxuICBsZXQgb3V0UG9zID0gMFxuXG4gIC8vIHNraXAgcHJlYW1ibGUgKGNvbnRhaW5zIHVuY29tcHJlc3NlZCBsZW5ndGggYXMgdmFyaW50KVxuICB3aGlsZSAocG9zIDwgaW5wdXRMZW5ndGgpIHtcbiAgICBjb25zdCBjID0gaW5wdXRbcG9zXVxuICAgIHBvcysrXG4gICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXRMZW5ndGggJiYgcG9zID49IGlucHV0TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNuYXBweSBsZW5ndGggaGVhZGVyJylcbiAgfVxuXG4gIHdoaWxlIChwb3MgPCBpbnB1dExlbmd0aCkge1xuICAgIGNvbnN0IGMgPSBpbnB1dFtwb3NdXG4gICAgbGV0IGxlbiA9IDBcbiAgICBwb3MrK1xuXG4gICAgaWYgKHBvcyA+PSBpbnB1dExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGVvZiBtYXJrZXInKVxuICAgIH1cblxuICAgIC8vIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgZWxlbWVudHMsIGxpdGVyYWxzIGFuZCBjb3BpZXMgKGJhY2sgcmVmZXJlbmNlcylcbiAgICBpZiAoKGMgJiAweDMpID09PSAwKSB7XG4gICAgICAvLyBMaXRlcmFscyBhcmUgdW5jb21wcmVzc2VkIGRhdGEgc3RvcmVkIGRpcmVjdGx5IGluIHRoZSBieXRlIHN0cmVhbVxuICAgICAgbGV0IGxlbiA9IChjID4+PiAyKSArIDFcbiAgICAgIC8vIExvbmdlciBsaXRlcmFsIGxlbmd0aCBpcyBlbmNvZGVkIGluIG11bHRpcGxlIGJ5dGVzXG4gICAgICBpZiAobGVuID4gNjApIHtcbiAgICAgICAgaWYgKHBvcyArIDMgPj0gaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NuYXBweSBlcnJvciBsaXRlcmFsIHBvcyArIDMgPj0gaW5wdXRMZW5ndGgnKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aFNpemUgPSBsZW4gLSA2MCAvLyBsZW5ndGggYnl0ZXMgLSAxXG4gICAgICAgIGxlbiA9IGlucHV0W3Bvc11cbiAgICAgICAgICArIChpbnB1dFtwb3MgKyAxXSA8PCA4KVxuICAgICAgICAgICsgKGlucHV0W3BvcyArIDJdIDw8IDE2KVxuICAgICAgICAgICsgKGlucHV0W3BvcyArIDNdIDw8IDI0KVxuICAgICAgICBsZW4gPSAobGVuICYgV09SRF9NQVNLW2xlbmd0aFNpemVdKSArIDFcbiAgICAgICAgcG9zICs9IGxlbmd0aFNpemVcbiAgICAgIH1cbiAgICAgIGlmIChwb3MgKyBsZW4gPiBpbnB1dExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NuYXBweSBlcnJvciBsaXRlcmFsIGV4Y2VlZHMgaW5wdXQgbGVuZ3RoJylcbiAgICAgIH1cbiAgICAgIGNvcHlCeXRlcyhpbnB1dCwgcG9zLCBvdXRwdXQsIG91dFBvcywgbGVuKVxuICAgICAgcG9zICs9IGxlblxuICAgICAgb3V0UG9zICs9IGxlblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb3B5IGVsZW1lbnRzXG4gICAgICBsZXQgb2Zmc2V0ID0gMCAvLyBvZmZzZXQgYmFjayBmcm9tIGN1cnJlbnQgcG9zaXRpb24gdG8gcmVhZFxuICAgICAgc3dpdGNoIChjICYgMHgzKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIENvcHkgd2l0aCAxLWJ5dGUgb2Zmc2V0XG4gICAgICAgIGxlbiA9IChjID4+PiAyICYgMHg3KSArIDRcbiAgICAgICAgb2Zmc2V0ID0gaW5wdXRbcG9zXSArIChjID4+PiA1IDw8IDgpXG4gICAgICAgIHBvcysrXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIENvcHkgd2l0aCAyLWJ5dGUgb2Zmc2V0XG4gICAgICAgIGlmIChpbnB1dExlbmd0aCA8PSBwb3MgKyAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzbmFwcHkgZXJyb3IgZW5kIG9mIGlucHV0JylcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSAoYyA+Pj4gMikgKyAxXG4gICAgICAgIG9mZnNldCA9IGlucHV0W3Bvc10gKyAoaW5wdXRbcG9zICsgMV0gPDwgOClcbiAgICAgICAgcG9zICs9IDJcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gQ29weSB3aXRoIDQtYnl0ZSBvZmZzZXRcbiAgICAgICAgaWYgKGlucHV0TGVuZ3RoIDw9IHBvcyArIDMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NuYXBweSBlcnJvciBlbmQgb2YgaW5wdXQnKVxuICAgICAgICB9XG4gICAgICAgIGxlbiA9IChjID4+PiAyKSArIDFcbiAgICAgICAgb2Zmc2V0ID0gaW5wdXRbcG9zXVxuICAgICAgICAgICsgKGlucHV0W3BvcyArIDFdIDw8IDgpXG4gICAgICAgICAgKyAoaW5wdXRbcG9zICsgMl0gPDwgMTYpXG4gICAgICAgICAgKyAoaW5wdXRbcG9zICsgM10gPDwgMjQpXG4gICAgICAgIHBvcyArPSA0XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA9PT0gMCB8fCBpc05hTihvZmZzZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvZmZzZXQgJHtvZmZzZXR9IHBvcyAke3Bvc30gaW5wdXRMZW5ndGggJHtpbnB1dExlbmd0aH1gKVxuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA+IG91dFBvcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjb3B5IGZyb20gYmVmb3JlIHN0YXJ0IG9mIGJ1ZmZlcicpXG4gICAgICB9XG4gICAgICBzZWxmQ29weUJ5dGVzKG91dHB1dCwgb3V0UG9zLCBvZmZzZXQsIGxlbilcbiAgICAgIG91dFBvcyArPSBsZW5cbiAgICB9XG4gIH1cblxuICBpZiAob3V0UG9zICE9PSBvdXRwdXRMZW5ndGgpIHRocm93IG5ldyBFcnJvcigncHJlbWF0dXJlIGVuZCBvZiBpbnB1dCcpXG59XG4iLCIvLyBUQ29tcGFjdFByb3RvY29sIHR5cGVzXG5jb25zdCBDb21wYWN0VHlwZSA9IHtcbiAgU1RPUDogMCxcbiAgVFJVRTogMSxcbiAgRkFMU0U6IDIsXG4gIEJZVEU6IDMsXG4gIEkxNjogNCxcbiAgSTMyOiA1LFxuICBJNjQ6IDYsXG4gIERPVUJMRTogNyxcbiAgQklOQVJZOiA4LFxuICBMSVNUOiA5LFxuICBTRVQ6IDEwLFxuICBNQVA6IDExLFxuICBTVFJVQ1Q6IDEyLFxuICBVVUlEOiAxMyxcbn1cblxuLyoqXG4gKiBQYXJzZSBUQ29tcGFjdFByb3RvY29sXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5EYXRhUmVhZGVyfSBEYXRhUmVhZGVyXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZVRDb21wYWN0UHJvdG9jb2wocmVhZGVyKSB7XG4gIGxldCBsYXN0RmlkID0gMFxuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovXG4gIGNvbnN0IHZhbHVlID0ge31cblxuICB3aGlsZSAocmVhZGVyLm9mZnNldCA8IHJlYWRlci52aWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAvLyBQYXJzZSBlYWNoIGZpZWxkIGJhc2VkIG9uIGl0cyB0eXBlIGFuZCBhZGQgdG8gdGhlIHJlc3VsdCBvYmplY3RcbiAgICBjb25zdCBbdHlwZSwgZmlkLCBuZXdMYXN0RmlkXSA9IHJlYWRGaWVsZEJlZ2luKHJlYWRlciwgbGFzdEZpZClcbiAgICBsYXN0RmlkID0gbmV3TGFzdEZpZFxuXG4gICAgaWYgKHR5cGUgPT09IENvbXBhY3RUeXBlLlNUT1ApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSBmaWVsZCBiYXNlZCBvbiBpdHMgdHlwZVxuICAgIHZhbHVlW2BmaWVsZF8ke2ZpZH1gXSA9IHJlYWRFbGVtZW50KHJlYWRlciwgdHlwZSlcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIFJlYWQgYSBzaW5nbGUgZWxlbWVudCBiYXNlZCBvbiBpdHMgdHlwZVxuICpcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHJldHVybnMge2FueX0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gcmVhZEVsZW1lbnQocmVhZGVyLCB0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlIENvbXBhY3RUeXBlLlRSVUU6XG4gICAgcmV0dXJuIHRydWVcbiAgY2FzZSBDb21wYWN0VHlwZS5GQUxTRTpcbiAgICByZXR1cm4gZmFsc2VcbiAgY2FzZSBDb21wYWN0VHlwZS5CWVRFOlxuICAgIC8vIHJlYWQgYnl0ZSBkaXJlY3RseVxuICAgIHJldHVybiByZWFkZXIudmlldy5nZXRJbnQ4KHJlYWRlci5vZmZzZXQrKylcbiAgY2FzZSBDb21wYWN0VHlwZS5JMTY6XG4gIGNhc2UgQ29tcGFjdFR5cGUuSTMyOlxuICAgIHJldHVybiByZWFkWmlnWmFnKHJlYWRlcilcbiAgY2FzZSBDb21wYWN0VHlwZS5JNjQ6XG4gICAgcmV0dXJuIHJlYWRaaWdaYWdCaWdJbnQocmVhZGVyKVxuICBjYXNlIENvbXBhY3RUeXBlLkRPVUJMRToge1xuICAgIGNvbnN0IHZhbHVlID0gcmVhZGVyLnZpZXcuZ2V0RmxvYXQ2NChyZWFkZXIub2Zmc2V0LCB0cnVlKVxuICAgIHJlYWRlci5vZmZzZXQgKz0gOFxuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIGNhc2UgQ29tcGFjdFR5cGUuQklOQVJZOiB7XG4gICAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gcmVhZFZhckludChyZWFkZXIpXG4gICAgY29uc3Qgc3RyQnl0ZXMgPSBuZXcgVWludDhBcnJheShyZWFkZXIudmlldy5idWZmZXIsIHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0LCBzdHJpbmdMZW5ndGgpXG4gICAgcmVhZGVyLm9mZnNldCArPSBzdHJpbmdMZW5ndGhcbiAgICByZXR1cm4gc3RyQnl0ZXNcbiAgfVxuICBjYXNlIENvbXBhY3RUeXBlLkxJU1Q6IHtcbiAgICBjb25zdCBbZWxlbVR5cGUsIGxpc3RTaXplXSA9IHJlYWRDb2xsZWN0aW9uQmVnaW4ocmVhZGVyKVxuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShsaXN0U2l6ZSlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RTaXplOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IHJlYWRFbGVtZW50KHJlYWRlciwgZWxlbVR5cGUpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXNcbiAgfVxuICBjYXNlIENvbXBhY3RUeXBlLlNUUlVDVDoge1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgICBjb25zdCBzdHJ1Y3RWYWx1ZXMgPSB7fVxuICAgIGxldCBzdHJ1Y3RMYXN0RmlkID0gMFxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgc3RydWN0RmllbGRUeXBlLCBzdHJ1Y3RGaWRcbiAgICAgIFtzdHJ1Y3RGaWVsZFR5cGUsIHN0cnVjdEZpZCwgc3RydWN0TGFzdEZpZF0gPSByZWFkRmllbGRCZWdpbihyZWFkZXIsIHN0cnVjdExhc3RGaWQpXG4gICAgICBpZiAoc3RydWN0RmllbGRUeXBlID09PSBDb21wYWN0VHlwZS5TVE9QKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBzdHJ1Y3RWYWx1ZXNbYGZpZWxkXyR7c3RydWN0RmlkfWBdID0gcmVhZEVsZW1lbnQocmVhZGVyLCBzdHJ1Y3RGaWVsZFR5cGUpXG4gICAgfVxuICAgIHJldHVybiBzdHJ1Y3RWYWx1ZXNcbiAgfVxuICAvLyBUT0RPOiBNQVAgYW5kIFNFVFxuICBjYXNlIENvbXBhY3RUeXBlLlVVSUQ6IHtcbiAgICAvLyBSZWFkIDE2IGJ5dGVzIHRvIHV1aWQgc3RyaW5nXG4gICAgbGV0IHV1aWQgPSAnJ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgdXVpZCArPSByZWFkZXIudmlldy5nZXRVaW50OChyZWFkZXIub2Zmc2V0KyspLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpXG4gICAgfVxuICAgIHJldHVybiB1dWlkXG4gIH1cbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHRocmlmdCB1bmhhbmRsZWQgdHlwZTogJHt0eXBlfWApXG4gIH1cbn1cblxuLyoqXG4gKiBWYXIgaW50LCBhbHNvIGtub3duIGFzIFVuc2lnbmVkIExFQjEyOC5cbiAqIFZhciBpbnRzIHRha2UgMSB0byA1IGJ5dGVzIChpbnQzMikgb3IgMSB0byAxMCBieXRlcyAoaW50NjQpLlxuICogVGFrZXMgYSBCaWcgRW5kaWFuIHVuc2lnbmVkIGludGVnZXIsIGxlZnQtcGFkcyB0aGUgYml0LXN0cmluZyB0byBtYWtlIGl0IGFcbiAqIG11bHRpcGxlIG9mIDcgYml0cywgc3BsaXRzIGl0IGludG8gNy1iaXQgZ3JvdXBzLCBwcmVmaXggdGhlIG1vc3Qtc2lnbmlmaWNhbnRcbiAqIDctYml0IGdyb3VwIHdpdGggdGhlIDAgYml0LCBwcmVmaXhpbmcgdGhlIHJlbWFpbmluZyA3LWJpdCBncm91cHMgd2l0aCB0aGVcbiAqIDEgYml0IGFuZCBlbmNvZGUgdGhlIHJlc3VsdGluZyBiaXQtc3RyaW5nIGFzIExpdHRsZSBFbmRpYW4uXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkVmFySW50KHJlYWRlcikge1xuICBsZXQgcmVzdWx0ID0gMFxuICBsZXQgc2hpZnQgPSAwXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgYnl0ZSA9IHJlYWRlci52aWV3LmdldFVpbnQ4KHJlYWRlci5vZmZzZXQrKylcbiAgICByZXN1bHQgfD0gKGJ5dGUgJiAweDdmKSA8PCBzaGlmdFxuICAgIGlmICghKGJ5dGUgJiAweDgwKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICBzaGlmdCArPSA3XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFkIGEgdmFyaW50IGFzIGEgYmlnaW50LlxuICpcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcmV0dXJucyB7YmlnaW50fSB2YWx1ZVxuICovXG5mdW5jdGlvbiByZWFkVmFyQmlnSW50KHJlYWRlcikge1xuICBsZXQgcmVzdWx0ID0gMG5cbiAgbGV0IHNoaWZ0ID0gMG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBieXRlID0gcmVhZGVyLnZpZXcuZ2V0VWludDgocmVhZGVyLm9mZnNldCsrKVxuICAgIHJlc3VsdCB8PSBCaWdJbnQoYnl0ZSAmIDB4N2YpIDw8IHNoaWZ0XG4gICAgaWYgKCEoYnl0ZSAmIDB4ODApKSB7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIHNoaWZ0ICs9IDduXG4gIH1cbn1cblxuLyoqXG4gKiBWYWx1ZXMgb2YgdHlwZSBpbnQzMiBhbmQgaW50NjQgYXJlIHRyYW5zZm9ybWVkIHRvIGEgemlnemFnIGludC5cbiAqIEEgemlnemFnIGludCBmb2xkcyBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgbnVtYmVycyBpbnRvIHRoZSBwb3NpdGl2ZSBudW1iZXIgc3BhY2UuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHJlYWRaaWdaYWcocmVhZGVyKSB7XG4gIGNvbnN0IHppZ3phZyA9IHJlYWRWYXJJbnQocmVhZGVyKVxuICAvLyBjb252ZXJ0IHppZ3phZyB0byBpbnRcbiAgcmV0dXJuIHppZ3phZyA+Pj4gMSBeIC0oemlnemFnICYgMSlcbn1cblxuLyoqXG4gKiBBIHppZ3phZyBpbnQgZm9sZHMgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIG51bWJlcnMgaW50byB0aGUgcG9zaXRpdmUgbnVtYmVyIHNwYWNlLlxuICogVGhpcyB2ZXJzaW9uIHJldHVybnMgYSBCaWdJbnQuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEByZXR1cm5zIHtiaWdpbnR9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkWmlnWmFnQmlnSW50KHJlYWRlcikge1xuICBjb25zdCB6aWd6YWcgPSByZWFkVmFyQmlnSW50KHJlYWRlcilcbiAgLy8gY29udmVydCB6aWd6YWcgdG8gaW50XG4gIHJldHVybiB6aWd6YWcgPj4gQmlnSW50KDEpIF4gLSh6aWd6YWcgJiBCaWdJbnQoMSkpXG59XG5cbi8qKlxuICogR2V0IHRocmlmdCB0eXBlIGZyb20gaGFsZiBhIGJ5dGVcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcGFjdFR5cGUoYnl0ZSkge1xuICByZXR1cm4gYnl0ZSAmIDB4MGZcbn1cblxuLyoqXG4gKiBSZWFkIGZpZWxkIHR5cGUgYW5kIGZpZWxkIGlkXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0RmlkXG4gKiBAcmV0dXJucyB7W251bWJlciwgbnVtYmVyLCBudW1iZXJdfSBbdHlwZSwgZmlkLCBuZXdMYXN0RmlkXVxuICovXG5mdW5jdGlvbiByZWFkRmllbGRCZWdpbihyZWFkZXIsIGxhc3RGaWQpIHtcbiAgY29uc3QgdHlwZSA9IHJlYWRlci52aWV3LmdldFVpbnQ4KHJlYWRlci5vZmZzZXQrKylcbiAgaWYgKCh0eXBlICYgMHgwZikgPT09IENvbXBhY3RUeXBlLlNUT1ApIHtcbiAgICAvLyBTVE9QIGFsc28gZW5kcyBhIHN0cnVjdFxuICAgIHJldHVybiBbMCwgMCwgbGFzdEZpZF1cbiAgfVxuICBjb25zdCBkZWx0YSA9IHR5cGUgPj4gNFxuICBsZXQgZmlkIC8vIGZpZWxkIGlkXG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIC8vIG5vdCBhIGRlbHRhLCByZWFkIHppZ3phZyB2YXJpbnQgZmllbGQgaWRcbiAgICBmaWQgPSByZWFkWmlnWmFnKHJlYWRlcilcbiAgfSBlbHNlIHtcbiAgICAvLyBhZGQgZGVsdGEgdG8gbGFzdCBmaWVsZCBpZFxuICAgIGZpZCA9IGxhc3RGaWQgKyBkZWx0YVxuICB9XG4gIHJldHVybiBbZ2V0Q29tcGFjdFR5cGUodHlwZSksIGZpZCwgZmlkXVxufVxuXG4vKipcbiAqIFJlYWQgY29sbGVjdGlvbiB0eXBlIGFuZCBzaXplXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXJdfSBbdHlwZSwgc2l6ZV1cbiAqL1xuZnVuY3Rpb24gcmVhZENvbGxlY3Rpb25CZWdpbihyZWFkZXIpIHtcbiAgY29uc3Qgc2l6ZVR5cGUgPSByZWFkZXIudmlldy5nZXRVaW50OChyZWFkZXIub2Zmc2V0KyspXG4gIGNvbnN0IHNpemUgPSBzaXplVHlwZSA+PiA0XG4gIGNvbnN0IHR5cGUgPSBnZXRDb21wYWN0VHlwZShzaXplVHlwZSlcbiAgaWYgKHNpemUgPT09IDE1KSB7XG4gICAgY29uc3QgbmV3U2l6ZSA9IHJlYWRWYXJJbnQocmVhZGVyKVxuICAgIHJldHVybiBbdHlwZSwgbmV3U2l6ZV1cbiAgfVxuICByZXR1cm4gW3R5cGUsIHNpemVdXG59XG5cbi8qKlxuICogQ29udmVydCBpbnQgdG8gdmFyaW50LiBPdXRwdXRzIDEtNSBieXRlcyBmb3IgaW50MzIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVmFySW50KG4pIHtcbiAgbGV0IGlkeCA9IDBcbiAgY29uc3QgdmFySW50ID0gW11cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoKG4gJiB+MHg3ZikgPT09IDApIHtcbiAgICAgIHZhckludFtpZHgrK10gPSBuXG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXJJbnRbaWR4KytdID0gbiAmIDB4N2YgfCAweDgwXG4gICAgICBuID4+Pj0gN1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFySW50XG59XG4iLCIvKipcbiAqIFJlcGxhY2UgYmlnaW50cyB3aXRoIG51bWJlcnMuXG4gKiBXaGVuIHBhcnNpbmcgcGFycXVldCBmaWxlcywgYmlnaW50cyBhcmUgdXNlZCB0byByZXByZXNlbnQgNjQtYml0IGludGVnZXJzLlxuICogSG93ZXZlciwgSlNPTiBkb2VzIG5vdCBzdXBwb3J0IGJpZ2ludHMsIHNvIGl0J3MgaGVscGZ1bCB0byBjb252ZXJ0IHRvIG51bWJlcnMuXG4gKlxuICogQHBhcmFtIHthbnl9IG9iaiBvYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMge3Vua25vd259IGNvbnZlcnRlZCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSnNvbihvYmopIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbFxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ2JpZ2ludCcpIHJldHVybiBOdW1iZXIob2JqKVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLm1hcCh0b0pzb24pXG4gIGlmIChvYmogaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gQXJyYXkuZnJvbShvYmopXG4gIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gb2JqLnRvSVNPU3RyaW5nKClcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59ICovXG4gICAgY29uc3QgbmV3T2JqID0ge31cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkgY29udGludWVcbiAgICAgIG5ld09ialtrZXldID0gdG9Kc29uKG9ialtrZXldKVxuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqXG4gIH1cbiAgcmV0dXJuIG9ialxufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlIHR3byBhcnJheXMgZmFzdC5cbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzLmpzJykuRGVjb2RlZEFycmF5fSBEZWNvZGVkQXJyYXlcbiAqIEBwYXJhbSB7YW55W119IGFhYSBmaXJzdCBhcnJheVxuICogQHBhcmFtIHtEZWNvZGVkQXJyYXl9IGJiYiBzZWNvbmQgYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChhYWEsIGJiYikge1xuICBjb25zdCBjaHVuayA9IDEwMDAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmJiLmxlbmd0aDsgaSArPSBjaHVuaykge1xuICAgIGFhYS5wdXNoKC4uLmJiYi5zbGljZShpLCBpICsgY2h1bmspKVxuICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IERhdGFzZXQgfSBmcm9tICdncmlkdml6J1xuaW1wb3J0IHsgcGFycXVldE1ldGFkYXRhIH0gZnJvbSAnaHlwYXJxdWV0J1xuLy9pbXBvcnQgeyB0YWJsZUZyb21JUEMgfSBmcm9tICdhcGFjaGUtYXJyb3cnXG4vL2ltcG9ydCB7IHJlYWRQYXJxdWV0IH0gZnJvbSBcInBhcnF1ZXQtd2FzbVwiXG4vL2ltcG9ydCB7IHJlYWRQYXJxdWV0IH0gZnJvbSBcInBhcnF1ZXQtd2FzbS9idW5kbGVyL2Fycm93MS5qc1wiO1xuLy9pbXBvcnQgeyByZWFkUGFycXVldCB9IGZyb20gXCJwYXJxdWV0LXdhc20vbm9kZTJcIjtcblxuLy9zZWUgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGFycXVldC13YXNtXG5cbi8vc2VlIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AYm1zY2htaWR0L2hlbGxvLXBhcnF1ZXQtd2FzbVxuLypcbnBxID0ge1xuICBjb25zdCBwcSA9IGF3YWl0IGltcG9ydCgnaHR0cHM6Ly91bnBrZy5jb20vcGFycXVldC13YXNtQDAuMS4xL3dlYi5qcycpXG4gIC8vIGRlZmF1bHQgc2VlbXMgdG8gbmVlZCB0byByZXNvbHZlIGZpcnN0P1xuICBhd2FpdCBwcS5kZWZhdWx0KClcbiAgcmV0dXJuIHBxXG59XG4qL1xuXG4vKipcbiAqIEEgZGF0YXNldCBjb21wb3NlZCBvZiBhIHNpbmdsZSBwYXJxdWV0IGZpbGUgKG5vdCB0aWxlZCkuXG4gKlxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgUGFycXVldEdyaWQgZXh0ZW5kcyBEYXRhc2V0IHtcblxuICAgIGNvbnN0cnVjdG9yKG1hcCwgdXJsLCByZXNvbHV0aW9uLCBvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIobWFwLCB1cmwsIHJlc29sdXRpb24sIG9wdHMpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48b2JqZWN0Pn0gKi9cbiAgICAgICAgdGhpcy5jZWxscyA9IFtdXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlICAqL1xuICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ25vdExvYWRlZCdcblxuICAgICAgICAvL2NvbnNvbGUubG9nKHJlYWRQYXJxdWV0KVxuICAgICAgICAvL2NvbnN0IHBxID0gYXdhaXQgaW1wb3J0KCdodHRwczovL3VucGtnLmNvbS9wYXJxdWV0LXdhc21AMC4xLjEvd2ViLmpzJylcbiAgICAgICAgLy9hd2FpdCBwcS5kZWZhdWx0KClcblxuICAgICAgICBpZiAoIW9wdHMucmVhZFBhcnF1ZXRGdW4pIHRocm93IG5ldyBFcnJvcigncmVhZFBhcnF1ZXQgZnVuY3Rpb24gbmVlZGVkIGZvciBwYXJxdWV0IGRhdGFzZXQnKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlICAqL1xuICAgICAgICAvL3RoaXMucmVhZFBhcnF1ZXRGdW4gPSBvcHRzLnJlYWRQYXJxdWV0RnVuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBkYXRhIHdpdGhpbiBhIGdlb2dyYXBoaWMgZW52ZWxvcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHx1bmRlZmluZWR9IGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gcmVkcmF3XG4gICAgICovXG4gICAgZ2V0RGF0YShlLCByZWRyYXcpIHtcbiAgICAgICAgLy9jaGVjayBpZiBkYXRhIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGlmICh0aGlzLmluZm9Mb2FkaW5nU3RhdHVzICE9ICdub3RMb2FkZWQnKSByZXR1cm4gdGhpc1xuXG4gICAgICAgIC8vbG9hZCBkYXRhXG4gICAgICAgIHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPSAnbG9hZGluZydcblxuICAgICAgICBjb25zdCByZXMgPSBmZXRjaCh0aGlzLnVybClcbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSByZXMuYXJyYXlCdWZmZXIoKVxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHBhcnF1ZXRNZXRhZGF0YShhcnJheUJ1ZmZlcilcbiAgICAgICAgY29uc29sZS5sb2cobWV0YWRhdGEpXG5cbiAgICAgICAgLyo7KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKHRoaXMudXJsKVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnF1ZXRVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcC5hcnJheUJ1ZmZlcigpKVxuICAgICAgICAgICAgICAgIGNvbnN0IGFycm93VWludDhBcnJheSA9IHRoaXMucmVhZFBhcnF1ZXRGdW4ocGFycXVldFVpbnQ4QXJyYXkpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gdGFibGVGcm9tSVBDKGFycm93VWludDhBcnJheSlcbiAgICAgICAgICAgICAgICAvL3NlZSBodHRwczovL2Fycm93LmFwYWNoZS5vcmcvZG9jcy9qcy9cbiAgICAgICAgICAgICAgICAvL2h0dHBzOi8vbG9hZGVycy5nbC9hcnJvd2pzL2RvY3MvZGV2ZWxvcGVyLWd1aWRlL3RhYmxlcyNyZWNvcmQtdG9qc29uLWFuZC10b2FycmF5XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzID0gW11cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdCkge1xuICAgICAgICAgICAgICAgICAgICAvL2dldCBjZWxsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBlLnRvSlNPTigpXG5cbiAgICAgICAgICAgICAgICAgICAgLy9wcmVwcm9jZXNzL2ZpbHRlclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmVwcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5wcmVwcm9jZXNzKGMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYiA9PSBmYWxzZSkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2VsbHMucHVzaChjKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxscy5wdXNoKGMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL1RPRE8gY2hlY2sgaWYgcmVkcmF3IGlzIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIC8vdGhhdCBpcyBpZiB0aGUgZGF0YXNldCBiZWxvbmdzIHRvIGEgbGF5ZXIgd2hpY2ggaXMgdmlzaWJsZSBhdCB0aGUgY3VycmVudCB6b29tIGxldmVsXG5cbiAgICAgICAgICAgICAgICAvL2V4ZWN1dGUgdGhlIGNhbGxiYWNrLCB1c3VhbGx5IGEgZHJhdyBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmIChyZWRyYXcpIHJlZHJhdygpXG5cbiAgICAgICAgICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2xvYWRlZCdcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy9tYXJrIGFzIGZhaWxlZFxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPSAnZmFpbGVkJ1xuICAgICAgICAgICAgICAgIHRoaXMuY2VsbHMgPSBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpKi9cblxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGwgdGhlIHZpZXcgY2FjaGUgd2l0aCBhbGwgY2VsbHMgd2hpY2ggYXJlIHdpdGhpbiBhIGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBleHRHZW9cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVWaWV3Q2FjaGUoZXh0R2VvKSB7XG4gICAgICAgIC8vZGF0YSBub3QgbG9hZGVkIHlldFxuICAgICAgICBpZiAoIXRoaXMuY2VsbHMpIHJldHVyblxuXG4gICAgICAgIHRoaXMuY2VsbHNWaWV3Q2FjaGUgPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGhpcy5jZWxscykge1xuICAgICAgICAgICAgaWYgKCtjZWxsLnggKyB0aGlzLnJlc29sdXRpb24gPCBleHRHZW8ueE1pbikgY29udGludWVcbiAgICAgICAgICAgIGlmICgrY2VsbC54IC0gdGhpcy5yZXNvbHV0aW9uID4gZXh0R2VvLnhNYXgpIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoK2NlbGwueSArIHRoaXMucmVzb2x1dGlvbiA8IGV4dEdlby55TWluKSBjb250aW51ZVxuICAgICAgICAgICAgaWYgKCtjZWxsLnkgLSB0aGlzLnJlc29sdXRpb24gPiBleHRHZW8ueU1heCkgY29udGludWVcbiAgICAgICAgICAgIHRoaXMuY2VsbHNWaWV3Q2FjaGUucHVzaChjZWxsKVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydCB7IFBhcnF1ZXRHcmlkIH0gZnJvbSBcIi4vUGFycXVldEdyaWQuanNcIlxuLy9leHBvcnQgeyBUaWxlZFBhcnF1ZXRHcmlkIH0gZnJvbSBcIi4vVGlsZWRQYXJxdWV0R3JpZC5qc1wiXG4vKlxuaW1wb3J0IHsgRGF0YXNldCB9IGZyb20gJ2dyaWR2aXonXG5pbXBvcnQgeyBQYXJxdWV0R3JpZCB9IGZyb20gXCIuL1BhcnF1ZXRHcmlkLmpzXCJcbmltcG9ydCB7IFRpbGVkUGFycXVldEdyaWQgfSBmcm9tIFwiLi9UaWxlZFBhcnF1ZXRHcmlkLmpzXCJcblxuLy9pbXBvcnQgeyByZWFkUGFycXVldCB9IGZyb20gXCJwYXJxdWV0LXdhc21cIlxuLy9pbXBvcnQgeyByZWFkUGFycXVldCB9IGZyb20gXCJwYXJxdWV0LXdhc20vYnVuZGxlci9hcnJvdzEuanNcIjtcbi8vaW1wb3J0IHsgcmVhZFBhcnF1ZXQgfSBmcm9tIFwicGFycXVldC13YXNtL25vZGUyXCI7XG5cblxuXG4vKlxuZXhwb3J0IGNvbnN0IG1ha2VQYXJxdWV0R3JpZERhdGFzZXQgPSBmdW5jdGlvbiAoYXBwLCB1cmwsIHJlc29sdXRpb24sIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IERhdGFzZXQoW25ldyBQYXJxdWV0R3JpZCh1cmwsIHJlc29sdXRpb24sIG9wdHMpLmdldERhdGEodW5kZWZpbmVkLCAoKSA9PiB7IGFwcC5jZy5yZWRyYXcoKTsgfSldLCBbXSwgb3B0cylcbn1cblxuLyoqXG4qIEFkZCBhIGxheWVyIGZyb20gYSBwYXJxdWV0IGdyaWQgZGF0YXNldC5cbipcbiogQHBhcmFtIHtvYmplY3R9IGFwcCBUaGUgZ3JpZHZpeiBhcHBsaWNhdGlvbi5cbiogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoZSBkYXRhc2V0LlxuKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBUaGUgZGF0YXNldCByZXNvbHV0aW9uIGluIGdlb2dyYXBoaWNhbCB1bml0LlxuKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBzdHlsZXMgVGhlIHN0eWxlcywgb3JkZXJlZCBpbiBkcmF3aW5nIG9yZGVyLlxuKiBAcGFyYW0ge29iamVjdD19IG9wdHMgVGhlIHBhcmFtZXRlcnMgb2YgdGhlIGRhdGFzZXQgYW5kIGxheWVyLlxuKiBAcmV0dXJucyB7b2JqZWN0fVxuKi9cbi8qZXhwb3J0IGNvbnN0IGFkZFBhcnF1ZXRHcmlkTGF5ZXIgPSBmdW5jdGlvbiAoYXBwLCB1cmwsIHJlc29sdXRpb24sIHN0eWxlcywgb3B0cykge1xuICAgIGNvbnN0IGRzID0gbWFrZVBhcnF1ZXRHcmlkRGF0YXNldChhcHAsIHVybCwgcmVzb2x1dGlvbiwgb3B0cylcbiAgICByZXR1cm4gYXBwLmFkZExheWVyRnJvbURhdGFzZXQoZHMsIHN0eWxlcywgb3B0cyk7XG59Ki9cblxuXG5cblxuXG5cbi8qXG5leHBvcnQgY29uc3QgbWFrZU11bHRpU2NhbGVQYXJxdWV0R3JpZERhdGFzZXQgPSBmdW5jdGlvbiAoYXBwLCByZXNvbHV0aW9ucywgcmVzVG9VUkwsIG9wdHMpIHtcbiAgICByZXR1cm4gRGF0YXNldC5tYWtlKFxuICAgICAgICByZXNvbHV0aW9ucyxcbiAgICAgICAgKHJlcykgPT4gbmV3IFBhcnF1ZXRHcmlkKHJlc1RvVVJMKHJlcyksIHJlcywgb3B0cykuZ2V0RGF0YSh1bmRlZmluZWQsICgpID0+IHsgYXBwLmNnLnJlZHJhdygpIH0pLFxuICAgICAgICBvcHRzXG4gICAgKVxufVxuXG4vKipcbiogQHBhcmFtIHtvYmplY3R9IGFwcCBUaGUgZ3JpZHZpeiBhcHBsaWNhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJlc29sdXRpb25zXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6c3RyaW5nfSByZXNUb1VSTFxuKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBzdHlsZXMgVGhlIHN0eWxlcywgb3JkZXJlZCBpbiBkcmF3aW5nIG9yZGVyLlxuICogQHBhcmFtIHtvYmplY3Q9fSBvcHRzIFRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBkYXRhc2V0IGFuZCBsYXllci5cbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbi8qZXhwb3J0IGNvbnN0IGFkZE11bHRpU2NhbGVQYXJxdWV0R3JpZExheWVyID0gZnVuY3Rpb24gKGFwcCwgcmVzb2x1dGlvbnMsIHJlc1RvVVJMLCBzdHlsZXMsIG9wdHMpIHtcbiAgICBjb25zdCBkcyA9IG1ha2VNdWx0aVNjYWxlUGFycXVldEdyaWREYXRhc2V0KGFwcCwgcmVzb2x1dGlvbnMsIHJlc1RvVVJMLCBvcHRzKVxuICAgIHJldHVybiBhcHAuYWRkTGF5ZXJGcm9tRGF0YXNldChkcywgc3R5bGVzLCBvcHRzKVxufVxuXG5cblxuXG5cblxuZXhwb3J0IGNvbnN0IG1ha2VUaWxlZFBhcnF1ZXRHcmlkRGF0YXNldCA9IGZ1bmN0aW9uIChhcHAsIHVybCwgb3B0cykge1xuICAgIHJldHVybiBuZXcgRGF0YXNldChcbiAgICAgICAgW25ldyBUaWxlZFBhcnF1ZXRHcmlkKHVybCwgYXBwLCBvcHRzKS5sb2FkSW5mbygoKSA9PiB7IGFwcC5jZy5yZWRyYXcoKSB9KSxdLFxuICAgICAgICBbXSxcbiAgICAgICAgb3B0c1xuICAgIClcbn1cblxuLyoqXG4qIEBwYXJhbSB7b2JqZWN0fSBhcHAgVGhlIGdyaWR2aXogYXBwbGljYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4qIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHN0eWxlcyBUaGUgc3R5bGVzLCBvcmRlcmVkIGluIGRyYXdpbmcgb3JkZXIuXG4gKiBAcGFyYW0ge3t2aXNpYmxlPzpib29sZWFuLG1pblpvb20/Om51bWJlcixtYXhab29tPzpudW1iZXIscGl4TmI/Om51bWJlcixjZWxsSW5mb0hUTUw/OmZ1bmN0aW9uKG9iamVjdCk6c3RyaW5nLCBwcmVwcm9jZXNzPzpmdW5jdGlvbihvYmplY3QpOmJvb2xlYW59fSBvcHRzXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG4vKmV4cG9ydCBjb25zdCBhZGRUaWxlZFBhcnF1ZXRHcmlkTGF5ZXIgPSBmdW5jdGlvbiAoYXBwLCB1cmwsIHN0eWxlcywgb3B0cykge1xuICAgIGNvbnN0IGRzID0gbWFrZVRpbGVkUGFycXVldEdyaWREYXRhc2V0KGFwcCwgdXJsLCBvcHRzKVxuICAgIHJldHVybiBhcHAuYWRkTGF5ZXJGcm9tRGF0YXNldChkcywgc3R5bGVzLCBvcHRzKVxufVxuXG5cblxuXG5cblxuZXhwb3J0IGNvbnN0IG1ha2VNdWx0aVNjYWxlVGlsZWRQYXJxdWV0R3JpZERhdGFzZXQgPSBmdW5jdGlvbiAoYXBwLCByZXNvbHV0aW9ucywgcmVzVG9VUkwsIG9wdHMpIHtcbiAgICByZXR1cm4gRGF0YXNldC5tYWtlKFxuICAgICAgICByZXNvbHV0aW9ucyxcbiAgICAgICAgKHJlcykgPT4gbmV3IFRpbGVkUGFycXVldEdyaWQocmVzVG9VUkwocmVzKSwgYXBwLCBvcHRzKS5sb2FkSW5mbygoKSA9PiB7IGFwcC5jZy5yZWRyYXcoKSB9KSxcbiAgICAgICAgb3B0c1xuICAgIClcbn1cblxuLyoqXG4qIEBwYXJhbSB7b2JqZWN0fSBhcHAgVGhlIGdyaWR2aXogYXBwbGljYXRpb24uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZXNvbHV0aW9uc1xuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOnN0cmluZ30gcmVzVG9VUkxcbiogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gc3R5bGVzIFRoZSBzdHlsZXMsIG9yZGVyZWQgaW4gZHJhd2luZyBvcmRlci5cbiAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0cyBUaGUgcGFyYW1ldGVycyBvZiB0aGUgZGF0YXNldCBhbmQgbGF5ZXIuXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG4vKmV4cG9ydCBjb25zdCBhZGRNdWx0aVNjYWxlVGlsZWRQYXJxdWV0R3JpZExheWVyID0gZnVuY3Rpb24gKGFwcCwgcmVzb2x1dGlvbnMsIHJlc1RvVVJMLCBzdHlsZXMsIG9wdHMpIHtcbiAgICBjb25zdCBkcyA9IG1ha2VNdWx0aVNjYWxlVGlsZWRQYXJxdWV0R3JpZERhdGFzZXQoYXBwLCByZXNvbHV0aW9ucywgcmVzVG9VUkwsIG9wdHMpXG4gICAgcmV0dXJuIGFwcC5hZGRMYXllckZyb21EYXRhc2V0KGRzLCBzdHlsZXMsIG9wdHMpXG59XG5cblxuXG4vL3Rlc3QgdXRpbGlzYXRpb24gb2YgdGhhdDpcbi8vPHNjcmlwdCBzcmM9XCJodHRwczovL3VucGtnLmNvbS9wYXJxdWV0LXdhc21AMC40LjAtYmV0YS41L2VzbS9hcnJvdzIuanNcIj48L3NjcmlwdD5cbi8qZXhwb3J0IGNvbnN0IGxvYWRXYXNtUGFycXVldFJlYWRlciA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBwYXJxdWV0TW9kdWxlID0gYXdhaXQgaW1wb3J0KFwicGFycXVldC13YXNtXCIpXG4gICAgcmV0dXJuIHBhcnF1ZXRNb2R1bGUucmVhZFBhcnF1ZXRcbiAgICAvL2F3YWl0IHBhcnF1ZXRNb2R1bGUuZGVmYXVsdCgpXG4gICAgLy9yZXR1cm4gcGFycXVldE1vZHVsZS5yZWFkUGFycXVldFxufSovXG5cblxuLyoqXG4gKiBSZXRyaWV2ZSBwYXJxdWV0IHdhc20gZGVjb2RlclxuICovXG4vKlxuY29uc3QgZ2V0UmVhZFBhcnF1ZXRQID0gKCk9PiBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcGFycXVldE1vZHVsZSA9IGF3YWl0IGltcG9ydChcImh0dHBzOi8vdW5wa2cuY29tL3BhcnF1ZXQtd2FzbUAwLjQuMC1iZXRhLjUvZXNtL2Fycm93Mi5qc1wiKTtcbiAgICBhd2FpdCBwYXJxdWV0TW9kdWxlLmRlZmF1bHQoKTtcbiAgICByZXR1cm4gcGFycXVldE1vZHVsZS5yZWFkUGFycXVldDtcbn1cbiovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=