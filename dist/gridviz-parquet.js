(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["gviz_par"] = factory();
	else
		root["gviz_par"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   Rgb: () => (/* binding */ Rgb),
/* harmony export */   brighter: () => (/* binding */ brighter),
/* harmony export */   darker: () => (/* binding */ darker),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   hsl: () => (/* binding */ hsl),
/* harmony export */   hslConvert: () => (/* binding */ hslConvert),
/* harmony export */   rgb: () => (/* binding */ rgb),
/* harmony export */   rgbConvert: () => (/* binding */ rgbConvert)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extend: () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nonpassive: () => (/* binding */ nonpassive),
/* harmony export */   nonpassivecapture: () => (/* binding */ nonpassivecapture),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csvFormat: () => (/* binding */ csvFormat),
/* harmony export */   csvFormatBody: () => (/* binding */ csvFormatBody),
/* harmony export */   csvFormatRow: () => (/* binding */ csvFormatRow),
/* harmony export */   csvFormatRows: () => (/* binding */ csvFormatRows),
/* harmony export */   csvFormatValue: () => (/* binding */ csvFormatValue),
/* harmony export */   csvParse: () => (/* binding */ csvParse),
/* harmony export */   csvParseRows: () => (/* binding */ csvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var csv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tsvFormat: () => (/* binding */ tsvFormat),
/* harmony export */   tsvFormatBody: () => (/* binding */ tsvFormatBody),
/* harmony export */   tsvFormatRow: () => (/* binding */ tsvFormatRow),
/* harmony export */   tsvFormatRows: () => (/* binding */ tsvFormatRows),
/* harmony export */   tsvFormatValue: () => (/* binding */ tsvFormatValue),
/* harmony export */   tsvParse: () => (/* binding */ tsvParse),
/* harmony export */   tsvParseRows: () => (/* binding */ tsvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var tsv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cubicIn: () => (/* binding */ cubicIn),
/* harmony export */   cubicInOut: () => (/* binding */ cubicInOut),
/* harmony export */   cubicOut: () => (/* binding */ cubicOut)
/* harmony export */ });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/dsv.js":
/*!******************************************!*\
  !*** ./node_modules/d3-fetch/src/dsv.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csv: () => (/* binding */ csv),
/* harmony export */   "default": () => (/* binding */ dsv),
/* harmony export */   tsv: () => (/* binding */ tsv)
/* harmony export */ });
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-fetch/src/text.js");



function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = (0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__["default"])(delimiter);
  return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_2__.csvParse);
var tsv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_3__.tsvParse);


/***/ }),

/***/ "./node_modules/d3-fetch/src/json.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseJson);
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/text.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/text.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseText);
}


/***/ }),

/***/ "./node_modules/d3-format/src/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/defaultLocale.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultLocale),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   formatPrefix: () => (/* binding */ formatPrefix)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-format/src/exponent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/exponent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatDecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatDecimal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   formatDecimalParts: () => (/* binding */ formatDecimalParts)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatGroup.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatGroup.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatNumerals.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/formatNumerals.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatPrefixAuto.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-format/src/formatPrefixAuto.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   prefixExponent: () => (/* binding */ prefixExponent)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatRounded.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatRounded.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatSpecifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/formatSpecifier.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormatSpecifier: () => (/* binding */ FormatSpecifier),
/* harmony export */   "default": () => (/* binding */ formatSpecifier)
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./node_modules/d3-format/src/formatTrim.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-format/src/formatTrim.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "./node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"])(x * 100, p),
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});


/***/ }),

/***/ "./node_modules/d3-format/src/identity.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/identity.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-format/src/locale.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-format/src/locale.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "./node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "./node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTrim.js */ "./node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTypes.js */ "./node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__["default"])(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__["default"])(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basis: () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nogamma),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   hue: () => (/* binding */ hue)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rgbBasis: () => (/* binding */ rgbBasis),
/* harmony export */   rgbBasisClosed: () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interpolateTransformCss: () => (/* binding */ interpolateTransformCss),
/* harmony export */   interpolateTransformSvg: () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseCss: () => (/* binding */ parseCss),
/* harmony export */   parseSvg: () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-random/src/defaultSource.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-random/src/defaultSource.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Math.random);


/***/ }),

/***/ "./node_modules/d3-random/src/normal.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-random/src/normal.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _defaultSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultSource.js */ "./node_modules/d3-random/src/defaultSource.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
})(_defaultSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ array)
/* harmony export */ });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   childMatcher: () => (/* binding */ childMatcher),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event, node) {
  event = (0,_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function* __WEBPACK_DEFAULT_EXPORT__() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return (0,_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = (0,_selectorAll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   timer: () => (/* binding */ timer),
/* harmony export */   timerFlush: () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.SCHEDULED && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   active: () => (/* reexport safe */ _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   interrupt: () => (/* reexport safe */ _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   transition: () => (/* reexport safe */ _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");






/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.STARTING && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDING;
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return this.each(function() {
    (0,_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/cubic.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_0__.cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0,_transition_index_js__WEBPACK_IMPORTED_MODULE_1__.newId)(), (timing = defaultTiming).time = (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__.now)(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0,_transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(groups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.interpolateTransformSvg : _interpolate_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_3__.tweenValue)(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).delay;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).duration;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).ease;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(subgroups, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transition: () => (/* binding */ Transition),
/* harmony export */   "default": () => (/* binding */ transition),
/* harmony export */   newId: () => (/* binding */ newId)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/string.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["default"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_1__["default"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"]
      : (c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(merges, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__.init : _schedule_js__WEBPACK_IMPORTED_MODULE_0__.set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.on("end.remove", removeFunction(this._id));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CREATED: () => (/* binding */ CREATED),
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   ENDING: () => (/* binding */ ENDING),
/* harmony export */   RUNNING: () => (/* binding */ RUNNING),
/* harmony export */   SCHEDULED: () => (/* binding */ SCHEDULED),
/* harmony export */   STARTED: () => (/* binding */ STARTED),
/* harmony export */   STARTING: () => (/* binding */ STARTING),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   set: () => (/* binding */ set)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timeout.js");



var emptyOn = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = (0,d3_timer__WEBPACK_IMPORTED_MODULE_1__.timer)(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selector.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(subgroup[i], name, id, i, subgroup, (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.constructor;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new Selection(this._groups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        string1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.set)(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.interpolateTransformCss : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_4__.tweenValue)(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction((0,_tween_js__WEBPACK_IMPORTED_MODULE_0__.tweenValue)(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var name = this._name,
      id0 = this._id,
      id1 = (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.newId)();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id0);
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(groups, this._parents, name, id1);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   tweenValue: () => (/* binding */ tweenValue)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZoomEvent)
/* harmony export */ });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   zoom: () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   zoomIdentity: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.identity),
/* harmony export */   zoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");




/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform),
/* harmony export */   "default": () => (/* binding */ transform),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_3__.identity;
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"],
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_6__["default"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_3__.identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_2__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__["default"])(event.view);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    g.mouse = [p, this.__zoom.invert(p)];
    (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
    g.start();

    function mousemoved(event) {
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__.yesdrag)(event.view, g.moved);
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    if (duration > 0) (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
}


/***/ }),

/***/ "./node_modules/gridviz/src/App.js":
/*!*****************************************!*\
  !*** ./node_modules/gridviz/src/App.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   App: () => (/* binding */ App)
/* harmony export */ });
/* harmony import */ var _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GeoCanvas.js */ "./node_modules/gridviz/src/GeoCanvas.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/gridviz/src/Layer.js");
/* harmony import */ var _Dataset_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dataset.js */ "./node_modules/gridviz/src/Dataset.js");
/* harmony import */ var _Tooltip_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Tooltip.js */ "./node_modules/gridviz/src/Tooltip.js");
/* harmony import */ var _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dataset/CSVGrid.js */ "./node_modules/gridviz/src/dataset/CSVGrid.js");
/* harmony import */ var _dataset_LGrid_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dataset/LGrid.js */ "./node_modules/gridviz/src/dataset/LGrid.js");
/* harmony import */ var _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dataset/TiledGrid.js */ "./node_modules/gridviz/src/dataset/TiledGrid.js");
/* harmony import */ var _BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BackgroundLayer.js */ "./node_modules/gridviz/src/BackgroundLayer.js");
/* harmony import */ var _BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BackgroundLayerWMS.js */ "./node_modules/gridviz/src/BackgroundLayerWMS.js");
/* harmony import */ var _LabelLayer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./LabelLayer.js */ "./node_modules/gridviz/src/LabelLayer.js");
/* harmony import */ var _LineLayer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./LineLayer.js */ "./node_modules/gridviz/src/LineLayer.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/Utils.js */ "./node_modules/gridviz/src/utils/Utils.js");
/* harmony import */ var _button_ZoomButtons_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./button/ZoomButtons.js */ "./node_modules/gridviz/src/button/ZoomButtons.js");
/* harmony import */ var _button_FullscreenButton_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./button/FullscreenButton.js */ "./node_modules/gridviz/src/button/FullscreenButton.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


// internal imports
;














// external imports


/**
 * A gridviz application.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class App {
    /**
     * @param {HTMLDivElement} container
     * @param {object} opts
     */
    constructor(container, opts) {
        opts = opts || {}

        /**
         * The layers.
         * @type {Array.<Layer>}
         * */
        this.layers = []

        //get container element
        this.container = container || document.getElementById('gridviz')
        if (!this.container) {
            console.error('Cannot find gridviz container element.')
            return
        }

        //https://css-tricks.com/absolute-positioning-inside-relative-positioning/
        this.container.style.position = "relative"; // container element must have relative positioning

        //set dimensions
        /** @type {number} */
        this.w = opts.w || this.container.offsetWidth
        /** @type {number} */
        this.h = opts.h || this.container.offsetHeight

        //create canvas element if user doesnt specify one
        /** @type {HTMLCanvasElement} */
        let canvas = opts.canvas || null
        if (!canvas) {
            canvas = document.createElement('canvas')
            canvas.setAttribute('width', '' + this.w)
            canvas.setAttribute('height', '' + this.h)
            this.container.appendChild(canvas)
        }

        /** Make geo canvas
         * @type {GeoCanvas}
         * @private */
        this.cg = new _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_0__.GeoCanvas(canvas, undefined, 1, opts)
        this.cg.redraw = (strong = true) => {
            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_11__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_11__.monitorDuration)('Start redraw')
            //console.log("?x=" + this.cg.getCenter().x + "&y=" + this.cg.getCenter().y + "&z=" + this.cg.getZf())

            //remove legend elements
            if (this.legend && strong) this.legend.selectAll('*').remove()

            //clear
            this.cg.initCanvasTransform()
            this.cg.clear(this.cg.backgroundColor)

            const zf = this.getZoomFactor()
            this.updateExtentGeo()

            //go through the background layers
            if (this.showBgLayers)
                for (const layer of this.bgLayers) {
                    //check if layer is visible
                    if (!layer.visible) continue
                    if (zf > layer.maxZoom) continue
                    if (zf < layer.minZoom) continue

                    //draw layer
                    layer.draw(this.cg)
                }

            //go through the layers
            for (const layer of this.layers) {
                //check if layer is visible
                if (!layer.visible) continue
                if (zf > layer.maxZoom) continue
                if (zf < layer.minZoom) continue

                //get layer dataset component
                /** @type {import('./DatasetComponent').DatasetComponent|undefined} */
                const dsc = layer.getDatasetComponent(zf)
                if (!dsc) continue

                //launch data download, if necessary
                if (strong)
                    dsc.getData(this.cg.extGeo, () => {
                        this.cg.redraw()
                    })

                //update dataset view cache
                if (strong) dsc.updateViewCache(this.cg.extGeo)

                //set layer alpha and blend mode
                this.cg.ctx.globalAlpha = layer.alpha ? layer.alpha(zf) : 1.0
                this.cg.ctx.globalCompositeOperation = layer.blendOperation(zf)

                //draw cells, style by style
                if (strong)
                    for (const s of layer.styles) {
                        //check if style is visible
                        if (!s.visible) continue
                        if (zf > s.maxZoom) continue
                        if (zf < s.minZoom) continue

                        //set style alpha and blend mode
                        //TODO: multiply by layer alpha ?
                        this.cg.ctx.globalAlpha = s.alpha ? s.alpha(zf) : 1.0
                        this.cg.ctx.globalCompositeOperation = s.blendOperation(zf)

                        s.draw(dsc.getViewCache(), dsc.getResolution(), this.cg)
                    }

                //add legend element
                if (this.legend && strong) {
                    for (const s of layer.styles) {
                        if (zf > s.maxZoom) continue
                        if (zf < s.minZoom) continue
                        for (const lg of s.legends) {
                            //console.log(s, lg)
                            //this.legend.append(lg.div)
                            //s1.node().appendChild(s2.node())
                            this.legend.node().append(lg.div.node())
                        }

                        //case for styles of styles, like kernel smoothing
                        //TODO do better
                        if (s['styles']) {
                            for (const s2 of s.styles) {
                                if (zf > s2.maxZoom) continue
                                if (zf < s2.minZoom) continue
                                for (const lg of s2.legends) {
                                    //console.log(s, lg)
                                    //this.legend.append(lg.div)
                                    //s1.node().appendChild(s2.node())
                                    this.legend.node().append(lg.div.node())
                                }
                            }
                        }
                    }
                }

                //restore default alpha and blend operation
                this.cg.ctx.globalAlpha = 1.0
                this.cg.ctx.globalCompositeOperation = this.defaultGlobalCompositeOperation
            }

            //draw boundary layer
            //if (strong)
            if (this.showBoundaries && this.boundaryLayer) this.boundaryLayer.draw(this.cg)

            //draw label layer
            //if (strong)
            if (this.showLabels && this.labelLayer) this.labelLayer.draw(this.cg)

            //
            this.canvasSave = null

            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_11__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_11__.monitorDuration)('End redraw')

            // listen for resize events on the App's container and handle them
            this.defineResizeObserver(this.container, canvas)

            return this
        }

        /** @type {Array.<BackgroundLayer|BackgroundLayerWMS>} */
        this.bgLayers = []
        /** @type {boolean} */
        this.showBgLayers = true

        /** @type {LabelLayer | undefined} */
        this.labelLayer = undefined
        /** @type {boolean} */
        this.showLabels = true

        /** @type {LineLayer | undefined} */
        this.boundaryLayer = undefined
        /** @type {boolean} */
        this.showBoundaries = true

        // legend div
        this.legendDivId = opts.legendDivId || 'gvizLegend'
        this.legend = (0,d3_selection__WEBPACK_IMPORTED_MODULE_14__["default"])('#' + this.legendDivId)
        if (this.legend.empty()) {
            this.legend = (0,d3_selection__WEBPACK_IMPORTED_MODULE_14__["default"])(
                this.container.id && this.container.id != '' ? '#' + this.container.id : 'body'
            )
                .append('div')
                .attr('id', this.legendDivId)
                .style('position', 'absolute')
                .style('width', 'auto')
                .style('height', 'auto')
                .style('background', '#FFFFFF')
                //.style("padding", this.padding)
                .style('border', '0px')
                //.style('border-radius', '5px')
                .style('box-shadow', '3px 3px 3px grey, -3px -3px 3px #ddd')
                .style('font-family', 'Helvetica, Arial, sans-serif')
                .style('bottom', '15px')
                .style('right', '15px')
            //hide
            //.style("visibility", "hidden")
        }

        //tooltip

        // set App container as default parent element for tooltip
        if (!opts.tooltip) opts.tooltip = {}
        if (!opts.tooltip.parentElement) opts.tooltip.parentElement = this.container

        /**
         * @private
         * @type {Tooltip} */
        this.tooltip = new _Tooltip_js__WEBPACK_IMPORTED_MODULE_3__.Tooltip(opts.tooltip)

        /** @param {MouseEvent} e */
        const focusCell = (e) => {
            //compute mouse geo position
            const mousePositionGeo = {
                x: this.cg.pixToGeoX(e.offsetX + this.tooltip.xMouseOffset),
                y: this.cg.pixToGeoY(e.offsetY + this.tooltip.yMouseOffset),
            }
            /** @type {{cell:import('./Dataset').Cell,html:string,resolution:number} | undefined} */
            const focus = this.getCellFocusInfo(mousePositionGeo)

            // transparent background (e.g. leaflet) 'red painting' fix
            if (opts.transparentBackground) {
                if (focus) {
                    this.tooltip.html(focus.html)
                    this.tooltip.setPosition(e)
                    this.tooltip.show()
                } else {
                    this.tooltip.hide()
                }
                this.canvasSave = document.createElement('canvas')
                this.canvasSave.setAttribute('width', '' + this.w)
                this.canvasSave.setAttribute('height', '' + this.h)
                this.canvasSave.getContext('2d').drawImage(this.cg.canvas, 0, 0)
                this.cg.initCanvasTransform()
                return
            }

            if (focus) {
                this.tooltip.html(focus.html)
                this.tooltip.setPosition(e)
                this.tooltip.show()

                //show cell position as a rectangle
                if (!this.canvasSave) {
                    this.canvasSave = document.createElement('canvas')
                    this.canvasSave.setAttribute('width', '' + this.w)
                    this.canvasSave.setAttribute('height', '' + this.h)
                    this.canvasSave.getContext('2d').drawImage(this.cg.canvas, 0, 0)
                } else {
                    this.cg.ctx.drawImage(this.canvasSave, 0, 0)
                }

                //draw image saved + draw rectangle
                const rectWPix = this.selectionRectangleWidthPix
                    ? this.selectionRectangleWidthPix(focus.resolution, this.getZoomFactor())
                    : 4
                this.cg.initCanvasTransform()
                this.cg.ctx.strokeStyle = this.selectionRectangleColor
                this.cg.ctx.lineWidth = rectWPix
                this.cg.ctx.beginPath()

                this.cg.ctx.rect(
                    this.cg.geoToPixX(focus.cell.x) - rectWPix / 2,
                    this.cg.geoToPixY(focus.cell.y) + rectWPix / 2,
                    focus.resolution / this.getZoomFactor() + rectWPix,
                    -focus.resolution / this.getZoomFactor() - rectWPix
                )
                this.cg.ctx.stroke()
            } else {
                this.tooltip.hide()
                if (this.canvasSave) this.cg.ctx.drawImage(this.canvasSave, 0, 0)
            }
        }

        // add event listeners to container
        this.mouseOverHandler = (e) => focusCell(e)
        this.mouseMoveHandler = (e) => focusCell(e)
        this.mouseOutHandler = (e) => this.tooltip.hide()
        this.cg.canvas.addEventListener('mouseover', this.mouseOverHandler)
        this.cg.canvas.addEventListener('mousemove', this.mouseMoveHandler)
        this.cg.canvas.addEventListener('mouseout', this.mouseOutHandler)

        // add extra logic to onZoomStartFun
        this.cg.onZoomStartFun = (e) => {
            if (opts.onZoomStartFun) opts.onZoomStartFun(e)
            this.tooltip.hide()
        }

        //for mouse over
        /**
         * @private
         * @type {HTMLCanvasElement|null} */
        this.canvasSave = null

        this.selectionRectangleColor = opts.selectionRectangleColor || 'red'
        this.selectionRectangleWidthPix = opts.selectionRectangleWidthPix || (() => 4) //(r,zf) => {}

        //
        //canvas.addEventListener("keydown", e => { console.log(arguments) });

        //set default globalCompositeOperation
        this.defaultGlobalCompositeOperation =
            opts.defaultGlobalCompositeOperation || this.cg.ctx.globalCompositeOperation
    }

    /**
     * @param {number} marginPx
     * @returns {import('./Dataset').Envelope}
     * @public
     */
    updateExtentGeo(marginPx = 20) {
        return this.cg.updateExtentGeo(marginPx)
    }

    /**
     * Return the cell HTML info at a given geo position.
     * This is usefull for user interactions, to show this info where the user clicks for example.
     *
     * @param {{x:number,y:number}} posGeo
     * @returns {{cell:import('./Dataset').Cell,html:string,resolution:number} | undefined}
     * @protected
     */
    getCellFocusInfo(posGeo) {
        //go through the layers, starting from top
        const zf = this.getZoomFactor()
        for (let i = this.layers.length - 1; i >= 0; i--) {
            /** @type {Layer} */
            const layer = this.layers[i]
            if (!layer.visible) continue
            if (!layer.cellInfoHTML) continue
            //if (layer.cellInfoHTML === 'none') continue
            const dsc = layer.getDatasetComponent(zf)
            if (!dsc) continue

            //get cell at mouse position
            /** @type {import('./Dataset').Cell|undefined} */
            const cell = dsc.getCellFromPosition(posGeo, dsc.getViewCache())
            //console.log(cell, dsc.resolution)
            if (!cell) return undefined
            const html = layer.cellInfoHTML(cell, dsc.getResolution())
            if (!html) return undefined
            return { cell: cell, html: html, resolution: dsc.getResolution() }
        }
    }

    //getters and setters

    /** @returns {{x:number,y:number}} */
    getGeoCenter() {
        return this.cg.getCenter()
    }
    /** @param {{x:number,y:number}} val @returns {this} */
    setGeoCenter(val) {
        this.cg.setCenter(val)
        return this
    }

    /** @returns {number} */
    getZoomFactor() {
        return this.cg.getZf()
    }
    /** @param {number} val @returns {this} */
    setZoomFactor(val) {
        this.cg.setZf(val)
        return this
    }

    /** @returns {Array.<number>} */
    getZoomFactorExtent() {
        return this.cg.getZfExtent()
    }
    /** @param {Array.<number>} val @returns {this} */
    setZoomFactorExtent(val) {
        this.cg.setZfExtent(val)
        return this
    }

    /** @returns {string} */
    getBackgroundColor() {
        return this.cg.backgroundColor
    }
    /** @param {string} val @returns {this} */
    setBackgroundColor(val) {
        this.cg.backgroundColor = val
        return this
    }

    /** @returns {LineLayer | undefined} */
    getBoundaryLayer() {
        return this.boundaryLayer
    }
    /** @param {object} opts @returns {this} */
    setBoundaryLayer(opts) {
        this.boundaryLayer = new _LineLayer_js__WEBPACK_IMPORTED_MODULE_10__.LineLayer(opts)
        return this
    }

    /** @returns {LabelLayer | undefined} */
    getLabelLayer() {
        return this.labelLayer
    }
    /** @param {object} opts @returns {this} */
    setLabelLayer(opts) {
        this.labelLayer = new _LabelLayer_js__WEBPACK_IMPORTED_MODULE_9__.LabelLayer(opts)
        return this
    }

    /** @returns {this} */
    redraw() {
        this.cg.redraw()
        return this
    }

    /**
     * Add a layer to the app.
     *
     * @param {Dataset} dataset The dataset of the layer
     * @param {Array.<import('./Style').Style>} styles The styles of the layer
     * @param {{visible?:boolean,minZoom?:number,maxZoom?:number,pixNb?:number,cellInfoHTML?:function(import('./Dataset').Cell):string}} opts The layer options.
     * @returns {this}
     */
    addLayerFromDataset(dataset, styles, opts) {
        const lay = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer(dataset, styles, opts)
        this.layers.push(lay)
        return this
    }

    //dataset creation

    /**
     * Make a local grid dataset.
     *
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {Array} cells The cells.
     * @param {object=} opts The parameters of the dataset.
     * @returns {Dataset}
     */
    makeLGridDataset(resolution, cells, opts) {
        return new _Dataset_js__WEBPACK_IMPORTED_MODULE_2__.Dataset([new _dataset_LGrid_js__WEBPACK_IMPORTED_MODULE_5__.LGrid(resolution, cells)], [], opts)
    }

    /**
     * Make a CSV grid dataset.
     *
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {object=} opts The parameters of the dataset.
     * @returns {Dataset}
     */
    makeCSVGridDataset(url, resolution, opts) {
        return new _Dataset_js__WEBPACK_IMPORTED_MODULE_2__.Dataset(
            [
                new _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_4__.CSVGrid(url, resolution, opts).getData(undefined, () => {
                    this.cg.redraw()
                }),
            ],
            [],
            opts
        )
    }

    /**
     * Make a tiled grid dataset.
     *
     * @param {string} url
     * @param {{preprocess?:function(import('./Dataset').Cell):boolean}} opts
     * @returns {Dataset}
     */
    makeTiledGridDataset(url, opts) {
        return new _Dataset_js__WEBPACK_IMPORTED_MODULE_2__.Dataset(
            [
                new _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__.TiledGrid(url, this, opts).loadInfo(() => {
                    this.cg.redraw()
                }),
            ],
            [],
            opts
        )
    }

    //multi scale dataset creation

    /**
     * Make a multi scale CSV grid dataset.
     *
     * @param {Array.<number>} resolutions
     * @param {function(number):string} resToURL
     * @param {{preprocess?:function(import('./Dataset').Cell):boolean}} opts
     * @returns {Dataset}
     */
    makeMultiScaleCSVGridDataset(resolutions, resToURL, opts) {
        return _Dataset_js__WEBPACK_IMPORTED_MODULE_2__.Dataset.make(
            resolutions,
            (res) =>
                new _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_4__.CSVGrid(resToURL(res), res, opts).getData(undefined, () => {
                    this.cg.redraw()
                }),
            opts
        )
    }

    //tiled multiscale

    /**
     * Make a multi scale tiled grid dataset.
     *
     * @param {Array.<number>} resolutions
     * @param {function(number):string} resToURL
     * @param {{preprocess?:function(import('./Dataset').Cell):boolean}} opts
     * @returns {Dataset}
     */
    makeMultiScaleTiledGridDataset(resolutions, resToURL, opts) {
        return _Dataset_js__WEBPACK_IMPORTED_MODULE_2__.Dataset.make(
            resolutions,
            (res) =>
                new _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__.TiledGrid(resToURL(res), this, opts).loadInfo(() => {
                    this.cg.redraw()
                }),
            opts
        )
    }

    // direct layer creation

    /**
     * Add a layer from a CSV grid dataset.
     *
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {Array.<import('./Style').Style>} styles The styles, ordered in drawing order.
     * @param {object=} opts The parameters of the dataset and layer.
     * @returns {this}
     */
    addCSVGridLayer(url, resolution, styles, opts) {
        const ds = this.makeCSVGridDataset(url, resolution, opts)
        return this.addLayerFromDataset(ds, styles, opts)
    }

    /**
     *
     * @param {string} url
     * @param {Array.<import('./Style').Style>} styles
     * @param {{visible?:boolean,minZoom?:number,maxZoom?:number,pixNb?:number,cellInfoHTML?:function(import('./Dataset').Cell):string, preprocess?:function(import('./Dataset').Cell):boolean}} opts
     * @returns {this}
     */
    addTiledGridLayer(url, styles, opts) {
        const ds = this.makeTiledGridDataset(url, opts)
        return this.addLayerFromDataset(ds, styles, opts)
    }

    /**
     * Add a layer from a CSV grid dataset.
     *
     * @param {Array.<number>} resolutions
     * @param {function(number):string} resToURL
     * @param {Array.<import('./Style').Style>} styles The styles, ordered in drawing order.
     * @param {object=} opts The parameters of the dataset and layer.
     * @returns {this}
     */
    addMultiScaleCSVGridLayer(resolutions, resToURL, styles, opts) {
        const ds = this.makeMultiScaleCSVGridDataset(resolutions, resToURL, opts)
        return this.addLayerFromDataset(ds, styles, opts)
    }

    /**
     * @param {Array.<number>} resolutions
     * @param {function(number):string} resToURL
     * @param {Array.<import('./Style').Style>} styles
     * @param {{visible?:boolean,minZoom?:number,maxZoom?:number,pixNb?:number,cellInfoHTML?:function(import('./Dataset').Cell):string, preprocess?:function(import('./Dataset').Cell):boolean}} opts
     * @returns {this}
     */
    addMultiScaleTiledGridLayer(resolutions, resToURL, styles, opts) {
        const ds = this.makeMultiScaleTiledGridDataset(resolutions, resToURL, opts)
        return this.addLayerFromDataset(ds, styles, opts)
    }

    /**
     * Add a background layer to the app.
     *
     * @param {object} opts
     * @returns {this}
     */
    addBackgroundLayer(opts) {
        this.bgLayers.push(new _BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_7__.BackgroundLayer(opts))
        this.redraw()
        return this
    }

    /**
     * Add a WMS background layer to the app.
     *
     * @param {object} opts
     * @returns {this}
     */
    addBackgroundLayerWMS(opts) {
        this.bgLayers.push(new _BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_8__.BackgroundLayerWMS(opts))
        this.redraw()
        return this
    }

    /**
     *
     * @param {string} id
     * @param {object} opts
     * @returns {this}
     */
    addZoomSlider(id, opts) {
        this.cg.addZoomSlider(id, opts)
        return this
    }

    /**
     * Adds a set of zoom buttons to the app
     *
     * @param {object} opts
     * @returns {this}
     */
    addZoomButtons(opts) {
        // * opts.id
        // * opts.onZoom - custom event handler function
        // * opts.x
        // * opts.y
        // * opts.delta - zoom delta applied on each click

        this.zoomButtons = new _button_ZoomButtons_js__WEBPACK_IMPORTED_MODULE_12__.ZoomButtons({
            app: this,
            id: opts?.id || 'gridviz-zoom-buttons',
            class: opts?.class,
            x: opts?.x,
            y: opts?.y,
            onZoom: opts?.onZoom,
            delta: opts?.delta || 0.2
        })

        return this
    }

    /**
     * Adds a fullscreen toggle button to the app
     *
     * @param {object} opts
     * @returns {this}
     */
    addFullscreenButton(opts) {
        // * opts.app - the gridviz app
        // * opts.id
        // * opts.x
        // * opts.y

        this.fullscreenButton = new _button_FullscreenButton_js__WEBPACK_IMPORTED_MODULE_13__.FullscreenButton({
            app: this,
            id: opts?.id || 'gridviz-fullscreen-button',
            class: opts?.class,
            x: opts?.x,
            y: opts?.y
        })

        return this
    }

    /** @returns {this} */
    setViewFromURL() {
        this.cg.setViewFromURL()
        return this
    }

    /**
     * @description Add a resize event observer to the Apps container and update the canvas accordingly
     * @param {HTMLDivElement} container The App's container element
     * @param {HTMLCanvasElement} canvas The App canvas element
     * @memberof App
     */
    defineResizeObserver(container, canvas) {
        // listen to resize events
        const resizeObserver = new ResizeObserver((entries) => {
            // make sure canvas has been built
            if (container.clientWidth > 0 && container.clientHeight > 0) {
                // make sure we dont exceed loop limit first
                // see: https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
                window.requestAnimationFrame(() => {
                    if (!Array.isArray(entries) || !entries.length) {
                        return
                    }
                    // update the app and canvas size
                    if (this.h !== container.clientHeight || this.w !== container.clientWidth) {
                        this.h = container.clientHeight
                        this.w = container.clientWidth
                        this.cg.h = container.clientHeight
                        this.cg.w = container.clientWidth
                        canvas.setAttribute('width', '' + this.w)
                        canvas.setAttribute('height', '' + this.h)
                        this.redraw()

                        //update button positions
                        // if (this.zoomButtons) this.zoomButtons.node.style.left = this.w - 50 + 'px'
                        // if (this.fullscreenButton) this.fullscreenButton.node.style.left = this.w - 50 + 'px'
                    }
                })
            }
        })

        resizeObserver.observe(container)
    }

    /**
     * @description Destroy the app and it's event listeners
     * This should significantly reduce the memory used when creating and destroying gridviz app instances (for example in leaflet-gridviz)
     * @memberof App
     */
    destroy() {
        // clear layers
        this.layers = []
        this.bgLayers = []

        // remove event listeners from container
        this.container.removeEventListener('mouseover', this.mouseOverHandler)
        this.container.removeEventListener('mousemove', this.mouseMoveHandler)
        this.container.removeEventListener('mouseout', this.mouseOutHandler)

        // remove canvas
        this.cg.canvas.remove()

        // remove legend
        this.legend?.remove()

        // remove tooltip
        this.tooltip.tooltip?.remove()
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/BackgroundLayer.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridviz/src/BackgroundLayer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundLayer: () => (/* binding */ BackgroundLayer)
/* harmony export */ });
//@ts-check


/**
 *
 * A map background layer in "Slippy map" XYZ standard.
 * See https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames
 * https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/#6/27.88/44.48
 * 
 * @author Julien Gaffuri
 */
class BackgroundLayer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** An attribute to specify if a layer should be drawn or not
         * @type {boolean} */
        this.visible = opts.visible == false ? false : true

        /** The minimum zoom factor: Below this level, the layer is not shown.
         * @type {number} */
        this.minZoom = opts.minZoom || 0

        /** The maximum zoom factor: Above this level, the layer is not shown.
         * @type {number} */
        this.maxZoom = opts.maxZoom || Infinity

        //ensure acceptable values for the zoom limits.
        if (this.minZoom >= this.maxZoom)
            throw new Error('Unexpected zoom limits for layer. Zoom min should be smaller than zoom max.')

        /** The image cache, indexed by z/y/x */
        this.cache = {}

        /**
         * @type {string} */
        this.url = opts.url
        /** @type {function(number,number,number):string} */
        this.urlFun = opts.urlFun || ((x, y, z) => this.url + z + '/' + x + '/' + y + '.png')

        /** @type {Array.<number>} */
        this.resolutions = opts.resolutions
        if (!this.resolutions || this.resolutions.length == 0)
            throw new Error('No resolutions provided for background layer')

        /** @type {number} */
        this.nbPix = opts.nbPix || 256
        /** CRS coordinates of top left corner
         * @type {Array.<number>} */
        this.origin = opts.origin || [0, 0]
        /** @type {number} */
        this.z0 = opts.z0 || 0

        /** @type {function(number):string} */
        this.filterColor = opts.filterColor // (zf) => "#eee7"
    }

    /**
     * Get z/x/y cache data.
     * @param {number} z
     * @param {number} x
     * @param {number} y
     * @returns {HTMLImageElement|string|undefined}
     * @private
     */
    get(z, x, y) {
        let d = this.cache[z]
        if (!d) return
        d = d[x]
        if (!d) return
        return d[y]
    }

    /**
     * Get z/x/y cache data.
     * @param {HTMLImageElement|string} img
     * @param {number} z
     * @param {number} x
     * @param {number} y
     * @returns
     * @private
     */
    put(img, z, x, y) {
        if (!this.cache[z]) this.cache[z] = {}
        if (!this.cache[z][x]) this.cache[z][x] = {}
        this.cache[z][x][y] = img
    }

    /**
     * @param {import("./GeoCanvas").GeoCanvas} cg The canvas where to draw the layer.
     * @returns {void}
     */
    draw(cg) {
        if (!this.resolutions || this.resolutions.length == 0) {
            console.error('No resolutions provided for background layer')
            return
        }

        //
        const zf = cg.getZf()
        const x0 = this.origin[0],
            y0 = this.origin[1]

        //get zoom level and resolution
        let z = 0
        for (z = 0; z < this.resolutions.length; z++) if (this.resolutions[z] < zf) break
        z -= 1
        z = Math.max(0, z)
        z = Math.min(z, this.resolutions.length - 1)
        //console.log(this.resolutions.length, z)
        const res = this.resolutions[z]

        z += this.z0

        const sizeG = this.nbPix * res
        const size = sizeG / zf

        //get tile numbers
        const xGeoToTMS = (x) => Math.ceil((x - x0) / sizeG)
        const yGeoToTMS = (y) => Math.ceil(-(y - y0) / sizeG)
        const xMin = xGeoToTMS(cg.extGeo.xMin) - 1
        const xMax = xGeoToTMS(cg.extGeo.xMax)
        const yMax = yGeoToTMS(cg.extGeo.yMin)
        const yMin = yGeoToTMS(cg.extGeo.yMax) - 1

        //TODO ?
        //cg.setCanvasTransform()

        //handle images
        for (let x = xMin; x < xMax; x++) {
            for (let y = yMin; y < yMax; y++) {
                //get image
                let img = this.get(z, x, y)

                //load image
                if (!img) {
                    const img = new Image()
                    this.put(img, z, x, y)
                    img.onload = () => {
                        cg.redraw()
                    }
                    img.onerror = () => {
                        //case when no image
                        this.put('failed', z, x, y)
                    }
                    img.src = this.urlFun(x, y, z)
                    continue
                }

                //case when no image
                if (img === 'failed') continue
                if (!(img instanceof HTMLImageElement)) {
                    console.log(img)
                    continue
                }
                if (img.width == 0 || img.height == 0) continue

                //draw image
                const xGeo = x0 + x * sizeG
                const yGeo = y0 - y * sizeG
                try {
                    cg.ctx.drawImage(img, cg.geoToPixX(xGeo), cg.geoToPixY(yGeo), size, size)
                    //cg.ctx.drawImage(img, xGeo, yGeo, sizeG, -sizeG)
                } catch (error) {
                    console.error(error)
                }
            }
        }

        //apply filter
        if (this.filterColor) {
            const fc = this.filterColor(zf)
            if (fc && fc != 'none') {
                cg.ctx.fillStyle = fc
                cg.ctx.fillRect(0, 0, cg.w, cg.h)
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/BackgroundLayerWMS.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/BackgroundLayerWMS.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundLayerWMS: () => (/* binding */ BackgroundLayerWMS)
/* harmony export */ });
//@ts-check


/**
 *
 * A map WMS background layer.
 * 
 * @author Julien Gaffuri
 */
class BackgroundLayerWMS {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** An attribute to specify if a layer should be drawn or not
         * @type {boolean} */
        this.visible = opts.visible == false ? false : true

        /** The minimum zoom factor: Below this level, the layer is not shown.
         * @type {number} */
        this.minZoom = opts.minZoom || 0

        /** The maximum zoom factor: Above this level, the layer is not shown.
         * @type {number} */
        this.maxZoom = opts.maxZoom || Infinity

        //ensure acceptable values for the zoom limits.
        if (this.minZoom >= this.maxZoom)
            throw new Error('Unexpected zoom limits for layer. Zoom min should be smaller than zoom max.')

        /**
         * @type {string} */
        this.url = opts.url

        /** @type {function(number):string} */
        this.filterColor = opts.filterColor // (zf) => "#eee7"

        /** @type {HTMLImageElement|undefined} */
        this.img = undefined;

        /** @type {number|undefined} */
        this.xMin = undefined;
        /** @type {number|undefined} */
        this.xMax = undefined;
        /** @type {number|undefined} */
        this.yMin = undefined;
        /** @type {number|undefined} */
        this.yMax = undefined;
    }

    /** Check if the view has moved and a new image needs to be retrieved.
     * @private */
    hasMoved(extGeo) {
        if ((extGeo.xMin) != this.xMin) return true
        else if ((extGeo.xMax) != this.xMax) return true
        else if ((extGeo.yMin) != this.yMin) return true
        else if ((extGeo.yMax) != this.yMax) return true
        else return false
    }


    /**
     * @param {import("./GeoCanvas").GeoCanvas} cg The canvas where to draw the layer.
     * @returns {void}
     */
    draw(cg) {

        //update map extent
        cg.updateExtentGeo(0)

        if (!this.hasMoved(cg.extGeo) && this.img) {
            //the map did not move and the image was already downloaded: draw the image
            cg.ctx.drawImage(this.img, 0, 0, cg.w, cg.h)

        } else {
            //the map moved: retrieve new image

            //
            this.xMin = cg.extGeo.xMin
            this.xMax = cg.extGeo.xMax
            this.yMin = cg.extGeo.yMin
            this.yMax = cg.extGeo.yMax

            //build WMS URL
            const url = []
            url.push(this.url)
            url.push("&width=")
            url.push(cg.w)
            url.push("&height=")
            url.push(cg.h)
            //bbox: xmin ymin xmax ymax
            url.push("&bbox=")
            url.push(cg.extGeo.xMin)
            url.push(",")
            url.push(cg.extGeo.yMin)
            url.push(",")
            url.push(cg.extGeo.xMax)
            url.push(",")
            url.push(cg.extGeo.yMax)

            const urlS = url.join("")
            //console.log(urlS)

            if (!this.img) {
                this.img = new Image()
                this.img.onload = () => {
                    cg.redraw()
                }
                this.img.onerror = () => {
                    //case when no image
                    console.warn("Could not retrieve WMS background image from", urlS)
                }
            }

            //set URL to launch the download
            this.img.src = urlS
        }

        //apply filter
        const zf = cg.getZf()
        if (this.filterColor) {
            const fc = this.filterColor(zf)
            if (fc && fc != 'none') {
                cg.ctx.fillStyle = fc
                cg.ctx.fillRect(0, 0, cg.w, cg.h)
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/Dataset.js":
/*!*********************************************!*\
  !*** ./node_modules/gridviz/src/Dataset.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dataset: () => (/* binding */ Dataset)
/* harmony export */ });
//@ts-check


/**
 * A grid cell.
 * @typedef {{x: number, y: number}} Cell */
/**
 * An envelope.
 * @typedef { {xMin: number, xMax: number, yMin: number, yMax: number} } Envelope */

/**
 * A multi resolution dataset of grid cells.
 * It consists of different {@link DatasetComponent}s for each resolution.
 *
 * @abstract
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class Dataset {
    /**
     * @param {Array.<import("./DatasetComponent").DatasetComponent>} datasetComponents The dataset components
     * @param {Array.<number>} resolutions The resolutions of the dataset components, in CRS geographical unit
     * @param { {preprocess?:function(Cell):boolean} } opts Options. preprocess: A function to apply on each dataset cell to prepare its values. Can be used also to select cells to keep.
     */
    constructor(datasetComponents, resolutions, opts = {}) {
        opts = opts || {}

        /** The dataset components.
         * @type {Array.<import("./DatasetComponent").DatasetComponent>} */
        this.datasetComponents = datasetComponents

        /** The resolutions of the dataset components, in CRS geographical unit.
         * @type {Array.<number>} */
        this.resolutions = resolutions

        //there must be as many dataset components as resolutions
        if (this.datasetComponents.length > 1 && this.datasetComponents.length != this.resolutions.length)
            throw new Error(
                'Uncompatible number of datasets and resolutions: ' +
                    this.datasetComponents.length +
                    ' ' +
                    this.resolutions.length
            )

        //set dataset preprocesses if specified
        if (opts.preprocess) this.setPrepocesses(opts.preprocess)
    }

    /**
     * Set a preprocess function for all dataset components.
     * This is a function applied on each cell after it has been loaded.
     *
     * @param {function(Cell):boolean} preprocess
     * @returns {this}
     */
    setPrepocesses(preprocess) {
        for (let ds of this.datasetComponents) ds.preprocess = preprocess
        return this
    }

    /**
     * A function to ease the creation of datasets from their components.
     *
     * @param {Array.<number>} resolutions The resolutions of the dataset components, in CRS geographical unit
     * @param {function(number):import("./DatasetComponent").DatasetComponent} resToDatasetComponent Function returning a dataset component from a resolution
     * @param { {preprocess?:function(Cell):boolean} } opts Options. preprocess: A function to apply on each dataset cell to prepare its values
     * @returns {Dataset}
     */
    static make(resolutions, resToDatasetComponent, opts) {
        //make dataset components
        const dsc = []
        for (const res of resolutions) dsc.push(resToDatasetComponent(res))
        //make dataset
        return new Dataset(dsc, resolutions, opts)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/DatasetComponent.js":
/*!******************************************************!*\
  !*** ./node_modules/gridviz/src/DatasetComponent.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DatasetComponent: () => (/* binding */ DatasetComponent)
/* harmony export */ });
//@ts-check


/**
 * A dataset component, of grid cells.
 * @abstract
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class DatasetComponent {
    /**
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution, in the CRS geographical unit.
     * @param {{preprocess?:function(import("./Dataset").Cell):boolean}} opts
     * @abstract
     */
    constructor(url, resolution, opts = {}) {
        opts = opts || {}

        /**
         * The url of the dataset.
         * @protected
         * @type {string} */
        this.url = url

        /**
         * The dataset resolution in geographical unit.
         * @protected
         * @type {number} */
        this.resolution = resolution

        /**
         * A preprocess to run on each cell after loading. It can be used to apply some specific treatment before or compute a new column. And also to determine which cells to keep after loading.
         * @type {(function(import("./Dataset").Cell):boolean )| undefined } */
        this.preprocess = opts.preprocess || undefined

        /** The cells within the view
         * @protected
         * @type {Array.<import("./Dataset").Cell>} */
        this.cellsViewCache = []
    }

    /**
     * Request data within a geographic envelope.
     *
     * @abstract
     * @param {import("./Dataset").Envelope|undefined} extGeo
     * @param {function():void} callback
     * @returns {this}
     */
    getData(extGeo, callback) {
        throw new Error('Method getData not implemented.')
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     * @abstract
     * @param {import("./Dataset").Envelope} extGeo The view geographical envelope.
     * @returns {void}
     */
    updateViewCache(extGeo) {
        throw new Error('Method updateViewCache not implemented.')
    }

    /**
     * Get a cell under a given position, if any.
     *
     * @param {{x:number,y:number}} posGeo
     * @param {Array.<import("./Dataset").Cell>} cells Some cells from the dataset (a subset if necessary, usually the view cache).
     * @returns {import("./Dataset").Cell|undefined}
     */
    getCellFromPosition(posGeo, cells) {
        //compute candidate cell position
        /** @type {number} */
        //const r = this.getResolution()
        /** @type {number} */
        //const cellX = r * Math.floor(posGeo.x / r)
        /** @type {number} */
        //const cellY = r * Math.floor(posGeo.y / r)

        /*/get cell
        for (const cell of cells) {
            if (cell.x != cellX) continue
            if (cell.y != cellY) continue
            return cell
        }
        return undefined*/

        /** @type {number} */
        const r = this.getResolution()
        for (const cell of cells) {
            if (posGeo.x < cell.x) continue
            else if (cell.x + r < posGeo.x) continue
            else if (posGeo.y < cell.y) continue
            else if (cell.y + r < posGeo.y) continue
            else return cell
        }
        return undefined

    }

    //getters and setters

    /** @returns {number} */
    getResolution() {
        return this.resolution
    }

    /** @returns {Array.<import("./Dataset").Cell>} */
    getViewCache() {
        return this.cellsViewCache
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/GeoCanvas.js":
/*!***********************************************!*\
  !*** ./node_modules/gridviz/src/GeoCanvas.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeoCanvas: () => (/* binding */ GeoCanvas)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
//@ts-check


/** @typedef { {xMin: number, xMax: number, yMin: number, yMax: number} } Envelope */

;


/**
 * A HTML canvas for geo data display, enhanced with zoom and pan capabilities.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class GeoCanvas {
    /**
     * @constructor
     * @param {HTMLCanvasElement} canvas
     * @param {object} center Geographical coordinates of the center
     * @param {number} zf The zoom factor (pixel size, in ground m)
     * @param {object} opts
     */
    constructor(canvas, center, zf, opts) {
        this.opts = opts || {}

        /** @type {HTMLCanvasElement} */
        this.canvas = canvas

        /** @type {number} */
        this.w = this.canvas.offsetWidth
        /** @type {number} */
        this.h = this.canvas.offsetHeight

        this.canvas.width = this.w
        this.canvas.height = this.h

        const ctx = this.canvas.getContext('2d')
        if (!ctx) throw 'Impossible to create canvas 2D context'
        /**@type {CanvasRenderingContext2D} */
        this.ctx = ctx

        // set geo coordinates of the center
        this.center = center || { x: this.w * 0.5, y: this.h * 0.5 }

        // zoom factor: pixel size, in m/pix
        /** @type {number} */
        this.zf = zf

        /** Background color.
         * @type {string} */
        this.backgroundColor = opts.backgroundColor || 'white'

        /** @type {function():void} */
        this.onZoomStartFun = opts.onZoomStartFun

        /** @type {function():void} */
        this.onZoomEndFun = opts.onZoomEndFun

        /** @type {function():void} */
        this.onZoomFun = opts.onZoomFun

        //current extent
        /** @type {Envelope} */
        this.extGeo = { xMin: NaN, xMax: NaN, yMin: NaN, yMax: NaN }
        this.updateExtentGeo()

        //rely on d3 zoom for pan/zoom
        if (!opts.disableZoom) {
            let tP = d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity
            const z = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()
                //to make the zooming a bit faster
                .wheelDelta((e) => -e.deltaY * (e.deltaMode === 1 ? 0.07 : e.deltaMode ? 1 : 0.004))
                .on('zoom', (e) => {
                    const t = e.transform
                    const f = tP.k / t.k
                    if (f == 1) {
                        //pan
                        const dx = tP.x - t.x
                        const dy = tP.y - t.y
                        this.pan(dx * this.getZf(), -dy * this.getZf())
                    } else {
                        const se = e.sourceEvent
                        if (se instanceof WheelEvent) {
                            //zoom at the mouse position
                            this.zoom(
                                f,
                                this.pixToGeoX(e.sourceEvent.offsetX),
                                this.pixToGeoY(e.sourceEvent.offsetY)
                            )
                        } else if (se instanceof TouchEvent) {
                            //compute average position of the touches
                            let tx = 0,
                                ty = 0
                            for (let tt of se.targetTouches) {
                                tx += tt.clientX
                                ty += tt.clientY
                            }
                            tx /= se.targetTouches.length
                            ty /= se.targetTouches.length
                            //zoom at this average position
                            this.zoom(f, this.pixToGeoX(tx), this.pixToGeoY(ty))
                        }
                    }
                    tP = t

                    if (this.onZoomFun) this.onZoomFun(e)
                })
                .on('start', (e) => {
                    this.canvasSave.c = document.createElement('canvas')
                    this.canvasSave.c.setAttribute('width', '' + this.w)
                    this.canvasSave.c.setAttribute('height', '' + this.h)
                    this.canvasSave.c.getContext('2d').drawImage(this.canvas, 0, 0)
                    this.canvasSave.dx = 0
                    this.canvasSave.dy = 0
                    this.canvasSave.f = 1

                    if (this.onZoomStartFun) this.onZoomStartFun(e)
                })
                .on('end', (e) => {
                    this.redraw(true)
                    this.canvasSave = { c: null, dx: 0, dy: 0, f: 1 }

                    if (this.onZoomEndFun) this.onZoomEndFun(e)
                })
            z((0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this.canvas))
        }
        //select(this.canvas).call(z);

        /** Zoom extent, to limit zoom in and out
         *  @type {Array.<number>} */
        this.zfExtent = [0, Infinity]

        /** Canvas state, to be used to avoid unnecessary redraws on zoom/pan
         *  @type {{c:HTMLCanvasElement|null,dx:number,dy:number,f:number}} */
        this.canvasSave = { c: null, dx: 0, dy: 0, f: 1 }
    }

    /** @param {{x:number,y:number}} v Geographical coordinates of the center */
    setCenter(v) {
        this.center = v
    }
    /** @returns {{x:number,y:number}} Geographical coordinates of the center */
    getCenter() {
        return this.center
    }

    /** @param {number} v The zoom factor (pixel size, in ground m) */
    setZf(v) {
        this.zf = v
        if (this.slider) this.slider.attr('value', +this.zf)
    }
    /** @returns {number} The zoom factor (pixel size, in ground m) */
    getZf() {
        return this.zf
    }

    /** @param {Array.<number>} v */
    setZfExtent(v) {
        this.zfExtent = v
    }
    /** @returns {Array.<number>} */
    getZfExtent() {
        return this.zfExtent
    }

    /** Initialise canvas transform with identity transformation. */
    initCanvasTransform() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0)
    }

    /** Initialise canvas transform with geo to screen transformation, so that geo objects can be drawn directly in geo coordinates. */
    setCanvasTransform() {
        const k = 1 / this.getZf()
        const tx = -this.center.x / this.getZf() + this.w * 0.5
        const ty = this.center.y / this.getZf() + this.h * 0.5
        this.ctx.setTransform(k, 0, 0, -k, tx, ty)
    }

    /** Get the transformation matrix to webGL screen coordinates, within [-1,1]*[-1,1] */
    getWebGLTransform() {
        const kx = 2.0 / (this.w * this.getZf())
        const ky = 2.0 / (this.h * this.getZf())
        return [kx, 0.0, 0.0, 0.0, ky, 0.0, -kx * this.center.x, -ky * this.center.y, 1.0]
    }

    /** The function specifying how to draw the map.
     * @param {boolean} strong */
    redraw(strong = true) {
        throw new Error('Method redraw not implemented.')
    }

    /**
     * Clear. To be used before a redraw for example.
     * @param {string} color
     */
    clear(color = 'white') {
        if (this.opts.transparentBackground) {
            this.ctx.clearRect(0, 0, this.w, this.h)
        } else {
            if (this.ctx) this.ctx.fillStyle = color
            this.ctx.fillRect(0, 0, this.w, this.h)
        }
    }

    /**
     * @param {number} dxGeo
     * @param {number} dyGeo
     */
    pan(dxGeo = 0, dyGeo = 0) {
        //TODO force extend to remain
        this.center.x += dxGeo
        this.center.y += dyGeo
        this.updateExtentGeo()

        if (this.canvasSave.c) {
            this.canvasSave.dx -= dxGeo / this.getZf()
            this.canvasSave.dy += dyGeo / this.getZf()
            this.clear(this.backgroundColor)
            // this doesnt work on mobile https://github.com/eurostat/gridviz/issues/98
            this.ctx.drawImage(this.canvasSave.c, this.canvasSave.dx, this.canvasSave.dy)
        }
    }

    /**
     * Zoom.
     * @param {number} f The zoom factor, within ]0, Infinity]. 1 is for no change. <1 to zoom-in, >1 to zoom-out.
     * @param {number} xGeo The x geo position fixed in the screen.
     * @param {number} yGeo The y geo position fixed in the screen.
     */
    zoom(f = 1, xGeo = this.center.x, yGeo = this.center.y) {
        //TODO force geo extend to remain

        //trying to zoom in/out beyond limit
        if (this.zfExtent[0] == this.getZf() && f <= 1) return
        if (this.zfExtent[1] == this.getZf() && f >= 1) return

        //ensure zoom extent preserved
        const newZf = f * this.getZf()
        if (newZf < this.zfExtent[0]) f = this.zfExtent[0] / this.getZf()
        if (newZf > this.zfExtent[1]) f = this.zfExtent[1] / this.getZf()

        this.setZf(f * this.getZf())
        const dxGeo = (xGeo - this.center.x) * (1 - f)
        this.center.x += dxGeo
        const dyGeo = (yGeo - this.center.y) * (1 - f)
        this.center.y += dyGeo
        this.updateExtentGeo()

        //TODO
        //this.redraw(false)
        if (this.canvasSave.c) {
            this.clear(this.backgroundColor)
            this.canvasSave.f /= f
            this.canvasSave.dx = this.geoToPixX(xGeo) * (1 - this.canvasSave.f)
            this.canvasSave.dy = this.geoToPixY(yGeo) * (1 - this.canvasSave.f)
            this.clear(this.backgroundColor)
            this.ctx.drawImage(
                this.canvasSave.c,
                this.canvasSave.dx,
                this.canvasSave.dy,
                this.canvasSave.f * this.canvasSave.c.width,
                this.canvasSave.f * this.canvasSave.c.height
            )
        }
    }

    /**
     * @param {number} marginPx
     * @returns {Envelope} The envelope of the view, in geo coordinates.
     */
    updateExtentGeo(marginPx = 20) {
        this.extGeo = {
            xMin: this.pixToGeoX(-marginPx),
            xMax: this.pixToGeoX(this.w + marginPx),
            yMin: this.pixToGeoY(this.h + marginPx),
            yMax: this.pixToGeoY(-marginPx),
        }
        return this.extGeo
    }

    /**
     * Check if the object has to be drawn
     *
     * @param {{x:number,y:number}} obj
     */
    toDraw(obj) {
        if (obj.x < this.extGeo.xMin) return false
        if (obj.x > this.extGeo.xMax) return false
        if (obj.y < this.extGeo.yMin) return false
        if (obj.y > this.extGeo.yMax) return false
        return true
    }

    //conversion functions
    /**
     * @param {number} xGeo Geo x coordinate, in m.
     * @returns {number} Screen x coordinate, in pix.
     */
    geoToPixX(xGeo) {
        return (xGeo - this.center.x) / this.getZf() + this.w * 0.5
    }
    /**
     * @param {number} yGeo Geo y coordinate, in m.
     * @returns {number} Screen y coordinate, in pix.
     */
    geoToPixY(yGeo) {
        return -(yGeo - this.center.y) / this.getZf() + this.h * 0.5
    }
    /**
     * @param {number} x Screen x coordinate, in pix.
     * @returns {number} Geo x coordinate, in m.
     */
    pixToGeoX(x) {
        return (x - this.w * 0.5) * this.getZf() + this.center.x
    }
    /**
     * @param {number} y Screen y coordinate, in pix.
     * @returns {number} Geo y coordinate, in m.
     */
    pixToGeoY(y) {
        return -(y - this.h * 0.5) * this.getZf() + this.center.y
    }

    /** Get x,y,z elements from URL and assign them to the view center and zoom level. */
    setViewFromURL() {
        const x = GeoCanvas.getParameterByName('x'),
            y = GeoCanvas.getParameterByName('y'),
            z = GeoCanvas.getParameterByName('z')
        const c = this.getCenter()
        if (x != null && x != undefined && !isNaN(+x)) c.x = +x
        if (y != null && y != undefined && !isNaN(+y)) c.y = +y
        if (z != null && z != undefined && !isNaN(+z)) this.setZf(+z)
    }

    /**
     *
     * @param {string} id
     * @param {object} opts
     * @returns {this}
     */
    addZoomSlider(id, opts) {
        opts = opts || {}
        opts.width = opts.width || '30px'
        opts.height = opts.height || '300px'

        //the div element
        const div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + id)
        if (div.empty()) {
            console.error('Could not find div element to build zoom slider. Id: ' + id)
            return this
        }

        const th = this
        /** */
        this.slider = div
            .append('input')
            .attr('type', 'range')
            .attr('min', this.getZfExtent()[0])
            .attr('max', this.getZfExtent()[1])
            .attr('value', this.getZf())
            .on('input', function (d) {
                if (!this || !this.value) return
                const v = +this.value
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this).attr('value', v)
                th.setZf(v)
                //redraw
                th.redraw()
            })
            .style('width', opts.width)
            .style('height', opts.height)
            .style('opacity', 0.7)
            .on('mouseover', function (d) {
                (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this).style('opacity', 1)
            })
            .on('mouseout', function (d) {
                (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this).style('opacity', 0.7)
            })
            .style('-webkit-appearance', 'slider-vertical') //for chrome
            .style('writing-mode', 'bt-lr') //for IE/edge
            .attr('orient', 'vertical') //for firefox
            .style('background', 'lightgray')
            .style('outline', 'none')
            .style('-webkit-transition', '.2s')
            .style('transition', 'opacity .2s')

        //TODO
        /*select(".slider::-webkit-slider-thumb")
            .style("-webkit-appearance", "none")
            .style("appearance", "none")
            .style("width", "30px")
            .style("height", "40px")
            .style("background", "black")
            .style("cursor", "pointer")*/

        /*select("slider::-moz-range-thumb")
            .style("-webkit-appearance", "none")
            .style("width", "30px")
            .style("height", "40px")
            .style("background", "#04AA6D")
            .style("cursor", "pointer")*/
        /*
            .slider::ms-thumb,
        .slider::-moz-range-thumb {
        }*/

        return this
    }

    /**
     * Get a URL parameter by name.
     *
     * @param {string} name
     * @returns {string | null}
     */
    static getParameterByName(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
        var regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
            results = regex.exec(location.search)
        return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/LabelLayer.js":
/*!************************************************!*\
  !*** ./node_modules/gridviz/src/LabelLayer.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LabelLayer: () => (/* binding */ LabelLayer)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
//@ts-check


;

/** A label. The name is the text to show. (x,y) are the coordinates in the same CRS as the grid.
 * @typedef {{name: string, x:number, y:number }} Label */

/**
 * A (generic) layer for placename labels, to be shown on top of the grid layers.
 * The input is a CSV file with the position (x, y) of the labels and name + some other info on the label importance.
 * If the label data is not in the expected format or in the same CRS as the grid, it can be corrected with the "preprocess" function.
 * The selection of the label, their style (font, weight, etc.) and color can be specified depending on their importance and the zoom level.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class LabelLayer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /**
         * The URL of the label data, as CSV file.
         * The file should contain the information for each label such as the text, the position and other information for the display of the label according to the zoom level.
         * If necessary, this data can be reformated with the 'preprocess' parameter.
         * @private
         * @type {string} */
        this.url = opts.url

        /** Specify if and how a label should be drawn, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.style = opts.style || (() => 'bold 1em Arial')

        /** Specify the label color, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.color = opts.color || (opts.dark ? () => '#ddd' : () => '#222')

        /** Specify the label halo color, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.haloColor = opts.haloColor || (opts.dark ? () => '#000000BB' : () => '#FFFFFFBB')

        /** Specify the label halo width, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):number} */
        this.haloWidth = opts.haloWidth || (() => 4)

        /** The anchor where to draw the text, from label position. See HTML-canvas textAlign property.
         * "left" || "right" || "center" || "start" || "end"
         * @private
         * @type {CanvasTextAlign} */
        this.textAlign = opts.textAlign || 'start'

        /**
         * @private
         * @type {Array.<number>} */
        this.offsetPix = opts.offsetPix || [5, 5]

        /**
         * A preprocess to run on each label after loading.
         * It can be used to apply some specific treatment before, format the label data, project coordinates, etc.
         * Return false if the label should not be kept.
         * @private
         * @type {function(Label):boolean} */
        this.preprocess = opts.preprocess

        /**
         * @private
         * @type {Array.<Label> | undefined} */
        this.labels = undefined

        /**
         * @private
         * @type {string} */
        this.loadingStatus = 'notLoaded'
    }

    /**
     * Draw the label layer.
     *
     * @param {import("./GeoCanvas").GeoCanvas} cg The canvas where to draw the layer.
     * @returns {void}
     */
    draw(cg) {
        //load labels, if not done yet.
        if (!this.labels) {
            this.load(cg.redraw)
            return
        }

        //zoom factor
        const zf = cg.getZf()

        //text align
        cg.ctx.textAlign = this.textAlign || 'start'

        //line join and cap
        cg.ctx.lineJoin = 'bevel' //|| "round" || "miter";
        cg.ctx.lineCap = 'butt' //|| "round" || "square";

        //draw in pix coordinates
        cg.initCanvasTransform()

        //draw labels, one by one
        for (const lb of this.labels) {
            //get label style
            const st = this.style(lb, zf)
            if (!st) continue
            cg.ctx.font = st

            //check label within the view, to be drawn
            if (!cg.toDraw(lb)) continue

            //position
            const xP = cg.geoToPixX(lb.x) + this.offsetPix[0]
            const yP = cg.geoToPixY(lb.y) - this.offsetPix[1]

            //label stroke, for the halo
            if (this.haloColor && this.haloWidth) {
                const hc = this.haloColor(lb, zf)
                const hw = this.haloWidth(lb, zf)
                if (hc && hw && hw > 0) {
                    cg.ctx.strokeStyle = hc
                    cg.ctx.lineWidth = hw
                    cg.ctx.strokeText(lb.name, xP, yP)
                }
            }

            //label fill
            if (this.color) {
                const col = this.color(lb, zf)
                if (col) {
                    cg.ctx.fillStyle = col
                    cg.ctx.fillText(lb.name, xP, yP)
                }
            }
        }
    }

    /**
     * Load data for labels, from URL this.url
     * @param {function():void} callback
     * @private
     */
    async load(callback) {
        if (!this.url) {
            console.log('Failed loading labels: No URL specified. ' + this.url)
            this.loadingStatus = 'failed'
            this.labels = []
            return
        }

        //check if data already loaded
        if (this.loadingStatus != 'notLoaded') return

        //load data
        this.loadingStatus = 'loading'

        try {
            /** @type { Array.<Label> } */
            const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_0__.csv)(this.url)

            //preprocess/filter
            if (this.preprocess) {
                this.labels = []
                for (const c of data) {
                    const b = this.preprocess(c)
                    if (b == false) continue
                    this.labels.push(c)
                }
            } else {
                //store labels
                this.labels = data
            }

            this.loadingStatus = 'loaded'

            //redraw
            if (callback) callback()
        } catch (error) {
            console.log('Failed loading labels from ' + this.url)
            this.labels = []
            this.loadingStatus = 'failed'
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/Layer.js":
/*!*******************************************!*\
  !*** ./node_modules/gridviz/src/Layer.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Layer: () => (/* binding */ Layer)
/* harmony export */ });
//@ts-check


/**
 * A layer, which specifies a dataset to be shown with specified styles.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class Layer {
    /**
     * @param {import("./Dataset").Dataset} dataset The multi resolution dataset to show.
     * @param {Array.<import("./Style").Style>} styles The styles, ordered in drawing order.
     * @param {{visible?:boolean,alpha?:number,blendOperation?:GlobalCompositeOperation,minZoom?:number,maxZoom?:number,pixNb?:number,cellInfoHTML?:function(import("./Dataset").Cell):string}} opts
     *      minZoom: The minimum zoom level when to show the layer. maxZoom: The maximum zoom level when to show the layer
     */
    constructor(dataset, styles, opts = {}) {
        opts = opts || {}

        /** @type {import("./Dataset").Dataset} */
        this.dataset = dataset
        /** @type {Array.<import("./Style").Style>} */
        this.styles = styles

        /** An attribute to specify if a layer should be drawn or not
         * @type {boolean} */
        this.visible = opts.visible === false ? false : true

        /** A function returning the alpha (transparency/opacity), between 0.0 (fully transparent) and 1.0 (fully opaque).
         *  The function parameter is the zoom factor.
         * (see CanvasRenderingContext2D: globalAlpha property)
         * @type {function(number):number|undefined} */
        this.alpha = opts.alpha

        /** A function returning the blend operation. The function parameter is the zoom factor.
         * (see CanvasRenderingContext2D: globalCompositeOperation property)
         * @type {GlobalCompositeOperation} */
        this.blendOperation = opts.blendOperation || (zf => "source-over")

        /** The minimum zoom factor: Below this level, the layer is not shown.
         * @type {number} */
        this.minZoom = opts.minZoom || 0

        /** The maximum zoom factor: Above this level, the layer is not shown.
         * @type {number} */
        this.maxZoom = opts.maxZoom || Infinity

        //ensure acceptable values for the zoom limits.
        if (this.minZoom >= this.maxZoom)
            throw new Error('Unexpected zoom limits for layer. Zoom min should be smaller than zoom max.')

        /** Unit: number of pixels
         * @type {number} */
        this.pixNb = opts.pixNb || 3

        /**
         * The function returning cell information as HTML.
         * This is typically used for tooltip information.
         * @type {function(import("./Dataset").Cell, number):string} */
        this.cellInfoHTML = opts.cellInfoHTML || Layer.defaultCellInfoHTML
    }

    /**
     * Return the relevant dataset component for a specified zoom factor.
     *
     * @param {number} zf
     * @returns {import("./DatasetComponent").DatasetComponent|undefined}
     * */
    getDatasetComponent(zf) {
        if (zf < this.minZoom || zf > this.maxZoom) return

        //special case whith single component dataset
        if (this.dataset.datasetComponents.length == 1) return this.dataset.datasetComponents[0]

        const rs = this.dataset.resolutions
        let i = 0
        let z = rs[i] / this.pixNb
        while (z < zf && i < rs.length) {
            i++
            z = rs[i] / this.pixNb
        }
        //if (i == 0) return this.dataset.datasetComponents[0];
        //return this.dataset.datasetComponents[i - 1];
        if (i == rs.length) return this.dataset.datasetComponents[rs.length - 1]
        return this.dataset.datasetComponents[i]
    }

    /**
     * The default function returning cell information as HTML.
     * This is typically used for tooltip information.
     *
     * @param {import("./Dataset").Cell} cell
     * @returns {string}
     */
    static defaultCellInfoHTML(cell) {
        const buf = []
        for (const key of Object.keys(cell)) {
            if (key === 'x') continue
            if (key === 'y') continue
            buf.push('<b>', key, '</b>', ' : ', cell[key], '<br>')
        }
        return buf.join('')
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/Legend.js":
/*!********************************************!*\
  !*** ./node_modules/gridviz/src/Legend.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Legend: () => (/* binding */ Legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


;

/**
 * A legend container.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class Legend {
    /**
     * @param {Object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** @type {string} */
        this.id = opts.id

        //TODO stop using it. Use style method below instead.

        /** @type {number} @deprecated */
        this.top = opts.top
        /** @type {number} @deprecated */
        this.bottom = opts.bottom
        /** @type {number} @deprecated */
        this.left = opts.left
        /** @type {number} @deprecated */
        this.right = opts.right
        /** @type {string} @deprecated */
        this.background = opts.background || 'none'
        /** @type {string} @deprecated */
        this.padding = opts.padding || '5px'
        /** @type {string} @deprecated */
        this.border = opts.border || '0px'
        /** @type {string} @deprecated */
        this['border-radius'] = opts['border-radius'] || 'none'
        /** @type {string} @deprecated */
        this['box-shadow'] = opts['box-shadow'] || 'none'
        /** @type {string} @deprecated */
        this['font-family'] = opts['font-family'] || 'Helvetica, Arial, sans-serif'
        /** @type {string} @deprecated */
        this.width = opts.width
        /** @type {string} @deprecated */
        this.height = opts.height

        //the div element
        if (this.id) this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + this.id)

        if (!this.div || this.div.empty()) {
            this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(document.createElement('div'))
            if (this.id) this.div.attr('id', this.id)
        }

        //set style
        this.div.style('background', this.background)
        this.div.style('padding', this.padding)
        this.div.style('border', this.border)
        this.div.style('border-radius', this['border-radius'])
        this.div.style('box-shadow', this['box-shadow'])
        this.div.style('font-family', this['font-family'])

        if (this.width) this.div.style('width', this.width)
        if (this.height) this.div.style('height', this.height)
    }

    /**
     * Apply a style to the legend div.
     * @param {string} k
     * @param {string} v
     * @returns {this}
     */
    style(k, v) {
        this.div.style(k, v)
        return this
    }

    /**
     * @param {Object} opts
     * @abstract
     */
    update(opts) {
        console.error('Legend update not implemented yet.')
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/LineLayer.js":
/*!***********************************************!*\
  !*** ./node_modules/gridviz/src/LineLayer.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineLayer: () => (/* binding */ LineLayer)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
//@ts-check


;

/**
 * @author Joseph Davies, Julien Gaffuri
 */
class LineLayer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /**
         * @private
         * @type {string} */
        this.url = opts.url

        /**
         * A preprocess to run on each feature after loading.
         * It can be used to apply some specific treatment before, format the label data, project coordinates, etc.
         * Return false if the label should not be kept.
         * @private
         * @type {function(object):boolean} */
        this.preprocess = opts.preprocess

        /**
         * @private
         * @type {function(object,number):string} */
        this.color = opts.color || ((f, zf) => 'gray')
        /**
         * @private
         * @type {function(object,number):number} */
        this.width = opts.width || ((f, zf) => 2)
        /**
         * @private
         * @type {function(object,number):Array.<number>|undefined} */
        this.lineDash = opts.lineDash || ((f, zf) => undefined)

        /**
         * @private
         * @type {Array.<object> | undefined} */
        this.fs = undefined

        /**
         * @private
         * @type {string} */
        this.loadingStatus = 'notLoaded'
    }

    /**
     * Draw the layer.
     * @param {import("./GeoCanvas").GeoCanvas} cg The canvas where to draw the layer.
     * @returns {void}
     */
    draw(cg) {
        //load data, if not done yet.
        if (!this.fs) {
            this.load(cg.redraw)
            return
        }

        //TODO sort lines by width ?

        //zoom factor
        const zf = cg.getZf()

        //draw in geo coordinates
        cg.setCanvasTransform()

        for (const f of this.fs) {
            const cs = f.geometry.coordinates
            if (cs.length < 2) continue

            //set color
            const col = this.color(f, zf)
            if (!col || col == 'none') continue
            cg.ctx.strokeStyle = col

            //set linewidth
            const wP = this.width(f, zf)
            if (!wP || wP < 0) continue
            cg.ctx.lineWidth = wP * zf

            //set line dash
            const ldP = this.lineDash(f, zf)
            if (ldP) cg.ctx.setLineDash(ldP)

            //draw line
            cg.ctx.beginPath()
            cg.ctx.moveTo(cs[0][0], cs[0][1])
            for (let i = 1; i < cs.length; i++) cg.ctx.lineTo(cs[i][0], cs[i][1])
            cg.ctx.stroke()
        }

        //...
        cg.ctx.setLineDash([])
    }

    /**
     * Load data for labels, from URL this.url
     * @param {function():void} callback
     * @private
     */
    async load(callback) {
        if (!this.url) {
            console.log('Failed loading boundaries: No URL specified. ' + this.url)
            this.loadingStatus = 'failed'
            this.labels = []
            return
        }

        //check if data already loaded
        if (this.loadingStatus != 'notLoaded') return

        //load data
        this.loadingStatus = 'loading'

        try {
            const data_ = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_0__["default"])(this.url)

            /** @type { Array.<object> } */
            const data = data_.features

            //preprocess/filter
            if (this.preprocess) {
                this.fs = []
                for (const c of data) {
                    const b = this.preprocess(c)
                    if (b == false) continue
                    this.fs.push(c)
                }
            } else {
                //store labels
                this.fs = data
            }

            this.loadingStatus = 'loaded'

            //redraw
            if (callback) callback()
        } catch (error) {
            console.log('Failed loading boundaries from ' + this.url)
            this.fs = []
            this.loadingStatus = 'failed'
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/Style.js":
/*!*******************************************!*\
  !*** ./node_modules/gridviz/src/Style.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Style: () => (/* binding */ Style)
/* harmony export */ });
//@ts-check


/**
 * Statistics of a set of values
 * @typedef {{min:number,max:number}} Stat */

/** @typedef {"square"|"circle"|"diamond"|"donut"|"none"} Shape */

/**
 * A style, to show a grid dataset.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class Style {
    /**
     * @abstract
     * @param {{filter?:function(import('./Dataset').Cell):boolean,offset?:function(import('./Dataset').Cell,number,number):{dx:number,dy:number},visible?:boolean,alpha?:function(number):number,blendOperation?:function(number):GlobalCompositeOperation,minZoom?:number,maxZoom?:number,drawFun?:function}} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** A filter function to apply to the cell list, to filter out some cells not to be drawn (such as for example the cells with value=0).
         * @protected
         * @type {function(import('./Dataset').Cell):boolean} */
        this.filter = opts.filter || (() => true)

        /** An offset. This is to alter the position of all symbols in a given direction. In geographical unit.
         * @protected
         * @type {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} */
        this.offset = opts.offset || ((c, r, zf) => ({ dx: 0, dy: 0 }))

        /** An attribute to specify if a style should be drawn or not
         * @type {boolean} */
        this.visible = opts.visible === false ? false : true

        /** A function returning the alpha (transparency/opacity), between 0.0 (fully transparent) and 1.0 (fully opaque).
         *  The function parameter is the zoom factor.
         * (see CanvasRenderingContext2D: globalAlpha property)
         * @type {function(number):number|undefined} */
        this.alpha = opts.alpha

        /** A function returning the blend operation. The function parameter is the zoom factor.
         * (see CanvasRenderingContext2D: globalCompositeOperation property)
         * @type {function(number):GlobalCompositeOperation} */
        this.blendOperation = opts.blendOperation || (zf => "source-over")

        /** The minimum zoom factor: Below this level, the layer is not shown.
         * @type {number}
         * */
        this.minZoom = opts.minZoom || 0

        /** The maximum zoom factor: Above this level, the layer is not shown.
         * @type {number}
         * */
        this.maxZoom = opts.maxZoom || Infinity

        /** A draw function for the style.
         * @type {function} */
        this.drawFun = opts.drawFun

        //ensure acceptable values for the zoom limits.
        if (this.minZoom >= this.maxZoom)
            throw new Error('Unexpected zoom limits for layer. Zoom min should be smaller than zoom max.')

        /**
         * @public
         * @type {Array.<import("./Legend").Legend>} */
        this.legends = []
    }

    /**
     * Draw cells.
     *
     * @param {Array.<import('./Dataset').Cell>} cells The cells to draw.
     * @param {number} resolution Their resolution (in geographic unit)
     * @param {import("./GeoCanvas").GeoCanvas} cg The canvas where to draw them.
     * @abstract
     */
    draw(cells, resolution, cg) {
        if (this.drawFun) this.drawFun(cells, resolution, cg)
        else throw new Error('Method draw not implemented.')
    }

    //getters and setters

    /** @returns {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} */
    getOffset() {
        return this.offset
    }
    /** @param {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} val @returns {this} */
    setOffset(val) {
        this.offset = val
        return this
    }

    /** Hide all legend elements of the style, if any
     * @param {object} opts
     * @returns {this} */
    updateLegends(opts) {
        for (const lg of this.legends) lg.update(opts)
        return this
    }

    /**
     * Compute some statistics on a value of some cells.
     * This is used to define how to draw specifically the cells within the view.
     * TODO: compute median ?
     *
     * @param {Array.<import('./Dataset').Cell>} cells
     * @param {function(import('./Dataset').Cell):number} valFun
     * @param {boolean} ignoreZeros
     * @returns {Stat | undefined}
     */
    static getStatistics(cells, valFun, ignoreZeros) {
        if (!cells || cells.length == 0) return undefined
        let min = Infinity
        let max = -Infinity
        //let sum = 0
        //let nb = 0
        for (const cell of cells) {
            const v = +valFun(cell)
            if (ignoreZeros && !v) continue
            if (v < min) min = v
            if (v > max) max = v
            //sum += v
            //nb++
        }
        return { min: min, max: max }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/Tooltip.js":
/*!*********************************************!*\
  !*** ./node_modules/gridviz/src/Tooltip.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tooltip: () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


;
//import { transition } from "d3-transition";

/**
 * A generic class to make a tooltip.
 * It is a div element, which can be moved under the mouse pointer and filled with some information in html.
 */
class Tooltip {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** @type {string} */
        this.div = opts.div || 'tooltip_eurostat'
        /** @type {string} */
        this.maxWidth = opts.maxWidth || '20em'
        /** @type {string} */
        this.fontSize = opts.fontSize || '1.2em'
        /** @type {string} */
        this.background = opts.background || 'white'
        /** @type {string} */
        this.padding = opts.padding || '5px'
        /** @type {string} */
        this.border = opts.border || '0px'
        /** @type {string} */
        this['border-radius'] = opts['border-radius'] || '0px'
        /** @type {string} */
        this['box-shadow'] = opts['box-shadow'] || '5px 5px 5px grey'
        /** @type {string} */
        this['font-family'] = opts['font-family'] || 'Helvetica, Arial, sans-serif'

        /** @type {number} */
        this.transitionDuration = opts.transitionDuration || 100
        /** @type {number} */
        this.xOffset = opts.xOffset || 30
        /** @type {number} */
        this.yOffset = opts.yOffset || 20
        /** @type {number} */ // e.g. to prevent mouse cursor covering cell being highlighted
        this.yMouseOffset = opts.yMouseOffset || 0
        /** @type {number} */
        this.xMouseOffset = opts.xMouseOffset || 0
        /** @type {HTMLElement} */
        this.parentElement = opts.parentElement || document.body

        /**
         * @public
         * @type {import("d3-selection").Selection} */
        this.tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + this.div)

        if (this.tooltip.empty()) {
            //create tooltip DOM node
            // this.tooltip = select(
            //     '#' + this.parentElement.id && this.parentElement.id != ''
            //         ? '#' + this.parentElement.id
            //         : 'body'
            // )
            this.tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('body').append('div').attr('id', this.div)
        }

        //initialise
        this.tooltip.style('max-width', this.maxWidth)
        this.tooltip.style('overflow', 'hidden')
        this.tooltip.style('font-size', this.fontSize)
        this.tooltip.style('background', this.background)
        this.tooltip.style('padding', this.padding)
        this.tooltip.style('border', this.border)
        this.tooltip.style('border-radius', this['border-radius'])
        this.tooltip.style('box-shadow', this['box-shadow'])
        this.tooltip.style('font-family', this['font-family'])
        this.tooltip.style('position', 'absolute')
        this.tooltip.style('pointer-events', 'none')
        this.tooltip.style('opacity', '0')
        this.tooltip.style('text-wrap', 'nowrap')

        // aria-labels (thanks to wahlatlas)
        this.tooltip.attr('role', 'tooltip').attr('aria-live', 'polite')
    }

    /** Show the tooltip */
    show() {
        // @ts-ignore
        this.tooltip.transition().duration(this.transitionDuration).style('opacity', 1)
    }

    /** Hide the tooltip */
    hide() {
        // @ts-ignore
        this.tooltip.transition().duration(this.transitionDuration).style('opacity', 0)
    }

    /**
     * Set the content of the tooltip.
     * @param {string} html
     */
    html(html) {
        this.tooltip.html(html)
    }

    /**
     * Set the position of the tooltip at the mouse event position.
     * @param {MouseEvent} event
     */
    setPosition(event) {
        let parentRect = this.parentElement.getBoundingClientRect()

        let x = event.pageX + this.xOffset
        let y = event.pageY - this.yOffset

        this.tooltip.style('left', x + 'px').style('top', y + 'px')

        this.ensureTooltipInsideContainer(event, parentRect)
    }

    /*
	my.mouseover = function (event, html) {
		if (html) my.html(html);
		my.setPosition(event);
		my.show()
		//this.ensureTooltipInsideContainer();
	};
	
	my.mousemove = function (event) {
		my.setPosition(event);
		//this.ensureTooltipInsideContainer();
	};
	
	my.mouseout = function () {
		my.hide();
	};*/

    style(k, v) {
        if (arguments.length == 1) return this.tooltip.style(k)
        this.tooltip.style(k, v)
        return this
    }

    attr(k, v) {
        if (arguments.length == 1) return this.tooltip.attr(k)
        this.tooltip.attr(k, v)
        return this
    }

    /**
     * @function ensureTooltipInsideContainer
     * @description Prevents the tooltip from overflowing out of the App container (ensures that the tooltip is inside the gridviz container)
     * @param {MouseEvent} event
     * @param {DOMRect} parentRect
     */
    ensureTooltipInsideContainer = function (event, parentRect) {
        let node = this.tooltip.node()
        let parentWidth = parentRect.width
        let parentHeight = parentRect.height

        //too far right
        if (node.offsetLeft > parentRect.left + parentWidth - node.clientWidth) {
            let left = event.x - node.clientWidth - this.xOffset
            node.style.left = left + 'px'
            // check if mouse covers tooltip
            if (node.offsetLeft + node.clientWidth > event.x) {
                //move tooltip left so it doesnt cover mouse
                let left2 = event.x - node.clientWidth - this.xOffset
                node.style.left = left2 + 'px'
            }
            // node.style.top = node.offsetTop + config.yOffset + "px";
        }

        //too far down
        if (node.offsetTop + node.clientHeight > parentRect.top + parentHeight) {
            node.style.top = node.offsetTop - node.clientHeight + 'px'
        }

        //too far up
        if (node.offsetTop < parentRect.top) {
            node.style.top = parentRect.top + this.yOffset + 'px'
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/button/Button.js":
/*!***************************************************!*\
  !*** ./node_modules/gridviz/src/button/Button.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: () => (/* binding */ Button)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");


/**
 * Parent class for button elements used to interact with the gridviz viewer.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class Button {
    /**
     * @param {Object} opts
     * opts.parentNode
     * opts.id
     * opts.title
     * opts.class
     * opts.onClickFunction
     * opts.x
     * opts.y
     */
    constructor(opts) {
        opts = opts || {}

        this.app = opts.app
        this.parentNode = opts.parentNode || opts.app.container

        // the div element
        if (this.id) this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + this.id)

        if (!this.div || this.div.empty()) {
            this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(document.createElement('div'))
            if (this.id) this.div.attr('id', this.id)
        }

        if (opts.title) this.div.attr('title',opts.title)
        if (opts.class) this.div.attr('class',opts.class)

        // add events
        if (opts.onClickFunction) this.div.on('click', opts.onClickFunction)

        //set styles
        this.style('box-shadow','0 7px 8px rgba(0,47,103,.08), 0 0 22px rgba(0,47,103,.04), 0 12px 17px rgba(0,47,103,.04), 0 -4px 4px rgba(0,47,103,.04)') //.ecl-u-shadow-3
        this.style('background-color','#ffffff')
        this.style('position' , 'absolute')
        this.style('cursor' , 'pointer')
        this.style('display' , 'flex')
        this.style('justify-content' , 'center')
        this.style('align-items' , 'center')
        this.style('width' , '30px')
        this.style('height' , '30px')
        // this.style(padding , '4px'


        // append to parent
        this.parentNode.appendChild(this.div.node())
    }

    /**
     * Apply a style to the button div.
     * @param {string} k
     * @param {string} v
     * @returns {this}
     */
    style(k, v) {
        this.div.style(k, v)
        return this
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/button/FullscreenButton.js":
/*!*************************************************************!*\
  !*** ./node_modules/gridviz/src/button/FullscreenButton.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FullscreenButton: () => (/* binding */ FullscreenButton)
/* harmony export */ });
/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ "./node_modules/gridviz/src/button/Button.js");


/**
 * Button for toggling fullscreen mode
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class FullscreenButton extends _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button {
    /**
     * @param {Object} opts
     * opts.parentNode - the node that the button is appended to
     * opts.canvas - the gridviz canvas
     * opts.id
     * opts.title - HTML title attribute
     * opts.class - css class
     * opts.onClickFunction
     * opts.x - x position of the button
     * opts.y - y position of the button
     */

    // default state
    isFullscreen = false

    constructor(opts) {
        super(opts)

        // append fullscreen icon to button container
        this.div.node().innerHTML = `
        <svg
            style="height: 1.2rem; width: 1.2rem; fill:black; margin:0;"
            focusable="false"
            aria-hidden="true"
        >
            <svg fill="#000000" viewBox="0 0 96 96" xmlns="http://www.w3.org/2000/svg">
            <title/>
            <g>
            <path d="M30,0H6A5.9966,5.9966,0,0,0,0,6V30a6,6,0,0,0,12,0V12H30A6,6,0,0,0,30,0Z"/>
            <path d="M90,0H66a6,6,0,0,0,0,12H84V30a6,6,0,0,0,12,0V6A5.9966,5.9966,0,0,0,90,0Z"/>
            <path d="M30,84H12V66A6,6,0,0,0,0,66V90a5.9966,5.9966,0,0,0,6,6H30a6,6,0,0,0,0-12Z"/>
            <path d="M90,60a5.9966,5.9966,0,0,0-6,6V84H66a6,6,0,0,0,0,12H90a5.9966,5.9966,0,0,0,6-6V66A5.9966,5.9966,0,0,0,90,60Z"/>
            </g>
            </svg>
        </svg>
        `

        //save initial app dimensions
        this.defaultHeight = this.app.h
        this.defaultWidth = this.app.w

        // event handler
        this.div.on('click', (e) => {
            this.onClickFunction(e)
        })
        this.div.on('mouseover', (e) => {
            this.style('background-color', 'lightgrey')
        })
        this.div.on('mouseout', (e) => {
            this.style('background-color', '#ffffff')
        })

        //set position
        if (opts.x) {
            this.style('left', opts.x + 'px')
        } else {
            this.style('right', '10px')
        }
        if (opts.y) {
            this.style('top', opts.y + 'px')
        } else {
            this.style('top', '90px')
        }
    }

    onClickFunction(e) {
        if (this.isFullscreen) {
            this.closeFullscreen(this.app.container)
            //resize canvas to default
            this.app.h = this.defaultHeight
            this.app.w = this.defaultWidth
            this.app.cg.h = this.defaultHeight
            this.app.cg.w = this.defaultWidth
            this.app.cg.canvas.setAttribute('width', '' + this.defaultWidth)
            this.app.cg.canvas.setAttribute('height', '' + this.defaultHeight)
            this.app.redraw()
            this.isFullscreen = false
        } else {
            this.openFullscreen(this.app.container)
            //resize canvas to fullscreen
            this.app.h = window.screen.height
            this.app.w = window.screen.width
            this.isFullscreen = true
        }
    }

    /* Open fullscreen */
    openFullscreen(elem) {
        if (elem.requestFullscreen) {
            elem.requestFullscreen()
        } else if (elem.webkitRequestFullscreen) {
            /* Safari */
            elem.webkitRequestFullscreen()
        } else if (elem.msRequestFullscreen) {
            /* IE11 */
            elem.msRequestFullscreen()
        }
    }

    /* Close fullscreen */
    closeFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen()
        } else if (document.webkitExitFullscreen) {
            /* Safari */
            document.webkitExitFullscreen()
        } else if (document.msExitFullscreen) {
            /* IE11 */
            document.msExitFullscreen()
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/button/ZoomButtons.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/button/ZoomButtons.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZoomButtons: () => (/* binding */ ZoomButtons)
/* harmony export */ });
/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ "./node_modules/gridviz/src/button/Button.js");


/**
 * Button for toggling fullscreen mode
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class ZoomButtons extends _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button {
    /**
     * @param {Object} opts
     */
    constructor(opts) {
        super(opts)

        this.onZoom = opts.onZoom // custom user event handler
        this.delta = opts.delta || 0.2

        // zoom in btn
        this.zoomInBtn = document.createElement('a')
        this.zoomInBtn.innerHTML = `<a id="zoomin" class="gridviz-zoom-button" title="Zoom in">+</a>`
        this.zoomInBtn.title = 'Zoom in'
        this.zoomInBtn.addEventListener('click', (e) => {
            this.zoomIn(e)
        })
        this.zoomInBtn.addEventListener('mouseover', (e) => {
            this.zoomInBtn.style.backgroundColor = 'lightgrey'
        })
        this.zoomInBtn.addEventListener('mouseout', (e) => {
            this.zoomInBtn.style.backgroundColor = '#ffffff'
        })

        // zoom out btn
        this.zoomOutBtn = document.createElement('a')
        this.zoomOutBtn.innerHTML = `<a id="zoomin" class="gridviz-zoom-button" title="Zoom out">-</a>`
        this.zoomOutBtn.title = 'Zoom out'
        this.zoomOutBtn.addEventListener('click', (e) => {
            this.zoomOut(e)
        })
        this.zoomOutBtn.addEventListener('mouseover', (e) => {
            this.zoomOutBtn.style.backgroundColor = 'lightgrey'
        })
        this.zoomOutBtn.addEventListener('mouseout', (e) => {
            this.zoomOutBtn.style.backgroundColor = '#ffffff'
        })

        //set styles
        let btns = [this.zoomInBtn, this.zoomOutBtn]
        btns.forEach((btn, i) => {
            btn.style.alignItems = 'center'
            btn.style.justifyContent = 'center'
            btn.style.display = 'flex'
            btn.style.border = 'none'
            btn.style.color = 'black'
            btn.style.textAlign = 'center'
            btn.style.textDecoration = 'none'
            btn.style.padding = '4px'
            btn.style.fontSize = '20px'
            btn.style.fontWeight = 'bold'
            btn.style.userSelect = 'none'
            if (i == 0) btn.style.borderBottom = '1px solid grey'
        })

        // unset parent class height and display for dual buttons
        this.style('height', 'unset')
        this.style('display', 'unset')

        //set position
        if (opts.x) {
            this.style('left', opts.x + 'px')
        } else {
            this.style('right', '10px')
        }
        if (opts.y) {
            this.style('top', opts.y + 'px')
        } else {
            this.style('top', '10px')
        }

        // append to button container
        this.div.node().appendChild(this.zoomInBtn)
        this.div.node().appendChild(this.zoomOutBtn)
    }

    /* Zoom in */
    zoomIn(e) {
        this.app.setZoomFactor(this.app.getZoomFactor() * (1 - this.delta)).redraw()
        if (this.onZoom) this.onZoom(e)
    }

    /* Zoom out */
    zoomOut(e) {
        this.app.setZoomFactor(this.app.getZoomFactor() * (1 + this.delta)).redraw()
        if (this.onZoom) this.onZoom(e)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/dataset/CSVGrid.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridviz/src/dataset/CSVGrid.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSVGrid: () => (/* binding */ CSVGrid)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
/* harmony import */ var _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DatasetComponent.js */ "./node_modules/gridviz/src/DatasetComponent.js");
//@ts-check


/** @typedef {{ dims: object, crs: string, tileSizeCell: number, originPoint: {x:number,y:number}, resolutionGeo: number, tilingBounds:import("../Dataset").Envelope }} GridInfo */

;


/**
 * A dataset composed of a single CSV file (not tiled).
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class CSVGrid extends _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_0__.DatasetComponent {
    /**
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {{preprocess?:(function(import("../Dataset").Cell):boolean)}} opts
     */
    constructor(url, resolution, opts = {}) {
        super(url, resolution, opts)

        /**
         * @private
         * @type {Array.<import("../Dataset").Cell>} */
        this.cells = []

        /**
         * @type {string}
         * @private  */
        this.infoLoadingStatus = 'notLoaded'
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {import("../Dataset").Envelope|undefined} e
     * @param {function():void} redraw
     */
    getData(e, redraw) {
        //check if data already loaded
        if (this.infoLoadingStatus != 'notLoaded') return this

        //load data
        this.infoLoadingStatus = 'loading'
        ;(async () => {
            try {
                const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_1__.csv)(this.url)

                //convert coordinates in numbers
                for (const c of data) {
                    c.x = +c.x
                    c.y = +c.y
                }

                //preprocess/filter
                if (this.preprocess) {
                    this.cells = []
                    for (const c of data) {
                        const b = this.preprocess(c)
                        if (b == false) continue
                        this.cells.push(c)
                    }
                } else {
                    this.cells = data
                }

                //TODO check if redraw is necessary
                //that is if the dataset belongs to a layer which is visible at the current zoom level

                //execute the callback, usually a draw function
                if (redraw) redraw()

                this.infoLoadingStatus = 'loaded'
            } catch (error) {
                //mark as failed
                this.infoLoadingStatus = 'failed'
                this.cells = []
            }
        })()

        return this
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     *
     * @param {import("../Dataset").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //data not loaded yet
        if (!this.cells) return

        this.cellsViewCache = []
        for (const cell of this.cells) {
            if (+cell.x + this.resolution < extGeo.xMin) continue
            if (+cell.x - this.resolution > extGeo.xMax) continue
            if (+cell.y + this.resolution < extGeo.yMin) continue
            if (+cell.y - this.resolution > extGeo.yMax) continue
            this.cellsViewCache.push(cell)
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/dataset/GridTile.js":
/*!******************************************************!*\
  !*** ./node_modules/gridviz/src/dataset/GridTile.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GridTile: () => (/* binding */ GridTile)
/* harmony export */ });
//@ts-check


/**
 * A grid tile.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class GridTile {
    /**
     * @param {Array.<import("../Dataset").Cell>} cells The tile cells.
     * @param {number} xT The X position of the tile.
     * @param {number} yT The Y position of the tile.
     * @param {import("./CSVGrid").GridInfo} gridInfo The grid info object.
     */
    constructor(cells, xT, yT, gridInfo) {
        /** @type {Array.<import("../Dataset").Cell>} */
        this.cells = cells
        /** @type {number} */
        this.x = xT
        /** @type {number} */
        this.y = yT

        const r = gridInfo.resolutionGeo
        const s = gridInfo.tileSizeCell

        /** @type {import("../Dataset").Envelope} */
        this.extGeo = {
            xMin: gridInfo.originPoint.x + r * s * this.x,
            xMax: gridInfo.originPoint.x + r * s * (this.x + 1),
            yMin: gridInfo.originPoint.y + r * s * this.y,
            yMax: gridInfo.originPoint.y + r * s * (this.y + 1),
        }

        //convert cell coordinates into geographical coordinates
        for (let cell of this.cells) {
            cell.x = this.extGeo.xMin + cell.x * r
            cell.y = this.extGeo.yMin + cell.y * r
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/dataset/LGrid.js":
/*!***************************************************!*\
  !*** ./node_modules/gridviz/src/dataset/LGrid.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LGrid: () => (/* binding */ LGrid)
/* harmony export */ });
/* harmony import */ var _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DatasetComponent.js */ "./node_modules/gridviz/src/DatasetComponent.js");
//@ts-check


/** @typedef {{ dims: object, crs: string, tileSizeCell: number, originPoint: {x:number,y:number}, resolutionGeo: number, tilingBounds:import("../Dataset.js").Envelope }} GridInfo */

;

/**
 * A dataset composed of a single CSV file (not tiled).
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class LGrid extends _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_0__.DatasetComponent {
    /**
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {Array.<Object>} cells The cells.
     */
    constructor(resolution, cells) {
        super("", resolution)

        /**
         * @private
         * @type {Array.<import("../Dataset.js").Cell>} */
        this.cells = cells || []
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {import("../Dataset.js").Envelope|undefined} e
     * @param {function():void} redraw
     */
    getData(e, redraw) { return this }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     *
     * @param {import("../Dataset.js").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //data not loaded yet
        if (!this.cells) return

        this.cellsViewCache = []
        for (const cell of this.cells) {
            if (+cell.x + this.resolution < extGeo.xMin) continue
            if (+cell.x - this.resolution > extGeo.xMax) continue
            if (+cell.y + this.resolution < extGeo.yMin) continue
            if (+cell.y - this.resolution > extGeo.yMax) continue
            this.cellsViewCache.push(cell)
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/dataset/TiledGrid.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/dataset/TiledGrid.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TiledGrid: () => (/* binding */ TiledGrid)
/* harmony export */ });
/* harmony import */ var _GridTile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GridTile.js */ "./node_modules/gridviz/src/dataset/GridTile.js");
/* harmony import */ var _App_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../App.js */ "./node_modules/gridviz/src/App.js");
/* harmony import */ var _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DatasetComponent.js */ "./node_modules/gridviz/src/DatasetComponent.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Utils.js */ "./node_modules/gridviz/src/utils/Utils.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
//@ts-check


/** @typedef {{ dims: object, crs: string, tileSizeCell: number, originPoint: {x:number,y:number}, resolutionGeo: number, tilingBounds:import("../Dataset").Envelope, format:import("../DatasetComponent").Format }} GridInfo */

// internal
;




// external


/**
 * A tiled dataset, composed of CSV tiles.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class TiledGrid extends _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_2__.DatasetComponent {
    /**
     * @param {string} url The URL of the dataset.
     * @param {App} app The application.
     * @param {{preprocess?:(function(import("../Dataset").Cell):boolean) }} opts
     */
    constructor(url, app, opts = {}) {
        super(url, 0, opts)

        /**
         * The app being used.
         * @type {App}
         */
        this.app = app

        /**
         * The grid info object, from the info.json file.
         *  @type {GridInfo | undefined}
         * @private
         *  */
        this.info = undefined

        /**
         * @type {string}
         * @private  */
        this.infoLoadingStatus = 'notLoaded'

        /**
         * The cache of the loaded tiles. It is double indexed: by xT and then yT.
         * Example: this.cache[xT][yT] returns the tile at [xT][yT] location.
         *
         * @type {object}
         * */
        this.cache = {}

    }

    /**
     * Load the info.json from the url.
     *
     * @param {function():void} callback
     * @returns this
     */
    loadInfo(callback) {
        if (!this.info && this.infoLoadingStatus === 'notLoaded') {
            ; (async () => {
                try {
                    const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(this.url + 'info.json')
                    this.info = data
                    this.resolution = data.resolutionGeo
                    this.infoLoadingStatus = 'loaded'
                    if (callback) callback()
                } catch (error) {
                    //mark as failed
                    this.infoLoadingStatus = 'failed'
                }
            })()
        } else if (callback && (this.infoLoadingStatus === 'loaded' || this.infoLoadingStatus === 'failed'))
            callback()
        return this
    }

    /**
     * Compute a tiling envelope from a geographical envelope.
     * This is the function to use to know which tiles to download for a geographical view.
     *
     * @param {import("../Dataset").Envelope} e
     * @returns {import("../Dataset").Envelope|undefined}
     */
    getTilingEnvelope(e) {
        if (!this.info) {
            this.loadInfo(() => { })
            return
        }

        const po = this.info.originPoint,
            r = this.info.resolutionGeo,
            s = this.info.tileSizeCell

        return {
            xMin: Math.floor((e.xMin - po.x) / (r * s)),
            xMax: Math.floor((e.xMax - po.x) / (r * s)),
            yMin: Math.floor((e.yMin - po.y) / (r * s)),
            yMax: Math.floor((e.yMax - po.y) / (r * s)),
        }
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {import("../Dataset").Envelope} extGeo
     * @param {function():void} redrawFun
     * @returns {this}
     */
    getData(extGeo, redrawFun) {
        //TODO empty cache when it gets too big ?

        //check if info has been loaded
        if (!this.info) return this

        //tiles within the scope
        /** @type {import("../Dataset").Envelope|undefined} */
        const tb = this.getTilingEnvelope(extGeo)
        if (!tb) return this

        //grid bounds
        /** @type {import("../Dataset").Envelope} */
        const gb = this.info.tilingBounds

        for (let xT = Math.max(tb.xMin, gb.xMin); xT <= Math.min(tb.xMax, gb.xMax); xT++) {
            for (let yT = Math.max(tb.yMin, gb.yMin); yT <= Math.min(tb.yMax, gb.yMax); yT++) {
                //prepare cache
                if (!this.cache[xT]) this.cache[xT] = {}

                //check if tile exists in the cache
                /** @type {GridTile} */
                let tile = this.cache[xT][yT]
                if (tile) continue

                //mark tile as loading
                this.cache[xT][yT] = "loading";
                (async () => {
                    //request tile
                    /** @type {Array.<import("../Dataset").Cell>}  */
                    let cells

                    try {
                        /** @type {Array.<import("../Dataset").Cell>}  */
                        // @ts-ignore
                        const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_5__.csv)(this.url + xT + '/' + yT + '.csv')

                        //if (monitor) monitorDuration('*** TiledGrid parse start')

                        //preprocess/filter
                        if (this.preprocess) {
                            cells = []
                            for (const c of data) {
                                const b = this.preprocess(c)
                                if (b == false) continue
                                cells.push(c)
                            }
                        } else {
                            cells = data
                        }

                        //if (monitor) monitorDuration('preprocess / filter')
                    } catch (error) {
                        //mark as failed
                        this.cache[xT][yT] = 'failed'
                        return
                    }

                    //store tile in cache
                    if (!this.info) {
                        console.error('Tile info inknown')
                        return
                    }
                    const tile_ = new _GridTile_js__WEBPACK_IMPORTED_MODULE_0__.GridTile(cells, xT, yT, this.info)
                    this.cache[xT][yT] = tile_

                    //if (monitor) monitorDuration('storage')

                    //if no redraw is specified, then leave
                    if (!redrawFun) return

                    //check if redraw is really needed, that is if:

                    // 1. the dataset belongs to a layer which is visible at the current zoom level
                    let redraw = false
                    //go through the layers
                    const zf = this.app.getZoomFactor()
                    for (const lay of this.app.layers) {
                        if (!lay.visible) continue
                        if (lay.getDatasetComponent(zf) != this) continue
                        //found one layer. No need to seek more.
                        redraw = true
                        break
                    }
                    //if (monitor) monitorDuration('check redraw 1')

                    if (!redraw) return

                    // 2. the tile is within the view, that is its geo envelope intersects the viewer geo envelope.
                    const env = this.app.updateExtentGeo()
                    const envT = tile_.extGeo
                    if (env.xMax <= envT.xMin) return
                    if (env.xMin >= envT.xMax) return
                    if (env.yMax <= envT.yMin) return
                    if (env.yMin >= envT.yMax) return

                    //if (monitor) monitorDuration('check redraw 2')
                    //if (monitor) monitorDuration('*** TiledGrid parse end')

                    //redraw
                    redrawFun()
                })()
            }
        }
        return this
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     * @abstract
     * @param {import("../Dataset").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //
        this.cellsViewCache = []

        //check if info has been loaded
        if (!this.info) return

        //tiles within the scope
        /** @type {import("../Dataset").Envelope|undefined} */
        const tb = this.getTilingEnvelope(extGeo)
        if (!tb) return

        //grid bounds
        /** @type {import("../Dataset").Envelope} */
        const gb = this.info.tilingBounds

        for (let xT = Math.max(tb.xMin, gb.xMin); xT <= Math.min(tb.xMax, gb.xMax); xT++) {
            if (!this.cache[xT]) continue
            for (let yT = Math.max(tb.yMin, gb.yMin); yT <= Math.min(tb.yMax, gb.yMax); yT++) {
                //get tile
                /** @type {GridTile} */
                const tile = this.cache[xT][yT]
                if (!tile || typeof tile === 'string') continue

                //get cells
                //this.cellsViewCache = this.cellsViewCache.concat(tile.cells)

                for (const cell of tile.cells) {
                    if (+cell.x + this.resolution < extGeo.xMin) continue
                    if (+cell.x - this.resolution > extGeo.xMax) continue
                    if (+cell.y + this.resolution < extGeo.yMin) continue
                    if (+cell.y - this.resolution > extGeo.yMax) continue
                    this.cellsViewCache.push(cell)
                }
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/gridviz/src/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   App: () => (/* reexport safe */ _App_js__WEBPACK_IMPORTED_MODULE_0__.App),
/* harmony export */   BackgroundLayer: () => (/* reexport safe */ _BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_31__.BackgroundLayer),
/* harmony export */   BackgroundLayerWMS: () => (/* reexport safe */ _BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_32__.BackgroundLayerWMS),
/* harmony export */   BoundaryLayer: () => (/* reexport safe */ _LineLayer_js__WEBPACK_IMPORTED_MODULE_34__.LineLayer),
/* harmony export */   CSVGrid: () => (/* reexport safe */ _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_8__.CSVGrid),
/* harmony export */   ColorCategoryLegend: () => (/* reexport safe */ _legend_ColorCategoryLegend_js__WEBPACK_IMPORTED_MODULE_37__.ColorCategoryLegend),
/* harmony export */   ColorDiscreteLegend: () => (/* reexport safe */ _legend_ColorDiscreteLegend_js__WEBPACK_IMPORTED_MODULE_36__.ColorDiscreteLegend),
/* harmony export */   ColorLegend: () => (/* reexport safe */ _legend_ColorLegend_js__WEBPACK_IMPORTED_MODULE_35__.ColorLegend),
/* harmony export */   CompositionStyle: () => (/* reexport safe */ _style_CompositionStyle_js__WEBPACK_IMPORTED_MODULE_14__.CompositionStyle),
/* harmony export */   CompositionStyle_: () => (/* reexport safe */ _style_CompositionStyle_js__WEBPACK_IMPORTED_MODULE_15__.CompositionStyle_),
/* harmony export */   ContourStyle: () => (/* reexport safe */ _style_ContourStyle_js__WEBPACK_IMPORTED_MODULE_20__.ContourStyle),
/* harmony export */   Dataset: () => (/* reexport safe */ _Dataset_js__WEBPACK_IMPORTED_MODULE_4__.Dataset),
/* harmony export */   DatasetComponent: () => (/* reexport safe */ _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_5__.DatasetComponent),
/* harmony export */   DotDensityStyle: () => (/* reexport safe */ _style_DotDensityStyle_js__WEBPACK_IMPORTED_MODULE_22__.DotDensityStyle),
/* harmony export */   GeoCanvas: () => (/* reexport safe */ _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__.GeoCanvas),
/* harmony export */   GridTile: () => (/* reexport safe */ _dataset_GridTile_js__WEBPACK_IMPORTED_MODULE_7__.GridTile),
/* harmony export */   IsoFenceStyle: () => (/* reexport safe */ _style_IsoFenceStyle_js__WEBPACK_IMPORTED_MODULE_30__.IsoFenceStyle),
/* harmony export */   JoyPlotStyle: () => (/* reexport safe */ _style_JoyPlotStyle_js__WEBPACK_IMPORTED_MODULE_13__.JoyPlotStyle),
/* harmony export */   LGrid: () => (/* reexport safe */ _dataset_LGrid_js__WEBPACK_IMPORTED_MODULE_9__.LGrid),
/* harmony export */   LabelLayer: () => (/* reexport safe */ _LabelLayer_js__WEBPACK_IMPORTED_MODULE_33__.LabelLayer),
/* harmony export */   Layer: () => (/* reexport safe */ _Layer_js__WEBPACK_IMPORTED_MODULE_3__.Layer),
/* harmony export */   LegoStyle: () => (/* reexport safe */ _style_LegoStyle_js__WEBPACK_IMPORTED_MODULE_24__.LegoStyle),
/* harmony export */   MosaicStyle: () => (/* reexport safe */ _style_MosaicStyle_js__WEBPACK_IMPORTED_MODULE_27__.MosaicStyle),
/* harmony export */   NinjaStarStyle: () => (/* reexport safe */ _style_NinjaStarStyle_js__WEBPACK_IMPORTED_MODULE_28__.NinjaStarStyle),
/* harmony export */   PillarStyle: () => (/* reexport safe */ _style_PillarStyle_js__WEBPACK_IMPORTED_MODULE_18__.PillarStyle),
/* harmony export */   SegmentOrientationLegend: () => (/* reexport safe */ _legend_SegmentOrientationLegend_js__WEBPACK_IMPORTED_MODULE_40__.SegmentOrientationLegend),
/* harmony export */   SegmentStyle: () => (/* reexport safe */ _style_SegmentStyle_js__WEBPACK_IMPORTED_MODULE_16__.SegmentStyle),
/* harmony export */   SegmentWidthLegend: () => (/* reexport safe */ _legend_SegmentWidthLegend_js__WEBPACK_IMPORTED_MODULE_39__.SegmentWidthLegend),
/* harmony export */   ShapeColorSizeStyle: () => (/* reexport safe */ _style_ShapeColorSizeStyle_js__WEBPACK_IMPORTED_MODULE_10__.ShapeColorSizeStyle),
/* harmony export */   ShapeColorSizeStyle_: () => (/* reexport safe */ _style_ShapeColorSizeStyle_js__WEBPACK_IMPORTED_MODULE_11__.ShapeColorSizeStyle_),
/* harmony export */   SideCatStyle: () => (/* reexport safe */ _style_SideCatStyle_js__WEBPACK_IMPORTED_MODULE_21__.SideCatStyle),
/* harmony export */   SideStyle: () => (/* reexport safe */ _style_SideStyle_js__WEBPACK_IMPORTED_MODULE_19__.SideStyle),
/* harmony export */   SizeLegend: () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_38__.SizeLegend),
/* harmony export */   SquareColorCatWGLStyle: () => (/* reexport safe */ _style_SquareColorCatWGLStyle_js__WEBPACK_IMPORTED_MODULE_26__.SquareColorCatWGLStyle),
/* harmony export */   SquareColorWGLStyle: () => (/* reexport safe */ _style_SquareColorWGLStyle_js__WEBPACK_IMPORTED_MODULE_25__.SquareColorWGLStyle),
/* harmony export */   StrokeStyle: () => (/* reexport safe */ _style_StrokeStyle_js__WEBPACK_IMPORTED_MODULE_12__.StrokeStyle),
/* harmony export */   Style: () => (/* reexport safe */ _Style_js__WEBPACK_IMPORTED_MODULE_2__.Style),
/* harmony export */   TanakaStyle: () => (/* reexport safe */ _style_TanakaStyle_js__WEBPACK_IMPORTED_MODULE_23__.TanakaStyle),
/* harmony export */   TextStyle: () => (/* reexport safe */ _style_TextStyle_js__WEBPACK_IMPORTED_MODULE_17__.TextStyle),
/* harmony export */   TiledGrid: () => (/* reexport safe */ _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__.TiledGrid),
/* harmony export */   TimeSeriesStyle: () => (/* reexport safe */ _style_TimeSeriesStyle_js__WEBPACK_IMPORTED_MODULE_29__.TimeSeriesStyle),
/* harmony export */   circularInverseScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.circularInverseScale),
/* harmony export */   circularScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.circularScale),
/* harmony export */   exponentialScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.exponentialScale),
/* harmony export */   getClass: () => (/* reexport safe */ _utils_Utils_js__WEBPACK_IMPORTED_MODULE_42__.getClass),
/* harmony export */   getParameterByName: () => (/* binding */ getParameterByName),
/* harmony export */   logarithmicScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.logarithmicScale),
/* harmony export */   powerInverseScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.powerInverseScale),
/* harmony export */   powerScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.powerScale),
/* harmony export */   sCircleHigh: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.sCircleHigh),
/* harmony export */   sCircleLow: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.sCircleLow),
/* harmony export */   sExp: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.sExp),
/* harmony export */   sExpInverse: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.sExpInverse),
/* harmony export */   sExpRev: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.sExpRev),
/* harmony export */   sExpRevInverse: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.sExpRevInverse),
/* harmony export */   sPow: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.sPow),
/* harmony export */   sPowInverse: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.sPowInverse),
/* harmony export */   sPowRev: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.sPowRev),
/* harmony export */   sPowRevInverse: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__.sPowRevInverse)
/* harmony export */ });
/* harmony import */ var _App_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.js */ "./node_modules/gridviz/src/App.js");
/* harmony import */ var _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeoCanvas.js */ "./node_modules/gridviz/src/GeoCanvas.js");
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Style.js */ "./node_modules/gridviz/src/Style.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/gridviz/src/Layer.js");
/* harmony import */ var _Dataset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Dataset.js */ "./node_modules/gridviz/src/Dataset.js");
/* harmony import */ var _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DatasetComponent.js */ "./node_modules/gridviz/src/DatasetComponent.js");
/* harmony import */ var _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dataset/TiledGrid.js */ "./node_modules/gridviz/src/dataset/TiledGrid.js");
/* harmony import */ var _dataset_GridTile_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataset/GridTile.js */ "./node_modules/gridviz/src/dataset/GridTile.js");
/* harmony import */ var _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dataset/CSVGrid.js */ "./node_modules/gridviz/src/dataset/CSVGrid.js");
/* harmony import */ var _dataset_LGrid_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dataset/LGrid.js */ "./node_modules/gridviz/src/dataset/LGrid.js");
/* harmony import */ var _style_ShapeColorSizeStyle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style/ShapeColorSizeStyle.js */ "./node_modules/gridviz/src/style/ShapeColorSizeStyle.js");
/* harmony import */ var _style_ShapeColorSizeStyle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./style/ShapeColorSizeStyle_.js */ "./node_modules/gridviz/src/style/ShapeColorSizeStyle_.js");
/* harmony import */ var _style_StrokeStyle_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./style/StrokeStyle.js */ "./node_modules/gridviz/src/style/StrokeStyle.js");
/* harmony import */ var _style_JoyPlotStyle_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./style/JoyPlotStyle.js */ "./node_modules/gridviz/src/style/JoyPlotStyle.js");
/* harmony import */ var _style_CompositionStyle_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./style/CompositionStyle.js */ "./node_modules/gridviz/src/style/CompositionStyle.js");
/* harmony import */ var _style_CompositionStyle_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./style/CompositionStyle_.js */ "./node_modules/gridviz/src/style/CompositionStyle_.js");
/* harmony import */ var _style_SegmentStyle_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./style/SegmentStyle.js */ "./node_modules/gridviz/src/style/SegmentStyle.js");
/* harmony import */ var _style_TextStyle_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./style/TextStyle.js */ "./node_modules/gridviz/src/style/TextStyle.js");
/* harmony import */ var _style_PillarStyle_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./style/PillarStyle.js */ "./node_modules/gridviz/src/style/PillarStyle.js");
/* harmony import */ var _style_SideStyle_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style/SideStyle.js */ "./node_modules/gridviz/src/style/SideStyle.js");
/* harmony import */ var _style_ContourStyle_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./style/ContourStyle.js */ "./node_modules/gridviz/src/style/ContourStyle.js");
/* harmony import */ var _style_SideCatStyle_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./style/SideCatStyle.js */ "./node_modules/gridviz/src/style/SideCatStyle.js");
/* harmony import */ var _style_DotDensityStyle_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./style/DotDensityStyle.js */ "./node_modules/gridviz/src/style/DotDensityStyle.js");
/* harmony import */ var _style_TanakaStyle_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./style/TanakaStyle.js */ "./node_modules/gridviz/src/style/TanakaStyle.js");
/* harmony import */ var _style_LegoStyle_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./style/LegoStyle.js */ "./node_modules/gridviz/src/style/LegoStyle.js");
/* harmony import */ var _style_SquareColorWGLStyle_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./style/SquareColorWGLStyle.js */ "./node_modules/gridviz/src/style/SquareColorWGLStyle.js");
/* harmony import */ var _style_SquareColorCatWGLStyle_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./style/SquareColorCatWGLStyle.js */ "./node_modules/gridviz/src/style/SquareColorCatWGLStyle.js");
/* harmony import */ var _style_MosaicStyle_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./style/MosaicStyle.js */ "./node_modules/gridviz/src/style/MosaicStyle.js");
/* harmony import */ var _style_NinjaStarStyle_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./style/NinjaStarStyle.js */ "./node_modules/gridviz/src/style/NinjaStarStyle.js");
/* harmony import */ var _style_TimeSeriesStyle_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./style/TimeSeriesStyle.js */ "./node_modules/gridviz/src/style/TimeSeriesStyle.js");
/* harmony import */ var _style_IsoFenceStyle_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./style/IsoFenceStyle.js */ "./node_modules/gridviz/src/style/IsoFenceStyle.js");
/* harmony import */ var _BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./BackgroundLayer.js */ "./node_modules/gridviz/src/BackgroundLayer.js");
/* harmony import */ var _BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./BackgroundLayerWMS.js */ "./node_modules/gridviz/src/BackgroundLayerWMS.js");
/* harmony import */ var _LabelLayer_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./LabelLayer.js */ "./node_modules/gridviz/src/LabelLayer.js");
/* harmony import */ var _LineLayer_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./LineLayer.js */ "./node_modules/gridviz/src/LineLayer.js");
/* harmony import */ var _legend_ColorLegend_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./legend/ColorLegend.js */ "./node_modules/gridviz/src/legend/ColorLegend.js");
/* harmony import */ var _legend_ColorDiscreteLegend_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./legend/ColorDiscreteLegend.js */ "./node_modules/gridviz/src/legend/ColorDiscreteLegend.js");
/* harmony import */ var _legend_ColorCategoryLegend_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./legend/ColorCategoryLegend.js */ "./node_modules/gridviz/src/legend/ColorCategoryLegend.js");
/* harmony import */ var _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./legend/SizeLegend.js */ "./node_modules/gridviz/src/legend/SizeLegend.js");
/* harmony import */ var _legend_SegmentWidthLegend_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./legend/SegmentWidthLegend.js */ "./node_modules/gridviz/src/legend/SegmentWidthLegend.js");
/* harmony import */ var _legend_SegmentOrientationLegend_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./legend/SegmentOrientationLegend.js */ "./node_modules/gridviz/src/legend/SegmentOrientationLegend.js");
/* harmony import */ var _utils_stretching_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./utils/stretching.js */ "./node_modules/gridviz/src/utils/stretching.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./utils/Utils.js */ "./node_modules/gridviz/src/utils/Utils.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
//@ts-check


// the application







// export dataset types




//export { GeoTIFF } from "./dataset/GeoTIFF"

// export styles






















// export additional layers





// export legends







// export { goToStraight, zoomTo } from "./utils/zoomUtils"






;
const getParameterByName = _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__.GeoCanvas.getParameterByName

// set default d3 locale
;
(0,d3_format__WEBPACK_IMPORTED_MODULE_43__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})


/***/ }),

/***/ "./node_modules/gridviz/src/legend/ColorCategoryLegend.js":
/*!****************************************************************!*\
  !*** ./node_modules/gridviz/src/legend/ColorCategoryLegend.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorCategoryLegend: () => (/* binding */ ColorCategoryLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./node_modules/gridviz/src/Legend.js");
//@ts-check


;

/**
 * A legend element for color categrories.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class ColorCategoryLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //col/categories array, in display order
        /**
         * @private
         * @type {Array.<Array.<string>>} */
        this.colCat = opts.colCat || [['gray', '-']]

        /**
         * @private
         * @type {import("../Style").Shape} */
        this.shape = opts.shape || 'circle'
        this.dimension = opts.dimension || { r: 8 }
        this.strokeColor = opts.strokeColor || 'gray'
        this.strokeWidth = opts.strokeWidth || 1

        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
    }

    /**
     * @param {{ style: import("../Style").Style, r: number, zf: number, sSize: import("../Style").Stat, sColor: import("../Style").Stat }} opts
     */
    update(opts) {
        //clear
        this.div.selectAll('*').remove()

        //build

        //title
        if (this.title)
            this.div
                .append('div')
                .style('font-size', this.titleFontSize)
                .style('font-weight', this.titleFontWeight)
                .style('margin-bottom', '7px')
                .text(this.title)

        //categories
        const nb = this.colCat.length
        if (nb == 0) return

        for (let i = 0; i < nb; i++) {
            const cat = this.colCat[i]

            //make div for category
            const d = this.div.append('div')
            //to enable vertical centering
            //.style("position", "relative")

            const sw = this.strokeWidth

            //draw graphic element: box / circle
            if (this.shape === 'square') {
                const h = this.dimension.h || 15
                const w = this.dimension.w || 20
                d.append('div')
                    .style('display', 'inline')

                    .append('svg')
                    .attr('width', w + 2 * sw)
                    .attr('height', h + 2 * sw)

                    .append('rect')
                    .attr('x', sw)
                    .attr('y', sw)
                    .attr('width', w)
                    .attr('height', h)
                    .style('fill', cat[0])
                    .style('stroke', this.strokeColor)
                    .style('stroke-width', this.strokeWidth)
            } else if (this.shape === 'circle') {
                const r = this.dimension.r || 8
                const h = 2 * r + 2 * sw
                d.append('div')
                    .style('display', 'inline')

                    .append('svg')
                    .attr('width', h)
                    .attr('height', h)

                    .append('circle')
                    .attr('cx', r + sw)
                    .attr('cy', r + sw)
                    .attr('r', r)
                    .style('fill', cat[0])
                    .style('stroke', this.strokeColor)
                    .style('stroke-width', this.strokeWidth)
            } else {
                throw new Error('Unexpected shape:' + this.shape)
            }

            //write label text
            d.append('div')
                //show on right of graphic
                .style('display', 'inline')

                //center vertically
                //.style("position", "absolute").style("top", "0").style("bottom", "0")

                .style('padding-left', '5px')
                .style('font-size', this.labelFontSize)
                .text(cat[1])
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/legend/ColorDiscreteLegend.js":
/*!****************************************************************!*\
  !*** ./node_modules/gridviz/src/legend/ColorDiscreteLegend.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorDiscreteLegend: () => (/* binding */ ColorDiscreteLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./node_modules/gridviz/src/Legend.js");
//@ts-check


;

/**
 * A legend element for discrete color style.
 * Inspiration: https://observablehq.com/@d3/color-legend
 *
 * @author Julien Gaffuri
 */
class ColorDiscreteLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** @private @type {Array.<Array.<string>>} */
        this.colors = opts.colors
        /** @private @type {Array.<Array.<string>>} */
        this.breaksText = opts.breaksText

        this.width = opts.width || 300
        this.height = opts.height || 15

        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        this.tickSize = opts.tickSize || 3

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
        this.invert = opts.invert
    }

    /**
     * @param {{ style: import("../Style").Style, r: number, zf: number, sSize: import("../Style").Stat, sColor: import("../Style").Stat }} opts
     */
    update(opts) {
        //clear
        this.div.selectAll('*').remove()

        //build

        //title
        if (this.title)
            this.div
                .append('div')
                .style('font-size', this.titleFontSize)
                .style('font-weight', this.titleFontWeight)
                .style('margin-bottom', '7px')
                .text(this.title)

        //classes
        const nb = this.colors.length
        if (nb == 0) return
        const w = this.width / nb

        //make svg element
        const svg = this.div
            .append('svg')
            .attr('width', this.width)
            .attr('height', this.height + this.tickSize + 2 + 10)

        //draw graphic elements
        for (let i = 0; i < nb; i++) {
            svg.append('rect')
                .attr('x', i * w)
                .attr('y', 0)
                .attr('width', w)
                .attr('height', this.height)
                .style('fill', this.colors[i])
        }

        //tick line
        for (let i = 1; i < nb; i++) {
            svg.append('line')
                .attr('x1', w * i)
                .attr('y1', 0)
                .attr('x2', w * i)
                .attr('y2', this.height + this.tickSize)
                .style('stroke', 'black')
        }

        //labels
        for (let i = 1; i < nb; i++) {
            //prepare label
            svg.append('text')
                .attr('id', 'ticklabel_' + i)
                .attr('x', w * i)
                .attr('y', this.height + this.tickSize + 2)
                .style('font-size', this.labelFontSize)
                //.style("font-weight", "bold")
                //.style("font-family", "Arial")
                .style('text-anchor', i == 0 ? 'start' : i == this.ticks - 1 ? 'end' : 'middle')
                .style('alignment-baseline', 'top')
                .style('dominant-baseline', 'hanging')
                .style('pointer-events', 'none')
                .text(this.breaksText[i - 1])
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/legend/ColorLegend.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/legend/ColorLegend.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorLegend: () => (/* binding */ ColorLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./node_modules/gridviz/src/Legend.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
//@ts-check


;


/**
 * A legend element for continuous color style.
 * Inspiration: https://observablehq.com/@d3/color-legend
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class ColorLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        this.colorRamp = opts.colorRamp

        //function (t[0,1], r, s) -> v (for label text)
        this.fun = opts.fun

        this.title = opts.title
        this.tickSize = opts.tickSize || 6
        this.width = opts.width || 300
        this.height = opts.height || 15
        this.margin = opts.margin || 5
        this.ticks = opts.ticks || Math.floor(this.width / 50)
        this.tickFormat = opts.tickFormat || ',.0f'
        this.tickUnit = opts.tickUnit

        this.fontSize = opts.fontSize || '0.8em'
        this.invert = opts.invert

        //to be used as opts => opts.sAlpha to show legend on alpha channel
        this.getStats = opts.getStats || (opts => opts.sColor)
    }

    /**
     * @param {{ style: import("../Style").Style, r: number, zf: number, sSize: import("../Style").Stat, sColor: import("../Style").Stat, sAlpha: import("../Style").Stat }} opts
     */
    update(opts) {
        //could happen when data is still loading
        if (!opts.sColor) return

        //clear
        this.div.selectAll('*').remove()

        const titleHeight = 12

        const svgW = this.width + 2 * this.margin
        const svgH = this.height + 3 * this.margin + titleHeight + this.tickSize + 10
        const svg = this.div.append('svg').attr('width', svgW).attr('height', svgH)
        //  <rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />

        //title
        svg.append('text')
            .attr('x', this.margin)
            .attr('y', this.margin)
            .style('font-size', '0.8em')
            .style('font-weight', 'bold')
            .style('alignment-baseline', 'top')
            .style('dominant-baseline', 'hanging')
            .style('pointer-events', 'none')
            .text(this.title)

        const g = svg
            .append('g')
            .attr('transform', 'translate(' + this.margin + ' ' + (2 * this.margin + titleHeight) + ')')

        //draw color bar
        const w = this.width,
            h = this.height
        const step = 5
        for (let i = 0; i < w; i += step) {
            let t = i / (w - 1)
            if (this.invert) t = 1 - t
            g.append('rect')
                .attr('x', i)
                .attr('y', 0)
                .attr('width', step)
                .attr('height', h)
                .style('fill', this.colorRamp(t))
        }

        for (let i = 0; i < this.ticks; i++) {
            let t = i / (this.ticks - 1)

            //tick line
            g.append('line')
                .attr('x1', w * t)
                .attr('y1', 0)
                .attr('x2', w * t)
                .attr('y2', h + this.tickSize)
                .style('stroke', 'black')

            //prepare tick label
            g.append('text')
                .attr('id', 'ticklabel_' + i)
                .attr('x', w * t)
                .attr('y', h + this.tickSize + 2)
                .style('font-size', this.fontSize)
                //.style("font-weight", "bold")
                //.style("font-family", "Arial")
                .style('text-anchor', i == 0 ? 'start' : i == this.ticks - 1 ? 'end' : 'middle')
                .style('alignment-baseline', 'top')
                .style('dominant-baseline', 'hanging')
                .style('pointer-events', 'none')
            //.text("-")
        }

        //update tick labels

        //label text format
        const f = this.tickFormat && this.tickFormat != 'text' ? (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.format)(this.tickFormat) : (v) => v
        const stat = this.getStats(opts)
        for (let i = 0; i < this.ticks; i++) {
            let t = i / (this.ticks - 1)

            const v = this.fun(t, opts.r, stat)
            const text = (v ? f(v) : '0') + (this.tickUnit ? this.tickUnit : '')

            //tick label
            this.div.select('#' + 'ticklabel_' + i).text(text)
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/legend/SegmentOrientationLegend.js":
/*!*********************************************************************!*\
  !*** ./node_modules/gridviz/src/legend/SegmentOrientationLegend.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SegmentOrientationLegend: () => (/* binding */ SegmentOrientationLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./node_modules/gridviz/src/Legend.js");
//@ts-check


;

/**
 * A legend element for segment orientation.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class SegmentOrientationLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //title
        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        //exageration
        this.exaggerationFactor = opts.exaggerationFactor || 0.5

        //color
        this.color = opts.color || 'gray'
        //orientation
        this.orientation = opts.orientation || 0
        //width
        this.widthPix = opts.widthPix || 3

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
        this.labelUnitText = opts.labelUnitText || ''
    }

    /**
     * @param {{ style: import("../style/SegmentStyle").SegmentStyle, r: number, zf: number, sColor: import("../Style").Stat, sLength: import("../Style").Stat, sWidth: import("../Style").Stat }} opts
     */
    update(opts) {
        //could happen when data is still loading
        if (!opts.sWidth) return

        //clear
        this.div.selectAll('*').remove()

        const d = this.div.append('div')

        //title
        if (this.title) {
            d.append('div')
                .attr('class', 'title')
                .style('font-size', this.titleFontSize)
                .style('font-weight', this.titleFontWeight)
                .text(this.title)
        }

        //compute segment width and length, in pix
        const sWidth = this.widthPix
        const sLength = (1 * opts.r) / opts.zf

        //draw SVG segment
        const svgS = Math.max(sLength, sWidth)
        const svg = d.append('svg').attr('width', svgS).attr('height', svgS).style('', 'inline-block')

        const cos = Math.cos((-this.orientation * Math.PI) / 180)
        const sin = Math.sin((-this.orientation * Math.PI) / 180)
        const dc = svgS * 0.5,
            l2 = sLength * 0.5
        svg.append('line')
            .attr('x1', dc - cos * l2)
            .attr('y1', dc - sin * l2)
            .attr('x2', dc + cos * l2)
            .attr('y2', dc + sin * l2)
            .style('stroke', this.color)
            .style('stroke-width', sWidth)

        //text label
        d.append('div')
            //show on right of svg
            .style('display', 'inline')
            .style('padding-left', '5px')
            .style('font-size', this.labelFontSize)
            //.style("font-weight", "bold")
            .text(this.labelUnitText)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/legend/SegmentWidthLegend.js":
/*!***************************************************************!*\
  !*** ./node_modules/gridviz/src/legend/SegmentWidthLegend.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SegmentWidthLegend: () => (/* binding */ SegmentWidthLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./node_modules/gridviz/src/Legend.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
//@ts-check


;


/**
 * A legend element for segment width.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class SegmentWidthLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //title
        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        //exageration
        //if set to 1, the segment width in the legend will be the one of the maximum width on the map
        this.exaggerationFactor = opts.exaggerationFactor || 0.5

        //color of the segment in the legend
        this.color = opts.color || 'gray'
        //orientation of the segment in the legend
        this.orientation = opts.orientation || 0

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
        this.labelUnitText = opts.labelUnitText || ''

        //segment length in geo unit - a function of the resolution r and zoom level zf
        this.lengthFun = opts.lengthExaggerationFactor || ((r, zf) => r)
    }

    /**
     * @param {{ style: import("../style/SegmentStyle").SegmentStyle, r: number, zf: number, sColor: import("../Style").Stat, sLength: import("../Style").Stat, sWidth: import("../Style").Stat }} opts
     */
    update(opts) {
        //could happen when data is still loading
        if (!opts.sWidth) return

        //clear
        this.div.selectAll('*').remove()

        const d = this.div.append('div')

        //title
        if (this.title) {
            d.append('div')
                .attr('class', 'title')
                .style('font-size', this.titleFontSize)
                .style('font-weight', this.titleFontWeight)
                .text(this.title)
        }

        //get segment max value
        const value_ = opts.sWidth.max * this.exaggerationFactor
        //make 'nice' value (power of ten, or multiple)
        let pow10 = Math.log10(value_)
        pow10 = Math.floor(pow10)
        let value = Math.pow(10, pow10)
        if (value * 8 <= value_) value *= 8
        else if (value * 6 <= value_) value *= 6
        else if (value * 5 <= value_) value *= 5
        else if (value * 4 <= value_) value *= 4
        else if (value * 2.5 <= value_) value *= 2.5
        else if (value * 2 <= value_) value *= 2
        else if (value * 1.5 <= value_) value *= 1.5

        //compute segment width and length, in pix
        const sWidth = opts.widthFun(value, opts.r, opts.sWidth, opts.zf) / opts.zf
        const sLength = this.lengthFun(opts.r, opts.zf) / opts.zf

        //TODO use orientation

        const svg = d.append('svg').attr('width', sLength).attr('height', sWidth).style('', 'inline-block')

        //<line x1="0" y1="0" x2="200" y2="200" style="stroke:rgb(255,0,0);stroke-width:2" />
        svg.append('line')
            .attr('x1', 0)
            .attr('y1', sWidth / 2)
            .attr('x2', sLength)
            .attr('y2', sWidth / 2)
            .style('stroke', this.color)
            .style('stroke-width', sWidth)

        const valueT = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.format)(',.2r')(value)
        d.append('div')
            //show on right of graphic
            .style('display', 'inline')
            .style('padding-left', '5px')
            .style('font-size', this.labelFontSize)
            //.style("font-weight", "bold")
            .text(valueT + (this.labelUnitText ? ' ' : '') + this.labelUnitText)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/legend/SizeLegend.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/legend/SizeLegend.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SizeLegend: () => (/* binding */ SizeLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./node_modules/gridviz/src/Legend.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
//@ts-check


;


/**
 * A legend element for proportional symbols.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class SizeLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //exageration
        this.exaggerationFactor = opts.exaggerationFactor || 0.8

        //if value is to be forced
        this.value = opts.value || undefined

        //title
        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        //symbol
        /**
         * @private
         * @type {import("../Style").Shape} */
        this.shape = opts.shape || 'circle'
        this.fillColor = opts.fillColor || 'none'
        this.strokeColor = opts.strokeColor || 'gray'
        this.strokeWidth = opts.strokeWidth || 1

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
        this.labelUnitText = opts.labelUnitText || ''
        this.labelFormat = opts.labelFormat || ',.2r'

        //
        //this.div.style("text-align", "center")
    }

    /**
     * @param {{ style: import("../style/ShapeColorSizeStyle").ShapeColorSizeStyle, r: number, zf: number, sSize: import("../Style").Stat, sColor: import("../Style").Stat }} opts
     */
    update(opts) {
        //could happen when data is still loading
        if (!opts.sSize) return

        //clear
        this.div.selectAll('*').remove()

        //get value
        let value = this.value
        if (value == undefined) {
            //compute 'nice value

            //get max value
            const value_ = opts.sSize.max * this.exaggerationFactor

            //take 'nice' value (power of ten, or multiple)
            let pow10 = Math.log10(value_)
            pow10 = Math.floor(pow10)
            value = Math.pow(10, pow10)
            if (value * 8 <= value_) value *= 8
            else if (value * 6 <= value_) value *= 6
            else if (value * 5 <= value_) value *= 5
            else if (value * 4 <= value_) value *= 4
            else if (value * 2.5 <= value_) value *= 2.5
            else if (value * 2 <= value_) value *= 2
        }

        if (!value) return

        const d = this.div.append('div')
        //to enable vertical centering
        //.style("position", "relative")

        //title
        if (this.title) {
            d.append('div')
                .attr('class', 'title')
                .style('font-size', this.titleFontSize)
                .style('font-weight', this.titleFontWeight)
                .text(this.title)
        }

        //compute size of symbol, in pix
        const size = opts.style.size(value, opts.r, opts.sSize, opts.zf) / opts.zf

        const svg = d
            .append('svg')
            .attr('width', size + this.strokeWidth + 2)
            .attr('height', size + this.strokeWidth + 2)
            .style('', 'inline-block')

        if (this.shape === 'square') {
            svg.append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', size)
                .attr('height', size)
                .style('fill', this.fillColor)
                .style('stroke', this.strokeColor)
                .style('stroke-width', this.strokeWidth)
            //TODO test
        } else if (this.shape === 'circle') {
            // <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
            const r = (size + this.strokeWidth) * 0.5
            svg.append('circle')
                .attr('cx', r + 1)
                .attr('cy', r + 1)
                .attr('r', r)
                .style('fill', this.fillColor)
                .style('stroke', this.strokeColor)
                .style('stroke-width', this.strokeWidth)
        } else if (this.shape === 'donut') {
            //TODO
        } else if (this.shape === 'diamond') {
            //TODO
        } else {
            throw new Error('Unexpected shape:' + this.shape)
        }

        const valueT = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.format)(this.labelFormat)(value)
        d.append('div')
            //show on right of graphic
            .style('display', 'inline')

            //center vertically
            //.style("position", "absolute").style("top", "0").style("bottom", "0")

            .style('padding-left', '5px')
            .style('font-size', this.labelFontSize)
            .text(valueT + (this.labelUnitText ? ' ' : '') + this.labelUnitText)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/CompositionStyle.js":
/*!************************************************************!*\
  !*** ./node_modules/gridviz/src/style/CompositionStyle.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompositionStyle: () => (/* binding */ CompositionStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/** @typedef {"flag"|"piechart"|"ring"|"segment"|"radar"|"agepyramid"|"halftone"} CompositionType */

/**
 * A style showing the composition of a total in different categories, with different color hues.
 * It consists of a symbol with different parts, whose size reflect the proportion of the corresponding category.
 * For a list of supported symbols, @see CompositionType
 * The symbol can be scaled depending on the cell importance.
 *
 * @author Julien Gaffuri
 */
class CompositionStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

        /**
         * A function returning the type of decomposition symbol of a cell, @see CompositionType
         * @type {function(import("../Dataset").Cell):CompositionType} */
        this.type = opts.type

        /** The column where to get the size values.
         * @type {string} */
        this.sizeCol = opts.sizeCol

        /** A function returning the size of a cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.size = opts.size || ((v, r, s, zf) => r)

        /** For style types with stripes (flag, segment), the orientation of the stripes (0 for horizontal, other for vertical).
         * @type {function(import("../Dataset").Cell,number,number):number} */
        this.stripesOrientation = opts.stripesOrientation || (() => 0) //(c,r,zf) => ...

        /** The function specifying an offset angle for a radar, halftone or pie chart style.
         * The angle is specified in degree. The rotation is anti-clockwise.
         * @type {function(import("../Dataset").Cell,number,number):number} */
        this.offsetAngle = opts.offsetAngle || (() => 0) //(cell,r,zf) => ...

        /** The function specifying the height of the age pyramid, in geo unit.
         * @type {function(import("../Dataset").Cell,number,number):number} */
        this.agePyramidHeight = opts.agePyramidHeight || ((c, r, zf) => r) //(cell,r,zf) => ...

        /** For pie chart, this is parameter for internal radius, so that the pie chart looks like a donut.
         * 0 for normal pie charts, 0.5 to empty half of the radius.
         * @type {number} */
        this.pieChartInternalRadiusFactor = opts.pieChartInternalRadiusFactor || 0
    }

    /**
     * Draw cells as squares depending on their value.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let stat
        if (this.sizeCol) {
            //if size is used, sort cells by size so that the biggest are drawn first
            cells.sort((c1, c2) => c2[this.sizeCol] - c1[this.sizeCol])
            //and compute statistics
            stat = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.sizeCol], true)
        }

        //nb categories - used for radar and agepyramid
        const nbCat = Object.entries(this.color).length

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw calls
        for (let cell of cells) {
            //size
            /** @type {function(number,number,import("../Style").Stat|undefined,number):number} */
            let s_ = this.size || (() => r)
            //size - in geo
            /** @type {number} */
            const sG = s_(cell[this.sizeCol], r, stat, zf)

            //get offset
            const offset = this.offset(cell, r, zf)

            //get symbol type
            const type_ = this.type ? this.type(cell) : 'flag'

            //compute center position
            const xc = cell.x + offset.dx + (type_ === 'agepyramid' ? 0 : r * 0.5)
            const yc = cell.y + offset.dy + (type_ === 'agepyramid' ? 0 : r * 0.5)

            //compute offset angle, when relevant
            const offAng = this.offsetAngle ? (this.offsetAngle(cell, r, zf) * Math.PI) / 180 : 0

            if (type_ === 'agepyramid' || type_ === 'radar' || type_ === 'halftone') {
                //get cell category max value
                let maxVal = -Infinity
                for (let key of Object.keys(this.color)) {
                    const v = +cell[key]
                    if (v > maxVal) maxVal = v
                }

                //cumul
                let cumul = 0
                if (type_ === 'agepyramid' && this.agePyramidHeight)
                    cumul = (r - this.agePyramidHeight(cell, r, zf)) / 2
                if (type_ === 'radar' || type_ === 'halftone') cumul = Math.PI / 2 + offAng

                //compute the increment, which is the value to increment the cumul for each category
                const incr =
                    type_ === 'agepyramid'
                        ? (this.agePyramidHeight ? this.agePyramidHeight(cell, r, zf) : r) / nbCat
                        : type_ === 'radar' || type_ === 'halftone'
                        ? (2 * Math.PI) / nbCat
                        : undefined
                if (incr === undefined) throw new Error('Unexpected symbol type:' + type_)

                for (let [column, color] of Object.entries(this.color)) {
                    if (type_ === 'agepyramid') {
                        //set category color
                        cg.ctx.fillStyle = color

                        //get category value
                        const val = cell[column]

                        //compute category length - in geo
                        /** @type {number} */
                        const wG = (sG * val) / maxVal

                        //draw bar
                        cg.ctx.fillRect(xc + (r - wG) / 2, yc + cumul, wG, incr)

                        //next height
                        cumul += incr
                    } else if (type_ === 'radar') {
                        //set category color
                        cg.ctx.fillStyle = color

                        //get categroy value
                        const val = cell[column]

                        //compute category radius - in geo
                        /** @type {number} */
                        //const rG = this.radius(val, r, stat, cellStat, zf)
                        const rG = (sG / 2) * Math.sqrt(val / maxVal)

                        //draw angular sector
                        cg.ctx.beginPath()
                        cg.ctx.moveTo(xc, yc)
                        cg.ctx.arc(xc, yc, rG, cumul - incr, cumul)
                        cg.ctx.lineTo(xc, yc)
                        cg.ctx.fill()

                        //next angular sector
                        cumul += incr
                    } else if (type_ === 'halftone') {
                        //set category color
                        cg.ctx.fillStyle = color

                        //get categroy value
                        const val = cell[column]

                        //compute category radius - in geo
                        /** @type {number} */
                        const rG = sG * 0.333 * Math.sqrt(val / maxVal)

                        //draw circle
                        cg.ctx.beginPath()
                        cg.ctx.arc(
                            xc + r * 0.25 * Math.cos(cumul),
                            yc + r * 0.25 * Math.sin(cumul),
                            rG,
                            0,
                            2 * Math.PI
                        )
                        cg.ctx.fill()

                        //next angular sector
                        cumul += incr
                    } else {
                        throw new Error('Unexpected symbol type:' + type_)
                    }
                }
            } else {
                //compute total
                let total = 0
                for (let column of Object.keys(this.color)) {
                    const v = +cell[column]
                    if (!v) continue
                    total += v
                }
                if (!total || isNaN(total)) continue

                //draw decomposition symbol
                let cumul = 0
                const d = r * (1 - sG / r) * 0.5
                const ori = this.stripesOrientation(cell, r, zf)

                for (let [column, color] of Object.entries(this.color)) {
                    //get share
                    const share = cell[column] / total
                    if (!share || isNaN(share)) continue

                    //set color
                    cg.ctx.fillStyle = color

                    //draw symbol part
                    if (type_ === 'flag') {
                        //draw flag stripe
                        if (ori == 0) {
                            //horizontal
                            cg.ctx.fillRect(
                                cell.x + d + offset.dx,
                                cell.y + d + cumul * sG + offset.dy,
                                sG,
                                share * sG
                            )
                        } else {
                            //vertical
                            cg.ctx.fillRect(
                                cell.x + d + cumul * sG + offset.dx,
                                cell.y + d + offset.dy,
                                share * sG,
                                sG
                            )
                        }
                    } else if (type_ === 'piechart') {
                        //draw pie chart angular sector

                        //compute angles
                        const a1 = cumul * 2 * Math.PI
                        const a2 = (cumul + share) * 2 * Math.PI

                        //draw
                        cg.ctx.beginPath()
                        cg.ctx.moveTo(xc, yc)
                        cg.ctx.arc(xc, yc, sG * 0.5, a1 + offAng, a2 + offAng)
                        if (this.pieChartInternalRadiusFactor)
                            cg.ctx.arc(
                                xc,
                                yc,
                                sG * 0.5 * this.pieChartInternalRadiusFactor,
                                a1 + offAng,
                                a2 + offAng,
                                true
                            )
                        cg.ctx.closePath()
                        cg.ctx.fill()
                    } else if (type_ === 'ring') {
                        //draw ring
                        cg.ctx.beginPath()
                        cg.ctx.arc(xc, yc, Math.sqrt(1 - cumul) * sG * 0.5, 0, 2 * Math.PI)
                        cg.ctx.fill()
                    } else if (type_ === 'segment') {
                        //draw segment sections
                        const wG = (sG * sG) / r
                        if (ori == 0) {
                            //horizontal
                            cg.ctx.fillRect(
                                cell.x + offset.dx,
                                cell.y + (r - wG) / 2 + cumul * wG + offset.dy,
                                r,
                                share * wG
                            )
                        } else {
                            //vertical
                            cg.ctx.fillRect(
                                cell.x + cumul * r + offset.dx,
                                cell.y + (r - wG) / 2 + offset.dy,
                                share * r,
                                wG
                            )
                        }
                    } else {
                        throw new Error('Unexpected symbol type:' + type_)
                    }

                    cumul += share
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sSize: stat })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/CompositionStyle_.js":
/*!*************************************************************!*\
  !*** ./node_modules/gridviz/src/style/CompositionStyle_.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompositionStyle_: () => (/* binding */ CompositionStyle_)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/** @typedef {"flag"|"piechart"|"ring"|"segment"|"radar"|"agepyramid"|"halftone"} CompositionType */

/**
 * A style showing the composition of a total in different categories, with different color hues.
 * It consists of a symbol with different parts, whose size reflect the proportion of the corresponding category.
 * For a list of supported symbols, @see CompositionType
 * The symbol can be scaled depending on the cell importance.
 *
 * @author Julien Gaffuri
 */
class CompositionStyle_ extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the view scale.
         * @type {function(Array.<import('../Dataset.js').Cell>,number, number):object} */
        this.viewScale = opts.viewScale

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

        /**
         * A function returning the type of decomposition symbol of a cell, @see CompositionType
         * @type {function(import("../Dataset.js").Cell,number, number,object):CompositionType} */
        this.type = opts.type

        /** A function returning the size of a cell in geographical unit.
         * @type {function(import('../Dataset.js').Cell,number, number,object):number} */
        this.size = opts.size

        /** For style types with stripes (flag, segment), the orientation of the stripes (0 for horizontal, other for vertical).
         * @type {function(import("../Dataset.js").Cell,number,number,object):number} */
        this.stripesOrientation = opts.stripesOrientation || (() => 0) //(c,r,zf,vc) => ...

        /** The function specifying an offset angle for a radar, halftone or pie chart style.
         * The angle is specified in degree. The rotation is anti-clockwise.
         * @type {function(import("../Dataset.js").Cell,number,number,object):number} */
        this.offsetAngle = opts.offsetAngle || (() => 0) //(cell,r,zf,vc) => ...

        /** The function specifying the height of the age pyramid, in geo unit.
         * @type {function(import("../Dataset.js").Cell,number,number,object):number} */
        this.agePyramidHeight = opts.agePyramidHeight || ((c, r, zf) => r) //(cell,r,zf,vc) => ...

        /** For pie chart, this is parameter for internal radius, so that the pie chart looks like a donut.
         * 0 for normal pie charts, 0.5 to empty half of the radius.
         * @type {number} */
        this.pieChartInternalRadiusFactor = opts.pieChartInternalRadiusFactor || 0
    }

    /**
     * Draw cells as squares depending on their value.
     *
     * @param {Array.<import("../Dataset.js").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas.js").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        //get view scale
        const vc = this.viewScale ? this.viewScale(cells, r, zf) : undefined

        //nb categories - used for radar and agepyramid
        const nbCat = Object.entries(this.color).length

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw calls
        for (let cell of cells) {

            //size
            const sG = this.size ? this.size(cell, r, zf, vc) : r
            if (!sG) continue

            //get offset
            const offset = this.offset(cell, r, zf)

            //get symbol type
            const type_ = this.type ? this.type(cell, r, zf, vc) : 'flag'

            //compute center position
            const xc = cell.x + offset.dx + (type_ === 'agepyramid' ? 0 : r * 0.5)
            const yc = cell.y + offset.dy + (type_ === 'agepyramid' ? 0 : r * 0.5)

            //compute offset angle, when relevant
            const offAng = this.offsetAngle ? (this.offsetAngle(cell, r, zf, vc) * Math.PI) / 180 : 0

            if (type_ === 'agepyramid' || type_ === 'radar' || type_ === 'halftone') {
                //get cell category max value
                let maxVal = -Infinity
                for (let key of Object.keys(this.color)) {
                    const v = +cell[key]
                    if (v > maxVal) maxVal = v
                }

                //cumul
                let cumul = 0
                if (type_ === 'agepyramid' && this.agePyramidHeight)
                    cumul = (r - this.agePyramidHeight(cell, r, zf, vc)) / 2
                if (type_ === 'radar' || type_ === 'halftone') cumul = Math.PI / 2 + offAng

                //compute the increment, which is the value to increment the cumul for each category
                const incr =
                    type_ === 'agepyramid'
                        ? (this.agePyramidHeight ? this.agePyramidHeight(cell, r, zf, vc) : r) / nbCat
                        : type_ === 'radar' || type_ === 'halftone'
                            ? (2 * Math.PI) / nbCat
                            : undefined
                if (incr === undefined) throw new Error('Unexpected symbol type:' + type_)

                for (let [column, color] of Object.entries(this.color)) {
                    if (type_ === 'agepyramid') {
                        //set category color
                        cg.ctx.fillStyle = color

                        //get category value
                        const val = cell[column]

                        //compute category length - in geo
                        /** @type {number} */
                        const wG = (sG * val) / maxVal

                        //draw bar
                        cg.ctx.fillRect(xc + (r - wG) / 2, yc + cumul, wG, incr)

                        //next height
                        cumul += incr
                    } else if (type_ === 'radar') {
                        //set category color
                        cg.ctx.fillStyle = color

                        //get categroy value
                        const val = cell[column]

                        //compute category radius - in geo
                        /** @type {number} */
                        //const rG = this.radius(val, r, stat, cellStat, zf)
                        const rG = (sG / 2) * Math.sqrt(val / maxVal)

                        //draw angular sector
                        cg.ctx.beginPath()
                        cg.ctx.moveTo(xc, yc)
                        cg.ctx.arc(xc, yc, rG, cumul - incr, cumul)
                        cg.ctx.lineTo(xc, yc)
                        cg.ctx.fill()

                        //next angular sector
                        cumul += incr
                    } else if (type_ === 'halftone') {
                        //set category color
                        cg.ctx.fillStyle = color

                        //get categroy value
                        const val = cell[column]

                        //compute category radius - in geo
                        /** @type {number} */
                        const rG = sG * 0.333 * Math.sqrt(val / maxVal)

                        //draw circle
                        cg.ctx.beginPath()
                        cg.ctx.arc(
                            xc + r * 0.25 * Math.cos(cumul),
                            yc + r * 0.25 * Math.sin(cumul),
                            rG,
                            0,
                            2 * Math.PI
                        )
                        cg.ctx.fill()

                        //next angular sector
                        cumul += incr
                    } else {
                        throw new Error('Unexpected symbol type:' + type_)
                    }
                }
            } else {
                //compute total
                let total = 0
                for (let column of Object.keys(this.color)) {
                    const v = +cell[column]
                    if (!v) continue
                    total += v
                }
                if (!total || isNaN(total)) continue

                //draw decomposition symbol
                let cumul = 0
                const d = r * (1 - sG / r) * 0.5
                const ori = this.stripesOrientation(cell, r, zf, vc)

                for (let [column, color] of Object.entries(this.color)) {
                    //get share
                    const share = cell[column] / total
                    if (!share || isNaN(share)) continue

                    //set color
                    cg.ctx.fillStyle = color

                    //draw symbol part
                    if (type_ === 'flag') {
                        //draw flag stripe
                        if (ori == 0) {
                            //horizontal
                            cg.ctx.fillRect(
                                cell.x + d + offset.dx,
                                cell.y + d + cumul * sG + offset.dy,
                                sG,
                                share * sG
                            )
                        } else {
                            //vertical
                            cg.ctx.fillRect(
                                cell.x + d + cumul * sG + offset.dx,
                                cell.y + d + offset.dy,
                                share * sG,
                                sG
                            )
                        }
                    } else if (type_ === 'piechart') {
                        //draw pie chart angular sector

                        //compute angles
                        const a1 = cumul * 2 * Math.PI
                        const a2 = (cumul + share) * 2 * Math.PI

                        //draw
                        cg.ctx.beginPath()
                        cg.ctx.moveTo(xc, yc)
                        cg.ctx.arc(xc, yc, sG * 0.5, a1 + offAng, a2 + offAng)
                        if (this.pieChartInternalRadiusFactor)
                            cg.ctx.arc(
                                xc,
                                yc,
                                sG * 0.5 * this.pieChartInternalRadiusFactor,
                                a1 + offAng,
                                a2 + offAng,
                                true
                            )
                        cg.ctx.closePath()
                        cg.ctx.fill()
                    } else if (type_ === 'ring') {
                        //draw ring
                        cg.ctx.beginPath()
                        cg.ctx.arc(xc, yc, Math.sqrt(1 - cumul) * sG * 0.5, 0, 2 * Math.PI)
                        cg.ctx.fill()
                    } else if (type_ === 'segment') {
                        //draw segment sections
                        const wG = (sG * sG) / r
                        if (ori == 0) {
                            //horizontal
                            cg.ctx.fillRect(
                                cell.x + offset.dx,
                                cell.y + (r - wG) / 2 + cumul * wG + offset.dy,
                                r,
                                share * wG
                            )
                        } else {
                            //vertical
                            cg.ctx.fillRect(
                                cell.x + cumul * r + offset.dx,
                                cell.y + (r - wG) / 2 + offset.dy,
                                share * r,
                                wG
                            )
                        }
                    } else {
                        throw new Error('Unexpected symbol type:' + type_)
                    }

                    cumul += share
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, viewScale: vc })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/ContourStyle.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/style/ContourStyle.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContourStyle: () => (/* binding */ ContourStyle)
/* harmony export */ });
/* harmony import */ var _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SideStyle.js */ "./node_modules/gridviz/src/style/SideStyle.js");
//@ts-check


;

/** @typedef {{x:number,y:number,or:"v"|"h",value:number}} Side */

/**
 *
 * @author Julien Gaffuri
 */
class ContourStyle extends _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__.SideStyle {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** @type {number} */
        //opts.interval = opts.interval || 100

        /** @type {Array.<number>} */
        opts.breaks = opts.breaks || [100, 1000, 10000, 100000, 1000000]

        /** @type {function(Side,number,number):string} */
        opts.width = opts.width || (() => 1) //(s, r, zf) => ...

        /** @type {function(Side,number,number):string} */
        opts.color = opts.color || (() => '#E7A935') //(s, r, zf) => ...

        //override method for contour drawing

        const getClass = function (v) {
            if (v == undefined) return 0
            for (let i = 0; i < opts.breaks.length; i++) if (v < opts.breaks[i]) return i
            return opts.breaks.length
        }

        this.value = (v1, v2, r, s, zf) => {
            //if (!v1 || !v2) return 0
            return Math.abs(getClass(v2) - getClass(v1))

            //check if v1 - v2 cross a contour line
            //const r1 = Math.floor(v1 / opts.interval);
            //const r2 = Math.floor(v2 / opts.interval);
            //return Math.abs(r2 - r1);
        }

        //same color for all
        this.color = (side, r, s, zf) => (side.value ? opts.color(side, r, zf) : undefined)

        //width: multiple of
        this.width = (side, r, s, zf) => side.value * zf * opts.width(side, r, zf)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/DotDensityStyle.js":
/*!***********************************************************!*\
  !*** ./node_modules/gridviz/src/style/DotDensityStyle.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DotDensityStyle: () => (/* binding */ DotDensityStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
/* harmony import */ var d3_random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-random */ "./node_modules/d3-random/src/normal.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoring_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/WebGLSquareColoring.js */ "./node_modules/gridviz/src/utils/WebGLSquareColoring.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Utils.js */ "./node_modules/gridviz/src/utils/Utils.js");
//@ts-check


;






/**
 *
 * @author Julien Gaffuri
 */
class DotDensityStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for dot number.
         * @type {string} */
        this.nbCol = opts.nbCol

        /** A function returning the number of dots for a cell value.
         * @type {function(number,number,import("../Style").Stat,number):number} */
        this.nb = opts.nb || ((v, r, s, zf) => (((0.3 * r * r) / (zf * zf)) * v) / s.max)

        /** The color of the dots. Same color for all dots within a cell.
         * @type {function(import("../Dataset").Cell):string} */
        this.color = opts.color || (() => '#FF5733')

        /** A function returning the size of the dots, in geo unit.
         * @type {function(number,number):number} */
        this.dotSize = opts.dotSize //|| ((r, zf) => ...

        /** A function returning the sigma of the distribution from the resolution, in geo unit.
         * @type {function(number,number):number} */
        this.sigma = opts.sigma //|| ((r,zf) => ...
    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** DotDensityStyle draw')

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let stat
        if (this.nbCol) stat = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.nbCol], true)
        if (!stat) return

        //size of the dots
        const sGeo = this.dotSize ? this.dotSize(r, zf) : 2 * zf

        //make random function
        const sig = this.sigma ? this.sigma(r, zf) : r * 0.4
        const rand = (0,d3_random__WEBPACK_IMPORTED_MODULE_4__["default"])(0, sig)

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)(' preparation')

        if ((0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.checkWebGLSupport)()) {
            //create canvas and webgl renderer
            const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeWebGLCanvas)(cg.w + '', cg.h + '')
            if (!cvWGL) {
                console.error('No webGL')
                return
            }

            //create webGL program
            const prog = new _utils_WebGLSquareColoring_js__WEBPACK_IMPORTED_MODULE_2__.WebGLSquareColoring(cvWGL.gl, sGeo / zf)

            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)(' webgl creation')

            const r2 = r / 2

            let col, offset, nb, cx, cy, cc
            for (let c of cells) {
                //get color
                col = this.color(c)
                if (!col || col === 'none') continue

                //get offset
                offset = this.offset(c, r, zf)

                //number of dots
                nb = this.nb(c[this.nbCol], r, stat, zf)

                //cell center
                cx = c.x + offset.dx + r2
                cy = c.y + offset.dy + r2

                //convert color
                cc = (0,d3_color__WEBPACK_IMPORTED_MODULE_5__["default"])(col)
                if (!cc) return

                //random points
                for (let i = 0; i <= nb; i++)
                    prog.addPointData2(cx + rand(), cy + rand(), cc.r, cc.g, cc.b, cc.opacity)
            }

            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)(' data preparation')

            //draw
            prog.draw(cg.getWebGLTransform())

            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)(' webgl drawing')

            //draw in canvas geo
            cg.initCanvasTransform()
            cg.ctx.drawImage(cvWGL.canvas, 0, 0)

            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)(' canvas drawing')
        } else {
            //draw with HTML canvas

            //draw in geo coordinates
            cg.setCanvasTransform()

            for (let c of cells) {
                //get color
                const col = this.color(c)
                if (!col || col === 'none') continue
                //set color
                cg.ctx.fillStyle = col

                //get offset
                const offset = this.offset(c, r, zf)

                //number of dots
                const nb = this.nb(c[this.nbCol], r, stat, zf)

                //draw random dots
                const cx = c.x + offset.dx + r / 2,
                    cy = c.y + offset.dy + r / 2
                for (let i = 0; i <= nb; i++) {
                    cg.ctx.fillRect(cx + rand(), cy + rand(), sGeo, sGeo)
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf })

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** DotDensityStyle end draw')
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/IsoFenceStyle.js":
/*!*********************************************************!*\
  !*** ./node_modules/gridviz/src/style/IsoFenceStyle.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IsoFenceStyle: () => (/* binding */ IsoFenceStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/** @typedef {{x:number,y:number,or:"v"|"h",c1:import('../Dataset.js').Cell|undefined,c2:import('../Dataset.js').Cell|undefined}} Side */

/**
 * @author Julien Gaffuri
 */
class IsoFenceStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {

    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

        /** The column where to get the height values.
         * @type {string} */
        this.heightCol = opts.heightCol

        /** A function returning the height of a cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.height = opts.height || ((v, r, s, zf) => r * 0.4)

        /** The perspective angle, in degree, within [-180,180], from [O,x] axis.
         * @type {number} */
        this.angle = opts.angle != undefined ? opts.angle : 50

        /** A function returning the corner line stroke style.
         * @type {function(import('../Dataset.js').Cell,number,number,number):string} */
        this.cornerLineStrokeColor = opts.cornerLineStrokeColor || ((c, r, zf, angle) => "#999")

        /** A function returning the corner line width.
        * @type {function(import('../Dataset.js').Cell,number,number,number):number} */
        this.cornerLineWidth = opts.cornerLineWidth || ((c, r, zf, angle) => (angle % 90 == 0 ? 0 : 0.8 * zf))

        /**
        * Show vertical cross-sections.
        * @type {boolean} */
        this.sVert = opts.sVert != undefined ? opts.sVert : true

        /**
        * Show horizontal cross-sections.
        * @type {boolean} */
        this.sHor = opts.sHor != undefined ? opts.sHor : true
    }

    /**
     * Draw cells as segments.
     *
     * @param {Array.<import("../Dataset.js").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas.js").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let stat
        if (this.heightCol) {
            //if size is used, sort cells by size so that the biggest are drawn first
            cells.sort((c1, c2) => c2[this.heightCol] - c1[this.heightCol])
            //and compute statistics
            stat = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.heightCol], true)
        }

        //nb categories - used for radar and agepyramid
        const cats = Object.keys(this.color)

        //half resolution
        const r2 = r / 2

        //get offset
        // @ts-ignore
        const offset = this.offset(undefined, r, zf), dx = offset.dx, dy = offset.dy

        //height
        /** @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        let h_ = this.height

        //make sides
        /**  @type {Array.<Side>} */
        const sides = []

        //make horizontal sides - except when angle%180=0
        //sort cells by x and y
        if (this.angle % 180 != 90 && this.sVert) {
            cells.sort((c1, c2) => (c2.x == c1.x ? c1.y - c2.y : c1.x - c2.x))
            let c1 = cells[0]
            for (let i = 1; i < cells.length; i++) {
                let c2 = cells[i]

                if ((c1.y + r == c2.y) && (c1.x == c2.x))
                    //cells in same column and touch along horizontal side
                    //make shared side
                    sides.push({ x: c1.x + r2, y: c2.y, or: 'h', c1: c1, c2: c2 })
                else {
                    //cells do not touch along horizontal side
                    //make two sides: top one for c1, bottom for c2
                    sides.push({ x: c1.x + r2, y: c1.y + r, or: 'h', c1: c1, c2: undefined })
                    sides.push({ x: c2.x + r2, y: c2.y, or: 'h', c1: undefined, c2: c2 })
                }

                c1 = c2
            }
        }

        //make vertical sides - except when angle%180=90
        //sort cells by y and x
        if (this.angle % 180 != 0 && this.sHor) {
            cells.sort((c1, c2) => (c2.y == c1.y ? c1.x - c2.x : c1.y - c2.y))
            let c1 = cells[0]
            for (let i = 1; i < cells.length; i++) {
                let c2 = cells[i]

                if ((c1.x + r == c2.x) && (c1.y == c2.y))
                    //cells in same row and touch along vertical side
                    //make shared side
                    sides.push({ x: c2.x, y: c1.y + r2, or: 'v', c1: c1, c2: c2 })
                else {
                    //cells do not touch along vertical side
                    //make two sides: right one for c1, left for c2
                    sides.push({ x: c1.x + r, y: c1.y + r2, or: 'v', c1: c1, c2: undefined })
                    sides.push({ x: c2.x, y: c2.y + r2, or: 'v', c1: undefined, c2: c2 })
                }

                c1 = c2
            }
        }

        //
        if (sides.length == 0) return

        //angle in radians
        const aRad = this.angle * Math.PI / 180, cos = Math.cos(aRad), sin = Math.sin(aRad)

        //sort sides so that the back ones are drawn first. This depends on the angle.
        //depending on distance to the reference corner point
        const xCorner = Math.abs(this.angle) < 90 ? cg.extGeo.xMin : cg.extGeo.xMax
        const yCorner = this.angle < 0 ? cg.extGeo.yMax : cg.extGeo.yMin
        sides.sort((s1, s2) => (Math.hypot(s2.x - xCorner, s2.y - yCorner) - Math.hypot(s1.x - xCorner, s1.y - yCorner)))

        //prepare function to draw corner line for a cell *c*
        const drawCornerLine = (c) => {

            if (!c) return
            //line style
            const lw = this.cornerLineWidth ? this.cornerLineWidth(c, r, zf, this.angle) : 0.8 * zf
            if (lw == 0) return
            cg.ctx.strokeStyle = this.cornerLineStrokeColor ? this.cornerLineStrokeColor(c, r, zf, this.angle) : "#333"
            cg.ctx.lineWidth = lw

            //height - in geo
            const hG = h_(c[this.heightCol], r, stat, zf)

            //draw line
            cg.ctx.beginPath()
            cg.ctx.moveTo(c.x + r2 + dx, c.y + r2 + dy)
            cg.ctx.lineTo(c.x + r2 + hG * cos + dx, c.y + r2 + hG * sin + dy)
            cg.ctx.stroke()
        }

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw sides
        cg.ctx.lineCap = "round";
        for (let s of sides) {

            //heights - in geo
            const hG1 = s.c1 ? h_(s.c1[this.heightCol], r, stat, zf) : 0,
                hG2 = s.c2 ? h_(s.c2[this.heightCol], r, stat, zf) : 0

            //compute totals for both cells
            const total1 = computeTotal(s.c1, cats),
                total2 = computeTotal(s.c2, cats)
            if (total1 == 0 && total2 == 0) continue

            let cumul1 = 0, cumul2 = 0
            for (let [column, color] of Object.entries(this.color)) {
                //draw stripe of side s and category column

                //get values for both cells
                let v1 = s.c1 ? +s.c1[column] : 0
                let v2 = s.c2 ? +s.c2[column] : 0
                if (v1 == 0 && v2 == 0) continue

                //compute heights
                const h1 = hG1 * cumul1 / total1 || 0
                const h1n = hG1 * (cumul1 + v1) / total1 || 0
                const h2 = hG2 * cumul2 / total2 || 0
                const h2n = hG2 * (cumul2 + v2) / total2 || 0

                //make path
                cg.ctx.beginPath()
                if (s.or == "h") {
                    //horizontal side - vertical section
                    //bottom left
                    cg.ctx.moveTo(s.x + h1 * cos + dx, s.y - r2 + h1 * sin + dy)
                    //top left
                    cg.ctx.lineTo(s.x + h2 * cos + dx, s.y + r2 + h2 * sin + dy)
                    //top right
                    cg.ctx.lineTo(s.x + h2n * cos + dx, s.y + r2 + h2n * sin + dy)
                    //bottom right
                    cg.ctx.lineTo(s.x + h1n * cos + dx, s.y - r2 + h1n * sin + dy)
                } else {
                    //vertical side - horizontal section
                    //bottom left
                    cg.ctx.moveTo(s.x - r2 + h1 * cos + dx, s.y + h1 * sin + dy)
                    //bottom right
                    cg.ctx.lineTo(s.x + r2 + h2 * cos + dx, s.y + h2 * sin + dy)
                    //top right
                    cg.ctx.lineTo(s.x + r2 + h2n * cos + dx, s.y + h2n * sin + dy)
                    //top left
                    cg.ctx.lineTo(s.x - r2 + h1n * cos + dx, s.y + h1n * sin + dy)
                }
                //cg.ctx.closePath()

                //fill
                cg.ctx.fillStyle = color
                cg.ctx.fill()

                cumul1 += v1
                cumul2 += v2

                //TODO draw only one line
                //draw corner line
                //if (s.or == "h") {
                drawCornerLine(s.c1)
                drawCornerLine(s.c2)
                //if (this.angle > 0 && s.or == "h") drawCornerLine(s.c2)
                //else drawCornerLine(s.c2)
                //}
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sSize: stat })
    }
}



const computeTotal = (cell, categories) => {
    if (!cell) return 0
    let total = 0
    for (let column of categories) {
        const v = cell[column]
        if (!v) continue
        total += +v
    }
    return total || 0
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/JoyPlotStyle.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/style/JoyPlotStyle.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JoyPlotStyle: () => (/* binding */ JoyPlotStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/**
 *
 * @author Julien Gaffuri
 */
class JoyPlotStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The cell column where to get the value to represent.
         * @type {string} */
        this.heightCol = opts.heightCol

        /** A function returning the height of a cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.height = opts.height || ((v) => Math.sqrt(v))

        /**
         * @type {function(number,{min:number, max:number},number,number):string} */
        this.lineColor = opts.lineColor || ((y, ys, r, zf) => '#BBB')
        /**
         * @type {function(number,{min:number, max:number},number,number):number} */
        this.lineWidth = opts.lineWidth || ((y, ys, r, zf) => zf)
        /**
         * @type {function(number,{min:number, max:number},number,number):string} */
        this.fillColor = opts.fillColor || ((y, ys, r, zf) => '#c08c5968')
    }

    /**
     * Draw cells as squares depending on their value.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     * */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        cg.ctx.lineJoin = 'round'

        //zoom factor
        const zf = cg.getZf()

        //compute statistics
        const stat = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.heightCol], true)

        //index cells by y and x
        /**  @type {object} */
        const ind = {}
        for (const cell of cells) {
            let row = ind[cell.y]
            if (!row) {
                row = {}
                ind[cell.y] = row
            }
            row[cell.x] = this.height(cell[this.heightCol], r, stat, zf)
        }

        //compute extent
        const e = cg.extGeo
        if (!e) return
        const xMin = Math.floor(e.xMin / r) * r
        const xMax = Math.floor(e.xMax / r) * r
        const yMin = Math.floor(e.yMin / r) * r
        const yMax = Math.floor(e.yMax / r) * r

        /**  @type {{min:number, max:number}} */
        const ys = { min: yMin, max: yMax }

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw lines, row by row, stating from the top
        for (let y = yMax; y >= yMin; y -= r) {
            //get row
            const row = ind[y]

            //no row
            if (!row) continue

            //place first point
            cg.ctx.beginPath()
            cg.ctx.moveTo(xMin - r / 2, y)

            //store the previous height
            /** @type {number|undefined} */
            let hG_

            //go through the line cells
            for (let x = xMin; x <= xMax; x += r) {
                //get column value
                /** @type {number} */
                let hG = row[x]
                if (!hG) hG = 0

                if (hG || hG_) {
                    //draw line only when at least one of both values is non-null
                    //TODO test bezierCurveTo
                    cg.ctx.lineTo(x + r / 2, y + hG)
                } else {
                    //else move the point
                    cg.ctx.moveTo(x + r / 2, y)
                }
                //store the previous value
                hG_ = hG
            }

            //last point
            if (hG_) cg.ctx.lineTo(xMax + r / 2, y)

            //draw fill
            const fc = this.fillColor(y, ys, r, zf)
            if (fc && fc != 'none') {
                cg.ctx.fillStyle = fc
                cg.ctx.fill()
            }

            //draw line
            const lc = this.lineColor(y, ys, r, zf)
            const lw = this.lineWidth(y, ys, r, zf)
            if (lc && lc != 'none' && lw > 0) {
                cg.ctx.strokeStyle = lc
                cg.ctx.lineWidth = lw
                cg.ctx.stroke()
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/LegoStyle.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridviz/src/style/LegoStyle.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LegoStyle: () => (/* binding */ LegoStyle)
/* harmony export */ });
/* harmony import */ var _TanakaStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TanakaStyle.js */ "./node_modules/gridviz/src/style/TanakaStyle.js");
/* harmony import */ var _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StrokeStyle.js */ "./node_modules/gridviz/src/style/StrokeStyle.js");
/* harmony import */ var _SquareColorCatWGLStyle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SquareColorCatWGLStyle.js */ "./node_modules/gridviz/src/style/SquareColorCatWGLStyle.js");
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;




/**
 * @author Julien Gaffuri
 */
class LegoStyle {
    /**
     * @param {string} col
     * @param {object} opts
     * @returns {Array.<Style>}
     */
    static get(col, opts) {
        opts = opts || {}

        //the colors
        //http://www.jennyscrayoncollection.com/2021/06/all-current-lego-colors.html
        //https://leonawicz.github.io/legocolors/reference/figures/README-plot-1.png
        opts.colors = opts.colors || [
            '#00852b', //darker green
            '#afd246', //light green
            '#fac80a', //dark yellow
            '#bb805a', //brown
            '#d67923', //mostard
            '#cb4e29', //redish
            '#b40000', //red
            '#720012', //dark red
            //"purple",
            //"#eee" //whithe
        ]

        opts.colDark = opts.colDark || '#333'
        opts.colBright = opts.colBright || '#aaa'
        opts.widthFactor = opts.widthFactor || 0.12

        //reuse tanaka as basis
        const ts = _TanakaStyle_js__WEBPACK_IMPORTED_MODULE_0__.TanakaStyle.get(col, opts)
        //style to show limits between pieces
        const sst = new _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__.StrokeStyle({
            strokeColor: () => '#666',
            strokeWidth: (v, r, s, z) => 0.2 * z,
            filter: opts.filter,
        })

        return [
            ts[0],
            sst,
            ts[1],
            new LegoTopStyle({ colDark: opts.colDark, colBright: opts.colBright, filter: opts.filter }),
        ]
    }

    /**
     * @param {function(string):string} col
     * @param {object} opts
     * @returns {Array.<Style>}
     */
    static getCat(col, opts) {
        opts = opts || {}

        opts.colDark = opts.colDark || '#333'
        opts.colBright = opts.colBright || '#aaa'

        //
        const s = new _SquareColorCatWGLStyle_js__WEBPACK_IMPORTED_MODULE_2__.SquareColorCatWGLStyle({ colorCol: col, color: opts.color })
        //style to show limits between pieces
        const sst = new _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__.StrokeStyle({ strokeColor: () => '#666', strokeWidth: (v, r, s, z) => 0.2 * z })

        return [s, sst, new LegoTopStyle({ colDark: opts.colDark, colBright: opts.colBright })]
    }
}

/**
 * A style to draw top circle of lego bricks.
 */
class LegoTopStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_3__.Style {
    /** @param {object|undefined} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}
        this.colDark = opts.colDark || '#333'
        this.colBright = opts.colBright || '#aaa'
    }

    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        cg.ctx.lineWidth = 0.6 * cg.getZf()

        //dark part
        cg.ctx.strokeStyle = this.colDark
        for (let c of cells) {
            cg.ctx.beginPath()
            cg.ctx.arc(c.x + r * 0.5, c.y + r * 0.5, r * 0.55 * 0.5, Math.PI / 4, -Math.PI * (3 / 4), true)
            cg.ctx.stroke()
        }

        //bright part
        cg.ctx.strokeStyle = this.colBright
        for (let c of cells) {
            cg.ctx.beginPath()
            cg.ctx.arc(c.x + r * 0.5, c.y + r * 0.5, r * 0.55 * 0.5, Math.PI / 4, -Math.PI * (3 / 4), false)
            cg.ctx.stroke()
        }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/MosaicStyle.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/style/MosaicStyle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MosaicStyle: () => (/* binding */ MosaicStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/**
 * @author Julien Gaffuri
 */
class MosaicStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell.
         * @type {function(number,number,import("../Style").Stat|undefined):string} */
        this.color = opts.color || (() => '#EA6BAC')

        /** The mosaic factor, within [0,0.5]. Set to 0 for no mosaic effect. Set to 0.5 for strong mosaic effect.
         * @type {number} */
        this.mosaicFactor = opts.mosaicFactor || 0.15

        /** The mosaic shadow factor, within [0,0.5]. Set to 0 for no mosaic shadow. Set to 0.5 for strong mosaic shadow.
         * @type {number} */
        this.shadowFactor = opts.shadowFactor || 0.2

        /** The mosaic shadow color.
         * @type {string} */
        this.shadowColor = opts.shadowColor || '#555'
    }

    /**
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} resolution
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, resolution, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        //set stroke style, for shadow
        cg.ctx.strokeStyle = this.shadowColor
        cg.ctx.lineWidth = this.shadowFactor * resolution
        cg.ctx.lineJoin = 'round'
        cg.ctx.lineCap = 'butt'

        //function to compute position mosaic effect
        const d = resolution * this.mosaicFactor
        const mosaic = () => {
            return { x: Math.random() * d, y: Math.random() * d }
        }

        //draw with HTML canvas in geo coordinates
        cg.setCanvasTransform()

        for (let cell of cells) {
            //set fill color
            const col = this.color ? this.color(cell[this.colorCol], resolution, statColor) : undefined
            if (!col || col === 'none') continue
            cg.ctx.fillStyle = col

            //get offset
            const offset = this.offset(cell, resolution, zf)

            //compute position mosaic effect
            const ll = mosaic(),
                ul = mosaic(),
                lr = mosaic(),
                ur = mosaic()

            //stroke
            if (this.shadowFactor > 0) {
                cg.ctx.beginPath()
                cg.ctx.moveTo(cell.x + offset.dx + ll.x, cell.y + offset.dy + ll.y)
                cg.ctx.lineTo(cell.x + offset.dx + resolution - lr.x, cell.y + offset.dy + lr.y)
                cg.ctx.lineTo(cell.x + offset.dx + resolution - ur.x, cell.y + offset.dy + resolution - ur.y)
                cg.ctx.stroke()
            }

            //fill

            cg.ctx.beginPath()
            cg.ctx.moveTo(cell.x + offset.dx + ll.x, cell.y + offset.dy + ll.y)
            cg.ctx.lineTo(cell.x + offset.dx + resolution - lr.x, cell.y + offset.dy + lr.y)
            cg.ctx.lineTo(cell.x + offset.dx + resolution - ur.x, cell.y + offset.dy + resolution - ur.y)
            cg.ctx.lineTo(cell.x + offset.dx + ul.x, cell.y + offset.dy + resolution - ul.y)
            cg.ctx.fill()
        }

        //update legends
        this.updateLegends({ style: this, r: resolution, zf: zf, sColor: statColor })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/NinjaStarStyle.js":
/*!**********************************************************!*\
  !*** ./node_modules/gridviz/src/style/NinjaStarStyle.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NinjaStarStyle: () => (/* binding */ NinjaStarStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/**
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class NinjaStarStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):string} */
        this.color = opts.color || (() => '#EA6BAC') //(v,r,s,zf) => {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for size.
         * @type {string} */
        this.sizeCol = opts.sizeCol

        /** A function returning the size of a cell, within [0,1]:
         *  - 0, nothing shown
         *  - 1, entire square
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.size = opts.size

        /** A function returning the shape.
         * @type {function(import("../Dataset").Cell):string} */
        this.shape = opts.shape || (() => 'o')
    }

    /**
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statSize
        if (this.sizeCol) {
            //if size is used, sort cells by size so that the biggest are drawn first
            cells.sort((c1, c2) => c2[this.sizeCol] - c1[this.sizeCol])
            //and compute size variable statistics
            statSize = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.sizeCol], true)
        }

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        //draw with HTML canvas
        //in geo coordinates
        cg.setCanvasTransform()

        const r2 = r * 0.5
        for (let cell of cells) {
            //color
            const col = this.color ? this.color(cell[this.colorCol], r, statColor, zf) : undefined
            if (!col || col === 'none') continue
            cg.ctx.fillStyle = col

            //shape
            const shape = this.shape ? this.shape(cell) : 'o'
            if (shape === 'none') continue

            //size
            /** @type {function(number,number,import("../Style").Stat|undefined,number):number} */
            let s_ = this.size || (() => 0.5)
            //size - in geo unit
            const sG2 = s_(cell[this.sizeCol], r, statSize, zf) * r2

            //get offset
            //TODO use
            //const offset = this.offset(cell, r, zf)

            //center position
            const cx = cell.x + r2
            const cy = cell.y + r2

            if (shape === 'p') {
                cg.ctx.beginPath()
                cg.ctx.moveTo(cx, cy + r2)
                cg.ctx.lineTo(cx + sG2, cy + sG2)
                cg.ctx.lineTo(cx + r2, cy)
                cg.ctx.lineTo(cx + sG2, cy - sG2)
                cg.ctx.lineTo(cx, cy - r2)
                cg.ctx.lineTo(cx - sG2, cy - sG2)
                cg.ctx.lineTo(cx - r2, cy)
                cg.ctx.lineTo(cx - sG2, cy + sG2)
                cg.ctx.fill()
            } else if (shape === 'o') {
                cg.ctx.beginPath()
                cg.ctx.moveTo(cx, cy + sG2)
                cg.ctx.lineTo(cx + r2, cy + r2)
                cg.ctx.lineTo(cx + sG2, cy)
                cg.ctx.lineTo(cx + r2, cy - r2)
                cg.ctx.lineTo(cx, cy - sG2)
                cg.ctx.lineTo(cx - r2, cy - r2)
                cg.ctx.lineTo(cx - sG2, cy)
                cg.ctx.lineTo(cx - r2, cy + r2)
                cg.ctx.fill()
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sSize: statSize, sColor: statColor })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/PillarStyle.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/style/PillarStyle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PillarStyle: () => (/* binding */ PillarStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/**
 * @author Julien Gaffuri
 */
class PillarStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    //TODO make a webGL version ?

    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** @type {string} */
        this.heightCol = opts.heightCol

        /** A function returning the height of the line representing a cell, in geo unit
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.height = opts.height

        /** @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the line representing a cell.
         * @type {function(number,number,import("../Style").Stat|undefined):string} */
        this.color = opts.color || (() => '#c08c59') //bb

        /** @type {string} */
        this.widthCol = opts.widthCol

        /** A function returning the width of the line representing a cell, in geo unit
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.width = opts.width || ((v, r) => 0.5 * r)

        /** @type {boolean} */
        this.simple = opts.simple == true

        /** @type {number} */
        this.viewHeightFactor = opts.viewHeightFactor || 1.5
        //0,0 is the center
        /** @type {number} */
        this.viewSX = opts.viewSX == undefined ? 0 : opts.viewSX
        /** @type {number} */
        this.viewSY = opts.viewSY == undefined ? -0.5 : opts.viewSY

        //TODO replace with sun location ?
        /** @type {number} */
        this.shadowDirection =
            opts.shadowDirection == undefined ? (-40.3 * Math.PI) / 180.0 : opts.shadowDirection
        /** @type {number} */
        this.shadowFactor = opts.shadowFactor || 0.3
        /** @type {string} */
        this.shadowColor = opts.shadowColor || '#00000033'

        /** @type {string} */
        this.outlineCol = opts.outlineCol || '#FFFFFF'
        /** @type {number} */
        this.outlineWidthPix = opts.outlineWidthPix == undefined ? 0.5 : opts.outlineWidthPix
    }

    /**
     * Draw cells as segments.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statHeight
        if (this.heightCol) {
            //compute size variable statistics
            statHeight = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.heightCol], true)
        }

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        let statWidth
        if (this.widthCol) {
            //and compute size variable statistics
            statWidth = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.widthCol], true)
        }

        //get view center geo position
        const cvx = cg.getCenter().x + this.viewSX * cg.w * zf
        const cvy = cg.getCenter().y + this.viewSY * cg.h * zf
        //get view height
        const H = this.viewHeightFactor * (cg.w + cg.h) * 0.5 * zf

        //sort cells by y and x
        //const distToViewCenter = (c) => { const dx = cvx - c.x, dy = cvy - c.y; return Math.sqrt(dx * dx + dy * dy) }
        cells.sort((c1, c2) => 100000000 * (c2.y - c1.y) + c1.x - c2.x)

        cg.ctx.lineCap = this.simple ? 'butt' : 'round'

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw shadows
        cg.ctx.strokeStyle = this.shadowColor
        cg.ctx.fillStyle = this.shadowColor
        for (let c of cells) {
            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(c[this.widthCol], r, statWidth, zf) : undefined
            if (!wG || wG < 0) continue

            //height
            /** @type {number|undefined} */
            const hG = this.height ? this.height(c[this.heightCol], r, statHeight, zf) : undefined
            if (!hG || hG < 0) continue

            //get offset
            //TODO use that
            const offset = this.offset(c, r, zf)

            //set width
            cg.ctx.lineWidth = wG

            //compute cell centre postition
            const cx = c.x + r / 2
            const cy = c.y + r / 2
            const ls = hG * this.shadowFactor

            //draw segment
            cg.ctx.beginPath()
            cg.ctx.moveTo(cx, cy)
            cg.ctx.lineTo(cx + ls * Math.cos(this.shadowDirection), cy + ls * Math.sin(this.shadowDirection))
            cg.ctx.stroke()

            /*
            if (this.simple) {
                //draw base circle
                cg.ctx.beginPath();
                cg.ctx.arc(
                    cx, cy,
                    wG * 0.5,
                    0, 2 * Math.PI, false);
                //cg.ctx.stroke();
                cg.ctx.fill();
            }*/
        }

        //draw pillars
        for (let c of cells) {
            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(c[this.colorCol], r, statColor) : undefined
            if (!col) continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(c[this.widthCol], r, statWidth, zf) : undefined
            if (!wG || wG < 0) continue

            //height
            /** @type {number|undefined} */
            const hG = this.height ? this.height(c[this.heightCol], r, statHeight, zf) : undefined
            if (!hG || hG < 0) continue

            //get offset
            //TODO use that
            const offset = this.offset(c, r, zf)

            //compute cell centre postition
            const cx = c.x + r / 2
            const cy = c.y + r / 2

            //compute angle
            const dx = cx - cvx,
                dy = cy - cvy
            const a = Math.atan2(dy, dx)
            const D = Math.sqrt(dx * dx + dy * dy)
            const d = (D * hG) / (H - hG)

            if (this.simple) {
                //draw segment
                cg.ctx.strokeStyle = col
                cg.ctx.lineWidth = wG
                cg.ctx.beginPath()
                cg.ctx.moveTo(cx, cy)
                cg.ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                cg.ctx.stroke()
            } else {
                //draw background segment
                cg.ctx.strokeStyle = this.outlineCol
                cg.ctx.lineWidth = wG + 2 * this.outlineWidthPix * zf
                cg.ctx.beginPath()
                cg.ctx.moveTo(cx, cy)
                cg.ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                cg.ctx.stroke()

                //draw segment
                cg.ctx.strokeStyle = col
                cg.ctx.lineWidth = wG
                cg.ctx.beginPath()
                cg.ctx.moveTo(cx, cy)
                cg.ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                cg.ctx.stroke()

                //draw top circle
                cg.ctx.strokeStyle = this.outlineCol
                //cg.ctx.fillStyle = "#c08c59"
                cg.ctx.lineWidth = this.outlineWidthPix * zf
                cg.ctx.beginPath()
                cg.ctx.arc(cx + d * Math.cos(a), cy + d * Math.sin(a), wG * 0.5, 0, 2 * Math.PI, false)
                cg.ctx.stroke()
                //cg.ctx.fill();
            }
        }

        //in case...
        cg.ctx.lineCap = 'butt'

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sColor: statColor })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/SegmentStyle.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/style/SegmentStyle.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SegmentStyle: () => (/* binding */ SegmentStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/**
 * A style where each cell is represented by a segment whose length, width, color and orientation can vary according to statistical values.
 *
 * @author Julien Gaffuri
 */
class SegmentStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the orientation (in degrees) of the segment representing a cell.
         * @type {function(import("../Dataset").Cell):number} */
        this.orientation = opts.orientation || (() => 0)

        /**
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell segment.
         * @type {function(number,number,import("../Style").Stat|undefined):string} */
        this.color = opts.color || (() => '#EA6BAC')

        /**
         * @type {string} */
        this.lengthCol = opts.lengthCol

        /** A function returning the length of the segment representing a cell, in geo unit
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.length = opts.length

        /**
         * @type {string} */
        this.widthCol = opts.widthCol

        /** A function returning the width of the segment representing a cell, in geo unit
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.width = opts.width
    }

    /**
     * Draw cells as segments.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        let statLength
        if (this.lengthCol) {
            //if length is used, sort cells by length so that the longests are drawn first
            cells.sort((c1, c2) => c2[this.lengthCol] - c1[this.lengthCol])
            //and compute size variable statistics
            statLength = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.lengthCol], true)
        }

        let statWidth
        if (this.widthCol) {
            //and compute size variable statistics
            statWidth = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.widthCol], true)
        }

        //
        cg.ctx.lineCap = 'butt'

        //conversion factor degree -> radian
        const f = Math.PI / 180

        //draw in geo coordinates
        cg.setCanvasTransform()

        for (let c of cells) {
            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(c[this.colorCol], r, statColor) : undefined
            if (!col) continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(c[this.widthCol], r, statWidth, zf) : undefined
            if (!wG || wG < 0) continue

            //length
            /** @type {number|undefined} */
            const lG = this.length ? this.length(c[this.lengthCol], r, statLength, zf) : undefined
            if (!lG || lG < 0) continue

            //orientation (in radian)
            /** @type {number} */
            const or = this.orientation(c) * f
            if (or === undefined || isNaN(or)) continue

            //get offset
            const offset = this.offset(c, r, zf)

            //set color and width
            cg.ctx.strokeStyle = col
            cg.ctx.lineWidth = wG

            //compute segment centre postition
            const cx = c.x + r / 2 + offset.dx
            const cy = c.y + r / 2 + offset.dy

            //compute segment direction
            const dx = 0.5 * Math.cos(or) * lG
            const dy = 0.5 * Math.sin(or) * lG

            //draw segment
            cg.ctx.beginPath()
            cg.ctx.moveTo(cx - dx, cy - dy)
            cg.ctx.lineTo(cx + dx, cy + dy)
            cg.ctx.stroke()
        }

        //update legend, if any
        this.updateLegends({
            widthFun: this.width,
            r: r,
            zf: zf,
            sColor: statColor,
            //sLength: statLength,
            sWidth: statWidth,
        })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/ShapeColorSizeStyle.js":
/*!***************************************************************!*\
  !*** ./node_modules/gridviz/src/style/ShapeColorSizeStyle.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShapeColorSizeStyle: () => (/* binding */ ShapeColorSizeStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * A very generic style that shows grid cells with specific color, size and shape.
 * It can be used to show variables as cell colors, cell size, cell shape, or any combination of the three visual variables.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class ShapeColorSizeStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):string} */
        this.color = opts.color || (() => '#EA6BAC') //(v,r,s,zf) => {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for size.
         * @type {string} */
        this.sizeCol = opts.sizeCol

        /** A function returning the size of a cell in geographical unit.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.size = opts.size

        /** A function returning the shape of a cell.
         * @type {function(import("../Dataset").Cell):import("../Style").Shape} */
        this.shape = opts.shape || (() => 'square')

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color alpha.
         * @type {string} */
        this.alphaCol = opts.alphaCol

        /** A function returning the color alpha of the cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.alphaF = opts.alphaF
    }

    /**
     * Draw cells as squares, with various colors and size.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statSize
        if (this.sizeCol) {
            //if size is used, sort cells by size so that the biggest are drawn first
            cells.sort((c1, c2) => c2[this.sizeCol] - c1[this.sizeCol])
            //and compute size variable statistics
            statSize = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.sizeCol], true)
        }

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        let statAlpha
        if (this.alphaCol) {
            //compute color alpha variable statistics
            statAlpha = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.alphaCol], true)
        }

        //draw with HTML canvas
        //in geo coordinates
        cg.setCanvasTransform()

        const r2 = r * 0.5
        for (let cell of cells) {
            //color
            let col = this.color ? this.color(cell[this.colorCol], r, statColor, zf) : undefined
            if (!col || col === 'none') continue

            //alpha
            if (this.alphaCol && this.alphaF) {
                //get alpha
                const alpha = this.alphaF(cell[this.alphaCol], r, statAlpha, zf)
                if (alpha == 0) continue
                //apply alpha to color col
                const col_ = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(col);
                if (col_) col = `rgba(${col_.r}, ${col_.g}, ${col_.b}, ${alpha})`;
                else console.warn("Could not decode color " + col + " in ShapeColorSizeStyle")
            }

            //shape
            const shape = this.shape ? this.shape(cell) : 'square'
            if (shape === 'none') continue

            //size
            /** @type {function(number,number,import("../Style").Stat|undefined,number):number} */
            let s_ = this.size || (() => r)
            //size - in geo unit
            const sG = s_(cell[this.sizeCol], r, statSize, zf)

            //get offset
            const offset = this.offset(cell, r, zf)

            cg.ctx.fillStyle = col
            if (shape === 'square') {
                //draw square
                const d = r * (1 - sG / r) * 0.5
                cg.ctx.fillRect(cell.x + d + offset.dx, cell.y + d + offset.dy, sG, sG)
            } else if (shape === 'circle') {
                //draw circle
                cg.ctx.beginPath()
                cg.ctx.arc(cell.x + r2 + offset.dx, cell.y + r2 + offset.dy, sG * 0.5, 0, 2 * Math.PI, false)
                cg.ctx.fill()
            } else if (shape === 'donut') {
                //draw donut
                const xc = cell.x + r2 + offset.dx,
                    yc = cell.y + r2 + offset.dy
                cg.ctx.beginPath()
                cg.ctx.moveTo(xc, yc)
                cg.ctx.arc(xc, yc, r2, 0, 2 * Math.PI)
                cg.ctx.arc(xc, yc, (1 - sG / r) * r2, 0, 2 * Math.PI, true)
                cg.ctx.closePath()
                cg.ctx.fill()
            } else if (shape === 'diamond') {
                const s2 = sG * 0.5
                cg.ctx.beginPath()
                cg.ctx.moveTo(cell.x + r2 - s2, cell.y + r2)
                cg.ctx.lineTo(cell.x + r2, cell.y + r2 + s2)
                cg.ctx.lineTo(cell.x + r2 + s2, cell.y + r2)
                cg.ctx.lineTo(cell.x + r2, cell.y + r2 - s2)
                cg.ctx.fill()
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sSize: statSize, sColor: statColor, sAlpha: statAlpha })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/ShapeColorSizeStyle_.js":
/*!****************************************************************!*\
  !*** ./node_modules/gridviz/src/style/ShapeColorSizeStyle_.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShapeColorSizeStyle_: () => (/* binding */ ShapeColorSizeStyle_)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/**
 * A very generic style that shows grid cells with specific color, size and shape.
 * It can be used to show variables as cell colors, cell size, cell shape, or any combination of the three visual variables.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class ShapeColorSizeStyle_ extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the view scale.
         * @type {function(Array.<import('../Dataset.js').Cell>,number, number):object} */
        this.viewScale = opts.viewScale //(cells,r,z) => {}

        /** A function returning the color of the cell.
         * @type {function(import('../Dataset.js').Cell,number, number,object):string} */
        this.color = opts.color //(c,r,z,o) => {}

        /** A function returning the size of a cell in geographical unit.
         * @type {function(import('../Dataset.js').Cell,number, number,object):number} */
        this.size = opts.size //(c,r,z,o) => {}

        /** A function returning the shape of a cell.
         * @type {function(import("../Dataset.js").Cell,number, number,object):import("../Style.js").Shape} */
        this.shape = opts.shape //(c,r,z,o) => {}
    }

    /**
     * Draw cells as squares, with various colors and sizes.
     *
     * @param {Array.<import("../Dataset.js").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas.js").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        //get view scale
        const vc = this.viewScale ? this.viewScale(cells, r, zf) : undefined

        //draw with HTML canvas in geo coordinates
        cg.setCanvasTransform()

        const r2 = r * 0.5
        for (let c of cells) {
            //color
            let col = this.color ? this.color(c, r, zf, vc) : "black"
            if (!col || col === 'none') continue

            //size
            const size = this.size ? this.size(c, r, zf, vc) : r
            if (!size) continue

            //shape
            const shape = this.shape ? this.shape(c, r, zf, vc) : 'square'
            if (shape === 'none') continue

            //get offset
            const offset = this.offset(c, r, zf)

            cg.ctx.fillStyle = col
            if (shape === 'square') {
                //draw square
                const d = r * (1 - size / r) * 0.5
                cg.ctx.fillRect(c.x + d + offset.dx, c.y + d + offset.dy, size, size)
            } else if (shape === 'circle') {
                //draw circle
                cg.ctx.beginPath()
                cg.ctx.arc(c.x + r2 + offset.dx, c.y + r2 + offset.dy, size * 0.5, 0, 2 * Math.PI, false)
                cg.ctx.fill()
            } else if (shape === 'donut') {
                //draw donut
                const xc = c.x + r2 + offset.dx,
                    yc = c.y + r2 + offset.dy
                cg.ctx.beginPath()
                cg.ctx.moveTo(xc, yc)
                cg.ctx.arc(xc, yc, r2, 0, 2 * Math.PI)
                cg.ctx.arc(xc, yc, (1 - size / r) * r2, 0, 2 * Math.PI, true)
                cg.ctx.closePath()
                cg.ctx.fill()
            } else if (shape === 'diamond') {
                const s2 = size * 0.5
                cg.ctx.beginPath()
                cg.ctx.moveTo(c.x + r2 - s2, c.y + r2)
                cg.ctx.lineTo(c.x + r2, c.y + r2 + s2)
                cg.ctx.lineTo(c.x + r2 + s2, c.y + r2)
                cg.ctx.lineTo(c.x + r2, c.y + r2 - s2)
                cg.ctx.fill()
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, viewScale: vc })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/SideCatStyle.js":
/*!********************************************************!*\
  !*** ./node_modules/gridviz/src/style/SideCatStyle.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SideCatStyle: () => (/* binding */ SideCatStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/** @typedef {{x:number,y:number,or:"v"|"h",v1:string|undefined,v2:string|undefined}} Side */

/**
 * A style to show the sides of grid cells based on their different categories.
 *
 * @author Julien Gaffuri
 */
class SideCatStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the categorical value.
         * @type {string} */
        this.col = opts.col

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

        /** A function returning the width of a cell side line, in geo unit
         * @type {function(Side,number,number):number} */
        this.width = opts.width || ((side, r, z) => r * 0.2)

        /** A fill color for the cells.
         * @type {function(import("../Dataset").Cell):string} */
        this.fillColor = opts.fillColor
    }

    /**
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        if (!cells || cells.length == 0) return

        //zoom factor
        const zf = cg.getZf()

        /**  @type {Array.<Side>} */
        const sides = []

        //make horizontal sides
        //sort cells by x and y
        cells.sort((c1, c2) => (c2.x == c1.x ? c1.y - c2.y : c1.x - c2.x))
        let c1 = cells[0]
        let v1 = c1[this.col]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]
            let v2 = c2[this.col]

            if (c1.y + r == c2.y && c1.x == c2.x) {
                //cells in same column and touch along horizontal side
                //make shared side
                if (v1 != v2) sides.push({ x: c1.x, y: c2.y, or: 'h', v1: v1, v2: v2 })
            } else {
                //cells do not touch along horizontal side
                //make two sides: top one for c1, bottom for c2
                sides.push({ x: c1.x, y: c1.y + r, or: 'h', v1: v1, v2: undefined })
                sides.push({ x: c2.x, y: c2.y, or: 'h', v1: undefined, v2: v2 })
            }

            c1 = c2
            v1 = v2
        }

        //make vertical sides
        //sort cells by y and x
        cells.sort((c1, c2) => (c2.y == c1.y ? c1.x - c2.x : c1.y - c2.y))
        c1 = cells[0]
        v1 = c1[this.col]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]
            let v2 = c2[this.col]

            if (c1.x + r == c2.x && c1.y == c2.y) {
                //cells in same row and touch along vertical side
                //make shared side
                if (v1 != v2) sides.push({ x: c1.x + r, y: c1.y, or: 'v', v1: v1, v2: v2 })
            } else {
                //cells do not touch along vertical side
                //make two sides: right one for c1, left for c2
                sides.push({ x: c1.x + r, y: c1.y, or: 'v', v1: v1, v2: undefined })
                sides.push({ x: c2.x, y: c2.y, or: 'v', v1: undefined, v2: v2 })
            }

            c1 = c2
            v1 = v2
        }

        //
        if (sides.length == 0) return

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw cells, if fillColor specified
        if (this.fillColor)
            for (let c of cells) {
                const fc = this.fillColor(c)
                if (!fc || fc == 'none') continue
                cg.ctx.fillStyle = fc
                cg.ctx.fillRect(c.x, c.y, r, r)
            }

        //draw sides
        cg.ctx.lineCap = 'butt'
        for (let s of sides) {
            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(s, r, zf) : undefined
            if (!wG || wG <= 0) continue
            const w2 = wG * 0.5

            //set color and width
            cg.ctx.lineWidth = wG

            //draw segment with correct orientation
            if (s.or === 'h') {
                //top line
                if (s.v2) {
                    cg.ctx.beginPath()
                    cg.ctx.strokeStyle = this.color[s.v2]
                    cg.ctx.moveTo(s.x, s.y + w2)
                    cg.ctx.lineTo(s.x + r, s.y + w2)
                    cg.ctx.stroke()
                }

                //bottom line
                if (s.v1) {
                    cg.ctx.beginPath()
                    cg.ctx.strokeStyle = this.color[s.v1]
                    cg.ctx.moveTo(s.x, s.y - w2)
                    cg.ctx.lineTo(s.x + r, s.y - w2)
                    cg.ctx.stroke()
                }
            } else {
                //right line
                if (s.v2) {
                    cg.ctx.beginPath()
                    cg.ctx.strokeStyle = this.color[s.v2]
                    cg.ctx.moveTo(s.x + w2, s.y)
                    cg.ctx.lineTo(s.x + w2, s.y + r)
                    cg.ctx.stroke()
                }

                //left line
                if (s.v1) {
                    cg.ctx.beginPath()
                    cg.ctx.strokeStyle = this.color[s.v1]
                    cg.ctx.moveTo(s.x - w2, s.y)
                    cg.ctx.lineTo(s.x - w2, s.y + r)
                    cg.ctx.stroke()
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf })
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/SideStyle.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridviz/src/style/SideStyle.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SideStyle: () => (/* binding */ SideStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/** @typedef {{x:number,y:number,or:"v"|"h",value:number}} Side */

/**
 *
 * @author Julien Gaffuri
 */
class SideStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for the cell values.
         * @type {string} */
        this.valueCol = opts.valueCol

        /** A function returning the value of a cell side. This value is computed from the two adjacent cell values.
         * For horizontal sides, v1 is the value of the cell below and v2 the value of the cell above.
         * For vertical sides, v1 is the value of the cell left and v2 the value of the cell right.
         * @type {function(number|undefined,number|undefined,number,import("../Style").Stat|undefined,number):number} */
        this.value = opts.value || ((v1, v2, r, s, zf) => 1)

        /** A function returning the color of a cell side.
         * @type {function(Side,number,import("../Style").Stat|undefined,number):string} */
        this.color = opts.color || (() => '#EA6BAC')

        /** A function returning the width of a cell side, in geo unit
         * @type {function(Side,number,import("../Style").Stat|undefined,number):number} */
        this.width = opts.width || ((side, r, s, zf) => (r * side.value) / 5)

        /** orientation. Set to 90 to show sides as slope lines for example.
         * @type {number} */
        this.orientation = opts.orientation || 0

        /** A fill color for the cells.
         * @type {function(import("../Dataset").Cell):string} */
        this.fillColor = opts.fillColor
    }

    /**
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        //compute stats on cell values
        let statValue
        if (this.valueCol) {
            //compute color variable statistics
            statValue = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.valueCol], true)
        }

        /**  @type {Array.<Side>} */
        const sides = []

        //make horizontal sides
        //sort cells by x and y
        cells.sort((c1, c2) => (c2.x == c1.x ? c1.y - c2.y : c1.x - c2.x))
        let c1 = cells[0]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]

            if ((c1.y + r == c2.y) && (c1.x == c2.x))
                //cells in same column and touch along horizontal side
                //make shared side
                sides.push({
                    x: c1.x,
                    y: c2.y,
                    or: 'h',
                    value: this.value(c1[this.valueCol], c2[this.valueCol], r, statValue, zf),
                })
            else {
                //cells do not touch along horizontal side
                //make two sides: top one for c1, bottom for c2
                sides.push({
                    x: c1.x,
                    y: c1.y + r,
                    or: 'h',
                    value: this.value(c1[this.valueCol], undefined, r, statValue, zf),
                })
                sides.push({
                    x: c2.x,
                    y: c2.y,
                    or: 'h',
                    value: this.value(undefined, c2[this.valueCol], r, statValue, zf),
                })
            }

            c1 = c2
        }

        //make vertical sides
        //sort cells by y and x
        cells.sort((c1, c2) => (c2.y == c1.y ? c1.x - c2.x : c1.y - c2.y))
        c1 = cells[0]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]

            if ((c1.x + r == c2.x) && (c1.y == c2.y))
                //cells in same row and touch along vertical side
                //make shared side
                sides.push({
                    x: c1.x + r,
                    y: c1.y,
                    or: 'v',
                    value: this.value(c1[this.valueCol], c2[this.valueCol], r, statValue, zf),
                })
            else {
                //cells do not touch along vertical side
                //make two sides: right one for c1, left for c2
                sides.push({
                    x: c1.x + r,
                    y: c1.y,
                    or: 'v',
                    value: this.value(c1[this.valueCol], undefined, r, statValue, zf),
                })
                sides.push({
                    x: c2.x,
                    y: c2.y,
                    or: 'v',
                    value: this.value(undefined, c2[this.valueCol], r, statValue, zf),
                })
            }

            c1 = c2
        }

        //
        if (sides.length == 0) return

        //compute stats on sides
        const statSides = SideStyle.getSideStatistics(sides, true)

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw cells, if fillColor specified
        if (this.fillColor)
            for (let c of cells) {
                const fc = this.fillColor(c)
                if (!fc || fc == 'none') continue
                cg.ctx.fillStyle = fc
                cg.ctx.fillRect(c.x, c.y, r, r)
            }

        //draw sides
        cg.ctx.lineCap = 'butt'
        const r2 = r / 2
        for (let s of sides) {
            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(s, r, statSides, zf) : undefined
            if (!col || col == 'none') continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(s, r, statSides, zf) : undefined
            if (!wG || wG <= 0) continue

            //set color and width
            cg.ctx.strokeStyle = col
            cg.ctx.lineWidth = wG

            //draw segment with correct orientation
            cg.ctx.beginPath()
            if (this.orientation == 90) {
                cg.ctx.moveTo(s.x + r2, s.y + r2)
                if (s.or === 'h') cg.ctx.lineTo(s.x + r2, s.y - r2)
                else cg.ctx.lineTo(s.x - r2, s.y + r2)
            } else {
                cg.ctx.moveTo(s.x, s.y)
                cg.ctx.lineTo(s.x + (s.or === 'h' ? r : 0), s.y + (s.or === 'v' ? r : 0))
            }
            cg.ctx.stroke()
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf })
    }

    /**
     * Compute some statistics on a value of some sides.
     * This is used to define how to draw specifically the sides within the view.
     *
     * @param {Array.<Side>} sides
     * @param {boolean} ignoreZeros
     * @returns {import("../Style").Stat | undefined}
     */
    static getSideStatistics(sides, ignoreZeros) {
        if (!sides || sides.length == 0) return undefined
        let min = Infinity
        let max = -Infinity
        //let sum = 0
        //let nb = 0
        for (const s of sides) {
            const v = s.value
            if (ignoreZeros && !v) continue
            if (v < min) min = v
            if (v > max) max = v
            //sum += v
            //nb++
        }
        return { min: min, max: max }
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/SquareColorCatWGLStyle.js":
/*!******************************************************************!*\
  !*** ./node_modules/gridviz/src/style/SquareColorCatWGLStyle.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SquareColorCatWGLStyle: () => (/* binding */ SquareColorCatWGLStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoringCatAdvanced_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/WebGLSquareColoringCatAdvanced.js */ "./node_modules/gridviz/src/utils/WebGLSquareColoringCatAdvanced.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Utils.js */ "./node_modules/gridviz/src/utils/Utils.js");
//@ts-check


;




/**
 * Style based on webGL
 * To show cells as colored squares, from categories.
 * Alls squares with the same size
 *
 * @author Julien Gaffuri
 */
class SquareColorCatWGLStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The name of the column/attribute of the tabular data where to retrieve the category of the cell, for coloring.
         * @type {string} */
        this.colorCol = opts.colorCol

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        opts.color = opts.color || undefined

        /** @type { Array.<string> } @private */
        const keys = Object.keys(opts.color)

        /** @type { object } @private */
        this.catToI = {}
        for (let i = 0; i < keys.length; i++) this.catToI[keys[i]] = i + ''

        /** @type { Array.<string> } @private */
        this.colors = []
        for (let i = 0; i < keys.length; i++) {
            this.colors.push(opts.color['' + keys[i]])
        }

        /**
         * A function returning the size of the cells, in geographical unit. All cells have the same size.
         * @type {function(number,number):number} */
        this.size = opts.size // (resolution, zf) => ...

        /**
         * @private
         * @type { WebGLSquareColoringCatAdvanced } */
        this.wgp = new _utils_WebGLSquareColoringCatAdvanced_js__WEBPACK_IMPORTED_MODULE_2__.WebGLSquareColoringCatAdvanced(this.colors)
    }

    /**
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** SquareColorCatWGLStyle draw')

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        //add vertice and fragment data
        const r2 = r / 2
        let c,
            nb = cells.length
        const verticesBuffer = []
        const iBuffer = []
        for (let i = 0; i < nb; i++) {
            c = cells[i]
            const cat = c[this.colorCol]
            if (cat == undefined) {
                console.log('Unexpected category: ' + cat)
                continue
            }
            /** @type {number} */
            const i_ = this.catToI[cat]
            if (isNaN(+i_)) {
                console.log('Unexpected category index: ' + cat + ' ' + i_)
                continue
            }
            verticesBuffer.push(c.x + r2, c.y + r2)
            iBuffer.push(+i_)
        }

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   webgl program inputs preparation')

        //create canvas and webgl renderer
        const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeWebGLCanvas)(cg.w + '', cg.h + '')
        if (!cvWGL) {
            console.error('No webGL')
            return
        }
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   web GL canvas creation')

        //draw
        const sizeGeo = this.size ? this.size(r, zf) : r + 0.2 * zf
        this.wgp.draw(cvWGL.gl, verticesBuffer, iBuffer, cg.getWebGLTransform(), sizeGeo / zf)

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   webgl drawing')

        //draw in canvas geo
        cg.initCanvasTransform()
        cg.ctx.drawImage(cvWGL.canvas, 0, 0)

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   canvas drawing')

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf })

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** SquareColorCatWGLStyle end draw')
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/SquareColorWGLStyle.js":
/*!***************************************************************!*\
  !*** ./node_modules/gridviz/src/style/SquareColorWGLStyle.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SquareColorWGLStyle: () => (/* binding */ SquareColorWGLStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoringAdvanced_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/WebGLSquareColoringAdvanced.js */ "./node_modules/gridviz/src/utils/WebGLSquareColoringAdvanced.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Utils.js */ "./node_modules/gridviz/src/utils/Utils.js");
//@ts-check


;




/**
 * Style based on webGL
 * To show cells as colored squares, with computation of the colors on GPU side (faster than JavaScript side).
 * Alls squares with the same size
 *
 * @author Julien Gaffuri
 */
class SquareColorWGLStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.colorCol = opts.colorCol

        /**
         * A function returning the t value (within [0,1]) of the cell.
         * @type {function(number,number,import("../Style").Stat):number} */
        this.tFun = opts.tFun || ((v, r, s) => v / s.max)

        /**
         * Distribution stretching method.
         * The stretching is performed on GPU side (fragment shader).
         * @type {{ fun:string, alpha:number }} */
        this.stretching = opts.stretching

        /**
         * The sample of the color ramp.
         * The color is computed on GPU side (fragment shader) based on those values (linear interpolation).
         * @type {Array.<string>} */
        this.colors =
            opts.colors ||
            [
                'rgb(158, 1, 66)',
                'rgb(248, 142, 83)',
                'rgb(251, 248, 176)',
                'rgb(137, 207, 165)',
                'rgb(94, 79, 162)',
            ].reverse()
        if (opts.color)
            this.colors = [
                opts.color(0),
                opts.color(0.2),
                opts.color(0.4),
                opts.color(0.6),
                opts.color(0.8),
                opts.color(1),
            ]

        /**
         * Define the opacity of the style, within [0,1].
         * If this opacity is defined, the individual color opacity will be ignored.
         * @type {function(number,number):number} */
        this.opacity = opts.opacity // (r,zf) => ...

        /**
         * A function returning the size of the cells, in geographical unit. All cells have the same size.
         * @type {function(number,number):number} */
        this.size = opts.size // (resolution, zf) => ...
    }

    /**
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** SquareColorWGLStyle draw')

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        //compute color variable statistics
        const statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   color stats computation')

        if (!statColor) return

        //create canvas and webgl renderer
        //for opacity control, see: https://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html
        const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeWebGLCanvas)(
            cg.w + '',
            cg.h + '',
            this.opacity != undefined ? { premultipliedAlpha: false } : undefined
        )
        if (!cvWGL) {
            console.error('No webGL')
            return
        }
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   web GL canvas creation')

        //add vertice and fragment data
        const r2 = r / 2
        const verticesBuffer = []
        const tBuffer = []
        for (let c of cells) {
            const t = this.tFun(c[this.colorCol], r, statColor)
            if (t == null || t == undefined) continue
            verticesBuffer.push(c.x + r2, c.y + r2)
            tBuffer.push(t > 1 ? 1 : t < 0 ? 0 : t)
        }

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   webgl drawing data preparation')

        //compute pixel size
        const sizeGeo = this.size ? this.size(r, zf) : r + 0.2 * zf

        //compute opacity
        const op = this.opacity ? this.opacity(r, zf) : undefined

        //
        const wgp = new _utils_WebGLSquareColoringAdvanced_js__WEBPACK_IMPORTED_MODULE_2__.WebGLSquareColoringAdvanced(cvWGL.gl, this.colors, this.stretching, sizeGeo / zf, op)

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   webgl program preparation')

        //draw
        wgp.draw(verticesBuffer, tBuffer, cg.getWebGLTransform())

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   webgl drawing')

        //draw in canvas geo
        cg.initCanvasTransform()
        cg.ctx.drawImage(cvWGL.canvas, 0, 0)

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   canvas drawing')

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sColor: statColor })

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** SquareColorWGLStyle end draw')
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/StrokeStyle.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/style/StrokeStyle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StrokeStyle: () => (/* binding */ StrokeStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/**
 *
 * @author Julien Gaffuri
 */
class StrokeStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.strokeColorCol = opts.strokeColorCol

        /** A function returning the color of the stroke.
         * @type {function(number,number,import("../Style").Stat|undefined):string} */
        this.strokeColor = opts.strokeColor || (() => '#666')

        /** The name of the column/attribute of the tabular data where to retrieve the variable for size.
         * @type {string} */
        this.sizeCol = opts.sizeCol

        /** A function returning the size of a cell in geographical unit.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.size = opts.size

        /** The stroke line width, in pixels.
         * @type {string} */
        this.strokeWidthCol = opts.strokeWidthCol

        /** The stroke line width in geographical unit.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.strokeWidth = opts.strokeWidth // (v,r,s,z)=>...

        /** A function returning the shape of a cell.
         * @type {function(import("../Dataset").Cell):import("../Style").Shape} */
        this.shape = opts.shape || (() => 'square')
    }

    /**
     * Draw cells as squares, with various colors and size.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statColor
        if (this.strokeColorCol) statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.strokeColorCol], true)

        let statSize
        if (this.sizeCol) statSize = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.sizeCol], true)

        let statWidth
        if (this.strokeWidthCol) statWidth = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.strokeWidthCol], true)

        //draw with HTML canvas
        //in geo coordinates
        cg.setCanvasTransform()

        const r2 = r * 0.5
        for (let cell of cells) {
            //color
            const col = this.strokeColor
                ? this.strokeColor(cell[this.strokeColorCol], r, statColor)
                : undefined
            if (!col || col === 'none') continue
            cg.ctx.strokeStyle = col

            //size
            /** @type {function(number,number,import("../Style").Stat|undefined,number):number} */
            let s_ = this.size || (() => r)
            //size - in geo unit
            const sG = s_(cell[this.sizeCol], r, statSize, zf)

            //width
            const wi = this.strokeWidth
                ? this.strokeWidth(cell[this.strokeWidthCol], r, statWidth, zf)
                : 1 * zf
            if (!wi || wi <= 0) continue
            cg.ctx.lineWidth = wi

            //shape
            const shape = this.shape ? this.shape(cell) : 'square'
            if (shape === 'none') continue

            //get offset
            const offset = this.offset(cell, r, zf)

            if (shape === 'square') {
                //draw square
                const d = r * (1 - sG / r) * 0.5
                cg.ctx.beginPath()
                cg.ctx.rect(cell.x + d + offset.dx, cell.y + d + offset.dy, sG, sG)
                cg.ctx.stroke()
            } else if (shape === 'circle') {
                //draw circle
                cg.ctx.beginPath()
                cg.ctx.arc(cell.x + r2 + offset.dx, cell.y + r2 + offset.dy, sG * 0.5, 0, 2 * Math.PI, false)
                cg.ctx.stroke()
            } else if (shape === 'diamond') {
                const s2 = sG * 0.5
                cg.ctx.beginPath()
                cg.ctx.moveTo(cell.x + r2 - s2, cell.y + r2)
                cg.ctx.lineTo(cell.x + r2, cell.y + r2 + s2)
                cg.ctx.lineTo(cell.x + r2 + s2, cell.y + r2)
                cg.ctx.lineTo(cell.x + r2, cell.y + r2 - s2)
                cg.ctx.lineTo(cell.x + r2 - s2, cell.y + r2)
                cg.ctx.stroke()
            } else if (shape === 'donut') {
                console.error('Not implemented')
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        //this.updateLegends({ style: this, r: resolution, zf: zf, sSize: statSize, sColor: statColor });
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/TanakaStyle.js":
/*!*******************************************************!*\
  !*** ./node_modules/gridviz/src/style/TanakaStyle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TanakaStyle: () => (/* binding */ TanakaStyle)
/* harmony export */ });
/* harmony import */ var _SquareColorWGLStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SquareColorWGLStyle.js */ "./node_modules/gridviz/src/style/SquareColorWGLStyle.js");
/* harmony import */ var _SideStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SideStyle.js */ "./node_modules/gridviz/src/style/SideStyle.js");
//@ts-check


;


/**
 *
 * @see https://manifold.net/doc/mfd9/example__tanaka_contours.htm
 *
 * @author Julien Gaffuri
 */
class TanakaStyle {
    /**
     * @param {string} col
     * @param {object} opts
     * @returns {Array.<import("../Style").Style>}
     */
    static get(col, opts) {
        opts = opts || {}

        //get colors from d3 ramps, if 'nb' is specified
        if (opts.nb != undefined) {
            if (opts.nb < 2) {
                console.error('unexpected number of colors in tanaka (<2): ' + opts.nb)
                opts.nb = 2
            }
            if (!opts.color) {
                console.error('color function not defined in tanaka')
                opts.color = () => 'gray'
            }
            opts.colors = []
            for (let i = 0; i < opts.nb; i++) opts.colors.push(opts.color(i / (opts.nb - 1)))
        }

        /**
         * The colors.
         * @type {Array.<string>} */
        opts.colors = opts.colors || ['#a9bb9e', '#c9dcaa', '#fde89f', '#f9a579', '#eb444b']
        const nb = opts.colors.length

        /** A function to compute 't' from the value v
         * @type {function(number,number,import("../Style").Stat):number} */
        opts.tFun = opts.tFun || ((v, r, s) => (v - s.min) / (s.max - s.min))

        //shadow colors
        opts.colDark = opts.colDark || '#111'
        opts.colBright = opts.colBright || '#ddd'

        //width of the segment (share of the resolution)
        opts.widthFactor = opts.widthFactor || 0.08

        //shading
        opts.newShading = opts.newShading
        opts.newShadingWidthPix = opts.newShadingWidthPix || 2
        //transparency value, within [0,1]
        opts.newShadingTr =
            opts.newShadingTr ||
            ((sideValue, sideStat) =>
                Math.abs(sideValue) / Math.max(Math.abs(sideStat.min), Math.abs(sideStat.max)))

        /**
         * @param {number} t A cell t value, within [0,1].
         * @returns the class number for the value
         */
        const getClass = (t) => {
            if (isNaN(t) || t == undefined) {
                console.error('Unexpected t value 1: ' + t)
                return -9
            }
            for (let i = 0; i < nb; i++) if (t <= (i + 1) / nb) return i
            console.error('Unexpected t value 2: ' + t)
            return -9
        }

        const colStyle = new _SquareColorWGLStyle_js__WEBPACK_IMPORTED_MODULE_0__.SquareColorWGLStyle({
            colorCol: col,
            colors: opts.colors,
            tFun: (v, r, s) => {
                const t = opts.tFun(v, r, s)
                const c = getClass(t)
                return c / (nb - 1)
            },
            //stretching: { fun: "expRev", alpha: -7 },
            size: (r, zf) => r + 0.5 * zf, //that is to ensure no gap between same class cells is visible
            filter: opts.filter,
        })

        /*
        if no web gl:    
            const colStyle = new ShapeColorSizeStyle({
                colorCol: col,
                //the color corresponding to the class
                color: (v, r, s, zf) => {
                    if (v == 0 && opts.tFun && isNaN(opts.tFun(v, r, s)))
                        return undefined
                    return opts.colors[getClass(opts.tFun ? opts.tFun(v, r, s) : v)]
                },
                shape: () => "square",
                size: (v, r, s, zf) => r + 0.5 * zf, //that is to ensure no gap between same class cells is visible
            })
        */

        /** The side style, for the shadow effect */
        const sideStyle = new _SideStyle_js__WEBPACK_IMPORTED_MODULE_1__.SideStyle({
            valueCol: col,
            value: (v1, v2, r, s, zf) => {
                //compute the number of classes of difference
                if (v1 === undefined && v2 === undefined) return 0
                else if (v2 === undefined) {
                    const t = opts.tFun(v1, r, s)
                    if (t == undefined || isNaN(t)) throw new Error('Unexpected value: ' + v1 + ' - ' + t)
                    const c = getClass(t)
                    return c + 1
                } else if (v1 === undefined) {
                    const t = opts.tFun(v2, r, s)
                    if (t == undefined || isNaN(t)) throw new Error('Unexpected value: ' + v2 + ' - ' + t)
                    const c = getClass(t)
                    return -c - 1
                }
                const t1 = opts.tFun(v1, r, s)
                if (t1 == undefined || isNaN(t1)) throw new Error('Unexpected value: ' + v1 + ' - ' + t1)
                const t2 = opts.tFun(v2, r, s)
                if (t2 == undefined || isNaN(t2)) throw new Error('Unexpected value: ' + v2 + ' - ' + t2)
                const c1 = getClass(t1)
                const c2 = getClass(t2)
                return -c2 + c1
            },

            color: opts.newShading
                ? //black with transparency depending on difference
                  (side, r, s, z) => {
                      const tr = opts.newShadingTr(side.value, s)
                      return (side.value > 0 && side.or === 'h') || (side.value < 0 && side.or === 'v')
                          ? 'rgba(255,255,100,' + tr + ')'
                          : 'rgba(0,0,0,' + tr + ')'
                  }
                : //white or black, depending on orientation and value
                  (side, r, s, z) => {
                      if (side.value === 0) return
                      //return "gray"
                      if (side.or === 'v') return side.value < 0 ? opts.colBright : opts.colDark
                      return side.value < 0 ? opts.colDark : opts.colBright
                  },

            width: opts.newShading
                ? //fill size
                  (side, r, s, z) => {
                      return opts.newShadingWidthPix * z
                  }
                : //width depends on the value, that is the number of classes of difference
                  (side, r, s, z) =>
                      opts.widthFactor * r * Math.abs(side.value) * (side.or === 'v' ? 0.5 : 1),

            filter: opts.filter,
        })

        return [colStyle, sideStyle]
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/TextStyle.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridviz/src/style/TextStyle.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextStyle: () => (/* binding */ TextStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/**
 *
 * @author Julien Gaffuri
 */
class TextStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for text.
         * @type {string} */
        this.textCol = opts.textCol

        /** A function returning the text of a cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):string} */
        this.text = opts.text || ((v, r, s, z) => 'X')

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):string} */
        this.color = opts.color || (() => '#EA6BAC')

        /** The name of the column/attribute of the tabular data where to retrieve the variable for font size.
         * @type {string} */
        this.fontSizeCol = opts.fontSizeCol

        /** A function returning the font size of a cell in geo unit.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.fontSize = opts.fontSize || ((v, r, s, z) => r * 0.8)

        /** The text font family.
         * @type {string} */
        this.fontFamily = opts.fontFamily || 'Arial'

        /** The text font weight.
         * @type {string} */
        this.fontWeight = opts.fontWeight || 'bold'
    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statText
        if (this.textCol) {
            //compute text variable statistics
            statText = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.textCol], true)
        }

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        let statFontSize
        if (this.fontSizeCol) {
            //if size is used, sort cells by size so that the biggest are drawn first
            cells.sort((c1, c2) => c2[this.fontSizeCol] - c1[this.fontSizeCol])
            //and compute size variable statistics
            statFontSize = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.fontSizeCol], true)
        }

        //draw with HTML canvas
        //in screen coordinates
        cg.initCanvasTransform()

        for (let cell of cells) {
            //get cell text
            const text = this.text ? this.text(cell[this.textCol], r, statText, zf) : undefined
            if (text == undefined || text == null || text + '' === '') continue

            //color
            const col = this.color ? this.color(cell[this.colorCol], r, statColor, zf) : undefined
            if (!col) continue
            cg.ctx.fillStyle = col

            //font size
            //size - in pixel unit
            const fontSizePix = this.fontSize(cell[this.fontSizeCol], r, statFontSize, zf) / zf

            //set font
            const fontFamily = this.fontFamily || 'Arial'
            const fontWeight = this.fontWeight || 'bold'
            cg.ctx.font = fontWeight + ' ' + fontSizePix + 'px ' + fontFamily

            //get offset
            const offset = this.offset(cell, r, zf)

            //text position
            cg.ctx.textAlign = 'center'
            const tx = cg.geoToPixX(cell.x + r * 0.5 + offset.dx)
            const ty = cg.geoToPixY(cell.y + r * 0.5 + offset.dy) + fontSizePix * 0.3 //it should be 0.5 but 0.3 seems to work better

            //draw the text
            cg.ctx.fillText(text, tx, ty)
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sColor: statColor })
    }

    /**
     * Build a function [0,1]->string for characters legend
     *
     * @param {Array.<string>} chars
     * @returns {function(number):string}
     */
    static getCharLegendFun(chars) {
        const nb = chars.length
        return (t) => (t == 0 ? '' : t == 1 ? chars[nb - 1] : chars[Math.floor(t * nb)])
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/style/TimeSeriesStyle.js":
/*!***********************************************************!*\
  !*** ./node_modules/gridviz/src/style/TimeSeriesStyle.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TimeSeriesStyle: () => (/* binding */ TimeSeriesStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./node_modules/gridviz/src/Style.js");
//@ts-check


;

/** @typedef {"first"|"bottom"|"center"|"top"|"last"} AnchorModeYEnum */

/**
 * Show cell as timeseries chart
 * Can be used for sparkline map of https://datagistips.hypotheses.org/488
 *
 * @author Julien Gaffuri
 */
class TimeSeriesStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The columns of the time series, ordered in chronological order.
         * @type {Array.<string>} */
        this.ts = opts.ts

        /** A function specifying when a value should be considered as "no data" and thus not ignored. The line will have a break at these values.
         * @type {function(string):boolean} */
        this.noData = opts.noData || ((v) => v === undefined || v == "" || v === null || isNaN(+v))

        //x
        /** in geo unit
         * @type {function(import("../Dataset.js").Cell,number,number):number} */
        this.offsetX = opts.offsetX || ((c, r, zf) => 0)
        /** @type {function(import("../Dataset.js").Cell,number,number):number} */
        this.width = opts.width || ((c, r, zf) => r)

        //y
        /** in geo unit
         * @type {function(import("../Dataset.js").Cell,number,number):number} */
        this.offsetY = opts.offsetY || ((c, r, zf) => 0)
        /** @type {function(import("../Dataset.js").Cell,number,number):number} */
        this.height = opts.height || ((c, r, zf) => r)
        /** @type {function(import("../Dataset.js").Cell,number,number):AnchorModeYEnum} */
        this.anchorModeY = opts.anchorModeY || ((c, r, zf) => "center")


        /**
         * @type {string} */
        this.lineWidthCol = opts.lineWidthCol

        /** A function returning the width of the line, in geo unit
         * @type {function(number,number,import("../Style.js").Stat|undefined,number):number} */
        this.lineWidth = opts.lineWidth || ((v, r, s, zf) => 1.5 * zf)

        /**
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell.
         * @type {function(number,number,import("../Style.js").Stat|undefined,number):string} */
        this.color = opts.color || ((v, r, s, zf) => 'black')

    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../Dataset.js").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas.js").GeoCanvas} cg
     */
    draw(cells, r, cg) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statWidth
        if (this.lineWidthCol) {
            //and compute size variable statistics
            statWidth = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.lineWidthCol], true)
        }

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        //compute cell amplitude
        const getAmplitude = c => {
            let min, max
            for (let t of this.ts) {
                const val = c[t];
                if (val == undefined) continue
                if (min == undefined || val < min) min = val
                if (max == undefined || val > max) max = val
            }
            if (min == undefined) return undefined
            return max - min
        }

        //compute max amplitude
        let ampMax
        for (let c of cells) {
            const amp = getAmplitude(c)
            if (amp == undefined) continue
            if (ampMax == undefined || amp > ampMax) ampMax = amp
        }
        if (!ampMax) return

        const nb = this.ts.length

        //draw with HTML canvas
        //in geo coordinates
        cg.setCanvasTransform()

        cg.ctx.lineCap = "butt"
        for (let c of cells) {

            //line width
            /** @type {number|undefined} */
            const wG = this.lineWidth ? this.lineWidth(c[this.lineWidthCol], r, statWidth, zf) : undefined
            if (!wG || wG < 0) continue

            //line color
            /** @type {string|undefined} */
            const col = this.color ? this.color(c[this.colorCol], r, statColor, zf) : undefined
            if (!col) continue


            //x
            const offX = this.offsetX ? this.offsetX(c, r, zf) : 0
            if (offX == undefined || isNaN(offX)) continue
            const w = this.width ? this.width(c, r, zf) : r
            if (w == undefined || isNaN(w)) continue

            //y
            const offY = this.offsetY ? this.offsetY(c, r, zf) : 0
            if (offY == undefined || isNaN(offY)) continue
            const h = this.height ? this.height(c, r, zf) : r
            if (h == undefined || isNaN(h)) continue
            const anchY = this.anchorModeY ? this.anchorModeY(c, r, zf) : "center"
            if (!anchY) continue

            cg.ctx.lineWidth = wG
            cg.ctx.strokeStyle = col

            //compute anchor Y figures
            let val0, y0
            if (anchY === "first") {
                //get first value
                val0 = c[this.ts[0]]
                y0 = 0
            } else if (anchY === "last") {
                //get last value
                val0 = c[this.ts[this.ts.length - 1]]
                y0 = 0
            } else if (anchY === "bottom") {
                //get min
                for (let t of this.ts) {
                    const val = +c[t];
                    if (val == undefined) continue
                    if (val0 == undefined || val < val0) val0 = val
                }
                y0 = 0
            } else if (anchY === "top") {
                //get max
                for (let t of this.ts) {
                    const val = +c[t];
                    if (val == undefined) continue
                    if (val0 == undefined || val > val0) val0 = val
                }
                y0 = r
            } else if (anchY === "center") {
                //get min and max
                let min, max
                for (let t of this.ts) {
                    const val = c[t];
                    if (val == undefined) continue
                    if (min == undefined || val < min) min = val
                    if (max == undefined || val > max) max = val
                }
                val0 = (+max + +min) * 0.5
                y0 = r / 2
            } else {
                console.log("Unexpected anchorModeY: " + anchY)
                continue;
            }

            /*/draw line
            if (val0 == undefined || isNaN(val0)) continue
            cg.ctx.beginPath()
            const sX = w / (nb - 1)
            for (let i = 0; i < nb; i++) {
                const val = c[this.ts[i]]
                if (val == undefined || isNaN(val)) break
                if (i == 0)
                    cg.ctx.moveTo(c.x + i * sX + offX, c.y + y0 + (val - val0) * h / ampMax + offY)
                else
                    cg.ctx.lineTo(c.x + i * sX + offX, c.y + y0 + (val - val0) * h / ampMax + offY)
            }
            cg.ctx.stroke()*/


            //draw line, segment by segment
            const sX = w / (nb - 1)

            //handle first point
            let v0 = c[this.ts[0]]
            if (!this.noData(v0)) {
                cg.ctx.beginPath()
                cg.ctx.moveTo(c.x + offX, c.y + y0 + (v0 - val0) * h / ampMax + offY)
            }
            //console.log(v0, isNaN(v0))

            let v1
            for (let i = 1; i < nb; i++) {
                v1 = c[this.ts[i]]

                //draw segment from v0 to v1

                //both points 'no data'
                if (this.noData(v0) && this.noData(v1)) {

                    //second point 'no data'
                } else if (!this.noData(v0) && this.noData(v1)) {
                    cg.ctx.stroke()

                    //first point 'no data'
                } else if (this.noData(v0) && !this.noData(v1)) {
                    cg.ctx.beginPath()
                    cg.ctx.moveTo(c.x + i * sX + offX, c.y + y0 + (v1 - val0) * h / ampMax + offY)

                    //both points have data: trace line
                } else {
                    cg.ctx.lineTo(c.x + i * sX + offX, c.y + y0 + (v1 - val0) * h / ampMax + offY)
                    //if it is the last point, stroke
                    if (i == nb - 1) cg.ctx.stroke()
                }
                v0 = v1
            }

        }

        //update legend, if any
        this.updateLegends({
            widthFun: this.lineWidth,
            r: r,
            zf: zf,
            sColor: statColor,
            //sLength: statLength,
            sWidth: statWidth,
        })

    }

}



/***/ }),

/***/ "./node_modules/gridviz/src/utils/Utils.js":
/*!*************************************************!*\
  !*** ./node_modules/gridviz/src/utils/Utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getClass: () => (/* binding */ getClass),
/* harmony export */   monitor: () => (/* binding */ monitor),
/* harmony export */   monitorDuration: () => (/* binding */ monitorDuration)
/* harmony export */ });
//@ts-check


/**
 * Get the class id from a value and class break values
 *
 * @param {number} v the value
 * @param {Array.<number>} breaks the breaks
 * @returns The class id, from 0 to breaks.length
 */
function getClass(v, breaks) {
    if (!breaks) return
    if (breaks.length == 0) return 0
    if (v <= breaks[0]) return 0
    for (let i = 1; i < breaks.length; i++) if (breaks[i - 1] < v && v <= breaks[i]) return i
    return breaks.length
}

let monitor = false

let previousDate
function monitorDuration(message) {
    const nowDate = Date.now()

    //first call
    if (!previousDate) {
        previousDate = nowDate
        console.log(previousDate, message)
        return
    }

    const d = nowDate - previousDate
    previousDate = nowDate
    console.log(d, message)
}


/***/ }),

/***/ "./node_modules/gridviz/src/utils/WebGLSquareColoring.js":
/*!***************************************************************!*\
  !*** ./node_modules/gridviz/src/utils/WebGLSquareColoring.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLSquareColoring: () => (/* binding */ WebGLSquareColoring)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 */
class WebGLSquareColoring {
    /**
     *
     * @param {WebGLRenderingContext} gl
     */
    constructor(gl, sizePix) {
        this.gl = gl
        this.sizePix = sizePix || 10.0

        this.program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(
            gl,
            (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
                gl,
                gl.VERTEX_SHADER,
                `
            attribute vec2 pos;
            uniform float sizePix;
            uniform mat3 mat;
            attribute vec4 color;
            varying vec4 vColor;
            void main() {
              gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
              gl_PointSize = sizePix;
              vColor = color;
            }
          `
            ),
            (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
                gl,
                gl.FRAGMENT_SHADER,
                `
            precision mediump float;
            varying vec4 vColor;
            void main(void) {
                vec4 vColor_ = vColor / 255.0;
                vColor_[3] = 255.0 * vColor_[3];
                gl_FragColor = vColor_;
            }`
            )
        )
        gl.useProgram(this.program)

        //buffer data
        this.verticesBuffer = []
        this.colorsBuffer = []
    }

    /** Add data to vertices/size/color buffers for color squares drawing */
    addPointData(xC, yC, col) {
        //convert color
        const cc = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(col)
        //const cc = {r:45,g:87,b:98,opacity:0.9}
        if (!cc) return

        //vertices
        this.verticesBuffer.push(xC, yC)
        //color
        this.colorsBuffer.push(cc.r, cc.g, cc.b, cc.opacity)
    }

    addPointData2(xC, yC, r, g, b, opacity) {
        //vertices
        this.verticesBuffer.push(xC, yC)
        //color
        this.colorsBuffer.push(r, g, b, opacity)
    }

    /**  */
    draw(transfoMat) {
        const gl = this.gl

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(this.program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //color data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.colorsBuffer), gl.STATIC_DRAW)
        var color = gl.getAttribLocation(this.program, 'color')
        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(color)

        //sizePix
        gl.uniform1f(gl.getUniformLocation(this.program, 'sizePix'), 1.0 * this.sizePix)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(this.program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, this.verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/utils/WebGLSquareColoringAdvanced.js":
/*!***********************************************************************!*\
  !*** ./node_modules/gridviz/src/utils/WebGLSquareColoringAdvanced.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLSquareColoringAdvanced: () => (/* binding */ WebGLSquareColoringAdvanced)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 * The color interpolation is computed in the fragment shader program, by the GPU, thus it is less flexible but faster.
 */
class WebGLSquareColoringAdvanced {
    //see:
    //https://webglfundamentals.org/webgl/lessons/fr/webgl-shaders-and-glsl.html#les-uniforms-dans-les-shaders-de-vertex
    //https://thebookofshaders.com/glossary/?search=mix
    //https://thebookofshaders.com/06/
    //https://thebookofshaders.com/glossary/

    /**
     *
     * @param {*} gl
     * @param {Array.<String>} colors
     * @param {{fun:string,alpha:number}} stretching
     * @param {number} sizePix
     * @param {number|undefined} globalOpacity
     */
    constructor(gl, colors, stretching, sizePix = 10, globalOpacity = undefined) {
        /** @type {WebGLRenderingContext} */
        this.gl = gl
        //gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        /** @type {WebGLShader} */
        const vShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
            gl,
            gl.VERTEX_SHADER,
            `
        attribute vec2 pos;
        uniform float sizePix;
        uniform mat3 mat;

        attribute float t;
        varying float vt;

        void main() {
          gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
          gl_PointSize = sizePix;
          vt = t;
        }
      `
        )

        //prepare fragment shader code
        //declare the uniform and other variables
        let fshString =
            '' +
            'precision mediump float;\n' +
            'varying float vt;\n' +
            'uniform float alpha;\n' +
            (() => {
                const out = []
                for (let i = 0; i < colors.length; i++) out.push('uniform vec4 c' + i + ';\n')
                return out.join('')
            })() +
            //start the main function, apply the stretching of t
            'void main(void) {\n'

        if (stretching) {
            if (stretching.fun == 'pow')
                //sPow = (t, alpha = 3) => Math.pow(t, alpha);
                fshString += '   float t = pow(vt, alpha);\n'
            else if (stretching.fun == 'powRev')
                //sPowRev = (t, alpha = 3) => 1 - Math.pow(1 - t, 1 / alpha);
                fshString += '   float t = 1.0-pow(1.0-vt, 1.0/alpha);\n'
            else if (stretching.fun == 'exp')
                //sExp = (t, alpha = 3) => alpha == 0 ? t : (Math.exp(t * alpha) - 1) / (Math.exp(alpha) - 1);
                fshString +=
                    stretching.alpha == 0
                        ? `float t = vt;`
                        : '   float t = (exp(vt * alpha) - 1.0) / (exp(alpha) - 1.0);\n'
            else if (stretching.fun == 'expRev')
                //sExpRev = (t, alpha = 3) => alpha == 0 ? t : 1 - (1 / alpha) * Math.log(Math.exp(alpha) * (1 - t) + t);
                fshString +=
                    stretching.alpha == 0
                        ? `float t = vt;`
                        : '   float t = 1.0 - (1.0 / alpha) * log(exp(alpha) * (1.0 - vt) + vt);\n'
            else if (stretching.fun == 'circleLow') {
                if (stretching.alpha == 0)
                    //if (alpha == 0) return t;
                    fshString += '   float t = vt;\n'
                else if (stretching.alpha == 1)
                    // if (alpha == 1) return Math.sqrt(2 * t - t * t);
                    fshString += '   float t = sqrt(vt * (2.0 - vt));\n'
                else {
                    //const a = alpha / (1 - alpha);
                    //return Math.sqrt(1 / (a * a) + t * (2 / a + 2 - t)) - 1 / a;
                    fshString +=
                        '   float a = alpha / (1.0 - alpha);\n' +
                        '   float t = sqrt(1.0 / (a * a) + vt * ( 2.0/a + 2.0 - vt )) - 1.0 / a;\n'
                }
            } else if (stretching.fun == 'circleHigh') {
                // 1 - sCircleLow(1 - t, alpha)
                if (stretching.alpha == 0)
                    //if (alpha == 0) return t;
                    fshString += '   float t = vt;\n'
                else if (stretching.alpha == 1)
                    // if (alpha == 1) return Math.sqrt(2 * t - t * t);
                    fshString += '   float t = 1.0 - sqrt((1.0 - vt) * (1.0 + vt));\n'
                else {
                    //const a = alpha / (1 - alpha);
                    //return Math.sqrt(1 / (a * a) + (2 * t) / a + 2 * t - t * t) - 1 / a;
                    fshString +=
                        '   float a = alpha / (1.0 - alpha);\n' +
                        '   float t = 1.0 - sqrt(1.0 / (a * a) + (1.0-vt) * ( 2.0/a + 1.0 + vt )) + 1.0 / a;\n'
                }
            } else {
                console.error('Unexpected stretching function code: ' + stretching.fun)
                fshString += '   float t = vt;\n'
            }
        } else {
            fshString += '   float t = vt;\n'
        }

        //choose initial and final colors, and adjust t value
        if (colors.length == 1) fshString += '   vec4 cI=c0;\n   vec4 cF=c0;\n'
        else if (colors.length == 2) fshString += '   vec4 cI=c0;\n   vec4 cF=c1;\n'
        else {
            const nb = colors.length - 1
            const nbs = nb + '.0'
            fshString += '   vec4 cI;\n'
            fshString += '   vec4 cF;\n'
            fshString += '   if(t<1.0/' + nbs + ') { cI=c0; cF=c1; t=t*' + nbs + '; }\n'
            for (let i = 2; i < nb; i++)
                fshString +=
                    '   else if(t<' +
                    i +
                    '.0/' +
                    nbs +
                    ') { cI=c' +
                    (i - 1) +
                    '; cF=c' +
                    i +
                    '; t=' +
                    nbs +
                    '*t-' +
                    (i - 1) +
                    '.0; }\n'
            fshString +=
                '   else { cI=c' + (nb - 1) + '; cF=c' + nb + '; t=' + nbs + '*t-' + (nb - 1) + '.0; }\n'
        }

        //one single color
        if (colors.length == 1) fshString += '   gl_FragColor = vec4(c0[0], c0[1], c0[2], c0[3]);}\n'
        //set interpolated color, between initial and final one
        else fshString += '   gl_FragColor = mix(cI, cF, t);}\n'

        //console.log(fshString)

        /** @type {WebGLShader} */
        const fShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.FRAGMENT_SHADER, fshString)

        /** @type {WebGLProgram} */
        this.program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(gl, vShader, fShader)
        gl.useProgram(this.program)

        //set uniforms

        //sizePix
        //TODO: bug here. Seems to be limited to some threshold value (around 250).
        gl.uniform1f(gl.getUniformLocation(this.program, 'sizePix'), 1.0 * sizePix)

        //stretching alpha factor
        gl.uniform1f(gl.getUniformLocation(this.program, 'alpha'), stretching ? 1.0 * stretching.alpha : 0.0)

        //colors
        for (let i = 0; i < colors.length; i++) {
            const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(colors[i])

            let opacity = c.opacity
            if (c.opacity == 1 && globalOpacity != undefined) opacity = globalOpacity

            gl.uniform4fv(gl.getUniformLocation(this.program, 'c' + i), [
                +c.r / 255.0,
                +c.g / 255.0,
                +c.b / 255.0,
                +opacity,
            ])
        }
    }

    /**  */
    draw(verticesBuffer, tBuffer, transfoMat) {
        const gl = this.gl
        const program = this.program

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //t data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tBuffer), gl.STATIC_DRAW)
        const t = gl.getAttribLocation(program, 't')
        gl.vertexAttribPointer(t, 1, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(t)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/utils/WebGLSquareColoringCatAdvanced.js":
/*!**************************************************************************!*\
  !*** ./node_modules/gridviz/src/utils/WebGLSquareColoringCatAdvanced.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLSquareColoringCatAdvanced: () => (/* binding */ WebGLSquareColoringCatAdvanced)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./node_modules/gridviz/src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 * Color based on categories.
 */
class WebGLSquareColoringCatAdvanced {
    /**
     * @param {Array.<string>} colors
     */
    constructor(colors) {
        /**
         * @type {Array.<string>} */
        this.colors = colors

        /** Vector shader program
         * @type {string} */
        this.vshString = `
        attribute vec2 pos;
        uniform float sizePix;
        uniform mat3 mat;

        attribute float i;
        varying float vi;

        void main() {
          gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
          gl_PointSize = sizePix;
          vi = i;
        }
        `

        //prepare fragment shader code
        //declare the uniform and other variables
        const out = []
        out.push('precision mediump float;\nvarying float vi;\n')
        //add color uniforms
        out.push('uniform vec4')
        for (let i = 0; i < colors.length; i++) {
            if (i > 0) out.push(',')
            out.push(' c' + i)
        }
        out.push(';\n')
        //start the main function
        out.push('void main(void) {\n')
        //choose color i
        for (let i = 0; i < colors.length; i++) {
            if (i > 0) out.push('else ')
            out.push('if(vi==')
            out.push(i)
            out.push('.0) gl_FragColor = vec4(c')
            out.push(i)
            out.push('[0], c')
            out.push(i)
            out.push('[1], c')
            out.push(i)
            out.push('[2], c')
            out.push(i)
            out.push('[3]);\n')
        }
        out.push('else gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}')
        /** Fragment shader program
         * @type {string} */
        this.fshString = out.join('')
    }

    /**  */
    draw(gl, verticesBuffer, iBuffer, transfoMat, sizePix = 10) {
        /** @type {WebGLShader} */
        const vShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.VERTEX_SHADER, this.vshString)

        /** @type {WebGLShader} */
        const fShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.FRAGMENT_SHADER, this.fshString)

        /** @type {WebGLProgram} */
        const program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(gl, vShader, fShader)
        gl.useProgram(program)

        //set uniforms

        //sizePix
        gl.uniform1f(gl.getUniformLocation(program, 'sizePix'), 1.0 * sizePix)

        //colors
        for (let i = 0; i < this.colors.length; i++) {
            const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(this.colors[i])
            gl.uniform4fv(gl.getUniformLocation(program, 'c' + i), [
                +c.r / 255.0,
                +c.g / 255.0,
                +c.b / 255.0,
                +c.opacity,
            ])
        }

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //i data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(iBuffer), gl.STATIC_DRAW)
        const i = gl.getAttribLocation(program, 'i')
        gl.vertexAttribPointer(i, 1, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(i)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./node_modules/gridviz/src/utils/stretching.js":
/*!******************************************************!*\
  !*** ./node_modules/gridviz/src/utils/stretching.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circularInverseScale: () => (/* binding */ circularInverseScale),
/* harmony export */   circularScale: () => (/* binding */ circularScale),
/* harmony export */   exponentialScale: () => (/* binding */ exponentialScale),
/* harmony export */   logarithmicScale: () => (/* binding */ logarithmicScale),
/* harmony export */   powerInverseScale: () => (/* binding */ powerInverseScale),
/* harmony export */   powerScale: () => (/* binding */ powerScale),
/* harmony export */   sCircleHigh: () => (/* binding */ sCircleHigh),
/* harmony export */   sCircleLow: () => (/* binding */ sCircleLow),
/* harmony export */   sExp: () => (/* binding */ sExp),
/* harmony export */   sExpInverse: () => (/* binding */ sExpInverse),
/* harmony export */   sExpRev: () => (/* binding */ sExpRev),
/* harmony export */   sExpRevInverse: () => (/* binding */ sExpRevInverse),
/* harmony export */   sPow: () => (/* binding */ sPow),
/* harmony export */   sPowInverse: () => (/* binding */ sPowInverse),
/* harmony export */   sPowRev: () => (/* binding */ sPowRev),
/* harmony export */   sPowRevInverse: () => (/* binding */ sPowRevInverse)
/* harmony export */ });
//@ts-check



/**
 * Some function [0,1]->[0,1] to stretch range of values.
 * @see https://github.com/eurostat/gridviz/blob/master/docs/reference.md#stretching
 * @see https://observablehq.com/@jgaffuri/stretching
 */


const powerScale = (exponent = 3) => t => Math.pow(t, exponent)
const powerInverseScale = (exponent = 3) => t => 1 - Math.pow(1 - t, 1 / exponent)
const exponentialScale = (base = 3) => {
    if (base == 0) return t => t
    const a = (Math.exp(base) - 1)
    return t => (Math.exp(t * base) - 1) / a
}
const logarithmicScale = (base = 3) => {
    if (base == 0) return t => t
    return t => 1 - (1 / base) * Math.log(Math.exp(base) * (1 - t) + t)
}

const circularScale = (alpha = 0.8) => {
    if (alpha == 0) return t => t
    if (alpha == 1) return t => Math.sqrt(t * (2 - t))
    else {
        const a = alpha / (1 - alpha)
        return t => Math.sqrt(1 / (a * a) + t * (2 / a + 2 - t)) - 1 / a
    }
}
const circularInverseScale = (alpha = 0.8) => {
    const f = circularScale(alpha)
    return t => 1 - f(1 - t)
}








// deprecated


/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Polynomial
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} exponent 1: no stretching. <1: show low values. >1: show high values.
 * @returns {number} The stretched value, within [0,1]
 */
const sPow = (t, exponent = 3) => Math.pow(t, exponent)

/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Polynomial (reverse)
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} exponent 1: no stretching. <1: show low values. >1: show high values.
 * @returns {number} The stretched value, within [0,1]
 */
const sPowRev = (t, exponent = 3) => 1 - Math.pow(1 - t, 1 / exponent)

/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Exponential
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} base 0: no stretching. -Inf: show low values. Inf: show high values.
 * @returns {number} The stretched value, within [0,1]
 */
const sExp = (t, base = 3) => (base == 0 ? t : (Math.exp(t * base) - 1) / (Math.exp(base) - 1))

/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Exponential (reverse)
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} base 0: no stretching. -Inf: show low values. Inf: show high values.
 * @returns {number} The stretched value, within [0,1]
 */
const sExpRev = (t, base = 3) =>
    base == 0 ? t : 1 - (1 / base) * Math.log(Math.exp(base) * (1 - t) + t)

/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Circle, show low values
 * NB: sCircleHigh and sCircleLow are inverse functions of each other.
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} alpha 0: no stretching. 1: perfect circle section
 * @returns {number} The stretched value, within [0,1]
 */
const sCircleLow = (t, alpha = 0.8) => {
    if (alpha == 0) return t
    if (alpha == 1) return Math.sqrt(t * (2 - t))
    const a = alpha / (1 - alpha)
    return Math.sqrt(1 / (a * a) + t * (2 / a + 2 - t)) - 1 / a
}

/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Circle, show high values
 * NB: sCircleHigh and sCircleLow are inverse functions of each other.
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} alpha 0: no stretching. 1: perfect circle section
 * @returns {number} The stretched value, within [0,1]
 */
const sCircleHigh = (t, alpha = 0.8) => 1 - sCircleLow(1 - t, alpha)

/**
 * Inverse functions
 */

/**
 * Inverse function of sExp
 * @param {number} y
 * @param {number} base
 * @returns {number}
 */
const sExpInverse = (y, base = 3) =>
    base == 0 ? y : (1 / base) * Math.log(1 - y + y * Math.exp(base))

/**
 * Inverse function of sExpRev
 * @param {number} y
 * @param {number} base
 * @returns {number}
 */
const sExpRevInverse = (y, base = 3) => (Math.exp(-base * y) - 1) / (Math.exp(-base) - 1)

/**
 * Inverse function of sPow
 * @param {number} y
 * @param {number} exponent
 * @returns {number}
 */

const sPowInverse = (y, exponent = 3) => Math.pow(y, 1 / exponent)





/**
 * Inverse function of sPowRev
 * @param {number} y
 * @param {number} exponent
 * @returns {number}
 */
const sPowRevInverse = (y, exponent = 3) => 1 - Math.pow(1 - y, exponent)

//test code
/*
for (let i = 0; i <= 1; i += 0.001) {
  //const v = gviz.sExp(gviz.sExpInverse(i));
  //const v = gviz.sExpInverse(gviz.sExp(i));
  //const v = gviz.sExpRev(gviz.sExpRevInverse(i));
  //const v = gviz.sExpRevInverse(gviz.sExpRev(i));
  //const v = gviz.sPow(gviz.sPowInverse(i));
  //const v = gviz.sPowInverse(gviz.sPow(i));
  //const v = gviz.sPowRev(gviz.sPowRevInverse(i));
  //const v = gviz.sPowRevInverse(gviz.sPowRev(i));
  //const v = gviz.sCircleLow(gviz.sCircleHigh(i));
  //const v = gviz.sCircleHigh(gviz.sCircleLow(i));
  console.log(i - v)
}
*/


/***/ }),

/***/ "./node_modules/gridviz/src/utils/webGLUtils.js":
/*!******************************************************!*\
  !*** ./node_modules/gridviz/src/utils/webGLUtils.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkWebGLSupport: () => (/* binding */ checkWebGLSupport),
/* harmony export */   createShader: () => (/* binding */ createShader),
/* harmony export */   initShaderProgram: () => (/* binding */ initShaderProgram),
/* harmony export */   makeWebGLCanvas: () => (/* binding */ makeWebGLCanvas)
/* harmony export */ });
//@ts-check


/**
 * @param {string} width
 * @param {string} height
 * @param {object} opts
 * @returns {{canvas:HTMLCanvasElement, gl:WebGLRenderingContext}}
 */
function makeWebGLCanvas(width, height, opts) {
    const canvas = document.createElement('canvas')
    canvas.setAttribute('width', width)
    canvas.setAttribute('height', height)
    const gl = canvas.getContext('webgl', opts)
    if (!gl) {
        throw new Error('Unable to initialize WebGL. Your browser or machine may not support it.')
    }
    return { canvas: canvas, gl: gl }
}

/**
 * Initialize a shader program, so WebGL knows how to draw our data
 *
 * @param {WebGLRenderingContext} gl
 * @param  {...WebGLShader} shaders
 * @returns {WebGLProgram}
 */
function initShaderProgram(gl, ...shaders) {
    /** @type {WebGLProgram|null} */
    const program = gl.createProgram()
    if (program == null) throw new Error('Cannot create webGL program')
    for (const shader of shaders) gl.attachShader(program, shader)
    gl.linkProgram(program)
    if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program
    throw new Error(gl.getProgramInfoLog(program) || 'Cannot create webGL program (2)')
}

/**
 * Creates a shader of the given type, uploads the source and compiles it.
 *
 * @param {WebGLRenderingContext} gl
 * @param {number} type
 * @param  {...string} sources
 * @returns {WebGLShader}
 */
function createShader(gl, type, ...sources) {
    /** @type {WebGLShader|null} */
    const shader = gl.createShader(type)
    if (shader == null) throw new Error('Cannot create webGL shader')
    gl.shaderSource(shader, sources.join('\n'))
    gl.compileShader(shader)
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader
    throw new Error(gl.getShaderInfoLog(shader) || 'Cannot create webGL shader (2)')
}

/**
 * Check if webGL is supported
 *
 * @returns {boolean}
 */
function checkWebGLSupport() {
    try {
        const canvas = document.createElement('canvas')
        return !!window.WebGLRenderingContext &&
            (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
            ? true
            : false
    } catch (err) {
        return false
    }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/assemble.js":
/*!************************************************!*\
  !*** ./node_modules/hyparquet/src/assemble.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assembleLists: () => (/* binding */ assembleLists),
/* harmony export */   assembleNested: () => (/* binding */ assembleNested)
/* harmony export */ });
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");


/**
 * Dremel-assembly of arrays of values into lists
 *
 * Reconstructs a complex nested structure from flat arrays of definition and repetition levels,
 * according to Dremel encoding.
 *
 * @typedef {import('./types.d.ts').DecodedArray} DecodedArray
 * @typedef {import('./types.d.ts').FieldRepetitionType} FieldRepetitionType
 * @param {number[] | undefined} definitionLevels
 * @param {number[]} repetitionLevels
 * @param {DecodedArray} values
 * @param {(FieldRepetitionType | undefined)[]} repetitionPath
 * @param {number} maxDefinitionLevel definition level that corresponds to non-null
 * @param {number} maxRepetitionLevel repetition level that corresponds to a new row
 * @returns {DecodedArray} array of values
 */
function assembleLists(
  definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel, maxRepetitionLevel
) {
  const n = definitionLevels?.length || repetitionLevels.length
  let valueIndex = 0
  /** @type {any[]} */
  const output = []

  // Track state of nested structures
  const containerStack = [output]
  let currentContainer = output
  let currentDepth = 0 // schema depth
  let currentDefLevel = 0 // list depth
  let currentRepLevel = 0

  for (let i = 0; i < n; i++) {
    // assert(currentDefLevel === containerStack.length - 1)
    const def = definitionLevels?.length ? definitionLevels[i] : maxDefinitionLevel
    const rep = repetitionLevels[i]

    // Pop up to start of rep level
    while (currentDepth && (rep < currentRepLevel || repetitionPath[currentDepth] !== 'REPEATED')) {
      if (repetitionPath[currentDepth] !== 'REQUIRED') {
        containerStack.pop()
        currentDefLevel--
      }
      if (repetitionPath[currentDepth] === 'REPEATED') currentRepLevel--
      currentDepth--
    }
    // @ts-expect-error won't be empty
    currentContainer = containerStack.at(-1)

    // Go deeper to end of definition level
    while (
      (currentDepth < repetitionPath.length - 2 || repetitionPath[currentDepth + 1] === 'REPEATED') &&
      (currentDefLevel < def || repetitionPath[currentDepth + 1] === 'REQUIRED')
    ) {
      currentDepth++
      if (repetitionPath[currentDepth] !== 'REQUIRED') {
        /** @type {any[]} */
        const newList = []
        currentContainer.push(newList)
        currentContainer = newList
        containerStack.push(newList)
        currentDefLevel++
      }
      if (repetitionPath[currentDepth] === 'REPEATED') currentRepLevel++
    }

    // Add value or null based on definition level
    if (def === maxDefinitionLevel) {
      // assert(currentDepth === maxDefinitionLevel || currentDepth === repetitionPath.length - 2)
      currentContainer.push(values[valueIndex++])
    } else if (currentDepth === repetitionPath.length - 2) {
      currentContainer.push(null)
    } else {
      currentContainer.push([])
    }
  }

  // Handle edge cases for empty inputs or single-level data
  if (output.length === 0) {
    if (values.length > 0 && maxRepetitionLevel === 0) {
      return values // flat list
    }
    // return max definition level of nested lists
    for (let i = 0; i < maxDefinitionLevel; i++) {
      /** @type {any[]} */
      const newList = []
      currentContainer.push(newList)
      currentContainer = newList
    }
  }

  return output
}

/**
 * Assemble a nested structure from subcolumn data.
 * https://github.com/apache/parquet-format/blob/apache-parquet-format-2.10.0/LogicalTypes.md#nested-types
 *
 * @typedef {import('./types.d.ts').SchemaTree} SchemaTree
 * @param {Map<string, any[]>} subcolumnData
 * @param {SchemaTree} schema top-level schema element
 * @param {number} [depth] depth of nested structure
 */
function assembleNested(subcolumnData, schema, depth = 0) {
  const path = schema.path.join('.')
  const optional = schema.element.repetition_type === 'OPTIONAL'
  const nextDepth = optional ? depth + 1 : depth

  if ((0,_schema_js__WEBPACK_IMPORTED_MODULE_0__.isListLike)(schema)) {
    let sublist = schema.children[0]
    let subDepth = nextDepth
    if (sublist.children.length === 1) {
      sublist = sublist.children[0]
      subDepth++
    }
    assembleNested(subcolumnData, sublist, subDepth)

    const subcolumn = sublist.path.join('.')
    const values = subcolumnData.get(subcolumn)
    if (!values) throw new Error('parquet list-like column missing values')
    if (optional) flattenAtDepth(values, depth)
    subcolumnData.set(path, values)
    subcolumnData.delete(subcolumn)
    return
  }

  if ((0,_schema_js__WEBPACK_IMPORTED_MODULE_0__.isMapLike)(schema)) {
    const mapName = schema.children[0].element.name

    // Assemble keys and values
    assembleNested(subcolumnData, schema.children[0].children[0], nextDepth + 1)
    assembleNested(subcolumnData, schema.children[0].children[1], nextDepth + 1)

    const keys = subcolumnData.get(`${path}.${mapName}.key`)
    const values = subcolumnData.get(`${path}.${mapName}.value`)

    if (!keys) throw new Error('parquet map-like column missing keys')
    if (!values) throw new Error('parquet map-like column missing values')
    if (keys.length !== values.length) {
      throw new Error('parquet map-like column key/value length mismatch')
    }

    const out = assembleMaps(keys, values, nextDepth)
    if (optional) flattenAtDepth(out, depth)

    subcolumnData.delete(`${path}.${mapName}.key`)
    subcolumnData.delete(`${path}.${mapName}.value`)
    subcolumnData.set(path, out)
    return
  }

  // Struct-like column
  if (schema.children.length) {
    // construct a meta struct and then invert
    /** @type {Record<string, any>} */
    const struct = {}
    for (const child of schema.children) {
      assembleNested(subcolumnData, child, nextDepth)
      const childData = subcolumnData.get(child.path.join('.'))
      if (!childData) throw new Error('parquet struct-like column missing child data')
      struct[child.element.name] = childData
    }
    // remove children
    for (const child of schema.children) {
      subcolumnData.delete(child.path.join('.'))
    }
    // invert struct by depth
    const invertDepth = schema.element.repetition_type === 'REQUIRED' ? depth : depth + 1
    const inverted = invertStruct(struct, invertDepth)
    if (optional) flattenAtDepth(inverted, depth)
    subcolumnData.set(path, inverted)
  }
  // assert(schema.element.repetition_type !== 'REPEATED')
}

/**
 * @param {any[]} arr
 * @param {number} depth
 */
function flattenAtDepth(arr, depth) {
  for (let i = 0; i < arr.length; i++) {
    if (depth) {
      flattenAtDepth(arr[i], depth - 1)
    } else {
      arr[i] = arr[i][0]
    }
  }
}

/**
 * @param {any[]} keys
 * @param {any[]} values
 * @param {number} depth
 * @returns {any[]}
 */
function assembleMaps(keys, values, depth) {
  const out = []
  for (let i = 0; i < keys.length; i++) {
    if (depth) {
      out.push(assembleMaps(keys[i], values[i], depth - 1)) // go deeper
    } else {
      if (keys[i]) {
        /** @type {Record<string, any>} */
        const obj = {}
        for (let j = 0; j < keys[i].length; j++) {
          const value = values[i][j]
          obj[keys[i][j]] = value === undefined ? null : value
        }
        out.push(obj)
      } else {
        out.push(undefined)
      }
    }
  }
  return out
}

/**
 * Invert a struct-like object by depth.
 *
 * @param {Record<string, any[]>} struct
 * @param {number} depth
 * @returns {any[]}
 */
function invertStruct(struct, depth) {
  const keys = Object.keys(struct)
  const length = struct[keys[0]]?.length
  const out = []
  for (let i = 0; i < length; i++) {
    /** @type {Record<string, any>} */
    const obj = {}
    for (const key of keys) {
      obj[key] = struct[key][i]
    }
    if (depth) {
      out.push(invertStruct(obj, depth - 1)) // deeper
    } else {
      out.push(obj)
    }
  }
  return out
}


/***/ }),

/***/ "./node_modules/hyparquet/src/column.js":
/*!**********************************************!*\
  !*** ./node_modules/hyparquet/src/column.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decompressPage: () => (/* binding */ decompressPage),
/* harmony export */   getColumnOffset: () => (/* binding */ getColumnOffset),
/* harmony export */   readColumn: () => (/* binding */ readColumn)
/* harmony export */ });
/* harmony import */ var _assemble_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assemble.js */ "./node_modules/hyparquet/src/assemble.js");
/* harmony import */ var _convert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./convert.js */ "./node_modules/hyparquet/src/convert.js");
/* harmony import */ var _datapage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./datapage.js */ "./node_modules/hyparquet/src/datapage.js");
/* harmony import */ var _datapageV2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./datapageV2.js */ "./node_modules/hyparquet/src/datapageV2.js");
/* harmony import */ var _header_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./header.js */ "./node_modules/hyparquet/src/header.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");
/* harmony import */ var _snappy_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./snappy.js */ "./node_modules/hyparquet/src/snappy.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./node_modules/hyparquet/src/utils.js");









/**
 * Parse column data from a buffer.
 *
 * @typedef {import('./types.js').ColumnMetaData} ColumnMetaData
 * @typedef {import('./types.js').DecodedArray} DecodedArray
 * @param {import('./types.js').DataReader} reader
 * @param {import('./types.js').RowGroup} rowGroup row group metadata
 * @param {ColumnMetaData} columnMetadata column metadata
 * @param {import('./types.js').SchemaTree[]} schemaPath schema path for the column
 * @param {import('./hyparquet.js').ParquetReadOptions} options read options
 * @returns {any[]} array of values
 */
function readColumn(reader, rowGroup, columnMetadata, schemaPath, { compressors, utf8 }) {
  const { element } = schemaPath[schemaPath.length - 1]
  /** @type {DecodedArray | undefined} */
  let dictionary = undefined
  let seen = 0
  /** @type {any[]} */
  const rowData = []

  while (seen < rowGroup.num_rows) {
    // parse column header
    const header = (0,_header_js__WEBPACK_IMPORTED_MODULE_4__.parquetHeader)(reader)
    // assert(header.compressed_page_size !== undefined)

    // read compressed_page_size bytes starting at offset
    const compressedBytes = new Uint8Array(
      reader.view.buffer, reader.view.byteOffset + reader.offset, header.compressed_page_size
    )

    // parse page data by type
    /** @type {DecodedArray} */
    let values
    if (header.type === 'DATA_PAGE') {
      const daph = header.data_page_header
      if (!daph) throw new Error('parquet data page header is undefined')

      const page = decompressPage(compressedBytes, Number(header.uncompressed_page_size), columnMetadata.codec, compressors)
      const { definitionLevels, repetitionLevels, dataPage } = (0,_datapage_js__WEBPACK_IMPORTED_MODULE_2__.readDataPage)(page, daph, schemaPath, columnMetadata)
      seen += daph.num_values
      // assert(!daph.statistics || daph.statistics.null_count === BigInt(daph.num_values - dataPage.length))

      // construct output values: skip nulls and construct lists
      values = (0,_convert_js__WEBPACK_IMPORTED_MODULE_1__.dereferenceDictionary)(dictionary, dataPage)
      values = (0,_convert_js__WEBPACK_IMPORTED_MODULE_1__.convert)(values, element, utf8)
      if (repetitionLevels.length || definitionLevels?.length) {
        // Use repetition levels to construct lists
        const maxDefinitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_5__.getMaxDefinitionLevel)(schemaPath)
        const maxRepetitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_5__.getMaxRepetitionLevel)(schemaPath)
        const repetitionPath = schemaPath.map(({ element }) => element.repetition_type)
        values = (0,_assemble_js__WEBPACK_IMPORTED_MODULE_0__.assembleLists)(
          definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel, maxRepetitionLevel
        )
      } else {
        // wrap nested flat data by depth
        for (let i = 2; i < schemaPath.length; i++) {
          if (schemaPath[i].element.repetition_type !== 'REQUIRED') {
            values = Array.from(values, e => [e])
          }
        }
      }
      // assert(BigInt(values.length) === rowGroup.num_rows)
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.concat)(rowData, values)
    } else if (header.type === 'DATA_PAGE_V2') {
      const daph2 = header.data_page_header_v2
      if (!daph2) throw new Error('parquet data page header v2 is undefined')

      const { definitionLevels, repetitionLevels, dataPage } = (0,_datapageV2_js__WEBPACK_IMPORTED_MODULE_3__.readDataPageV2)(
        compressedBytes, header, schemaPath, columnMetadata, compressors
      )
      seen += daph2.num_values

      values = (0,_convert_js__WEBPACK_IMPORTED_MODULE_1__.dereferenceDictionary)(dictionary, dataPage)
      values = (0,_convert_js__WEBPACK_IMPORTED_MODULE_1__.convert)(values, element, utf8)
      if (repetitionLevels.length || definitionLevels?.length) {
        // Use repetition levels to construct lists
        const maxDefinitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_5__.getMaxDefinitionLevel)(schemaPath)
        const maxRepetitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_5__.getMaxRepetitionLevel)(schemaPath)
        const repetitionPath = schemaPath.map(({ element }) => element.repetition_type)
        values = (0,_assemble_js__WEBPACK_IMPORTED_MODULE_0__.assembleLists)(
          definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel, maxRepetitionLevel
        )
      }
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.concat)(rowData, values)
    } else if (header.type === 'DICTIONARY_PAGE') {
      const diph = header.dictionary_page_header
      if (!diph) throw new Error('parquet dictionary page header is undefined')

      const page = decompressPage(
        compressedBytes, Number(header.uncompressed_page_size), columnMetadata.codec, compressors
      )
      dictionary = (0,_datapage_js__WEBPACK_IMPORTED_MODULE_2__.readDictionaryPage)(page, diph, columnMetadata, element.type_length)
    } else {
      throw new Error(`parquet unsupported page type: ${header.type}`)
    }
    reader.offset += header.compressed_page_size
  }
  if (rowData.length !== Number(rowGroup.num_rows)) {
    throw new Error(`parquet row data length ${rowData.length} does not match row group length ${rowGroup.num_rows}}`)
  }
  return rowData
}

/**
 * Find the start byte offset for a column chunk.
 *
 * @param {ColumnMetaData} columnMetadata
 * @returns {number} byte offset
 */
function getColumnOffset({ dictionary_page_offset, data_page_offset }) {
  let columnOffset = dictionary_page_offset
  if (!dictionary_page_offset || data_page_offset < dictionary_page_offset) {
    columnOffset = data_page_offset
  }
  return Number(columnOffset)
}

/**
 * @param {Uint8Array} compressedBytes
 * @param {number} uncompressed_page_size
 * @param {import('./types.js').CompressionCodec} codec
 * @param {import('./types.js').Compressors | undefined} compressors
 * @returns {Uint8Array}
 */
function decompressPage(compressedBytes, uncompressed_page_size, codec, compressors) {
  /** @type {Uint8Array} */
  let page
  const customDecompressor = compressors?.[codec]
  if (codec === 'UNCOMPRESSED') {
    page = compressedBytes
  } else if (customDecompressor) {
    page = customDecompressor(compressedBytes, uncompressed_page_size)
  } else if (codec === 'SNAPPY') {
    page = new Uint8Array(uncompressed_page_size)
    ;(0,_snappy_js__WEBPACK_IMPORTED_MODULE_6__.snappyUncompress)(compressedBytes, page)
  } else {
    throw new Error(`parquet unsupported compression codec: ${codec}`)
  }
  if (page?.length !== uncompressed_page_size) {
    throw new Error(`parquet decompressed page length ${page?.length} does not match header ${uncompressed_page_size}`)
  }
  return page
}


/***/ }),

/***/ "./node_modules/hyparquet/src/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/hyparquet/src/constants.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompressionCodec: () => (/* binding */ CompressionCodec),
/* harmony export */   ConvertedType: () => (/* binding */ ConvertedType),
/* harmony export */   Encoding: () => (/* binding */ Encoding),
/* harmony export */   FieldRepetitionType: () => (/* binding */ FieldRepetitionType),
/* harmony export */   PageType: () => (/* binding */ PageType),
/* harmony export */   ParquetType: () => (/* binding */ ParquetType),
/* harmony export */   logicalTypeType: () => (/* binding */ logicalTypeType)
/* harmony export */ });
/**
 * @type {import('./types.js').ParquetType[]}
 */
const ParquetType = [
  'BOOLEAN',
  'INT32',
  'INT64',
  'INT96', // deprecated
  'FLOAT',
  'DOUBLE',
  'BYTE_ARRAY',
  'FIXED_LEN_BYTE_ARRAY',
]

const Encoding = [
  'PLAIN',
  undefined,
  'PLAIN_DICTIONARY',
  'RLE',
  'BIT_PACKED', // deprecated
  'DELTA_BINARY_PACKED',
  'DELTA_LENGTH_BYTE_ARRAY',
  'DELTA_BYTE_ARRAY',
  'RLE_DICTIONARY',
  'BYTE_STREAM_SPLIT',
]

const FieldRepetitionType = [
  'REQUIRED',
  'OPTIONAL',
  'REPEATED',
]

/**
 * @type {import('./types.js').ConvertedType[]}
 */
const ConvertedType = [
  'UTF8',
  'MAP',
  'MAP_KEY_VALUE',
  'LIST',
  'ENUM',
  'DECIMAL',
  'DATE',
  'TIME_MILLIS',
  'TIME_MICROS',
  'TIMESTAMP_MILLIS',
  'TIMESTAMP_MICROS',
  'UINT_8',
  'UINT_16',
  'UINT_32',
  'UINT_64',
  'INT_8',
  'INT_16',
  'INT_32',
  'INT_64',
  'JSON',
  'BSON',
  'INTERVAL',
]

/**
 * @type {import('./types.js').LogicalTypeType[]}
 */
const logicalTypeType = [
  'NULL',
  'STRING',
  'MAP',
  'LIST',
  'ENUM',
  'DECIMAL',
  'DATE',
  'TIME',
  'TIMESTAMP',
  'INTERVAL',
  'INTEGER',
  'NULL',
  'JSON',
  'BSON',
  'UUID',
]

const CompressionCodec = [
  'UNCOMPRESSED',
  'SNAPPY',
  'GZIP',
  'LZO',
  'BROTLI',
  'LZ4',
  'ZSTD',
  'LZ4_RAW',
]

/**
 * @type {import('./types.js').PageType[]}
 */
const PageType = [
  'DATA_PAGE',
  'INDEX_PAGE',
  'DICTIONARY_PAGE',
  'DATA_PAGE_V2',
]


/***/ }),

/***/ "./node_modules/hyparquet/src/convert.js":
/*!***********************************************!*\
  !*** ./node_modules/hyparquet/src/convert.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convert: () => (/* binding */ convert),
/* harmony export */   dereferenceDictionary: () => (/* binding */ dereferenceDictionary),
/* harmony export */   parseFloat16: () => (/* binding */ parseFloat16)
/* harmony export */ });
const dayMillis = 86400000 // 1 day in milliseconds

/**
 * Convert known types from primitive to rich.
 *
 * @typedef {import('./types.js').DecodedArray} DecodedArray
 * @param {DecodedArray} data series of primitive types
 * @param {import('./types.js').SchemaElement} schemaElement schema element for the data
 * @param {boolean | undefined} utf8 decode bytes as utf8?
 * @returns {DecodedArray} series of rich types
 */
function convert(data, schemaElement, utf8 = true) {
  const ctype = schemaElement.converted_type
  if (ctype === 'DECIMAL') {
    const scale = schemaElement.scale || 0
    const factor = Math.pow(10, -scale)
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      if (data[0] instanceof Uint8Array) {
        arr[i] = parseDecimal(data[i]) * factor
      } else {
        arr[i] = Number(data[i]) * factor
      }
    }
    return arr
  }
  if (ctype === undefined && schemaElement.type === 'INT96') {
    return Array.from(data).map(parseInt96Date)
  }
  if (ctype === 'DATE') {
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = new Date(data[i] * dayMillis)
    }
    return arr
  }
  if (ctype === 'TIMESTAMP_MILLIS') {
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = new Date(Number(data[i]))
    }
    return arr
  }
  if (ctype === 'TIMESTAMP_MICROS') {
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = new Date(Number(data[i] / 1000n))
    }
    return arr
  }
  if (ctype === 'JSON') {
    const decoder = new TextDecoder()
    return data.map(v => JSON.parse(decoder.decode(v)))
  }
  if (ctype === 'BSON') {
    throw new Error('parquet bson not supported')
  }
  if (ctype === 'INTERVAL') {
    throw new Error('parquet interval not supported')
  }
  if (ctype === 'UTF8' || utf8 && schemaElement.type === 'BYTE_ARRAY') {
    const decoder = new TextDecoder()
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = data[i] && decoder.decode(data[i])
    }
    return arr
  }
  if (ctype === 'UINT_64') {
    const arr = new BigUint64Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = BigInt(data[i])
    }
    return arr
  }
  const logicalType = schemaElement.logical_type?.type
  if (logicalType === 'FLOAT16') {
    return Array.from(data).map(parseFloat16)
  }
  if (logicalType === 'TIMESTAMP') {
    const arr = new Array(data.length)
    for (let i = 0; i < arr.length; i++) {
      arr[i] = new Date(Number(data[i]))
    }
    return arr
  }
  return data
}

/**
 * @param {Uint8Array} bytes
 * @returns {number}
 */
function parseDecimal(bytes) {
  // TODO: handle signed
  let value = 0
  for (const byte of bytes) {
    value = value << 8 | byte
  }
  return value
}

/**
 * @param {bigint} value
 * @returns {Date}
 */
function parseInt96Date(value) {
  const days = Number((value >> 64n) - 2440588n)
  const nano = Number((value & 0xffffffffffffffffn) / 1000000n)
  const millis = days * dayMillis + nano
  return new Date(millis)
}

/**
 * @param {Uint8Array | undefined} bytes
 * @returns {number | undefined}
 */
function parseFloat16(bytes) {
  if (!bytes) return undefined
  const int16 = bytes[1] << 8 | bytes[0]
  const sign = int16 >> 15 ? -1 : 1
  const exp = int16 >> 10 & 0x1f
  const frac = int16 & 0x3ff
  if (exp === 0) return sign * Math.pow(2, -14) * (frac / 1024) // subnormals
  if (exp === 0x1f) return frac ? NaN : sign * Infinity
  return sign * Math.pow(2, exp - 15) * (1 + frac / 1024)
}

/**
 * Map data to dictionary values in place.
 *
 * @param {DecodedArray | undefined} dictionary
 * @param {DecodedArray} dataPage
 * @returns {DecodedArray}
 */
function dereferenceDictionary(dictionary, dataPage) {
  let output = dataPage
  if (dictionary) {
    if (dataPage instanceof Uint8Array && !(dictionary instanceof Uint8Array)) {
      // upgrade dataPage to match dictionary type
      // @ts-expect-error not my fault typescript doesn't understand constructors
      output = new dictionary.constructor(dataPage.length)
    }
    for (let i = 0; i < dataPage.length; i++) {
      output[i] = dictionary[dataPage[i]]
    }
  }
  return output
}


/***/ }),

/***/ "./node_modules/hyparquet/src/datapage.js":
/*!************************************************!*\
  !*** ./node_modules/hyparquet/src/datapage.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readDataPage: () => (/* binding */ readDataPage),
/* harmony export */   readDictionaryPage: () => (/* binding */ readDictionaryPage)
/* harmony export */ });
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encoding.js */ "./node_modules/hyparquet/src/encoding.js");
/* harmony import */ var _plain_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plain.js */ "./node_modules/hyparquet/src/plain.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");




/**
 * Read a data page from uncompressed reader.
 *
 * @typedef {import("./types.d.ts").DataPage} DataPage
 * @typedef {import("./types.d.ts").ColumnMetaData} ColumnMetaData
 * @typedef {import("./types.d.ts").DataPageHeader} DataPageHeader
 * @typedef {import("./types.d.ts").SchemaTree} SchemaTree
 * @typedef {import("./types.d.ts").DecodedArray} DecodedArray
 * @param {Uint8Array} bytes raw page data (should already be decompressed)
 * @param {DataPageHeader} daph data page header
 * @param {SchemaTree[]} schemaPath
 * @param {ColumnMetaData} columnMetadata
 * @returns {DataPage} definition levels, repetition levels, and array of values
 */
function readDataPage(bytes, daph, schemaPath, { type }) {
  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)
  const reader = { view, offset: 0 }
  /** @type {DecodedArray} */
  let dataPage

  // repetition and definition levels
  const repetitionLevels = readRepetitionLevels(reader, daph, schemaPath)
  const { definitionLevels, numNulls } = readDefinitionLevels(reader, daph, schemaPath)

  // read values based on encoding
  const nValues = daph.num_values - numNulls
  if (daph.encoding === 'PLAIN') {
    const { type_length } = schemaPath[schemaPath.length - 1].element
    dataPage = (0,_plain_js__WEBPACK_IMPORTED_MODULE_1__.readPlain)(reader, type, nValues, type_length)
  } else if (
    daph.encoding === 'PLAIN_DICTIONARY' ||
    daph.encoding === 'RLE_DICTIONARY' ||
    daph.encoding === 'RLE'
  ) {
    const bitWidth = type === 'BOOLEAN' ? 1 : view.getUint8(reader.offset++)
    if (bitWidth) {
      dataPage = new Array(nValues)
      ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.readRleBitPackedHybrid)(reader, bitWidth, view.byteLength - reader.offset, dataPage)
    } else {
      dataPage = new Uint8Array(nValues) // nValue zeroes
    }
  } else if (daph.encoding === 'BYTE_STREAM_SPLIT') {
    const { type_length } = schemaPath[schemaPath.length - 1].element
    dataPage = (0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.byteStreamSplit)(reader, nValues, type, type_length)
  } else {
    throw new Error(`parquet unsupported encoding: ${daph.encoding}`)
  }

  return { definitionLevels, repetitionLevels, dataPage }
}

/**
 * @param {Uint8Array} bytes raw page data
 * @param {import("./types.d.ts").DictionaryPageHeader} diph dictionary page header
 * @param {ColumnMetaData} columnMetadata
 * @param {number | undefined} typeLength - type_length from schema
 * @returns {DecodedArray}
 */
function readDictionaryPage(bytes, diph, columnMetadata, typeLength) {
  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)
  const reader = { view, offset: 0 }
  return (0,_plain_js__WEBPACK_IMPORTED_MODULE_1__.readPlain)(reader, columnMetadata.type, diph.num_values, typeLength)
}

/**
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @param {DataReader} reader data view for the page
 * @param {DataPageHeader} daph data page header
 * @param {SchemaTree[]} schemaPath
 * @returns {any[]} repetition levels and number of bytes read
 */
function readRepetitionLevels(reader, daph, schemaPath) {
  if (schemaPath.length > 1) {
    const maxRepetitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_2__.getMaxRepetitionLevel)(schemaPath)
    if (maxRepetitionLevel) {
      const values = new Array(daph.num_values)
      ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.readRleBitPackedHybrid)(reader, (0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.bitWidth)(maxRepetitionLevel), 0, values)
      return values
    }
  }
  return []
}

/**
 * @param {DataReader} reader data view for the page
 * @param {DataPageHeader} daph data page header
 * @param {SchemaTree[]} schemaPath
 * @returns {{ definitionLevels: number[], numNulls: number }} definition levels
 */
function readDefinitionLevels(reader, daph, schemaPath) {
  const maxDefinitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_2__.getMaxDefinitionLevel)(schemaPath)
  if (!maxDefinitionLevel) return { definitionLevels: [], numNulls: 0 }

  const definitionLevels = new Array(daph.num_values)
  ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.readRleBitPackedHybrid)(reader, (0,_encoding_js__WEBPACK_IMPORTED_MODULE_0__.bitWidth)(maxDefinitionLevel), 0, definitionLevels)

  // count nulls
  let numNulls = daph.num_values
  for (const def of definitionLevels) {
    if (def === maxDefinitionLevel) numNulls--
  }
  if (numNulls === 0) definitionLevels.length = 0

  return { definitionLevels, numNulls }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/datapageV2.js":
/*!**************************************************!*\
  !*** ./node_modules/hyparquet/src/datapageV2.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readDataPageV2: () => (/* binding */ readDataPageV2),
/* harmony export */   readRepetitionLevelsV2: () => (/* binding */ readRepetitionLevelsV2)
/* harmony export */ });
/* harmony import */ var _column_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./column.js */ "./node_modules/hyparquet/src/column.js");
/* harmony import */ var _delta_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./delta.js */ "./node_modules/hyparquet/src/delta.js");
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ "./node_modules/hyparquet/src/encoding.js");
/* harmony import */ var _plain_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plain.js */ "./node_modules/hyparquet/src/plain.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");






/**
 * Read a data page from the given Uint8Array.
 *
 * @typedef {import("./types.d.ts").DataPage} DataPage
 * @typedef {import("./types.d.ts").ColumnMetaData} ColumnMetaData
 * @typedef {import("./types.d.ts").Compressors} Compressors
 * @typedef {import("./types.d.ts").DataPageHeaderV2} DataPageHeaderV2
 * @typedef {import("./types.d.ts").SchemaTree} SchemaTree
 * @param {Uint8Array} compressedBytes raw page data
 * @param {import("./types.d.ts").PageHeader} ph page header
 * @param {SchemaTree[]} schemaPath
 * @param {ColumnMetaData} columnMetadata
 * @param {Compressors | undefined} compressors
 * @returns {DataPage} definition levels, repetition levels, and array of values
 */
function readDataPageV2(compressedBytes, ph, schemaPath, columnMetadata, compressors) {
  const view = new DataView(compressedBytes.buffer, compressedBytes.byteOffset, compressedBytes.byteLength)
  const reader = { view, offset: 0 }
  const { codec, type } = columnMetadata
  const daph2 = ph.data_page_header_v2
  if (!daph2) throw new Error('parquet data page header v2 is undefined')

  // repetition levels
  const repetitionLevels = readRepetitionLevelsV2(reader, daph2, schemaPath)
  reader.offset = daph2.repetition_levels_byte_length // readVarInt() => len for boolean v2?

  // definition levels
  const definitionLevels = readDefinitionLevelsV2(reader, daph2, schemaPath)
  // assert(reader.offset === daph2.repetition_levels_byte_length + daph2.definition_levels_byte_length)

  const uncompressedPageSize = ph.uncompressed_page_size - daph2.definition_levels_byte_length - daph2.repetition_levels_byte_length

  let page = compressedBytes.subarray(reader.offset)
  if (daph2.is_compressed !== false) {
    page = (0,_column_js__WEBPACK_IMPORTED_MODULE_0__.decompressPage)(page, uncompressedPageSize, codec, compressors)
  }
  const pageView = new DataView(page.buffer, page.byteOffset, page.byteLength)
  const pageReader = { view: pageView, offset: 0 }

  // read values based on encoding
  /** @type {import('./types.d.ts').DecodedArray} */
  let dataPage
  const nValues = daph2.num_values - daph2.num_nulls
  if (daph2.encoding === 'PLAIN') {
    const { type_length } = schemaPath[schemaPath.length - 1].element
    dataPage = (0,_plain_js__WEBPACK_IMPORTED_MODULE_3__.readPlain)(pageReader, type, nValues, type_length)
  } else if (daph2.encoding === 'RLE') {
    // assert(columnMetadata.type === 'BOOLEAN')
    dataPage = new Array(nValues)
    ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.readRleBitPackedHybrid)(pageReader, 1, 0, dataPage)
    dataPage = dataPage.map(x => !!x)
  } else if (
    daph2.encoding === 'PLAIN_DICTIONARY' ||
    daph2.encoding === 'RLE_DICTIONARY'
  ) {
    const bitWidth = pageView.getUint8(pageReader.offset++)
    dataPage = new Array(nValues)
    ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.readRleBitPackedHybrid)(pageReader, bitWidth, uncompressedPageSize - 1, dataPage)
  } else if (daph2.encoding === 'DELTA_BINARY_PACKED') {
    const int32 = type === 'INT32'
    dataPage = int32 ? new Int32Array(nValues) : new BigInt64Array(nValues)
    ;(0,_delta_js__WEBPACK_IMPORTED_MODULE_1__.deltaBinaryUnpack)(pageReader, nValues, dataPage)
  } else if (daph2.encoding === 'DELTA_LENGTH_BYTE_ARRAY') {
    dataPage = new Array(nValues)
    ;(0,_delta_js__WEBPACK_IMPORTED_MODULE_1__.deltaLengthByteArray)(pageReader, nValues, dataPage)
  } else if (daph2.encoding === 'DELTA_BYTE_ARRAY') {
    dataPage = new Array(nValues)
    ;(0,_delta_js__WEBPACK_IMPORTED_MODULE_1__.deltaByteArray)(pageReader, nValues, dataPage)
  } else if (daph2.encoding === 'BYTE_STREAM_SPLIT') {
    const { type_length } = schemaPath[schemaPath.length - 1].element
    dataPage = (0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.byteStreamSplit)(reader, nValues, type, type_length)
  } else {
    throw new Error(`parquet unsupported encoding: ${daph2.encoding}`)
  }

  return { definitionLevels, repetitionLevels, dataPage }
}

/**
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @param {DataReader} reader
 * @param {DataPageHeaderV2} daph2 data page header v2
 * @param {SchemaTree[]} schemaPath
 * @returns {any[]} repetition levels
 */
function readRepetitionLevelsV2(reader, daph2, schemaPath) {
  const maxRepetitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_4__.getMaxRepetitionLevel)(schemaPath)
  if (!maxRepetitionLevel) return []

  const values = new Array(daph2.num_values)
  ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.readRleBitPackedHybrid)(
    reader, (0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.bitWidth)(maxRepetitionLevel), daph2.repetition_levels_byte_length, values
  )
  return values
}

/**
 * @param {DataReader} reader
 * @param {DataPageHeaderV2} daph2 data page header v2
 * @param {SchemaTree[]} schemaPath
 * @returns {number[] | undefined} definition levels
 */
function readDefinitionLevelsV2(reader, daph2, schemaPath) {
  const maxDefinitionLevel = (0,_schema_js__WEBPACK_IMPORTED_MODULE_4__.getMaxDefinitionLevel)(schemaPath)
  if (maxDefinitionLevel) {
    // V2 we know the length
    const values = new Array(daph2.num_values)
    ;(0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.readRleBitPackedHybrid)(reader, (0,_encoding_js__WEBPACK_IMPORTED_MODULE_2__.bitWidth)(maxDefinitionLevel), daph2.definition_levels_byte_length, values)
    return values
  }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/delta.js":
/*!*********************************************!*\
  !*** ./node_modules/hyparquet/src/delta.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deltaBinaryUnpack: () => (/* binding */ deltaBinaryUnpack),
/* harmony export */   deltaByteArray: () => (/* binding */ deltaByteArray),
/* harmony export */   deltaLengthByteArray: () => (/* binding */ deltaLengthByteArray)
/* harmony export */ });
/* harmony import */ var _thrift_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thrift.js */ "./node_modules/hyparquet/src/thrift.js");


/**
 * @typedef {import('./types.d.ts').DataReader} DataReader
 * @param {DataReader} reader
 * @param {number} count number of values to read
 * @param {Int32Array | BigInt64Array} output
 */
function deltaBinaryUnpack(reader, count, output) {
  const int32 = output instanceof Int32Array
  const blockSize = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readVarInt)(reader)
  const miniblockPerBlock = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readVarInt)(reader)
  ;(0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readVarInt)(reader) // assert(=== count)
  let value = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readZigZagBigInt)(reader) // first value
  let outputIndex = 0
  output[outputIndex++] = int32 ? Number(value) : value

  const valuesPerMiniblock = blockSize / miniblockPerBlock

  while (outputIndex < count) {
    // new block
    const minDelta = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readZigZagBigInt)(reader)
    const bitWidths = new Uint8Array(miniblockPerBlock)
    for (let i = 0; i < miniblockPerBlock; i++) {
      bitWidths[i] = reader.view.getUint8(reader.offset++)
    }

    for (let i = 0; i < miniblockPerBlock && outputIndex < count; i++) {
      // new miniblock
      const bitWidth = BigInt(bitWidths[i])
      if (bitWidth) {
        let bitpackPos = 0n
        let miniblockCount = valuesPerMiniblock
        const mask = (1n << bitWidth) - 1n
        while (miniblockCount && outputIndex < count) {
          let bits = BigInt(reader.view.getUint8(reader.offset)) >> bitpackPos & mask // TODO: don't re-read value every time
          bitpackPos += bitWidth
          while (bitpackPos >= 8) {
            bitpackPos -= 8n
            reader.offset++
            if (bitpackPos) {
              bits |= BigInt(reader.view.getUint8(reader.offset)) << bitWidth - bitpackPos & mask
            }
          }
          const delta = minDelta + bits
          value += delta
          output[outputIndex++] = int32 ? Number(value) : value
          miniblockCount--
        }
        if (miniblockCount) {
          // consume leftover miniblock
          reader.offset += Math.ceil((miniblockCount * Number(bitWidth) + Number(bitpackPos)) / 8)
        }
      } else {
        for (let j = 0; j < valuesPerMiniblock && outputIndex < count; j++) {
          value += minDelta
          output[outputIndex++] = int32 ? Number(value) : value
        }
      }
    }
  }
}

/**
 * @param {DataReader} reader
 * @param {number} count
 * @param {Uint8Array[]} output
 */
function deltaLengthByteArray(reader, count, output) {
  const lengths = new Int32Array(count)
  deltaBinaryUnpack(reader, count, lengths)
  for (let i = 0; i < count; i++) {
    output[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, lengths[i])
    reader.offset += lengths[i]
  }
}

/**
 * @param {DataReader} reader
 * @param {number} count
 * @param {Uint8Array[]} output
 */
function deltaByteArray(reader, count, output) {
  const prefixData = new Int32Array(count)
  deltaBinaryUnpack(reader, count, prefixData)
  const suffixData = new Int32Array(count)
  deltaBinaryUnpack(reader, count, suffixData)

  for (let i = 0; i < count; i++) {
    const suffix = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, suffixData[i])
    if (prefixData[i]) {
      // copy from previous value
      output[i] = new Uint8Array(prefixData[i] + suffixData[i])
      output[i].set(output[i - 1].subarray(0, prefixData[i]))
      output[i].set(suffix, prefixData[i])
    } else {
      output[i] = suffix
    }
    reader.offset += suffixData[i]
  }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/encoding.js":
/*!************************************************!*\
  !*** ./node_modules/hyparquet/src/encoding.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bitWidth: () => (/* binding */ bitWidth),
/* harmony export */   byteStreamSplit: () => (/* binding */ byteStreamSplit),
/* harmony export */   readRleBitPackedHybrid: () => (/* binding */ readRleBitPackedHybrid)
/* harmony export */ });
/* harmony import */ var _thrift_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thrift.js */ "./node_modules/hyparquet/src/thrift.js");


/**
 * Minimum bits needed to store value.
 *
 * @param {number} value
 * @returns {number}
 */
function bitWidth(value) {
  return 32 - Math.clz32(value)
}

/**
 * Read values from a run-length encoded/bit-packed hybrid encoding.
 *
 * If length is zero, then read int32 length at the start.
 *
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @typedef {import("./types.d.ts").DecodedArray} DecodedArray
 * @param {DataReader} reader
 * @param {number} width - width of each bit-packed group
 * @param {number} length - length of the encoded data
 * @param {DecodedArray} output
 */
function readRleBitPackedHybrid(reader, width, length, output) {
  if (!length) {
    // length = reader.view.getUint32(reader.offset, true)
    reader.offset += 4
  }
  let seen = 0
  while (seen < output.length) {
    const header = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_0__.readVarInt)(reader)
    if (header & 1) {
      // bit-packed
      seen = readBitPacked(reader, header, width, output, seen)
    } else {
      // rle
      const count = header >>> 1
      readRle(reader, count, width, output, seen)
      seen += count
    }
  }
  // assert(reader.offset - startOffset === length)
}

/**
 * Run-length encoding: read value with bitWidth and repeat it count times.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @param {number} bitWidth
 * @param {DecodedArray} output
 * @param {number} seen
 */
function readRle(reader, count, bitWidth, output, seen) {
  const width = bitWidth + 7 >> 3
  let value = 0
  if (width === 1) {
    value = reader.view.getUint8(reader.offset)
    // assert(value < 1 << bitWidth)
  } else if (width === 2) {
    value = reader.view.getUint16(reader.offset, true)
  } else if (width === 4) {
    value = reader.view.getUint32(reader.offset, true)
  } else if (width) {
    throw new Error(`parquet invalid rle width ${width}`)
  }
  reader.offset += width

  // repeat value count times
  for (let i = 0; i < count; i++) {
    output[seen + i] = value
  }
}

/**
 * Read a bit-packed run of the rle/bitpack hybrid.
 * Supports width > 8 (crossing bytes).
 *
 * @param {DataReader} reader
 * @param {number} header - bit-pack header
 * @param {number} bitWidth
 * @param {DecodedArray} output
 * @param {number} seen
 * @returns {number} total output values so far
 */
function readBitPacked(reader, header, bitWidth, output, seen) {
  let count = header >> 1 << 3 // values to read
  const mask = (1 << bitWidth) - 1

  let data = 0
  if (reader.offset < reader.view.byteLength) {
    data = reader.view.getUint8(reader.offset++)
  } else if (mask) {
    // sometimes out-of-bounds reads are masked out
    throw new Error(`parquet bitpack offset ${reader.offset} out of range`)
  }
  let left = 8
  let right = 0

  // read values
  while (count) {
    // if we have crossed a byte boundary, shift the data
    if (right > 8) {
      right -= 8
      left -= 8
      data >>= 8
    } else if (left - right < bitWidth) {
      // if we don't have bitWidth number of bits to read, read next byte
      data |= reader.view.getUint8(reader.offset) << left
      reader.offset++
      left += 8
    } else {
      if (seen < output.length) {
        // emit value
        output[seen++] = data >> right & mask
      }
      count--
      right += bitWidth
    }
  }

  return seen
}

/**
 * @typedef {import("./types.d.ts").ParquetType} ParquetType
 * @param {DataReader} reader
 * @param {number} count
 * @param {ParquetType} type
 * @param {number | undefined} typeLength
 * @returns {DecodedArray}
 */
function byteStreamSplit(reader, count, type, typeLength) {
  const width = byteWidth(type, typeLength)
  const bytes = new Uint8Array(count * width)
  for (let b = 0; b < width; b++) {
    for (let i = 0; i < count; i++) {
      bytes[i * width + b] = reader.view.getUint8(reader.offset++)
    }
  }
  // interpret bytes as typed array
  if (type === 'FLOAT') return new Float32Array(bytes.buffer)
  else if (type === 'DOUBLE') return new Float64Array(bytes.buffer)
  else if (type === 'INT32') return new Int32Array(bytes.buffer)
  else if (type === 'INT64') return new BigInt64Array(bytes.buffer)
  else if (type === 'FIXED_LEN_BYTE_ARRAY') {
    // split into arrays of typeLength
    const split = new Array(count)
    for (let i = 0; i < count; i++) {
      split[i] = bytes.subarray(i * width, (i + 1) * width)
    }
    return split
  }
  throw new Error(`parquet byte_stream_split unsupported type: ${type}`)
}

/**
 * @param {ParquetType} type
 * @param {number | undefined} typeLength
 * @returns {number}
 */
function byteWidth(type, typeLength) {
  switch (type) {
  case 'INT32':
  case 'FLOAT':
    return 4
  case 'INT64':
  case 'DOUBLE':
    return 8
  case 'FIXED_LEN_BYTE_ARRAY':
    if (!typeLength) throw new Error('parquet byteWidth missing type_length')
    return typeLength
  default:
    throw new Error(`parquet unsupported type: ${type}`)
  }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/header.js":
/*!**********************************************!*\
  !*** ./node_modules/hyparquet/src/header.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parquetHeader: () => (/* binding */ parquetHeader)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/hyparquet/src/constants.js");
/* harmony import */ var _thrift_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./thrift.js */ "./node_modules/hyparquet/src/thrift.js");



/**
 * Read parquet header from a buffer.
 *
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @typedef {import("./types.d.ts").PageHeader} PageHeader
 * @param {DataReader} reader - parquet file reader
 * @returns {PageHeader} metadata object and bytes read
 */
function parquetHeader(reader) {
  const header = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_1__.deserializeTCompactProtocol)(reader)

  // Parse parquet header from thrift data
  const type = _constants_js__WEBPACK_IMPORTED_MODULE_0__.PageType[header.field_1]
  const uncompressed_page_size = header.field_2
  const compressed_page_size = header.field_3
  const crc = header.field_4
  const data_page_header = header.field_5 && {
    num_values: header.field_5.field_1,
    encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[header.field_5.field_2],
    definition_level_encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[header.field_5.field_3],
    repetition_level_encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[header.field_5.field_4],
    statistics: header.field_5.field_5 && {
      max: header.field_5.field_5.field_1,
      min: header.field_5.field_5.field_2,
      null_count: header.field_5.field_5.field_3,
      distinct_count: header.field_5.field_5.field_4,
      max_value: header.field_5.field_5.field_5,
      min_value: header.field_5.field_5.field_6,
    },
  }
  const index_page_header = header.field_6
  const dictionary_page_header = header.field_7 && {
    num_values: header.field_7.field_1,
    encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[header.field_7.field_2],
    is_sorted: header.field_7.field_3,
  }
  const data_page_header_v2 = header.field_8 && {
    num_values: header.field_8.field_1,
    num_nulls: header.field_8.field_2,
    num_rows: header.field_8.field_3,
    encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[header.field_8.field_4],
    definition_levels_byte_length: header.field_8.field_5,
    repetition_levels_byte_length: header.field_8.field_6,
    is_compressed: header.field_8.field_7 === undefined ? true : header.field_8.field_7, // default true
    statistics: header.field_8.field_8,
  }

  return {
    type,
    uncompressed_page_size,
    compressed_page_size,
    crc,
    data_page_header,
    index_page_header,
    dictionary_page_header,
    data_page_header_v2,
  }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/hyparquet.js":
/*!*************************************************!*\
  !*** ./node_modules/hyparquet/src/hyparquet.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parquetMetadata: () => (/* reexport safe */ _metadata_js__WEBPACK_IMPORTED_MODULE_0__.parquetMetadata),
/* harmony export */   parquetMetadataAsync: () => (/* reexport safe */ _metadata_js__WEBPACK_IMPORTED_MODULE_0__.parquetMetadataAsync),
/* harmony export */   parquetRead: () => (/* reexport safe */ _read_js__WEBPACK_IMPORTED_MODULE_1__.parquetRead),
/* harmony export */   parquetSchema: () => (/* reexport safe */ _metadata_js__WEBPACK_IMPORTED_MODULE_0__.parquetSchema),
/* harmony export */   snappyUncompress: () => (/* reexport safe */ _snappy_js__WEBPACK_IMPORTED_MODULE_2__.snappyUncompress),
/* harmony export */   toJson: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_3__.toJson)
/* harmony export */ });
/* harmony import */ var _metadata_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metadata.js */ "./node_modules/hyparquet/src/metadata.js");
/* harmony import */ var _read_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./read.js */ "./node_modules/hyparquet/src/read.js");
/* harmony import */ var _snappy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./snappy.js */ "./node_modules/hyparquet/src/snappy.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ "./node_modules/hyparquet/src/utils.js");



;


;


;



/***/ }),

/***/ "./node_modules/hyparquet/src/metadata.js":
/*!************************************************!*\
  !*** ./node_modules/hyparquet/src/metadata.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parquetMetadata: () => (/* binding */ parquetMetadata),
/* harmony export */   parquetMetadataAsync: () => (/* binding */ parquetMetadataAsync),
/* harmony export */   parquetSchema: () => (/* binding */ parquetSchema)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/hyparquet/src/constants.js");
/* harmony import */ var _convert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./convert.js */ "./node_modules/hyparquet/src/convert.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");
/* harmony import */ var _thrift_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./thrift.js */ "./node_modules/hyparquet/src/thrift.js");





/**
 * Read parquet metadata from an async buffer.
 *
 * An AsyncBuffer is like an ArrayBuffer, but the slices are loaded
 * asynchronously, possibly over the network.
 *
 * You must provide the byteLength of the buffer, typically from a HEAD request.
 *
 * In theory, you could use suffix-range requests to fetch the end of the file,
 * and save a round trip. But in practice, this doesn't work because chrome
 * deems suffix-range requests as a not-safe-listed header, and will require
 * a pre-flight. So the byteLength is required.
 *
 * To make this efficient, we initially request the last 512kb of the file,
 * which is likely to contain the metadata. If the metadata length exceeds the
 * initial fetch, 512kb, we request the rest of the metadata from the AsyncBuffer.
 *
 * This ensures that we either make one 512kb initial request for the metadata,
 * or a second request for up to the metadata size.
 *
 * @typedef {import("./types.d.ts").AsyncBuffer} AsyncBuffer
 * @typedef {import("./types.d.ts").FileMetaData} FileMetaData
 * @typedef {import("./types.d.ts").SchemaElement} SchemaElement
 * @param {AsyncBuffer} asyncBuffer parquet file contents
 * @param {number} initialFetchSize initial fetch size in bytes
 * @returns {Promise<FileMetaData>} parquet metadata object
 */
async function parquetMetadataAsync(asyncBuffer, initialFetchSize = 1 << 19 /* 512kb */) {
  if (!asyncBuffer) throw new Error('parquet file is required')
  if (!(asyncBuffer.byteLength >= 0)) throw new Error('parquet file byteLength is required')

  // fetch last bytes (footer) of the file
  const footerOffset = Math.max(0, asyncBuffer.byteLength - initialFetchSize)
  const footerBuffer = await asyncBuffer.slice(footerOffset, asyncBuffer.byteLength)

  // Check for parquet magic number "PAR1"
  const footerView = new DataView(footerBuffer)
  if (footerView.getUint32(footerBuffer.byteLength - 4, true) !== 0x31524150) {
    throw new Error('parquet file invalid (footer != PAR1)')
  }

  // Parquet files store metadata at the end of the file
  // Metadata length is 4 bytes before the last PAR1
  const metadataLength = footerView.getUint32(footerBuffer.byteLength - 8, true)
  if (metadataLength > asyncBuffer.byteLength - 8) {
    throw new Error(`parquet metadata length ${metadataLength} exceeds available buffer ${asyncBuffer.byteLength - 8}`)
  }

  // check if metadata size fits inside the initial fetch
  if (metadataLength + 8 > initialFetchSize) {
    // fetch the rest of the metadata
    const metadataOffset = asyncBuffer.byteLength - metadataLength - 8
    const metadataBuffer = await asyncBuffer.slice(metadataOffset, footerOffset)
    // combine initial fetch with the new slice
    const combinedBuffer = new ArrayBuffer(metadataLength + 8)
    const combinedView = new Uint8Array(combinedBuffer)
    combinedView.set(new Uint8Array(metadataBuffer))
    combinedView.set(new Uint8Array(footerBuffer), footerOffset - metadataOffset)
    return parquetMetadata(combinedBuffer)
  } else {
    // parse metadata from the footer
    return parquetMetadata(footerBuffer)
  }
}

/**
 * Read parquet metadata from a buffer synchronously.
 *
 * @param {ArrayBuffer} arrayBuffer parquet file contents
 * @returns {FileMetaData} parquet metadata object
 */
function parquetMetadata(arrayBuffer) {
  if (!arrayBuffer) throw new Error('parquet file is required')
  const view = new DataView(arrayBuffer)

  // Validate footer magic number "PAR1"
  if (view.byteLength < 8) {
    throw new Error('parquet file is too short')
  }
  if (view.getUint32(view.byteLength - 4, true) !== 0x31524150) {
    throw new Error('parquet file invalid (footer != PAR1)')
  }

  // Parquet files store metadata at the end of the file
  // Metadata length is 4 bytes before the last PAR1
  const metadataLengthOffset = view.byteLength - 8
  const metadataLength = view.getUint32(metadataLengthOffset, true)
  if (metadataLength > view.byteLength - 8) {
    // {metadata}, metadata_length, PAR1
    throw new Error(`parquet metadata length ${metadataLength} exceeds available buffer ${view.byteLength - 8}`)
  }

  const metadataOffset = metadataLengthOffset - metadataLength
  const reader = { view, offset: metadataOffset }
  const metadata = (0,_thrift_js__WEBPACK_IMPORTED_MODULE_3__.deserializeTCompactProtocol)(reader)
  const decoder = new TextDecoder()
  function decode(/** @type {Uint8Array} */ value) {
    return value && decoder.decode(value)
  }

  // Parse metadata from thrift data
  const version = metadata.field_1
  /** @type {SchemaElement[]} */
  const schema = metadata.field_2.map((/** @type {any} */ field) => ({
    type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ParquetType[field.field_1],
    type_length: field.field_2,
    repetition_type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.FieldRepetitionType[field.field_3],
    name: decode(field.field_4),
    num_children: field.field_5,
    converted_type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ConvertedType[field.field_6],
    scale: field.field_7,
    precision: field.field_8,
    field_id: field.field_9,
    logical_type: logicalType(field.field_10),
  }))
  // schema element per column index
  const columnSchema = schema.filter(e => e.type)
  const num_rows = metadata.field_3
  const row_groups = metadata.field_4.map((/** @type {any} */ rowGroup) => ({
    columns: rowGroup.field_1.map((/** @type {any} */ column, /** @type {number} */ columnIndex) => ({
      file_path: decode(column.field_1),
      file_offset: column.field_2,
      meta_data: column.field_3 && {
        type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ParquetType[column.field_3.field_1],
        encodings: column.field_3.field_2?.map((/** @type {number} */ e) => _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[e]),
        path_in_schema: column.field_3.field_3.map(decode),
        codec: _constants_js__WEBPACK_IMPORTED_MODULE_0__.CompressionCodec[column.field_3.field_4],
        num_values: column.field_3.field_5,
        total_uncompressed_size: column.field_3.field_6,
        total_compressed_size: column.field_3.field_7,
        key_value_metadata: column.field_3.field_8,
        data_page_offset: column.field_3.field_9,
        index_page_offset: column.field_3.field_10,
        dictionary_page_offset: column.field_3.field_11,
        statistics: columnStats(column.field_3.field_12, columnSchema[columnIndex]),
        encoding_stats: column.field_3.field_13?.map((/** @type {any} */ encodingStat) => ({
          page_type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.PageType[encodingStat.field_1],
          encoding: _constants_js__WEBPACK_IMPORTED_MODULE_0__.Encoding[encodingStat.field_2],
          count: encodingStat.field_3,
        })),
        bloom_filter_offset: column.field_3.field_14,
        bloom_filter_length: column.field_3.field_15,
        size_statistics: column.field_3.field_16 && {
          unencoded_byte_array_data_bytes: column.field_3.field_16.field_1,
          repetition_level_histogram: column.field_3.field_16.field_2,
          definition_level_histogram: column.field_3.field_16.field_3,
        },
      },
      offset_index_offset: column.field_4,
      offset_index_length: column.field_5,
      column_index_offset: column.field_6,
      column_index_length: column.field_7,
      crypto_metadata: column.field_7,
      encrypted_column_metadata: column.field_8,
    })),
    total_byte_size: rowGroup.field_2,
    num_rows: rowGroup.field_3,
    sorting_columns: rowGroup.field_4?.map((/** @type {any} */ sortingColumn) => ({
      column_idx: sortingColumn.field_1,
      descending: sortingColumn.field_2,
      nulls_first: sortingColumn.field_3,
    })),
    file_offset: rowGroup.field_5,
    total_compressed_size: rowGroup.field_6,
    ordinal: rowGroup.field_7,
  }))
  const key_value_metadata = metadata.field_5?.map((/** @type {any} */ keyValue) => ({
    key: decode(keyValue.field_1),
    value: decode(keyValue.field_2),
  }))
  const created_by = decode(metadata.field_6)

  return {
    version,
    schema,
    num_rows,
    row_groups,
    key_value_metadata,
    created_by,
    metadata_length: metadataLength,
  }
}

/**
 * Return a tree of schema elements from parquet metadata.
 *
 * @param {FileMetaData} metadata parquet metadata object
 * @returns {import("./types.d.ts").SchemaTree} tree of schema elements
 */
function parquetSchema(metadata) {
  return (0,_schema_js__WEBPACK_IMPORTED_MODULE_2__.getSchemaPath)(metadata.schema, [])[0]
}

/**
 * @param {any} logicalType
 * @returns {import("./types.d.ts").LogicalType | undefined}
 */
function logicalType(logicalType) {
  if (logicalType?.field_1) return { type: 'STRING' }
  if (logicalType?.field_2) return { type: 'MAP' }
  if (logicalType?.field_3) return { type: 'LIST' }
  if (logicalType?.field_4) return { type: 'ENUM' }
  if (logicalType?.field_5) return {
    type: 'DECIMAL',
    scale: logicalType.field_5.field_1,
    precision: logicalType.field_5.field_2,
  }
  if (logicalType?.field_6) return { type: 'DATE' }
  if (logicalType?.field_7) return {
    type: 'TIME',
    isAdjustedToUTC: logicalType.field_7.field_1,
    unit: logicalType.field_7.field_2,
  }
  if (logicalType?.field_8) return {
    type: 'TIMESTAMP',
    isAdjustedToUTC: logicalType.field_8.field_1,
    unit: logicalType.field_8.field_2,
  }
  if (logicalType?.field_10) return {
    type: 'INTEGER',
    bitWidth: logicalType.field_10.field_1,
    isSigned: logicalType.field_10.field_2,
  }
  if (logicalType?.field_11) return { type: 'NULL' }
  if (logicalType?.field_12) return { type: 'JSON' }
  if (logicalType?.field_13) return { type: 'BSON' }
  if (logicalType?.field_14) return { type: 'UUID' }
  if (logicalType?.field_15) return { type: 'FLOAT16' }
  return logicalType
}

/**
 * Convert column statistics based on column type.
 *
 * @param {any} stats
 * @param {SchemaElement} schema
 * @returns {import("./types.d.ts").Statistics}
 */
function columnStats(stats, schema) {
  const { type, logical_type } = schema
  function convert(/** @type {Uint8Array} */ value) {
    if (value === undefined) return value
    if (type === 'BOOLEAN') return value[0] === 1
    if (type === 'BYTE_ARRAY') return new TextDecoder().decode(value)
    if (type === 'INT32') {
      const view = new DataView(value.buffer, value.byteOffset, value.byteLength)
      return view.getInt32(0, true)
    }
    if (type === 'INT64') {
      const view = new DataView(value.buffer, value.byteOffset, value.byteLength)
      return view.getBigInt64(0, true)
    }
    if (type === 'FLOAT') {
      const view = new DataView(value.buffer, value.byteOffset, value.byteLength)
      return view.getFloat32(0, true)
    }
    if (type === 'DOUBLE') {
      const view = new DataView(value.buffer, value.byteOffset, value.byteLength)
      return view.getFloat64(0, true)
    }
    if (logical_type?.type === 'FLOAT16') {
      return (0,_convert_js__WEBPACK_IMPORTED_MODULE_1__.parseFloat16)(value)
    }
    return value
  }
  return stats && {
    max: convert(stats.field_1),
    min: convert(stats.field_2),
    null_count: stats.field_3,
    distinct_count: stats.field_4,
    max_value: convert(stats.field_5),
    min_value: convert(stats.field_6),
    is_max_value_exact: stats.field_7,
    is_min_value_exact: stats.field_8,
  }
}


/***/ }),

/***/ "./node_modules/hyparquet/src/plain.js":
/*!*********************************************!*\
  !*** ./node_modules/hyparquet/src/plain.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readPlain: () => (/* binding */ readPlain)
/* harmony export */ });
/**
 * Read `count` values of the given type from the reader.view.
 *
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @typedef {import("./types.d.ts").DecodedArray} DecodedArray
 * @typedef {import("./types.d.ts").ParquetType} ParquetType
 * @param {DataReader} reader - buffer to read data from
 * @param {ParquetType} type - parquet type of the data
 * @param {number} count - number of values to read
 * @param {number | undefined} fixedLength - length of each fixed length byte array
 * @returns {DecodedArray} array of values
 */
function readPlain(reader, type, count, fixedLength) {
  if (count === 0) return []
  if (type === 'BOOLEAN') {
    return readPlainBoolean(reader, count)
  } else if (type === 'INT32') {
    return readPlainInt32(reader, count)
  } else if (type === 'INT64') {
    return readPlainInt64(reader, count)
  } else if (type === 'INT96') {
    return readPlainInt96(reader, count)
  } else if (type === 'FLOAT') {
    return readPlainFloat(reader, count)
  } else if (type === 'DOUBLE') {
    return readPlainDouble(reader, count)
  } else if (type === 'BYTE_ARRAY') {
    return readPlainByteArray(reader, count)
  } else if (type === 'FIXED_LEN_BYTE_ARRAY') {
    if (!fixedLength) throw new Error('parquet missing fixed length')
    return readPlainByteArrayFixed(reader, count, fixedLength)
  } else {
    throw new Error(`parquet unhandled type: ${type}`)
  }
}

/**
 * Read `count` boolean values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {boolean[]}
 */
function readPlainBoolean(reader, count) {
  const values = new Array(count)
  for (let i = 0; i < count; i++) {
    const byteOffset = reader.offset + (i / 8 | 0)
    const bitOffset = i % 8
    const byte = reader.view.getUint8(byteOffset)
    values[i] = (byte & 1 << bitOffset) !== 0
  }
  reader.offset += Math.ceil(count / 8)
  return values
}

/**
 * Read `count` int32 values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {Int32Array}
 */
function readPlainInt32(reader, count) {
  const values = (reader.view.byteOffset + reader.offset) % 4
    ? new Int32Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 4))
    : new Int32Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)
  reader.offset += count * 4
  return values
}

/**
 * Read `count` int64 values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {BigInt64Array}
 */
function readPlainInt64(reader, count) {
  const values = (reader.view.byteOffset + reader.offset) % 8
    ? new BigInt64Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 8))
    : new BigInt64Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)
  reader.offset += count * 8
  return values
}

/**
 * Read `count` int96 values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {bigint[]}
 */
function readPlainInt96(reader, count) {
  const values = new Array(count)
  for (let i = 0; i < count; i++) {
    const low = reader.view.getBigInt64(reader.offset + i * 12, true)
    const high = reader.view.getInt32(reader.offset + i * 12 + 8, true)
    values[i] = BigInt(high) << 64n | low
  }
  reader.offset += count * 12
  return values
}

/**
 * Read `count` float values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {Float32Array}
 */
function readPlainFloat(reader, count) {
  const values = (reader.view.byteOffset + reader.offset) % 4
    ? new Float32Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 4))
    : new Float32Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)
  reader.offset += count * 4
  return values
}

/**
 * Read `count` double values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {Float64Array}
 */
function readPlainDouble(reader, count) {
  const values = (reader.view.byteOffset + reader.offset) % 8
    ? new Float64Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 8))
    : new Float64Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)
  reader.offset += count * 8
  return values
}

/**
 * Read `count` byte array values.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @returns {Uint8Array[]}
 */
function readPlainByteArray(reader, count) {
  const values = new Array(count)
  for (let i = 0; i < count; i++) {
    const length = reader.view.getInt32(reader.offset, true)
    reader.offset += 4
    values[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, length)
    reader.offset += length
  }
  return values
}

/**
 * Read a fixed length byte array.
 *
 * @param {DataReader} reader
 * @param {number} count
 * @param {number} fixedLength
 * @returns {Uint8Array[]}
 */
function readPlainByteArrayFixed(reader, count, fixedLength) {
  // assert(reader.view.byteLength - reader.offset >= count * fixedLength)
  const values = new Array(count)
  for (let i = 0; i < count; i++) {
    values[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, fixedLength)
    reader.offset += fixedLength
  }
  return values
}

/**
 * Create a new buffer with the offset and size.
 *
 * @param {ArrayBuffer} buffer
 * @param {number} offset
 * @param {number} size
 * @returns {ArrayBuffer}
 */
function align(buffer, offset, size) {
  const aligned = new ArrayBuffer(size)
  new Uint8Array(aligned).set(new Uint8Array(buffer, offset, size))
  return aligned
}


/***/ }),

/***/ "./node_modules/hyparquet/src/read.js":
/*!********************************************!*\
  !*** ./node_modules/hyparquet/src/read.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parquetRead: () => (/* binding */ parquetRead)
/* harmony export */ });
/* harmony import */ var _assemble_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assemble.js */ "./node_modules/hyparquet/src/assemble.js");
/* harmony import */ var _column_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./column.js */ "./node_modules/hyparquet/src/column.js");
/* harmony import */ var _metadata_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metadata.js */ "./node_modules/hyparquet/src/metadata.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schema.js */ "./node_modules/hyparquet/src/schema.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ "./node_modules/hyparquet/src/utils.js");







/**
 * Read parquet data rows from a file-like object.
 * Reads the minimal number of row groups and columns to satisfy the request.
 *
 * Returns a void promise when complete, and to throw errors.
 * Data is returned in onComplete, not the return promise, because
 * if onComplete is undefined, we parse the data, and emit chunks, but skip
 * computing the row view directly. This saves on allocation if the caller
 * wants to cache the full chunks, and make their own view of the data from
 * the chunks.
 *
 * @typedef {import('./hyparquet.js').ColumnData} ColumnData
 * @typedef {import('./types.js').Compressors} Compressors
 * @typedef {import('./types.js').AsyncBuffer} AsyncBuffer
 * @typedef {import('./types.js').FileMetaData} FileMetaData
 * @param {object} options read options
 * @param {AsyncBuffer} options.file file-like object containing parquet data
 * @param {FileMetaData} [options.metadata] parquet file metadata
 * @param {string[]} [options.columns] columns to read, all columns if undefined
 * @param {number} [options.rowStart] first requested row index (inclusive)
 * @param {number} [options.rowEnd] last requested row index (exclusive)
 * @param {(chunk: ColumnData) => void} [options.onChunk] called when a column chunk is parsed. chunks may include row data outside the requested range.
 * @param {(rows: any[][]) => void} [options.onComplete] called when all requested rows and columns are parsed
 * @param {Compressors} [options.compressors] custom decompressors
 * @returns {Promise<void>} resolves when all requested rows and columns are parsed
 */
async function parquetRead(options) {
  if (!options.file) throw new Error('parquet file is required')

  // load metadata if not provided
  options.metadata ||= await (0,_metadata_js__WEBPACK_IMPORTED_MODULE_2__.parquetMetadataAsync)(options.file)
  if (!options.metadata) throw new Error('parquet metadata not found')

  const { metadata, onComplete, rowEnd } = options
  const rowStart = options.rowStart || 0
  /** @type {any[][]} */
  const rowData = []

  // find which row groups to read
  let groupStart = 0 // first row index of the current group
  for (const rowGroup of metadata.row_groups) {
    // number of rows in this row group
    const groupRows = Number(rowGroup.num_rows)
    // if row group overlaps with row range, read it
    if (groupStart + groupRows >= rowStart && (rowEnd === undefined || groupStart < rowEnd)) {
      // read row group
      const groupData = await readRowGroup(options, rowGroup, groupStart)
      if (onComplete) {
        // filter to rows in range
        const start = Math.max(rowStart - groupStart, 0)
        const end = rowEnd === undefined ? undefined : rowEnd - groupStart
        ;(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.concat)(rowData, groupData.slice(start, end))
      }
    }
    groupStart += groupRows
  }

  if (onComplete) onComplete(rowData)
}

/**
 * Read a row group from a file-like object.
 *
 * @typedef {import('./types.js').RowGroup} RowGroup
 * @param {object} options read options
 * @param {AsyncBuffer} options.file file-like object containing parquet data
 * @param {FileMetaData} [options.metadata] parquet file metadata
 * @param {string[]} [options.columns] columns to read, all columns if undefined
 * @param {(chunk: ColumnData) => void} [options.onChunk] called when a column chunk is parsed. chunks may include row data outside the requested range.
 * @param {(rows: any[][]) => void} [options.onComplete] called when all requested rows and columns are parsed
 * @param {Compressors} [options.compressors]
 * @param {RowGroup} rowGroup row group to read
 * @param {number} groupStart row index of the first row in the group
 * @returns {Promise<any[][]>} resolves to row data
 */
async function readRowGroup(options, rowGroup, groupStart) {
  const { file, metadata, columns } = options
  if (!metadata) throw new Error('parquet metadata not found')

  // loop through metadata to find min/max bytes to read
  let [groupStartByte, groupEndByte] = [file.byteLength, 0]
  rowGroup.columns.forEach(({ meta_data: columnMetadata }) => {
    if (!columnMetadata) throw new Error('parquet column metadata is undefined')
    // skip columns that are not requested
    if (columns && !columns.includes(columnMetadata.path_in_schema[0])) return

    const startByte = (0,_column_js__WEBPACK_IMPORTED_MODULE_1__.getColumnOffset)(columnMetadata)
    const endByte = startByte + Number(columnMetadata.total_compressed_size)
    groupStartByte = Math.min(groupStartByte, startByte)
    groupEndByte = Math.max(groupEndByte, endByte)
  })
  if (groupStartByte >= groupEndByte && columns?.length) {
    // TODO: should throw if any column is missing
    throw new Error(`parquet columns not found: ${columns.join(', ')}`)
  }
  // if row group size is less than 32mb, pre-load in one read
  let groupBuffer
  if (groupEndByte - groupStartByte <= 1 << 25) {
    // pre-load row group byte data in one big read,
    // otherwise read column data individually
    groupBuffer = await file.slice(groupStartByte, groupEndByte)
  }

  /** @type {any[][]} */
  const groupColumnData = []
  const promises = []
  // Top-level columns to assemble
  const { children } = (0,_schema_js__WEBPACK_IMPORTED_MODULE_3__.getSchemaPath)(metadata.schema, [])[0]
  const subcolumnNames = new Map(children.map(child => [child.element.name, getSubcolumns(child)]))
  const subcolumnData = new Map() // columns to assemble as maps
  // read column data
  for (let columnIndex = 0; columnIndex < rowGroup.columns.length; columnIndex++) {
    const columnMetadata = rowGroup.columns[columnIndex].meta_data
    if (!columnMetadata) throw new Error('parquet column metadata is undefined')

    // skip columns that are not requested
    const columnName = columnMetadata.path_in_schema[0]
    if (columns && !columns.includes(columnName)) continue

    const columnStartByte = (0,_column_js__WEBPACK_IMPORTED_MODULE_1__.getColumnOffset)(columnMetadata)
    const columnEndByte = columnStartByte + Number(columnMetadata.total_compressed_size)
    const columnBytes = columnEndByte - columnStartByte

    // skip columns larger than 1gb
    // TODO: stream process the data, returning only the requested rows
    if (columnBytes > 1 << 30) {
      console.warn(`parquet skipping huge column "${columnMetadata.path_in_schema}" ${columnBytes.toLocaleString()} bytes`)
      // TODO: set column to new Error('parquet column too large')
      continue
    }

    // use pre-loaded row group byte data if available, else read column data
    /** @type {Promise<ArrayBuffer>} */
    let buffer
    let bufferOffset = 0
    if (groupBuffer) {
      buffer = Promise.resolve(groupBuffer)
      bufferOffset = columnStartByte - groupStartByte
    } else {
      // wrap awaitable to ensure it's a promise
      buffer = Promise.resolve(file.slice(columnStartByte, columnEndByte))
    }

    // read column data async
    promises.push(buffer.then(arrayBuffer => {
      const schemaPath = (0,_schema_js__WEBPACK_IMPORTED_MODULE_3__.getSchemaPath)(metadata.schema, columnMetadata.path_in_schema)
      const reader = { view: new DataView(arrayBuffer), offset: bufferOffset }
      /** @type {any[] | undefined} */
      let columnData = (0,_column_js__WEBPACK_IMPORTED_MODULE_1__.readColumn)(reader, rowGroup, columnMetadata, schemaPath, options)
      // assert(columnData.length === Number(rowGroup.num_rows)

      // TODO: fast path for non-nested columns
      // Save column data for assembly
      const subcolumn = columnMetadata.path_in_schema.join('.')
      subcolumnData.set(subcolumn, columnData)
      columnData = undefined

      const subcolumns = subcolumnNames.get(columnName)
      if (subcolumns?.every(name => subcolumnData.has(name))) {
        // We have all data needed to assemble a top level column
        (0,_assemble_js__WEBPACK_IMPORTED_MODULE_0__.assembleNested)(subcolumnData, schemaPath[1])
        columnData = subcolumnData.get(columnName)
        if (!columnData) {
          throw new Error(`parquet column data not assembled: ${columnName}`)
        }
      }

      // do not emit column data until structs are fully parsed
      if (!columnData) return
      // notify caller of column data
      options.onChunk?.({
        columnName,
        columnData,
        rowStart: groupStart,
        rowEnd: groupStart + columnData.length,
      })
      // save column data only if onComplete is defined
      if (options.onComplete) groupColumnData.push(columnData)
    }))
  }
  await Promise.all(promises)
  if (options.onComplete) {
    // transpose columns into rows
    return groupColumnData[0].map((_, row) => groupColumnData.map(col => col[row]))
  }
  return []
}


/**
 * Return a list of sub-columns needed to construct a top-level column.
 *
 * @param {import('./types.js').SchemaTree} schema
 * @param {string[]} output
 * @returns {string[]}
 */
function getSubcolumns(schema, output = []) {
  if (schema.children.length) {
    for (const child of schema.children) {
      getSubcolumns(child, output)
    }
  } else {
    output.push(schema.path.join('.'))
  }
  return output
}


/***/ }),

/***/ "./node_modules/hyparquet/src/schema.js":
/*!**********************************************!*\
  !*** ./node_modules/hyparquet/src/schema.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMaxDefinitionLevel: () => (/* binding */ getMaxDefinitionLevel),
/* harmony export */   getMaxRepetitionLevel: () => (/* binding */ getMaxRepetitionLevel),
/* harmony export */   getSchemaPath: () => (/* binding */ getSchemaPath),
/* harmony export */   isListLike: () => (/* binding */ isListLike),
/* harmony export */   isMapLike: () => (/* binding */ isMapLike)
/* harmony export */ });
/**
 * Build a tree from the schema elements.
 *
 * @typedef {import('./types.js').SchemaElement} SchemaElement
 * @typedef {import('./types.js').SchemaTree} SchemaTree
 * @param {SchemaElement[]} schema
 * @param {number} rootIndex index of the root element
 * @param {string[]} path path to the element
 * @returns {SchemaTree} tree of schema elements
 */
function schemaTree(schema, rootIndex, path) {
  const element = schema[rootIndex]
  const children = []
  let count = 1

  // Read the specified number of children
  if (element.num_children) {
    while (children.length < element.num_children) {
      const childElement = schema[rootIndex + count]
      const child = schemaTree(schema, rootIndex + count, [...path, childElement.name])
      count += child.count
      children.push(child)
    }
  }

  return { count, element, children, path }
}

/**
 * Get schema elements from the root to the given element name.
 *
 * @param {SchemaElement[]} schema
 * @param {string[]} name path to the element
 * @returns {SchemaTree[]} list of schema elements
 */
function getSchemaPath(schema, name) {
  let tree = schemaTree(schema, 0, [])
  const path = [tree]
  for (const part of name) {
    const child = tree.children.find(child => child.element.name === part)
    if (!child) throw new Error(`parquet schema element not found: ${name}`)
    path.push(child)
    tree = child
  }
  return path
}

/**
 * Get the max repetition level for a given schema path.
 *
 * @param {SchemaTree[]} schemaPath
 * @returns {number} max repetition level
 */
function getMaxRepetitionLevel(schemaPath) {
  let maxLevel = 0
  for (const { element } of schemaPath) {
    if (element.repetition_type === 'REPEATED') {
      maxLevel++
    }
  }
  return maxLevel
}

/**
 * Get the max definition level for a given schema path.
 *
 * @param {SchemaTree[]} schemaPath
 * @returns {number} max definition level
 */
function getMaxDefinitionLevel(schemaPath) {
  let maxLevel = 0
  for (const { element } of schemaPath.slice(1)) {
    if (element.repetition_type !== 'REQUIRED') {
      maxLevel++
    }
  }
  return maxLevel
}

/**
 * Check if a column is list-like.
 *
 * @param {SchemaTree} schema
 * @returns {boolean} true if list-like
 */
function isListLike(schema) {
  if (!schema) return false
  if (schema.element.converted_type !== 'LIST') return false
  if (schema.children.length > 1) return false

  const firstChild = schema.children[0]
  if (firstChild.children.length > 1) return false
  if (firstChild.element.repetition_type !== 'REPEATED') return false

  return true
}

/**
 * Check if a column is map-like.
 *
 * @param {SchemaTree} schema
 * @returns {boolean} true if map-like
 */
function isMapLike(schema) {
  if (!schema) return false
  if (schema.element.converted_type !== 'MAP') return false
  if (schema.children.length > 1) return false

  const firstChild = schema.children[0]
  if (firstChild.children.length !== 2) return false
  if (firstChild.element.repetition_type !== 'REPEATED') return false

  const keyChild = firstChild.children.find(child => child.element.name === 'key')
  if (keyChild?.element.repetition_type === 'REPEATED') return false

  const valueChild = firstChild.children.find(child => child.element.name === 'value')
  if (valueChild?.element.repetition_type === 'REPEATED') return false

  return true
}


/***/ }),

/***/ "./node_modules/hyparquet/src/snappy.js":
/*!**********************************************!*\
  !*** ./node_modules/hyparquet/src/snappy.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   snappyUncompress: () => (/* binding */ snappyUncompress)
/* harmony export */ });
/**
 * The MIT License (MIT)
 * Copyright (c) 2016 Zhipeng Jia
 * https://github.com/zhipeng-jia/snappyjs
 */

const WORD_MASK = [0, 0xff, 0xffff, 0xffffff, 0xffffffff]

/**
 * Copy bytes from one array to another
 *
 * @param {Uint8Array} fromArray source array
 * @param {number} fromPos source position
 * @param {Uint8Array} toArray destination array
 * @param {number} toPos destination position
 * @param {number} length number of bytes to copy
 * @returns {void}
 */
function copyBytes(fromArray, fromPos, toArray, toPos, length) {
  for (let i = 0; i < length; i++) {
    toArray[toPos + i] = fromArray[fromPos + i]
  }
}

/**
 * Copy bytes within an array
 *
 * @param {Uint8Array} array source and destination array
 * @param {number} pos source position
 * @param {number} offset offset back from current position to read
 * @param {number} length number of bytes to copy
 * @returns {void}
 */
function selfCopyBytes(array, pos, offset, length) {
  for (let i = 0; i < length; i++) {
    array[pos + i] = array[pos - offset + i]
  }
}

/**
 * Decompress snappy data.
 * Accepts an output buffer to avoid allocating a new buffer for each call.
 *
 * @param {Uint8Array} input compressed data
 * @param {Uint8Array} output output buffer
 * @returns {void}
 */
function snappyUncompress(input, output) {
  const inputLength = input.byteLength
  const outputLength = output.byteLength
  let pos = 0
  let outPos = 0

  // skip preamble (contains uncompressed length as varint)
  while (pos < inputLength) {
    const c = input[pos]
    pos++
    if (c < 128) {
      break
    }
  }
  if (outputLength && pos >= inputLength) {
    throw new Error('invalid snappy length header')
  }

  while (pos < inputLength) {
    const c = input[pos]
    let len = 0
    pos++

    if (pos >= inputLength) {
      throw new Error('missing eof marker')
    }

    // There are two types of elements, literals and copies (back references)
    if ((c & 0x3) === 0) {
      // Literals are uncompressed data stored directly in the byte stream
      let len = (c >>> 2) + 1
      // Longer literal length is encoded in multiple bytes
      if (len > 60) {
        if (pos + 3 >= inputLength) {
          throw new Error('snappy error literal pos + 3 >= inputLength')
        }
        const lengthSize = len - 60 // length bytes - 1
        len = input[pos]
          + (input[pos + 1] << 8)
          + (input[pos + 2] << 16)
          + (input[pos + 3] << 24)
        len = (len & WORD_MASK[lengthSize]) + 1
        pos += lengthSize
      }
      if (pos + len > inputLength) {
        throw new Error('snappy error literal exceeds input length')
      }
      copyBytes(input, pos, output, outPos, len)
      pos += len
      outPos += len
    } else {
      // Copy elements
      let offset = 0 // offset back from current position to read
      switch (c & 0x3) {
      case 1:
        // Copy with 1-byte offset
        len = (c >>> 2 & 0x7) + 4
        offset = input[pos] + (c >>> 5 << 8)
        pos++
        break
      case 2:
        // Copy with 2-byte offset
        if (inputLength <= pos + 1) {
          throw new Error('snappy error end of input')
        }
        len = (c >>> 2) + 1
        offset = input[pos] + (input[pos + 1] << 8)
        pos += 2
        break
      case 3:
        // Copy with 4-byte offset
        if (inputLength <= pos + 3) {
          throw new Error('snappy error end of input')
        }
        len = (c >>> 2) + 1
        offset = input[pos]
          + (input[pos + 1] << 8)
          + (input[pos + 2] << 16)
          + (input[pos + 3] << 24)
        pos += 4
        break
      default:
        break
      }
      if (offset === 0 || isNaN(offset)) {
        throw new Error(`invalid offset ${offset} pos ${pos} inputLength ${inputLength}`)
      }
      if (offset > outPos) {
        throw new Error('cannot copy from before start of buffer')
      }
      selfCopyBytes(output, outPos, offset, len)
      outPos += len
    }
  }

  if (outPos !== outputLength) throw new Error('premature end of input')
}


/***/ }),

/***/ "./node_modules/hyparquet/src/thrift.js":
/*!**********************************************!*\
  !*** ./node_modules/hyparquet/src/thrift.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deserializeTCompactProtocol: () => (/* binding */ deserializeTCompactProtocol),
/* harmony export */   readVarInt: () => (/* binding */ readVarInt),
/* harmony export */   readZigZagBigInt: () => (/* binding */ readZigZagBigInt),
/* harmony export */   toVarInt: () => (/* binding */ toVarInt)
/* harmony export */ });
// TCompactProtocol types
const CompactType = {
  STOP: 0,
  TRUE: 1,
  FALSE: 2,
  BYTE: 3,
  I16: 4,
  I32: 5,
  I64: 6,
  DOUBLE: 7,
  BINARY: 8,
  LIST: 9,
  SET: 10,
  MAP: 11,
  STRUCT: 12,
  UUID: 13,
}

/**
 * Parse TCompactProtocol
 *
 * @typedef {import("./types.d.ts").DataReader} DataReader
 * @param {DataReader} reader
 * @returns {Record<string, any>}
 */
function deserializeTCompactProtocol(reader) {
  let lastFid = 0
  /** @type {Record<string, any>} */
  const value = {}

  while (reader.offset < reader.view.byteLength) {
    // Parse each field based on its type and add to the result object
    const [type, fid, newLastFid] = readFieldBegin(reader, lastFid)
    lastFid = newLastFid

    if (type === CompactType.STOP) {
      break
    }

    // Handle the field based on its type
    value[`field_${fid}`] = readElement(reader, type)
  }

  return value
}

/**
 * Read a single element based on its type
 *
 * @param {DataReader} reader
 * @param {number} type
 * @returns {any} value
 */
function readElement(reader, type) {
  switch (type) {
  case CompactType.TRUE:
    return true
  case CompactType.FALSE:
    return false
  case CompactType.BYTE:
    // read byte directly
    return reader.view.getInt8(reader.offset++)
  case CompactType.I16:
  case CompactType.I32:
    return readZigZag(reader)
  case CompactType.I64:
    return readZigZagBigInt(reader)
  case CompactType.DOUBLE: {
    const value = reader.view.getFloat64(reader.offset, true)
    reader.offset += 8
    return value
  }
  case CompactType.BINARY: {
    const stringLength = readVarInt(reader)
    const strBytes = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, stringLength)
    reader.offset += stringLength
    return strBytes
  }
  case CompactType.LIST: {
    const [elemType, listSize] = readCollectionBegin(reader)
    const values = new Array(listSize)
    for (let i = 0; i < listSize; i++) {
      values[i] = readElement(reader, elemType)
    }
    return values
  }
  case CompactType.STRUCT: {
    /** @type {Record<string, any>} */
    const structValues = {}
    let structLastFid = 0
    while (true) {
      let structFieldType, structFid
      [structFieldType, structFid, structLastFid] = readFieldBegin(reader, structLastFid)
      if (structFieldType === CompactType.STOP) {
        break
      }
      structValues[`field_${structFid}`] = readElement(reader, structFieldType)
    }
    return structValues
  }
  // TODO: MAP and SET
  case CompactType.UUID: {
    // Read 16 bytes to uuid string
    let uuid = ''
    for (let i = 0; i < 16; i++) {
      uuid += reader.view.getUint8(reader.offset++).toString(16).padStart(2, '0')
    }
    return uuid
  }
  default:
    throw new Error(`thrift unhandled type: ${type}`)
  }
}

/**
 * Var int, also known as Unsigned LEB128.
 * Var ints take 1 to 5 bytes (int32) or 1 to 10 bytes (int64).
 * Takes a Big Endian unsigned integer, left-pads the bit-string to make it a
 * multiple of 7 bits, splits it into 7-bit groups, prefix the most-significant
 * 7-bit group with the 0 bit, prefixing the remaining 7-bit groups with the
 * 1 bit and encode the resulting bit-string as Little Endian.
 *
 * @param {DataReader} reader
 * @returns {number} value
 */
function readVarInt(reader) {
  let result = 0
  let shift = 0
  while (true) {
    const byte = reader.view.getUint8(reader.offset++)
    result |= (byte & 0x7f) << shift
    if (!(byte & 0x80)) {
      return result
    }
    shift += 7
  }
}

/**
 * Read a varint as a bigint.
 *
 * @param {DataReader} reader
 * @returns {bigint} value
 */
function readVarBigInt(reader) {
  let result = 0n
  let shift = 0n
  while (true) {
    const byte = reader.view.getUint8(reader.offset++)
    result |= BigInt(byte & 0x7f) << shift
    if (!(byte & 0x80)) {
      return result
    }
    shift += 7n
  }
}

/**
 * Values of type int32 and int64 are transformed to a zigzag int.
 * A zigzag int folds positive and negative numbers into the positive number space.
 *
 * @param {DataReader} reader
 * @returns {number} value
 */
function readZigZag(reader) {
  const zigzag = readVarInt(reader)
  // convert zigzag to int
  return zigzag >>> 1 ^ -(zigzag & 1)
}

/**
 * A zigzag int folds positive and negative numbers into the positive number space.
 * This version returns a BigInt.
 *
 * @param {DataReader} reader
 * @returns {bigint} value
 */
function readZigZagBigInt(reader) {
  const zigzag = readVarBigInt(reader)
  // convert zigzag to int
  return zigzag >> BigInt(1) ^ -(zigzag & BigInt(1))
}

/**
 * Get thrift type from half a byte
 *
 * @param {number} byte
 * @returns {number}
 */
function getCompactType(byte) {
  return byte & 0x0f
}

/**
 * Read field type and field id
 *
 * @param {DataReader} reader
 * @param {number} lastFid
 * @returns {[number, number, number]} [type, fid, newLastFid]
 */
function readFieldBegin(reader, lastFid) {
  const type = reader.view.getUint8(reader.offset++)
  if ((type & 0x0f) === CompactType.STOP) {
    // STOP also ends a struct
    return [0, 0, lastFid]
  }
  const delta = type >> 4
  let fid // field id
  if (delta === 0) {
    // not a delta, read zigzag varint field id
    fid = readZigZag(reader)
  } else {
    // add delta to last field id
    fid = lastFid + delta
  }
  return [getCompactType(type), fid, fid]
}

/**
 * Read collection type and size
 *
 * @param {DataReader} reader
 * @returns {[number, number]} [type, size]
 */
function readCollectionBegin(reader) {
  const sizeType = reader.view.getUint8(reader.offset++)
  const size = sizeType >> 4
  const type = getCompactType(sizeType)
  if (size === 15) {
    const newSize = readVarInt(reader)
    return [type, newSize]
  }
  return [type, size]
}

/**
 * Convert int to varint. Outputs 1-5 bytes for int32.
 *
 * @param {number} n
 * @returns {number[]}
 */
function toVarInt(n) {
  let idx = 0
  const varInt = []
  while (true) {
    if ((n & ~0x7f) === 0) {
      varInt[idx++] = n
      break
    } else {
      varInt[idx++] = n & 0x7f | 0x80
      n >>>= 7
    }
  }
  return varInt
}


/***/ }),

/***/ "./node_modules/hyparquet/src/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/hyparquet/src/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concat: () => (/* binding */ concat),
/* harmony export */   toJson: () => (/* binding */ toJson)
/* harmony export */ });
/**
 * Replace bigints with numbers.
 * When parsing parquet files, bigints are used to represent 64-bit integers.
 * However, JSON does not support bigints, so it's helpful to convert to numbers.
 *
 * @param {any} obj object to convert
 * @returns {unknown} converted object
 */
function toJson(obj) {
  if (obj === undefined) return null
  if (typeof obj === 'bigint') return Number(obj)
  if (Array.isArray(obj)) return obj.map(toJson)
  if (obj instanceof Uint8Array) return Array.from(obj)
  if (obj instanceof Date) return obj.toISOString()
  if (obj instanceof Object) {
    /** @type {Record<string, unknown>} */
    const newObj = {}
    for (const key of Object.keys(obj)) {
      if (obj[key] === undefined) continue
      newObj[key] = toJson(obj[key])
    }
    return newObj
  }
  return obj
}

/**
 * Concatenate two arrays fast.
 *
 * @typedef {import('./types.js').DecodedArray} DecodedArray
 * @param {any[]} aaa first array
 * @param {DecodedArray} bbb second array
 */
function concat(aaa, bbb) {
  const chunk = 10000
  for (let i = 0; i < bbb.length; i += chunk) {
    aaa.push(...bbb.slice(i, i + chunk))
  }
}


/***/ }),

/***/ "./src/ParquetGrid.js":
/*!****************************!*\
  !*** ./src/ParquetGrid.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParquetGrid: () => (/* binding */ ParquetGrid)
/* harmony export */ });
/* harmony import */ var gridviz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gridviz */ "./node_modules/gridviz/src/index.js");
/* harmony import */ var hyparquet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hyparquet */ "./node_modules/hyparquet/src/hyparquet.js");
//@ts-check


;

//import { tableFromIPC } from 'apache-arrow'
//import { readParquet } from "parquet-wasm"
//import { readParquet } from "parquet-wasm/bundler/arrow1.js";
//import { readParquet } from "parquet-wasm/node2";

//see https://www.npmjs.com/package/parquet-wasm

//see https://observablehq.com/@bmschmidt/hello-parquet-wasm
/*
pq = {
  const pq = await import('https://unpkg.com/parquet-wasm@0.1.1/web.js')
  // default seems to need to resolve first?
  await pq.default()
  return pq
}
*/

/**
 * A dataset composed of a single parquet file (not tiled).
 *
 * @author Julien Gaffuri
 */
class ParquetGrid extends gridviz__WEBPACK_IMPORTED_MODULE_0__.DatasetComponent {
    /**
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {{preprocess?:(function(object):boolean), readParquetFun?:Function}} opts
     */
    constructor(url, resolution, opts = {}) {
        super(url, resolution, opts)

        /**
         * @private
         * @type {Array.<object>} */
        this.cells = []

        /**
         * @type {string}
         * @private  */
        this.infoLoadingStatus = 'notLoaded'

        //console.log(readParquet)
        //const pq = await import('https://unpkg.com/parquet-wasm@0.1.1/web.js')
        //await pq.default()

        if (!opts.readParquetFun) throw new Error('readParquet function needed for parquet dataset')

        /**
         * @type {Function}
         * @private  */
        //this.readParquetFun = opts.readParquetFun
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {object|undefined} e
     * @param {function():void} redraw
     */
    getData(e, redraw) {
        //check if data already loaded
        if (this.infoLoadingStatus != 'notLoaded') return this

        //load data
        this.infoLoadingStatus = 'loading'

        const res = fetch(this.url)
        const arrayBuffer = res.arrayBuffer()
        const metadata = (0,hyparquet__WEBPACK_IMPORTED_MODULE_1__.parquetMetadata)(arrayBuffer)
        console.log(metadata)

        /*;(async () => {
            try {
                const resp = await fetch(this.url)
                const parquetUint8Array = new Uint8Array(await resp.arrayBuffer())
                const arrowUint8Array = this.readParquetFun(parquetUint8Array)

                const t = tableFromIPC(arrowUint8Array)
                //see https://arrow.apache.org/docs/js/
                //https://loaders.gl/arrowjs/docs/developer-guide/tables#record-tojson-and-toarray

                this.cells = []
                for (const e of t) {
                    //get cell
                    const c = e.toJSON()

                    //preprocess/filter
                    if (this.preprocess) {
                        const b = this.preprocess(c)
                        if (b == false) continue
                        this.cells.push(c)
                    } else {
                        this.cells.push(c)
                    }
                }

                //TODO check if redraw is necessary
                //that is if the dataset belongs to a layer which is visible at the current zoom level

                //execute the callback, usually a draw function
                if (redraw) redraw()

                this.infoLoadingStatus = 'loaded'
            } catch (error) {
                //mark as failed
                this.infoLoadingStatus = 'failed'
                this.cells = []
            }
        })()*/

        return this
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     *
     * @param {object} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //data not loaded yet
        if (!this.cells) return

        this.cellsViewCache = []
        for (const cell of this.cells) {
            if (+cell.x + this.resolution < extGeo.xMin) continue
            if (+cell.x - this.resolution > extGeo.xMax) continue
            if (+cell.y + this.resolution < extGeo.yMin) continue
            if (+cell.y - this.resolution > extGeo.yMax) continue
            this.cellsViewCache.push(cell)
        }
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParquetGrid: () => (/* reexport safe */ _ParquetGrid_js__WEBPACK_IMPORTED_MODULE_0__.ParquetGrid)
/* harmony export */ });
/* harmony import */ var _ParquetGrid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ParquetGrid.js */ "./src/ParquetGrid.js");
//@ts-check



//export { TiledParquetGrid } from "./TiledParquetGrid.js"
/*
import { Dataset } from 'gridviz'
import { ParquetGrid } from "./ParquetGrid.js"
import { TiledParquetGrid } from "./TiledParquetGrid.js"

//import { readParquet } from "parquet-wasm"
//import { readParquet } from "parquet-wasm/bundler/arrow1.js";
//import { readParquet } from "parquet-wasm/node2";



/*
export const makeParquetGridDataset = function (app, url, resolution, opts) {
    return new Dataset([new ParquetGrid(url, resolution, opts).getData(undefined, () => { app.cg.redraw(); })], [], opts)
}

/**
* Add a layer from a parquet grid dataset.
*
* @param {object} app The gridviz application.
* @param {string} url The URL of the dataset.
* @param {number} resolution The dataset resolution in geographical unit.
* @param {Array.<object>} styles The styles, ordered in drawing order.
* @param {object=} opts The parameters of the dataset and layer.
* @returns {object}
*/
/*export const addParquetGridLayer = function (app, url, resolution, styles, opts) {
    const ds = makeParquetGridDataset(app, url, resolution, opts)
    return app.addLayerFromDataset(ds, styles, opts);
}*/






/*
export const makeMultiScaleParquetGridDataset = function (app, resolutions, resToURL, opts) {
    return Dataset.make(
        resolutions,
        (res) => new ParquetGrid(resToURL(res), res, opts).getData(undefined, () => { app.cg.redraw() }),
        opts
    )
}

/**
* @param {object} app The gridviz application.
 * @param {Array.<number>} resolutions
 * @param {function(number):string} resToURL
* @param {Array.<object>} styles The styles, ordered in drawing order.
 * @param {object=} opts The parameters of the dataset and layer.
 * @returns {object}
 */
/*export const addMultiScaleParquetGridLayer = function (app, resolutions, resToURL, styles, opts) {
    const ds = makeMultiScaleParquetGridDataset(app, resolutions, resToURL, opts)
    return app.addLayerFromDataset(ds, styles, opts)
}






export const makeTiledParquetGridDataset = function (app, url, opts) {
    return new Dataset(
        [new TiledParquetGrid(url, app, opts).loadInfo(() => { app.cg.redraw() }),],
        [],
        opts
    )
}

/**
* @param {object} app The gridviz application.
 * @param {string} url
* @param {Array.<object>} styles The styles, ordered in drawing order.
 * @param {{visible?:boolean,minZoom?:number,maxZoom?:number,pixNb?:number,cellInfoHTML?:function(object):string, preprocess?:function(object):boolean}} opts
 * @returns {object}
 */
/*export const addTiledParquetGridLayer = function (app, url, styles, opts) {
    const ds = makeTiledParquetGridDataset(app, url, opts)
    return app.addLayerFromDataset(ds, styles, opts)
}






export const makeMultiScaleTiledParquetGridDataset = function (app, resolutions, resToURL, opts) {
    return Dataset.make(
        resolutions,
        (res) => new TiledParquetGrid(resToURL(res), app, opts).loadInfo(() => { app.cg.redraw() }),
        opts
    )
}

/**
* @param {object} app The gridviz application.
 * @param {Array.<number>} resolutions
 * @param {function(number):string} resToURL
* @param {Array.<object>} styles The styles, ordered in drawing order.
 * @param {object=} opts The parameters of the dataset and layer.
 * @returns {object}
 */
/*export const addMultiScaleTiledParquetGridLayer = function (app, resolutions, resToURL, styles, opts) {
    const ds = makeMultiScaleTiledParquetGridDataset(app, resolutions, resToURL, opts)
    return app.addLayerFromDataset(ds, styles, opts)
}



//test utilisation of that:
//<script src="https://unpkg.com/parquet-wasm@0.4.0-beta.5/esm/arrow2.js"></script>
/*export const loadWasmParquetReader = async () => {
    const parquetModule = await import("parquet-wasm")
    return parquetModule.readParquet
    //await parquetModule.default()
    //return parquetModule.readParquet
}*/


/**
 * Retrieve parquet wasm decoder
 */
/*
const getReadParquetP = ()=> async () => {
    const parquetModule = await import("https://unpkg.com/parquet-wasm@0.4.0-beta.5/esm/arrow2.js");
    await parquetModule.default();
    return parquetModule.readParquet;
}
*/

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZHZpei1wYXJxdWV0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1YyQzs7QUFFcEM7O0FBRUE7QUFDQTs7QUFFUDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3Qix3Q0FBd0MsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQzFELHdDQUF3QyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDMUQsMENBQTBDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDbkUsMENBQTBDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDbkUsd0NBQXdDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSTtBQUMxRCwwQ0FBMEMsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQU0sV0FBVyxrREFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsYUFBYSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVk7QUFDckQ7O0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZIb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsOENBQU07QUFDdkM7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUZBO0FBQ1k7O0FBRVosZ0JBQWdCLCtEQUErRCxrQkFBa0IsdUVBQXVFOztBQUV4SyxDQUE4QjtBQUMyQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHNCQUFzQixrRUFBZ0I7QUFDN0M7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQiw0REFBNEQ7QUFDNUU7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQ0FBbUM7QUFDckQ7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUNBQXlDO0FBQ3hELGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtQ0FBbUMsNkNBQUc7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3ZHQTtBQUNZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUNZOztBQUVaLGdCQUFnQiwrREFBK0Qsa0JBQWtCLDBFQUEwRTs7QUFFM0ssQ0FBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvQkFBb0Isa0VBQWdCO0FBQzNDO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHNDQUFzQztBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQTRDO0FBQzNELGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JEQTtBQUNZOztBQUVaLGdCQUFnQiwrREFBK0Qsa0JBQWtCLG9IQUFvSDs7QUFFck47QUFDQSxDQUF3QztBQUNUO0FBQzBCO0FBQ0c7O0FBRTVEO0FBQ29DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLGtFQUFnQjtBQUMvQztBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCLDZEQUE2RDtBQUM3RTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsdUNBQXVDLG9EQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QyxlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIseUNBQXlDO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEOztBQUVBLGtEQUFrRCxrQ0FBa0M7QUFDcEYsc0RBQXNELGtDQUFrQztBQUN4RjtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQ0FBb0M7QUFDbkU7O0FBRUE7QUFDQSxtQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0EsMkNBQTJDLDZDQUFHOztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrREFBUTtBQUM5Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIseUNBQXlDO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEOztBQUVBLGtEQUFrRCxrQ0FBa0M7QUFDcEY7QUFDQSxzREFBc0Qsa0NBQWtDO0FBQ3hGO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZRQTtBQUNZOztBQUVaO0FBQzhCO0FBQ1k7QUFDUjtBQUNBO0FBQ0k7QUFDa0I7O0FBRXhEO0FBQ2tEO0FBQ0Y7QUFDRjtBQUNKO0FBQzFDLFdBQVcsVUFBVTs7QUFFckI7QUFDb0U7QUFDRTtBQUNsQjtBQUNFO0FBQ1E7QUFDRTtBQUNWO0FBQ047QUFDSTtBQUNKO0FBQ007QUFDQTtBQUNNO0FBQ1I7QUFDSjtBQUNvQjtBQUNNO0FBQ3RCO0FBQ007QUFDRTtBQUNKOztBQUV4RDtBQUNzRDtBQUNNO0FBQ2hCO0FBQ2U7O0FBRTNEO0FBQ3FEO0FBQ2dCO0FBQ0E7QUFDbEI7QUFDZ0I7QUFDWTs7QUFFL0UsWUFBWSx1QkFBdUI7QUFDRTs7QUFFTTs7OztBQUkzQyxDQUEwQztBQUNuQywyQkFBMkIsb0RBQVM7O0FBRTNDO0FBQ0EsQ0FBK0M7QUFDL0Msc0RBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hFRDtBQUNZOztBQUVaLENBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLDhDQUFNO0FBQy9DLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiwySEFBMkg7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFFBQVE7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ1k7O0FBRVosQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyw4Q0FBTTtBQUMvQyxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsMkhBQTJIO0FBQzVJO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0R0E7QUFDWTs7QUFFWixDQUFxQztBQUNIOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsOENBQU07QUFDdkMsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw0SkFBNEo7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZUFBZTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixnQkFBZ0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlFQUFpRSxpREFBTTtBQUN2RTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0hBO0FBQ1k7O0FBRVosQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUMsOENBQU07QUFDcEQsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGtMQUFrTDtBQUNuTTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RGQTtBQUNZOztBQUVaLENBQXFDO0FBQ0g7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsOENBQU07QUFDOUMsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGtMQUFrTDtBQUNuTTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaURBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BHQTtBQUNZOztBQUVaLENBQXFDO0FBQ0g7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUIsOENBQU07QUFDdEMsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw2SkFBNko7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLHVCQUF1QixpREFBTTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUlBO0FBQ1k7O0FBRVosQ0FBbUM7O0FBRW5DLGNBQWMsb0VBQW9FOztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDRDQUFLO0FBQzNDLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixxREFBcUQ7QUFDdkU7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLGtCQUFrQix5RUFBeUU7QUFDM0Y7O0FBRUE7QUFDQSxrQkFBa0IsMERBQTBEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQTBEO0FBQzVFOztBQUVBO0FBQ0Esa0JBQWtCLDBEQUEwRDtBQUM1RTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRCxlQUFlLFFBQVE7QUFDdkIsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUFLO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUVBQXlFO0FBQ2hHO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJB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Q3pKLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGlCQUFpQjtBQUNsRztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFFBQVE7QUFDbEIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyx5QkFBeUI7QUFDcEMsVUFBVSxnQkFBZ0I7QUFDMUIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2d2aXpfcGFyL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2RlZmluZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9zcmMvZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9kcmFnLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL25vZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZHN2L3NyYy9jc3YuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZHN2L3NyYy9kc3YuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZHN2L3NyYy90c3YuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvY3ViaWMuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZmV0Y2gvc3JjL2Rzdi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mZXRjaC9zcmMvanNvbi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mZXRjaC9zcmMvdGV4dC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2RlZmF1bHRMb2NhbGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9leHBvbmVudC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdERlY2ltYWwuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRHcm91cC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdE51bWVyYWxzLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0UHJlZml4QXV0by5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFJvdW5kZWQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRTcGVjaWZpZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRUcmltLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHlwZXMuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2xvY2FsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYmFzaXMuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL251bWJlci5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcmdiLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9kZWNvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL3BhcnNlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy96b29tLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXJhbmRvbS9zcmMvZGVmYXVsdFNvdXJjZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1yYW5kb20vc3JjL25vcm1hbC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2FycmF5LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdG9yLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbWF0Y2hlci5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9wb2ludGVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2FwcGVuZC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hdHRyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NhbGwuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vY2xhc3NlZC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbG9uZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXRhLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2RhdHVtLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VhY2guanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW1wdHkuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW50ZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZXhpdC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaHRtbC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbnNlcnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vam9pbi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9sb3dlci5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9ub2RlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGVzLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29uLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29yZGVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3Byb3BlcnR5LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JhaXNlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdENoaWxkLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdENoaWxkcmVuLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NpemUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc29ydC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zcGFyc2UuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vdGV4dC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdG9yLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3JBbGwuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zb3VyY2VFdmVudC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3dpbmRvdy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvdGltZW91dC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvdGltZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvYWN0aXZlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL2luZGV4LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL2ludGVycnVwdC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvc2VsZWN0aW9uL2ludGVycnVwdC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vdHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9hdHRyVHdlZW4uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9kZWxheS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2R1cmF0aW9uLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZWFzZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2VWYXJ5aW5nLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZW5kLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZmlsdGVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL21lcmdlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vb24uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zY2hlZHVsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3N0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGVUd2Vlbi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90ZXh0VHdlZW4uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vdHdlZW4uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvbm9ldmVudC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9BcHAuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvQmFja2dyb3VuZExheWVyLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL0JhY2tncm91bmRMYXllcldNUy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9EYXRhc2V0LmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL0RhdGFzZXRDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvR2VvQ2FudmFzLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL0xhYmVsTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvTGVnZW5kLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL0xpbmVMYXllci5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9TdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9Ub29sdGlwLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2J1dHRvbi9CdXR0b24uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvYnV0dG9uL0Z1bGxzY3JlZW5CdXR0b24uanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvYnV0dG9uL1pvb21CdXR0b25zLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2RhdGFzZXQvQ1NWR3JpZC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9kYXRhc2V0L0dyaWRUaWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2RhdGFzZXQvTEdyaWQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvZGF0YXNldC9UaWxlZEdyaWQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvbGVnZW5kL0NvbG9yQ2F0ZWdvcnlMZWdlbmQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvbGVnZW5kL0NvbG9yRGlzY3JldGVMZWdlbmQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvbGVnZW5kL0NvbG9yTGVnZW5kLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL2xlZ2VuZC9TZWdtZW50T3JpZW50YXRpb25MZWdlbmQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvbGVnZW5kL1NlZ21lbnRXaWR0aExlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9sZWdlbmQvU2l6ZUxlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9Db21wb3NpdGlvblN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL0NvbXBvc2l0aW9uU3R5bGVfLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL0NvbnRvdXJTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9Eb3REZW5zaXR5U3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvc3R5bGUvSXNvRmVuY2VTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9Kb3lQbG90U3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvc3R5bGUvTGVnb1N0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL01vc2FpY1N0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL05pbmphU3RhclN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL1BpbGxhclN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL1NlZ21lbnRTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9TaGFwZUNvbG9yU2l6ZVN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL1NoYXBlQ29sb3JTaXplU3R5bGVfLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL1NpZGVDYXRTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9TaWRlU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvc3R5bGUvU3F1YXJlQ29sb3JDYXRXR0xTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9TcXVhcmVDb2xvcldHTFN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL1N0cm9rZVN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL1RhbmFrYVN0eWxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3N0eWxlL1RleHRTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy9zdHlsZS9UaW1lU2VyaWVzU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvdXRpbHMvVXRpbHMuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvdXRpbHMvV2ViR0xTcXVhcmVDb2xvcmluZy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9ncmlkdml6L3NyYy91dGlscy9XZWJHTFNxdWFyZUNvbG9yaW5nQWR2YW5jZWQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvdXRpbHMvV2ViR0xTcXVhcmVDb2xvcmluZ0NhdEFkdmFuY2VkLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2dyaWR2aXovc3JjL3V0aWxzL3N0cmV0Y2hpbmcuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvZ3JpZHZpei9zcmMvdXRpbHMvd2ViR0xVdGlscy5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9oeXBhcnF1ZXQvc3JjL2Fzc2VtYmxlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvY29sdW1uLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvY29uc3RhbnRzLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvY29udmVydC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9oeXBhcnF1ZXQvc3JjL2RhdGFwYWdlLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvZGF0YXBhZ2VWMi5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9oeXBhcnF1ZXQvc3JjL2RlbHRhLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvZW5jb2RpbmcuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvaHlwYXJxdWV0L3NyYy9oZWFkZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvaHlwYXJxdWV0L3NyYy9oeXBhcnF1ZXQuanMiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9ub2RlX21vZHVsZXMvaHlwYXJxdWV0L3NyYy9tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9oeXBhcnF1ZXQvc3JjL3BsYWluLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vbm9kZV9tb2R1bGVzL2h5cGFycXVldC9zcmMvcmVhZC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9oeXBhcnF1ZXQvc3JjL3NjaGVtYS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9oeXBhcnF1ZXQvc3JjL3NuYXBweS5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9oeXBhcnF1ZXQvc3JjL3RocmlmdC5qcyIsIndlYnBhY2s6Ly9ndml6X3Bhci8uL25vZGVfbW9kdWxlcy9oeXBhcnF1ZXQvc3JjL3V0aWxzLmpzIiwid2VicGFjazovL2d2aXpfcGFyLy4vc3JjL1BhcnF1ZXRHcmlkLmpzIiwid2VicGFjazovL2d2aXpfcGFyL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2d2aXpfcGFyL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9ndml6X3Bhci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2d2aXpfcGFyL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vZ3Zpel9wYXIvLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZ3Zpel9wYXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZ3Zpel9wYXJcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCAoKSA9PiB7XG5yZXR1cm4gIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2xvcigpIHt9XG5cbmV4cG9ydCB2YXIgZGFya2VyID0gMC43O1xuZXhwb3J0IHZhciBicmlnaHRlciA9IDEgLyBkYXJrZXI7XG5cbnZhciByZUkgPSBcIlxcXFxzKihbKy1dP1xcXFxkKylcXFxccypcIixcbiAgICByZU4gPSBcIlxcXFxzKihbKy1dPyg/OlxcXFxkKlxcXFwuKT9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPylcXFxccypcIixcbiAgICByZVAgPSBcIlxcXFxzKihbKy1dPyg/OlxcXFxkKlxcXFwuKT9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCIsXG4gICAgcmVIZXggPSAvXiMoWzAtOWEtZl17Myw4fSkkLyxcbiAgICByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKGBecmdiXFxcXCgke3JlSX0sJHtyZUl9LCR7cmVJfVxcXFwpJGApLFxuICAgIHJlUmdiUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5yZ2JcXFxcKCR7cmVQfSwke3JlUH0sJHtyZVB9XFxcXCkkYCksXG4gICAgcmVSZ2JhSW50ZWdlciA9IG5ldyBSZWdFeHAoYF5yZ2JhXFxcXCgke3JlSX0sJHtyZUl9LCR7cmVJfSwke3JlTn1cXFxcKSRgKSxcbiAgICByZVJnYmFQZXJjZW50ID0gbmV3IFJlZ0V4cChgXnJnYmFcXFxcKCR7cmVQfSwke3JlUH0sJHtyZVB9LCR7cmVOfVxcXFwpJGApLFxuICAgIHJlSHNsUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5oc2xcXFxcKCR7cmVOfSwke3JlUH0sJHtyZVB9XFxcXCkkYCksXG4gICAgcmVIc2xhUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5oc2xhXFxcXCgke3JlTn0sJHtyZVB9LCR7cmVQfSwke3JlTn1cXFxcKSRgKTtcblxudmFyIG5hbWVkID0ge1xuICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICBhcXVhOiAweDAwZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXG4gIGF6dXJlOiAweGYwZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjLFxuICBiaXNxdWU6IDB4ZmZlNGM0LFxuICBibGFjazogMHgwMDAwMDAsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgYmx1ZTogMHgwMDAwZmYsXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICBicm93bjogMHhhNTJhMmEsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODcsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxuICBjb3JhbDogMHhmZjdmNTAsXG4gIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgY29ybnNpbGs6IDB4ZmZmOGRjLFxuICBjcmltc29uOiAweGRjMTQzYyxcbiAgY3lhbjogMHgwMGZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YixcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxuICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgZGFya2dyYXk6IDB4YTlhOWE5LFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICBkYXJrZ3JleTogMHhhOWE5YTksXG4gIGRhcmtraGFraTogMHhiZGI3NmIsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxuICBkZWVwcGluazogMHhmZjE0OTMsXG4gIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjksXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxuICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgZ29sZDogMHhmZmQ3MDAsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gIGdyYXk6IDB4ODA4MDgwLFxuICBncmVlbjogMHgwMDgwMDAsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgZ3JleTogMHg4MDgwODAsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMCxcbiAgaG90cGluazogMHhmZjY5YjQsXG4gIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gIGluZGlnbzogMHg0YjAwODIsXG4gIGl2b3J5OiAweGZmZmZmMCxcbiAga2hha2k6IDB4ZjBlNjhjLFxuICBsYXZlbmRlcjogMHhlNmU2ZmEsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgbGlnaHRjeWFuOiAweGUwZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MCxcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxuICBsaW1lOiAweDAwZmYwMCxcbiAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgbGluZW46IDB4ZmFmMGU2LFxuICBtYWdlbnRhOiAweGZmMDBmZixcbiAgbWFyb29uOiAweDgwMDAwMCxcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgbW9jY2FzaW46IDB4ZmZlNGI1LFxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gIG5hdnk6IDB4MDAwMDgwLFxuICBvbGRsYWNlOiAweGZkZjVlNixcbiAgb2xpdmU6IDB4ODA4MDAwLFxuICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICBvcmFuZ2U6IDB4ZmZhNTAwLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgcGVydTogMHhjZDg1M2YsXG4gIHBpbms6IDB4ZmZjMGNiLFxuICBwbHVtOiAweGRkYTBkZCxcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXG4gIHB1cnBsZTogMHg4MDAwODAsXG4gIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICByZWQ6IDB4ZmYwMDAwLFxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXG4gIHNhbG1vbjogMHhmYTgwNzIsXG4gIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICBzZWFncmVlbjogMHgyZThiNTcsXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgc2llbm5hOiAweGEwNTIyZCxcbiAgc2lsdmVyOiAweGMwYzBjMCxcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTAsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gIHNub3c6IDB4ZmZmYWZhLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gIHRhbjogMHhkMmI0OGMsXG4gIHRlYWw6IDB4MDA4MDgwLFxuICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgdG9tYXRvOiAweGZmNjM0NyxcbiAgdHVycXVvaXNlOiAweDQwZTBkMCxcbiAgdmlvbGV0OiAweGVlODJlZSxcbiAgd2hlYXQ6IDB4ZjVkZWIzLFxuICB3aGl0ZTogMHhmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcbn07XG5cbmRlZmluZShDb2xvciwgY29sb3IsIHtcbiAgY29weShjaGFubmVscykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLCBjaGFubmVscyk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpLmRpc3BsYXlhYmxlKCk7XG4gIH0sXG4gIGhleDogY29sb3JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IGNvbG9yX2Zvcm1hdEhleCxcbiAgZm9ybWF0SGV4ODogY29sb3JfZm9ybWF0SGV4OCxcbiAgZm9ybWF0SHNsOiBjb2xvcl9mb3JtYXRIc2wsXG4gIGZvcm1hdFJnYjogY29sb3JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogY29sb3JfZm9ybWF0UmdiXG59KTtcblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRIZXgoKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SGV4OCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4OCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIc2woKSB7XG4gIHJldHVybiBoc2xDb252ZXJ0KHRoaXMpLmZvcm1hdEhzbCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRSZ2IoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdFJnYigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG0sIGw7XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXguZXhlYyhmb3JtYXQpKSA/IChsID0gbVsxXS5sZW5ndGgsIG0gPSBwYXJzZUludChtWzFdLCAxNiksIGwgPT09IDYgPyByZ2JuKG0pIC8vICNmZjAwMDBcbiAgICAgIDogbCA9PT0gMyA/IG5ldyBSZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSwgMSkgLy8gI2YwMFxuICAgICAgOiBsID09PSA4ID8gcmdiYShtID4+IDI0ICYgMHhmZiwgbSA+PiAxNiAmIDB4ZmYsIG0gPj4gOCAmIDB4ZmYsIChtICYgMHhmZikgLyAweGZmKSAvLyAjZmYwMDAwMDBcbiAgICAgIDogbCA9PT0gNCA/IHJnYmEoKG0gPj4gMTIgJiAweGYpIHwgKG0gPj4gOCAmIDB4ZjApLCAobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSkgLyAweGZmKSAvLyAjZjAwMFxuICAgICAgOiBudWxsKSAvLyBpbnZhbGlkIGhleFxuICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdLCBtWzJdLCBtWzNdLCAxKSAvLyByZ2IoMjU1LCAwLCAwKVxuICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxuICAgICAgOiAobSA9IHJlUmdiYUludGVnZXIuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSwgbVsyXSwgbVszXSwgbVs0XSkgLy8gcmdiYSgyNTUsIDAsIDAsIDEpXG4gICAgICA6IChtID0gcmVSZ2JhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCBtWzRdKSAvLyByZ2IoMTAwJSwgMCUsIDAlLCAxKVxuICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcbiAgICAgIDogKG0gPSByZUhzbGFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIG1bNF0pIC8vIGhzbGEoMTIwLCA1MCUsIDUwJSwgMSlcbiAgICAgIDogbmFtZWQuaGFzT3duUHJvcGVydHkoZm9ybWF0KSA/IHJnYm4obmFtZWRbZm9ybWF0XSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApXG4gICAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJnYm4obikge1xuICByZXR1cm4gbmV3IFJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYsIDEpO1xufVxuXG5mdW5jdGlvbiByZ2JhKHIsIGcsIGIsIGEpIHtcbiAgaWYgKGEgPD0gMCkgciA9IGcgPSBiID0gTmFOO1xuICByZXR1cm4gbmV3IFJnYihyLCBnLCBiLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYkNvbnZlcnQobykge1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBSZ2I7XG4gIG8gPSBvLnJnYigpO1xuICByZXR1cm4gbmV3IFJnYihvLnIsIG8uZywgby5iLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICB0aGlzLnIgPSArcjtcbiAgdGhpcy5nID0gK2c7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKFJnYiwgcmdiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY2xhbXAoKSB7XG4gICAgcmV0dXJuIG5ldyBSZ2IoY2xhbXBpKHRoaXMuciksIGNsYW1waSh0aGlzLmcpLCBjbGFtcGkodGhpcy5iKSwgY2xhbXBhKHRoaXMub3BhY2l0eSkpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gKC0wLjUgPD0gdGhpcy5yICYmIHRoaXMuciA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmcgJiYgdGhpcy5nIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuYiAmJiB0aGlzLmIgPCAyNTUuNSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgaGV4OiByZ2JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IHJnYl9mb3JtYXRIZXgsXG4gIGZvcm1hdEhleDg6IHJnYl9mb3JtYXRIZXg4LFxuICBmb3JtYXRSZ2I6IHJnYl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiByZ2JfZm9ybWF0UmdiXG59KSk7XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiBgIyR7aGV4KHRoaXMucil9JHtoZXgodGhpcy5nKX0ke2hleCh0aGlzLmIpfWA7XG59XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRIZXg4KCkge1xuICByZXR1cm4gYCMke2hleCh0aGlzLnIpfSR7aGV4KHRoaXMuZyl9JHtoZXgodGhpcy5iKX0ke2hleCgoaXNOYU4odGhpcy5vcGFjaXR5KSA/IDEgOiB0aGlzLm9wYWNpdHkpICogMjU1KX1gO1xufVxuXG5mdW5jdGlvbiByZ2JfZm9ybWF0UmdiKCkge1xuICBjb25zdCBhID0gY2xhbXBhKHRoaXMub3BhY2l0eSk7XG4gIHJldHVybiBgJHthID09PSAxID8gXCJyZ2IoXCIgOiBcInJnYmEoXCJ9JHtjbGFtcGkodGhpcy5yKX0sICR7Y2xhbXBpKHRoaXMuZyl9LCAke2NsYW1waSh0aGlzLmIpfSR7YSA9PT0gMSA/IFwiKVwiIDogYCwgJHthfSlgfWA7XG59XG5cbmZ1bmN0aW9uIGNsYW1wYShvcGFjaXR5KSB7XG4gIHJldHVybiBpc05hTihvcGFjaXR5KSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBvcGFjaXR5KSk7XG59XG5cbmZ1bmN0aW9uIGNsYW1waSh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHZhbHVlKSB8fCAwKSk7XG59XG5cbmZ1bmN0aW9uIGhleCh2YWx1ZSkge1xuICB2YWx1ZSA9IGNsYW1waSh2YWx1ZSk7XG4gIHJldHVybiAodmFsdWUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyB2YWx1ZS50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIGhzbGEoaCwgcywgbCwgYSkge1xuICBpZiAoYSA8PSAwKSBoID0gcyA9IGwgPSBOYU47XG4gIGVsc2UgaWYgKGwgPD0gMCB8fCBsID49IDEpIGggPSBzID0gTmFOO1xuICBlbHNlIGlmIChzIDw9IDApIGggPSBOYU47XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbmV3IEhzbChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBIc2w7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcbiAgbyA9IG8ucmdiKCk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgaCA9IE5hTixcbiAgICAgIHMgPSBtYXggLSBtaW4sXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAocykge1xuICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcyArIChnIDwgYikgKiA2O1xuICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyBzICsgMjtcbiAgICBlbHNlIGggPSAociAtIGcpIC8gcyArIDQ7XG4gICAgcyAvPSBsIDwgMC41ID8gbWF4ICsgbWluIDogMiAtIG1heCAtIG1pbjtcbiAgICBoICo9IDYwO1xuICB9IGVsc2Uge1xuICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICB9XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhzbENvbnZlcnQoaCkgOiBuZXcgSHNsKGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gSHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShIc2wsIGhzbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYigpIHtcbiAgICB2YXIgaCA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCxcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxuICAgICAgICBsID0gdGhpcy5sLFxuICAgICAgICBtMiA9IGwgKyAobCA8IDAuNSA/IGwgOiAxIC0gbCkgKiBzLFxuICAgICAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBoc2wycmdiKGggPj0gMjQwID8gaCAtIDI0MCA6IGggKyAxMjAsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGgsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGggPCAxMjAgPyBoICsgMjQwIDogaCAtIDEyMCwgbTEsIG0yKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH0sXG4gIGNsYW1wKCkge1xuICAgIHJldHVybiBuZXcgSHNsKGNsYW1waCh0aGlzLmgpLCBjbGFtcHQodGhpcy5zKSwgY2xhbXB0KHRoaXMubCksIGNsYW1wYSh0aGlzLm9wYWNpdHkpKTtcbiAgfSxcbiAgZGlzcGxheWFibGUoKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGZvcm1hdEhzbCgpIHtcbiAgICBjb25zdCBhID0gY2xhbXBhKHRoaXMub3BhY2l0eSk7XG4gICAgcmV0dXJuIGAke2EgPT09IDEgPyBcImhzbChcIiA6IFwiaHNsYShcIn0ke2NsYW1waCh0aGlzLmgpfSwgJHtjbGFtcHQodGhpcy5zKSAqIDEwMH0lLCAke2NsYW1wdCh0aGlzLmwpICogMTAwfSUke2EgPT09IDEgPyBcIilcIiA6IGAsICR7YX0pYH1gO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIGNsYW1waCh2YWx1ZSkge1xuICB2YWx1ZSA9ICh2YWx1ZSB8fCAwKSAlIDM2MDtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IHZhbHVlICsgMzYwIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNsYW1wdCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUgfHwgMCkpO1xufVxuXG4vKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXG5mdW5jdGlvbiBoc2wycmdiKGgsIG0xLCBtMikge1xuICByZXR1cm4gKGggPCA2MCA/IG0xICsgKG0yIC0gbTEpICogaCAvIDYwXG4gICAgICA6IGggPCAxODAgPyBtMlxuICAgICAgOiBoIDwgMjQwID8gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MFxuICAgICAgOiBtMSkgKiAyNTU7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIGRlZmluaXRpb24pIHtcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSBwcm90b3R5cGVba2V5XSA9IGRlZmluaXRpb25ba2V5XTtcbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cbiIsInZhciBub29wID0ge3ZhbHVlOiAoKSA9PiB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSB8fCAvW1xccy5dLy50ZXN0KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgX1t0XSA9IFtdO1xuICB9XG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICB0LFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgfSxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRpc3BhdGNoO1xuIiwiaW1wb3J0IHtzZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2V2ZW50LCB7bm9ucGFzc2l2ZWNhcHR1cmV9IGZyb20gXCIuL25vZXZlbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmlldykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuX19ub3NlbGVjdCA9IHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdDtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24geWVzZHJhZyh2aWV3LCBub2NsaWNrKSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgaWYgKG5vY2xpY2spIHtcbiAgICBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG51bGwpOyB9LCAwKTtcbiAgfVxuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gcm9vdC5fX25vc2VsZWN0O1xuICAgIGRlbGV0ZSByb290Ll9fbm9zZWxlY3Q7XG4gIH1cbn1cbiIsIi8vIFRoZXNlIGFyZSB0eXBpY2FsbHkgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIG5vZXZlbnQgdG8gZW5zdXJlIHRoYXQgd2UgY2FuXG4vLyBwcmV2ZW50RGVmYXVsdCBvbiB0aGUgZXZlbnQuXG5leHBvcnQgY29uc3Qgbm9ucGFzc2l2ZSA9IHtwYXNzaXZlOiBmYWxzZX07XG5leHBvcnQgY29uc3Qgbm9ucGFzc2l2ZWNhcHR1cmUgPSB7Y2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogZmFsc2V9O1xuXG5leHBvcnQgZnVuY3Rpb24gbm9wcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJpbXBvcnQgZHN2IGZyb20gXCIuL2Rzdi5qc1wiO1xuXG52YXIgY3N2ID0gZHN2KFwiLFwiKTtcblxuZXhwb3J0IHZhciBjc3ZQYXJzZSA9IGNzdi5wYXJzZTtcbmV4cG9ydCB2YXIgY3N2UGFyc2VSb3dzID0gY3N2LnBhcnNlUm93cztcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0ID0gY3N2LmZvcm1hdDtcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0Qm9keSA9IGNzdi5mb3JtYXRCb2R5O1xuZXhwb3J0IHZhciBjc3ZGb3JtYXRSb3dzID0gY3N2LmZvcm1hdFJvd3M7XG5leHBvcnQgdmFyIGNzdkZvcm1hdFJvdyA9IGNzdi5mb3JtYXRSb3c7XG5leHBvcnQgdmFyIGNzdkZvcm1hdFZhbHVlID0gY3N2LmZvcm1hdFZhbHVlO1xuIiwidmFyIEVPTCA9IHt9LFxuICAgIEVPRiA9IHt9LFxuICAgIFFVT1RFID0gMzQsXG4gICAgTkVXTElORSA9IDEwLFxuICAgIFJFVFVSTiA9IDEzO1xuXG5mdW5jdGlvbiBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucykge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyBjb2x1bW5zLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdIHx8IFxcXCJcXFwiXCI7XG4gIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xufVxuXG5mdW5jdGlvbiBjdXN0b21Db252ZXJ0ZXIoY29sdW1ucywgZikge1xuICB2YXIgb2JqZWN0ID0gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpO1xuICByZXR1cm4gZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgcmV0dXJuIGYob2JqZWN0KHJvdyksIGksIGNvbHVtbnMpO1xuICB9O1xufVxuXG4vLyBDb21wdXRlIHVuaXF1ZSBjb2x1bW5zIGluIG9yZGVyIG9mIGRpc2NvdmVyeS5cbmZ1bmN0aW9uIGluZmVyQ29sdW1ucyhyb3dzKSB7XG4gIHZhciBjb2x1bW5TZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgY29sdW1ucyA9IFtdO1xuXG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICBmb3IgKHZhciBjb2x1bW4gaW4gcm93KSB7XG4gICAgICBpZiAoIShjb2x1bW4gaW4gY29sdW1uU2V0KSkge1xuICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uU2V0W2NvbHVtbl0gPSBjb2x1bW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbHVtbnM7XG59XG5cbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgd2lkdGgpIHtcbiAgdmFyIHMgPSB2YWx1ZSArIFwiXCIsIGxlbmd0aCA9IHMubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKDApICsgcyA6IHM7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXIoeWVhcikge1xuICByZXR1cm4geWVhciA8IDAgPyBcIi1cIiArIHBhZCgteWVhciwgNilcbiAgICA6IHllYXIgPiA5OTk5ID8gXCIrXCIgKyBwYWQoeWVhciwgNilcbiAgICA6IHBhZCh5ZWFyLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgIG1pbnV0ZXMgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgIHNlY29uZHMgPSBkYXRlLmdldFVUQ1NlY29uZHMoKSxcbiAgICAgIG1pbGxpc2Vjb25kcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHJldHVybiBpc05hTihkYXRlKSA/IFwiSW52YWxpZCBEYXRlXCJcbiAgICAgIDogZm9ybWF0WWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIDQpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENNb250aCgpICsgMSwgMikgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ0RhdGUoKSwgMilcbiAgICAgICsgKG1pbGxpc2Vjb25kcyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCI6XCIgKyBwYWQoc2Vjb25kcywgMikgKyBcIi5cIiArIHBhZChtaWxsaXNlY29uZHMsIDMpICsgXCJaXCJcbiAgICAgIDogc2Vjb25kcyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCI6XCIgKyBwYWQoc2Vjb25kcywgMikgKyBcIlpcIlxuICAgICAgOiBtaW51dGVzIHx8IGhvdXJzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIlpcIlxuICAgICAgOiBcIlwiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGVsaW1pdGVyKSB7XG4gIHZhciByZUZvcm1hdCA9IG5ldyBSZWdFeHAoXCJbXFxcIlwiICsgZGVsaW1pdGVyICsgXCJcXG5cXHJdXCIpLFxuICAgICAgREVMSU1JVEVSID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG5cbiAgZnVuY3Rpb24gcGFyc2UodGV4dCwgZikge1xuICAgIHZhciBjb252ZXJ0LCBjb2x1bW5zLCByb3dzID0gcGFyc2VSb3dzKHRleHQsIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgaWYgKGNvbnZlcnQpIHJldHVybiBjb252ZXJ0KHJvdywgaSAtIDEpO1xuICAgICAgY29sdW1ucyA9IHJvdywgY29udmVydCA9IGYgPyBjdXN0b21Db252ZXJ0ZXIocm93LCBmKSA6IG9iamVjdENvbnZlcnRlcihyb3cpO1xuICAgIH0pO1xuICAgIHJvd3MuY29sdW1ucyA9IGNvbHVtbnMgfHwgW107XG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVJvd3ModGV4dCwgZikge1xuICAgIHZhciByb3dzID0gW10sIC8vIG91dHB1dCByb3dzXG4gICAgICAgIE4gPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgSSA9IDAsIC8vIGN1cnJlbnQgY2hhcmFjdGVyIGluZGV4XG4gICAgICAgIG4gPSAwLCAvLyBjdXJyZW50IGxpbmUgbnVtYmVyXG4gICAgICAgIHQsIC8vIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgZW9mID0gTiA8PSAwLCAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPRj9cbiAgICAgICAgZW9sID0gZmFsc2U7IC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9MP1xuXG4gICAgLy8gU3RyaXAgdGhlIHRyYWlsaW5nIG5ld2xpbmUuXG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IE5FV0xJTkUpIC0tTjtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gUkVUVVJOKSAtLU47XG5cbiAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgIGlmIChlb2YpIHJldHVybiBFT0Y7XG4gICAgICBpZiAoZW9sKSByZXR1cm4gZW9sID0gZmFsc2UsIEVPTDtcblxuICAgICAgLy8gVW5lc2NhcGUgcXVvdGVzLlxuICAgICAgdmFyIGksIGogPSBJLCBjO1xuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA9PT0gUVVPVEUpIHtcbiAgICAgICAgd2hpbGUgKEkrKyA8IE4gJiYgdGV4dC5jaGFyQ29kZUF0KEkpICE9PSBRVU9URSB8fCB0ZXh0LmNoYXJDb2RlQXQoKytJKSA9PT0gUVVPVEUpO1xuICAgICAgICBpZiAoKGkgPSBJKSA+PSBOKSBlb2YgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChJKyspKSA9PT0gTkVXTElORSkgZW9sID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gUkVUVVJOKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpICsrSTsgfVxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqICsgMSwgaSAtIDEpLnJlcGxhY2UoL1wiXCIvZywgXCJcXFwiXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgZGVsaW1pdGVyIG9yIG5ld2xpbmUuXG4gICAgICB3aGlsZSAoSSA8IE4pIHtcbiAgICAgICAgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KGkgPSBJKyspKSA9PT0gTkVXTElORSkgZW9sID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gUkVUVVJOKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpICsrSTsgfVxuICAgICAgICBlbHNlIGlmIChjICE9PSBERUxJTUlURVIpIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqLCBpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGxhc3QgdG9rZW4gYmVmb3JlIEVPRi5cbiAgICAgIHJldHVybiBlb2YgPSB0cnVlLCB0ZXh0LnNsaWNlKGosIE4pO1xuICAgIH1cblxuICAgIHdoaWxlICgodCA9IHRva2VuKCkpICE9PSBFT0YpIHtcbiAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgIHdoaWxlICh0ICE9PSBFT0wgJiYgdCAhPT0gRU9GKSByb3cucHVzaCh0KSwgdCA9IHRva2VuKCk7XG4gICAgICBpZiAoZiAmJiAocm93ID0gZihyb3csIG4rKykpID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gcm93cy5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbY29sdW1uXSk7XG4gICAgICB9KS5qb2luKGRlbGltaXRlcik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQocm93cywgY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgcmV0dXJuIFtjb2x1bW5zLm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpXS5jb25jYXQocHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEJvZHkocm93cywgY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgcmV0dXJuIHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvd3Mocm93cykge1xuICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgcmV0dXJuIHJvdy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiXG4gICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZm9ybWF0RGF0ZSh2YWx1ZSlcbiAgICAgICAgOiByZUZvcm1hdC50ZXN0KHZhbHVlICs9IFwiXCIpID8gXCJcXFwiXCIgKyB2YWx1ZS5yZXBsYWNlKC9cIi9nLCBcIlxcXCJcXFwiXCIpICsgXCJcXFwiXCJcbiAgICAgICAgOiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHBhcnNlUm93czogcGFyc2VSb3dzLFxuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGZvcm1hdEJvZHk6IGZvcm1hdEJvZHksXG4gICAgZm9ybWF0Um93czogZm9ybWF0Um93cyxcbiAgICBmb3JtYXRSb3c6IGZvcm1hdFJvdyxcbiAgICBmb3JtYXRWYWx1ZTogZm9ybWF0VmFsdWVcbiAgfTtcbn1cbiIsImltcG9ydCBkc3YgZnJvbSBcIi4vZHN2LmpzXCI7XG5cbnZhciB0c3YgPSBkc3YoXCJcXHRcIik7XG5cbmV4cG9ydCB2YXIgdHN2UGFyc2UgPSB0c3YucGFyc2U7XG5leHBvcnQgdmFyIHRzdlBhcnNlUm93cyA9IHRzdi5wYXJzZVJvd3M7XG5leHBvcnQgdmFyIHRzdkZvcm1hdCA9IHRzdi5mb3JtYXQ7XG5leHBvcnQgdmFyIHRzdkZvcm1hdEJvZHkgPSB0c3YuZm9ybWF0Qm9keTtcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0Um93cyA9IHRzdi5mb3JtYXRSb3dzO1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRSb3cgPSB0c3YuZm9ybWF0Um93O1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRWYWx1ZSA9IHRzdi5mb3JtYXRWYWx1ZTtcbiIsImV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCAqIHQgOiAodCAtPSAyKSAqIHQgKiB0ICsgMikgLyAyO1xufVxuIiwiaW1wb3J0IHtjc3ZQYXJzZSwgZHN2Rm9ybWF0LCB0c3ZQYXJzZX0gZnJvbSBcImQzLWRzdlwiO1xuaW1wb3J0IHRleHQgZnJvbSBcIi4vdGV4dC5qc1wiO1xuXG5mdW5jdGlvbiBkc3ZQYXJzZShwYXJzZSkge1xuICByZXR1cm4gZnVuY3Rpb24oaW5wdXQsIGluaXQsIHJvdykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBpbml0ID09PSBcImZ1bmN0aW9uXCIpIHJvdyA9IGluaXQsIGluaXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRleHQoaW5wdXQsIGluaXQpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBwYXJzZShyZXNwb25zZSwgcm93KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZHN2KGRlbGltaXRlciwgaW5wdXQsIGluaXQsIHJvdykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgaW5pdCA9PT0gXCJmdW5jdGlvblwiKSByb3cgPSBpbml0LCBpbml0ID0gdW5kZWZpbmVkO1xuICB2YXIgZm9ybWF0ID0gZHN2Rm9ybWF0KGRlbGltaXRlcik7XG4gIHJldHVybiB0ZXh0KGlucHV0LCBpbml0KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGZvcm1hdC5wYXJzZShyZXNwb25zZSwgcm93KTtcbiAgfSk7XG59XG5cbmV4cG9ydCB2YXIgY3N2ID0gZHN2UGFyc2UoY3N2UGFyc2UpO1xuZXhwb3J0IHZhciB0c3YgPSBkc3ZQYXJzZSh0c3ZQYXJzZSk7XG4iLCJmdW5jdGlvbiByZXNwb25zZUpzb24ocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNSkgcmV0dXJuO1xuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VKc29uKTtcbn1cbiIsImZ1bmN0aW9uIHJlc3BvbnNlVGV4dChyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlVGV4dCk7XG59XG4iLCJpbXBvcnQgZm9ybWF0TG9jYWxlIGZyb20gXCIuL2xvY2FsZS5qc1wiO1xuXG52YXIgbG9jYWxlO1xuZXhwb3J0IHZhciBmb3JtYXQ7XG5leHBvcnQgdmFyIGZvcm1hdFByZWZpeDtcblxuZGVmYXVsdExvY2FsZSh7XG4gIHRob3VzYW5kczogXCIsXCIsXG4gIGdyb3VwaW5nOiBbM10sXG4gIGN1cnJlbmN5OiBbXCIkXCIsIFwiXCJdXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIGxvY2FsZSA9IGZvcm1hdExvY2FsZShkZWZpbml0aW9uKTtcbiAgZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgZm9ybWF0UHJlZml4ID0gbG9jYWxlLmZvcm1hdFByZWZpeDtcbiAgcmV0dXJuIGxvY2FsZTtcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPSBmb3JtYXREZWNpbWFsUGFydHMoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggPSBNYXRoLnJvdW5kKHgpKSA+PSAxZTIxXG4gICAgICA/IHgudG9Mb2NhbGVTdHJpbmcoXCJlblwiKS5yZXBsYWNlKC8sL2csIFwiXCIpXG4gICAgICA6IHgudG9TdHJpbmcoMTApO1xufVxuXG4vLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4vLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbi8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsUGFydHMoMS4yMykgcmV0dXJucyBbXCIxMjNcIiwgMF0uXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApIHtcbiAgaWYgKChpID0gKHggPSBwID8geC50b0V4cG9uZW50aWFsKHAgLSAxKSA6IHgudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSkgPCAwKSByZXR1cm4gbnVsbDsgLy8gTmFOLCDCsUluZmluaXR5XG4gIHZhciBpLCBjb2VmZmljaWVudCA9IHguc2xpY2UoMCwgaSk7XG5cbiAgLy8gVGhlIHN0cmluZyByZXR1cm5lZCBieSB0b0V4cG9uZW50aWFsIGVpdGhlciBoYXMgdGhlIGZvcm0gXFxkXFwuXFxkK2VbLStdXFxkK1xuICAvLyAoZS5nLiwgMS4yZSszKSBvciB0aGUgZm9ybSBcXGRlWy0rXVxcZCsgKGUuZy4sIDFlKzMpLlxuICByZXR1cm4gW1xuICAgIGNvZWZmaWNpZW50Lmxlbmd0aCA+IDEgPyBjb2VmZmljaWVudFswXSArIGNvZWZmaWNpZW50LnNsaWNlKDIpIDogY29lZmZpY2llbnQsXG4gICAgK3guc2xpY2UoaSArIDEpXG4gIF07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihncm91cGluZywgdGhvdXNhbmRzKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgdCA9IFtdLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgZyA9IGdyb3VwaW5nWzBdLFxuICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgZyA9IGdyb3VwaW5nW2ogPSAoaiArIDEpICUgZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obnVtZXJhbHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1swLTldL2csIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBudW1lcmFsc1sraV07XG4gICAgfSk7XG4gIH07XG59XG4iLCJpbXBvcnQge2Zvcm1hdERlY2ltYWxQYXJ0c30gZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuXG5leHBvcnQgdmFyIHByZWZpeEV4cG9uZW50O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXSxcbiAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgIG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gIHJldHVybiBpID09PSBuID8gY29lZmZpY2llbnRcbiAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICA6IGkgPiAwID8gY29lZmZpY2llbnQuc2xpY2UoMCwgaSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGkpXG4gICAgICA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gaSkuam9pbihcIjBcIikgKyBmb3JtYXREZWNpbWFsUGFydHMoeCwgTWF0aC5tYXgoMCwgcCArIGkgLSAxKSlbMF07IC8vIGxlc3MgdGhhbiAxeSFcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICByZXR1cm4gZXhwb25lbnQgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1leHBvbmVudCkuam9pbihcIjBcIikgKyBjb2VmZmljaWVudFxuICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG59XG4iLCIvLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW35dW3R5cGVdXG52YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyh+KT8oW2EteiVdKT8kL2k7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgaWYgKCEobWF0Y2ggPSByZS5leGVjKHNwZWNpZmllcikpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBzcGVjaWZpZXIpO1xuICB2YXIgbWF0Y2g7XG4gIHJldHVybiBuZXcgRm9ybWF0U3BlY2lmaWVyKHtcbiAgICBmaWxsOiBtYXRjaFsxXSxcbiAgICBhbGlnbjogbWF0Y2hbMl0sXG4gICAgc2lnbjogbWF0Y2hbM10sXG4gICAgc3ltYm9sOiBtYXRjaFs0XSxcbiAgICB6ZXJvOiBtYXRjaFs1XSxcbiAgICB3aWR0aDogbWF0Y2hbNl0sXG4gICAgY29tbWE6IG1hdGNoWzddLFxuICAgIHByZWNpc2lvbjogbWF0Y2hbOF0gJiYgbWF0Y2hbOF0uc2xpY2UoMSksXG4gICAgdHJpbTogbWF0Y2hbOV0sXG4gICAgdHlwZTogbWF0Y2hbMTBdXG4gIH0pO1xufVxuXG5mb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlID0gRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZTsgLy8gaW5zdGFuY2VvZlxuXG5leHBvcnQgZnVuY3Rpb24gRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICB0aGlzLmZpbGwgPSBzcGVjaWZpZXIuZmlsbCA9PT0gdW5kZWZpbmVkID8gXCIgXCIgOiBzcGVjaWZpZXIuZmlsbCArIFwiXCI7XG4gIHRoaXMuYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24gPT09IHVuZGVmaW5lZCA/IFwiPlwiIDogc3BlY2lmaWVyLmFsaWduICsgXCJcIjtcbiAgdGhpcy5zaWduID0gc3BlY2lmaWVyLnNpZ24gPT09IHVuZGVmaW5lZCA/IFwiLVwiIDogc3BlY2lmaWVyLnNpZ24gKyBcIlwiO1xuICB0aGlzLnN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBzcGVjaWZpZXIuc3ltYm9sICsgXCJcIjtcbiAgdGhpcy56ZXJvID0gISFzcGVjaWZpZXIuemVybztcbiAgdGhpcy53aWR0aCA9IHNwZWNpZmllci53aWR0aCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogK3NwZWNpZmllci53aWR0aDtcbiAgdGhpcy5jb21tYSA9ICEhc3BlY2lmaWVyLmNvbW1hO1xuICB0aGlzLnByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICtzcGVjaWZpZXIucHJlY2lzaW9uO1xuICB0aGlzLnRyaW0gPSAhIXNwZWNpZmllci50cmltO1xuICB0aGlzLnR5cGUgPSBzcGVjaWZpZXIudHlwZSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHNwZWNpZmllci50eXBlICsgXCJcIjtcbn1cblxuRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWxsXG4gICAgICArIHRoaXMuYWxpZ25cbiAgICAgICsgdGhpcy5zaWduXG4gICAgICArIHRoaXMuc3ltYm9sXG4gICAgICArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKVxuICAgICAgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMucHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCB0aGlzLnByZWNpc2lvbiB8IDApKVxuICAgICAgKyAodGhpcy50cmltID8gXCJ+XCIgOiBcIlwiKVxuICAgICAgKyB0aGlzLnR5cGU7XG59O1xuIiwiLy8gVHJpbXMgaW5zaWduaWZpY2FudCB6ZXJvcywgZS5nLiwgcmVwbGFjZXMgMS4yMDAwayB3aXRoIDEuMmsuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzKSB7XG4gIG91dDogZm9yICh2YXIgbiA9IHMubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICBzd2l0Y2ggKHNbaV0pIHtcbiAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogaWYgKCErc1tpXSkgYnJlYWsgb3V0OyBpZiAoaTAgPiAwKSBpMCA9IDA7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTAgPiAwID8gcy5zbGljZSgwLCBpMCkgKyBzLnNsaWNlKGkxICsgMSkgOiBzO1xufVxuIiwiaW1wb3J0IGZvcm1hdERlY2ltYWwgZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuaW1wb3J0IGZvcm1hdFByZWZpeEF1dG8gZnJvbSBcIi4vZm9ybWF0UHJlZml4QXV0by5qc1wiO1xuaW1wb3J0IGZvcm1hdFJvdW5kZWQgZnJvbSBcIi4vZm9ybWF0Um91bmRlZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFwiJVwiOiAoeCwgcCkgPT4gKHggKiAxMDApLnRvRml4ZWQocCksXG4gIFwiYlwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKSxcbiAgXCJjXCI6ICh4KSA9PiB4ICsgXCJcIixcbiAgXCJkXCI6IGZvcm1hdERlY2ltYWwsXG4gIFwiZVwiOiAoeCwgcCkgPT4geC50b0V4cG9uZW50aWFsKHApLFxuICBcImZcIjogKHgsIHApID0+IHgudG9GaXhlZChwKSxcbiAgXCJnXCI6ICh4LCBwKSA9PiB4LnRvUHJlY2lzaW9uKHApLFxuICBcIm9cIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCksXG4gIFwicFwiOiAoeCwgcCkgPT4gZm9ybWF0Um91bmRlZCh4ICogMTAwLCBwKSxcbiAgXCJyXCI6IGZvcm1hdFJvdW5kZWQsXG4gIFwic1wiOiBmb3JtYXRQcmVmaXhBdXRvLFxuICBcIlhcIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksXG4gIFwieFwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNilcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5pbXBvcnQgZm9ybWF0R3JvdXAgZnJvbSBcIi4vZm9ybWF0R3JvdXAuanNcIjtcbmltcG9ydCBmb3JtYXROdW1lcmFscyBmcm9tIFwiLi9mb3JtYXROdW1lcmFscy5qc1wiO1xuaW1wb3J0IGZvcm1hdFNwZWNpZmllciBmcm9tIFwiLi9mb3JtYXRTcGVjaWZpZXIuanNcIjtcbmltcG9ydCBmb3JtYXRUcmltIGZyb20gXCIuL2Zvcm1hdFRyaW0uanNcIjtcbmltcG9ydCBmb3JtYXRUeXBlcyBmcm9tIFwiLi9mb3JtYXRUeXBlcy5qc1wiO1xuaW1wb3J0IHtwcmVmaXhFeHBvbmVudH0gZnJvbSBcIi4vZm9ybWF0UHJlZml4QXV0by5qc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuL2lkZW50aXR5LmpzXCI7XG5cbnZhciBtYXAgPSBBcnJheS5wcm90b3R5cGUubWFwLFxuICAgIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obG9jYWxlKSB7XG4gIHZhciBncm91cCA9IGxvY2FsZS5ncm91cGluZyA9PT0gdW5kZWZpbmVkIHx8IGxvY2FsZS50aG91c2FuZHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0R3JvdXAobWFwLmNhbGwobG9jYWxlLmdyb3VwaW5nLCBOdW1iZXIpLCBsb2NhbGUudGhvdXNhbmRzICsgXCJcIiksXG4gICAgICBjdXJyZW5jeVByZWZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVswXSArIFwiXCIsXG4gICAgICBjdXJyZW5jeVN1ZmZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVsxXSArIFwiXCIsXG4gICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWwgPT09IHVuZGVmaW5lZCA/IFwiLlwiIDogbG9jYWxlLmRlY2ltYWwgKyBcIlwiLFxuICAgICAgbnVtZXJhbHMgPSBsb2NhbGUubnVtZXJhbHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0TnVtZXJhbHMobWFwLmNhbGwobG9jYWxlLm51bWVyYWxzLCBTdHJpbmcpKSxcbiAgICAgIHBlcmNlbnQgPSBsb2NhbGUucGVyY2VudCA9PT0gdW5kZWZpbmVkID8gXCIlXCIgOiBsb2NhbGUucGVyY2VudCArIFwiXCIsXG4gICAgICBtaW51cyA9IGxvY2FsZS5taW51cyA9PT0gdW5kZWZpbmVkID8gXCLiiJJcIiA6IGxvY2FsZS5taW51cyArIFwiXCIsXG4gICAgICBuYW4gPSBsb2NhbGUubmFuID09PSB1bmRlZmluZWQgPyBcIk5hTlwiIDogbG9jYWxlLm5hbiArIFwiXCI7XG5cbiAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllcikge1xuICAgIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuXG4gICAgdmFyIGZpbGwgPSBzcGVjaWZpZXIuZmlsbCxcbiAgICAgICAgYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24sXG4gICAgICAgIHNpZ24gPSBzcGVjaWZpZXIuc2lnbixcbiAgICAgICAgc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCxcbiAgICAgICAgemVybyA9IHNwZWNpZmllci56ZXJvLFxuICAgICAgICB3aWR0aCA9IHNwZWNpZmllci53aWR0aCxcbiAgICAgICAgY29tbWEgPSBzcGVjaWZpZXIuY29tbWEsXG4gICAgICAgIHByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24sXG4gICAgICAgIHRyaW0gPSBzcGVjaWZpZXIudHJpbSxcbiAgICAgICAgdHlwZSA9IHNwZWNpZmllci50eXBlO1xuXG4gICAgLy8gVGhlIFwiblwiIHR5cGUgaXMgYW4gYWxpYXMgZm9yIFwiLGdcIi5cbiAgICBpZiAodHlwZSA9PT0gXCJuXCIpIGNvbW1hID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gVGhlIFwiXCIgdHlwZSwgYW5kIGFueSBpbnZhbGlkIHR5cGUsIGlzIGFuIGFsaWFzIGZvciBcIi4xMn5nXCIuXG4gICAgZWxzZSBpZiAoIWZvcm1hdFR5cGVzW3R5cGVdKSBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCAmJiAocHJlY2lzaW9uID0gMTIpLCB0cmltID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gSWYgemVybyBmaWxsIGlzIHNwZWNpZmllZCwgcGFkZGluZyBnb2VzIGFmdGVyIHNpZ24gYW5kIGJlZm9yZSBkaWdpdHMuXG4gICAgaWYgKHplcm8gfHwgKGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikpIHplcm8gPSB0cnVlLCBmaWxsID0gXCIwXCIsIGFsaWduID0gXCI9XCI7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAvLyBGb3IgU0ktcHJlZml4LCB0aGUgc3VmZml4IGlzIGxhemlseSBjb21wdXRlZC5cbiAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5UHJlZml4IDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuICAgICAgICBzdWZmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lTdWZmaXggOiAvWyVwXS8udGVzdCh0eXBlKSA/IHBlcmNlbnQgOiBcIlwiO1xuXG4gICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cbiAgICAvLyBJcyB0aGlzIGFuIGludGVnZXIgdHlwZT9cbiAgICAvLyBDYW4gdGhpcyB0eXBlIGdlbmVyYXRlIGV4cG9uZW50aWFsIG5vdGF0aW9uP1xuICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXG4gICAgICAgIG1heWJlU3VmZml4ID0gL1tkZWZncHJzJV0vLnRlc3QodHlwZSk7XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXG4gICAgLy8gb3IgY2xhbXAgdGhlIHNwZWNpZmllZCBwcmVjaXNpb24gdG8gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAvLyBGb3Igc2lnbmlmaWNhbnQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFsxLCAyMV0uXG4gICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gNlxuICAgICAgICA6IC9bZ3Byc10vLnRlc3QodHlwZSkgPyBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSlcbiAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHN1ZmZpeCxcbiAgICAgICAgICBpLCBuLCBjO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgdmFsdWVTdWZmaXggPSBmb3JtYXRUeXBlKHZhbHVlKSArIHZhbHVlU3VmZml4O1xuICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNpZ24uIC0wIGlzIG5vdCBsZXNzIHRoYW4gMCwgYnV0IDEgLyAtMCBpcyFcbiAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSB2YWx1ZSA8IDAgfHwgMSAvIHZhbHVlIDwgMDtcblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIGZvcm1hdHRpbmcuXG4gICAgICAgIHZhbHVlID0gaXNOYU4odmFsdWUpID8gbmFuIDogZm9ybWF0VHlwZShNYXRoLmFicyh2YWx1ZSksIHByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gVHJpbSBpbnNpZ25pZmljYW50IHplcm9zLlxuICAgICAgICBpZiAodHJpbSkgdmFsdWUgPSBmb3JtYXRUcmltKHZhbHVlKTtcblxuICAgICAgICAvLyBJZiBhIG5lZ2F0aXZlIHZhbHVlIHJvdW5kcyB0byB6ZXJvIGFmdGVyIGZvcm1hdHRpbmcsIGFuZCBubyBleHBsaWNpdCBwb3NpdGl2ZSBzaWduIGlzIHJlcXVlc3RlZCwgaGlkZSB0aGUgc2lnbi5cbiAgICAgICAgaWYgKHZhbHVlTmVnYXRpdmUgJiYgK3ZhbHVlID09PSAwICYmIHNpZ24gIT09IFwiK1wiKSB2YWx1ZU5lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogbWludXMpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcbiAgICAgICAgdmFsdWVTdWZmaXggPSAodHlwZSA9PT0gXCJzXCIgPyBwcmVmaXhlc1s4ICsgcHJlZml4RXhwb25lbnQgLyAzXSA6IFwiXCIpICsgdmFsdWVTdWZmaXggKyAodmFsdWVOZWdhdGl2ZSAmJiBzaWduID09PSBcIihcIiA/IFwiKVwiIDogXCJcIik7XG5cbiAgICAgICAgLy8gQnJlYWsgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpbnRvIHRoZSBpbnRlZ2VyIOKAnHZhbHVl4oCdIHBhcnQgdGhhdCBjYW4gYmVcbiAgICAgICAgLy8gZ3JvdXBlZCwgYW5kIGZyYWN0aW9uYWwgb3IgZXhwb25lbnRpYWwg4oCcc3VmZml44oCdIHBhcnQgdGhhdCBpcyBub3QuXG4gICAgICAgIGlmIChtYXliZVN1ZmZpeCkge1xuICAgICAgICAgIGkgPSAtMSwgbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgaWYgKGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpLCA0OCA+IGMgfHwgYyA+IDU3KSB7XG4gICAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gKGMgPT09IDQ2ID8gZGVjaW1hbCArIHZhbHVlLnNsaWNlKGkgKyAxKSA6IHZhbHVlLnNsaWNlKGkpKSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIG5vdCBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBiZWZvcmUgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiAhemVybykgdmFsdWUgPSBncm91cCh2YWx1ZSwgSW5maW5pdHkpO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBwYWRkaW5nLlxuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlUHJlZml4Lmxlbmd0aCArIHZhbHVlLmxlbmd0aCArIHZhbHVlU3VmZml4Lmxlbmd0aCxcbiAgICAgICAgICBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcblxuICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGFmdGVyIHBhZGRpbmcuXG4gICAgICBpZiAoY29tbWEgJiYgemVybykgdmFsdWUgPSBncm91cChwYWRkaW5nICsgdmFsdWUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSB2YWx1ZVN1ZmZpeC5sZW5ndGggOiBJbmZpbml0eSksIHBhZGRpbmcgPSBcIlwiO1xuXG4gICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgZmluYWwgb3V0cHV0IGJhc2VkIG9uIHRoZSBkZXNpcmVkIGFsaWdubWVudC5cbiAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgY2FzZSBcIjxcIjogdmFsdWUgPSB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nOyBicmVhaztcbiAgICAgICAgY2FzZSBcIj1cIjogdmFsdWUgPSB2YWx1ZVByZWZpeCArIHBhZGRpbmcgKyB2YWx1ZSArIHZhbHVlU3VmZml4OyBicmVhaztcbiAgICAgICAgY2FzZSBcIl5cIjogdmFsdWUgPSBwYWRkaW5nLnNsaWNlKDAsIGxlbmd0aCA9IHBhZGRpbmcubGVuZ3RoID4+IDEpICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZy5zbGljZShsZW5ndGgpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdmFsdWUgPSBwYWRkaW5nICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4OyBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bWVyYWxzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3JtYXQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcGVjaWZpZXIgKyBcIlwiO1xuICAgIH07XG5cbiAgICByZXR1cm4gZm9ybWF0O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpIHtcbiAgICB2YXIgZiA9IG5ld0Zvcm1hdCgoc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciksIHNwZWNpZmllci50eXBlID0gXCJmXCIsIHNwZWNpZmllcikpLFxuICAgICAgICBlID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMsXG4gICAgICAgIGsgPSBNYXRoLnBvdygxMCwgLWUpLFxuICAgICAgICBwcmVmaXggPSBwcmVmaXhlc1s4ICsgZSAvIDNdO1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGYoayAqIHZhbHVlKSArIHByZWZpeDtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IG5ld0Zvcm1hdCxcbiAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGJhc2lzKHQxLCB2MCwgdjEsIHYyLCB2Mykge1xuICB2YXIgdDIgPSB0MSAqIHQxLCB0MyA9IHQyICogdDE7XG4gIHJldHVybiAoKDEgLSAzICogdDEgKyAzICogdDIgLSB0MykgKiB2MFxuICAgICAgKyAoNCAtIDYgKiB0MiArIDMgKiB0MykgKiB2MVxuICAgICAgKyAoMSArIDMgKiB0MSArIDMgKiB0MiAtIDMgKiB0MykgKiB2MlxuICAgICAgKyB0MyAqIHYzKSAvIDY7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdCA8PSAwID8gKHQgPSAwKSA6IHQgPj0gMSA/ICh0ID0gMSwgbiAtIDEpIDogTWF0aC5mbG9vcih0ICogbiksXG4gICAgICAgIHYxID0gdmFsdWVzW2ldLFxuICAgICAgICB2MiA9IHZhbHVlc1tpICsgMV0sXG4gICAgICAgIHYwID0gaSA+IDAgPyB2YWx1ZXNbaSAtIDFdIDogMiAqIHYxIC0gdjIsXG4gICAgICAgIHYzID0gaSA8IG4gLSAxID8gdmFsdWVzW2kgKyAyXSA6IDIgKiB2MiAtIHYxO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7YmFzaXN9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKCgodCAlPSAxKSA8IDAgPyArK3QgOiB0KSAqIG4pLFxuICAgICAgICB2MCA9IHZhbHVlc1soaSArIG4gLSAxKSAlIG5dLFxuICAgICAgICB2MSA9IHZhbHVlc1tpICUgbl0sXG4gICAgICAgIHYyID0gdmFsdWVzWyhpICsgMSkgJSBuXSxcbiAgICAgICAgdjMgPSB2YWx1ZXNbKGkgKyAyKSAlIG5dO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBsaW5lYXIoYSwgZCkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICsgdCAqIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9uZW50aWFsKGEsIGIsIHkpIHtcbiAgcmV0dXJuIGEgPSBNYXRoLnBvdyhhLCB5KSwgYiA9IE1hdGgucG93KGIsIHkpIC0gYSwgeSA9IDEgLyB5LCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGEgKyB0ICogYiwgeSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBodWUoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkID4gMTgwIHx8IGQgPCAtMTgwID8gZCAtIDM2MCAqIE1hdGgucm91bmQoZCAvIDM2MCkgOiBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2FtbWEoeSkge1xuICByZXR1cm4gKHkgPSAreSkgPT09IDEgPyBub2dhbW1hIDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYSA/IGV4cG9uZW50aWFsKGEsIGIsIHkpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vZ2FtbWEoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbiAgfTtcbn1cbiIsImltcG9ydCB7cmdiIGFzIGNvbG9yUmdifSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBiYXNpcyBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuaW1wb3J0IGJhc2lzQ2xvc2VkIGZyb20gXCIuL2Jhc2lzQ2xvc2VkLmpzXCI7XG5pbXBvcnQgbm9nYW1tYSwge2dhbW1hfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gcmdiR2FtbWEoeSkge1xuICB2YXIgY29sb3IgPSBnYW1tYSh5KTtcblxuICBmdW5jdGlvbiByZ2Ioc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gY29sb3IoKHN0YXJ0ID0gY29sb3JSZ2Ioc3RhcnQpKS5yLCAoZW5kID0gY29sb3JSZ2IoZW5kKSkuciksXG4gICAgICAgIGcgPSBjb2xvcihzdGFydC5nLCBlbmQuZyksXG4gICAgICAgIGIgPSBjb2xvcihzdGFydC5iLCBlbmQuYiksXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuciA9IHIodCk7XG4gICAgICBzdGFydC5nID0gZyh0KTtcbiAgICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICByZ2IuZ2FtbWEgPSByZ2JHYW1tYTtcblxuICByZXR1cm4gcmdiO1xufSkoMSk7XG5cbmZ1bmN0aW9uIHJnYlNwbGluZShzcGxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9ycykge1xuICAgIHZhciBuID0gY29sb3JzLmxlbmd0aCxcbiAgICAgICAgciA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgZyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgaSwgY29sb3I7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29sb3IgPSBjb2xvclJnYihjb2xvcnNbaV0pO1xuICAgICAgcltpXSA9IGNvbG9yLnIgfHwgMDtcbiAgICAgIGdbaV0gPSBjb2xvci5nIHx8IDA7XG4gICAgICBiW2ldID0gY29sb3IuYiB8fCAwO1xuICAgIH1cbiAgICByID0gc3BsaW5lKHIpO1xuICAgIGcgPSBzcGxpbmUoZyk7XG4gICAgYiA9IHNwbGluZShiKTtcbiAgICBjb2xvci5vcGFjaXR5ID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29sb3IuciA9IHIodCk7XG4gICAgICBjb2xvci5nID0gZyh0KTtcbiAgICAgIGNvbG9yLmIgPSBiKHQpO1xuICAgICAgcmV0dXJuIGNvbG9yICsgXCJcIjtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIHJnYkJhc2lzID0gcmdiU3BsaW5lKGJhc2lzKTtcbmV4cG9ydCB2YXIgcmdiQmFzaXNDbG9zZWQgPSByZ2JTcGxpbmUoYmFzaXNDbG9zZWQpO1xuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxudmFyIHJlQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZyxcbiAgICByZUIgPSBuZXcgUmVnRXhwKHJlQS5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gemVybyhiKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25lKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXG4gICAgICBhbSwgLy8gY3VycmVudCBtYXRjaCBpbiBhXG4gICAgICBibSwgLy8gY3VycmVudCBtYXRjaCBpbiBiXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcbiAgICAgIGkgPSAtMSwgLy8gaW5kZXggaW4gc1xuICAgICAgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAvLyBDb2VyY2UgaW5wdXRzIHRvIHN0cmluZ3MuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuXG4gIC8vIEludGVycG9sYXRlIHBhaXJzIG9mIG51bWJlcnMgaW4gYSAmIGIuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcbiAgICAgICYmIChibSA9IHJlQi5leGVjKGIpKSkge1xuICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkgeyAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkgeyAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHsgLy8gaW50ZXJwb2xhdGUgbm9uLW1hdGNoaW5nIG51bWJlcnNcbiAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICBxLnB1c2goe2k6IGksIHg6IG51bWJlcihhbSwgYm0pfSk7XG4gICAgfVxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCByZW1haW5zIG9mIGIuXG4gIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICBlbHNlIHNbKytpXSA9IGJzO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG4gIHJldHVybiBzLmxlbmd0aCA8IDIgPyAocVswXVxuICAgICAgPyBvbmUocVswXS54KVxuICAgICAgOiB6ZXJvKGIpKVxuICAgICAgOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbn1cbiIsInZhciBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IHtcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgcm90YXRlOiAwLFxuICBza2V3WDogMCxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQge3BhcnNlQ3NzLCBwYXJzZVN2Z30gZnJvbSBcIi4vcGFyc2UuanNcIjtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2UsIHB4Q29tbWEsIHB4UGFyZW4sIGRlZ1BhcmVuKSB7XG5cbiAgZnVuY3Rpb24gcG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIgXCIgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBweENvbW1hLCBudWxsLCBweFBhcmVuKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgfHwgeWIpIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiICsgeGIgKyBcIixcIiArIHliICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcbiAgICBhID0gcGFyc2UoYSksIGIgPSBwYXJzZShiKTtcbiAgICB0cmFuc2xhdGUoYS50cmFuc2xhdGVYLCBhLnRyYW5zbGF0ZVksIGIudHJhbnNsYXRlWCwgYi50cmFuc2xhdGVZLCBzLCBxKTtcbiAgICByb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBza2V3WChhLnNrZXdYLCBiLnNrZXdYLCBzLCBxKTtcbiAgICBzY2FsZShhLnNjYWxlWCwgYS5zY2FsZVksIGIuc2NhbGVYLCBiLnNjYWxlWSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsOyAvLyBnY1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VDc3MsIFwicHgsIFwiLCBcInB4KVwiLCBcImRlZylcIik7XG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VTdmcsIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcbiIsImltcG9ydCBkZWNvbXBvc2UsIHtpZGVudGl0eX0gZnJvbSBcIi4vZGVjb21wb3NlLmpzXCI7XG5cbnZhciBzdmdOb2RlO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGNvbnN0IG0gPSBuZXcgKHR5cGVvZiBET01NYXRyaXggPT09IFwiZnVuY3Rpb25cIiA/IERPTU1hdHJpeCA6IFdlYktpdENTU01hdHJpeCkodmFsdWUgKyBcIlwiKTtcbiAgcmV0dXJuIG0uaXNJZGVudGl0eSA/IGlkZW50aXR5IDogZGVjb21wb3NlKG0uYSwgbS5iLCBtLmMsIG0uZCwgbS5lLCBtLmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFzdmdOb2RlKSBzdmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICBzdmdOb2RlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB2YWx1ZSk7XG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5O1xuICB2YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcbn1cbiIsInZhciBlcHNpbG9uMiA9IDFlLTEyO1xuXG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCgyICogeCkpIC0gMSkgLyAoeCArIDEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gem9vbVJobyhyaG8sIHJobzIsIHJobzQpIHtcblxuICAvLyBwMCA9IFt1eDAsIHV5MCwgdzBdXG4gIC8vIHAxID0gW3V4MSwgdXkxLCB3MV1cbiAgZnVuY3Rpb24gem9vbShwMCwgcDEpIHtcbiAgICB2YXIgdXgwID0gcDBbMF0sIHV5MCA9IHAwWzFdLCB3MCA9IHAwWzJdLFxuICAgICAgICB1eDEgPSBwMVswXSwgdXkxID0gcDFbMV0sIHcxID0gcDFbMl0sXG4gICAgICAgIGR4ID0gdXgxIC0gdXgwLFxuICAgICAgICBkeSA9IHV5MSAtIHV5MCxcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgICAgaSxcbiAgICAgICAgUztcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdTAg4omFIHUxLlxuICAgIGlmIChkMiA8IGVwc2lsb24yKSB7XG4gICAgICBTID0gTWF0aC5sb2codzEgLyB3MCkgLyByaG87XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHV4MCArIHQgKiBkeCxcbiAgICAgICAgICB1eTAgKyB0ICogZHksXG4gICAgICAgICAgdzAgKiBNYXRoLmV4cChyaG8gKiB0ICogUylcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmFsIGNhc2UuXG4gICAgZWxzZSB7XG4gICAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLFxuICAgICAgICAgIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgcmhvNCAqIGQyKSAvICgyICogdzAgKiByaG8yICogZDEpLFxuICAgICAgICAgIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvNCAqIGQyKSAvICgyICogdzEgKiByaG8yICogZDEpLFxuICAgICAgICAgIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKSxcbiAgICAgICAgICByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gICAgICBTID0gKHIxIC0gcjApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHMgPSB0ICogUyxcbiAgICAgICAgICAgIGNvc2hyMCA9IGNvc2gocjApLFxuICAgICAgICAgICAgdSA9IHcwIC8gKHJobzIgKiBkMSkgKiAoY29zaHIwICogdGFuaChyaG8gKiBzICsgcjApIC0gc2luaChyMCkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHV4MCArIHUgKiBkeCxcbiAgICAgICAgICB1eTAgKyB1ICogZHksXG4gICAgICAgICAgdzAgKiBjb3NocjAgLyBjb3NoKHJobyAqIHMgKyByMClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpLmR1cmF0aW9uID0gUyAqIDEwMDAgKiByaG8gLyBNYXRoLlNRUlQyO1xuXG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICB6b29tLnJobyA9IGZ1bmN0aW9uKF8pIHtcbiAgICB2YXIgXzEgPSBNYXRoLm1heCgxZS0zLCArXyksIF8yID0gXzEgKiBfMSwgXzQgPSBfMiAqIF8yO1xuICAgIHJldHVybiB6b29tUmhvKF8xLCBfMiwgXzQpO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufSkoTWF0aC5TUVJUMiwgMiwgNCk7XG4iLCJleHBvcnQgZGVmYXVsdCBNYXRoLnJhbmRvbTtcbiIsImltcG9ydCBkZWZhdWx0U291cmNlIGZyb20gXCIuL2RlZmF1bHRTb3VyY2UuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHNvdXJjZVJhbmRvbU5vcm1hbChzb3VyY2UpIHtcbiAgZnVuY3Rpb24gcmFuZG9tTm9ybWFsKG11LCBzaWdtYSkge1xuICAgIHZhciB4LCByO1xuICAgIG11ID0gbXUgPT0gbnVsbCA/IDAgOiArbXU7XG4gICAgc2lnbWEgPSBzaWdtYSA9PSBudWxsID8gMSA6ICtzaWdtYTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeTtcblxuICAgICAgLy8gSWYgYXZhaWxhYmxlLCB1c2UgdGhlIHNlY29uZCBwcmV2aW91c2x5LWdlbmVyYXRlZCB1bmlmb3JtIHJhbmRvbS5cbiAgICAgIGlmICh4ICE9IG51bGwpIHkgPSB4LCB4ID0gbnVsbDtcblxuICAgICAgLy8gT3RoZXJ3aXNlLCBnZW5lcmF0ZSBhIG5ldyB4IGFuZCB5LlxuICAgICAgZWxzZSBkbyB7XG4gICAgICAgIHggPSBzb3VyY2UoKSAqIDIgLSAxO1xuICAgICAgICB5ID0gc291cmNlKCkgKiAyIC0gMTtcbiAgICAgICAgciA9IHggKiB4ICsgeSAqIHk7XG4gICAgICB9IHdoaWxlICghciB8fCByID4gMSk7XG5cbiAgICAgIHJldHVybiBtdSArIHNpZ21hICogeSAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHIpIC8gcik7XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbU5vcm1hbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21Ob3JtYWw7XG5cbiAgcmV0dXJuIHJhbmRvbU5vcm1hbDtcbn0pKGRlZmF1bHRTb3VyY2UpO1xuIiwiLy8gR2l2ZW4gc29tZXRoaW5nIGFycmF5IGxpa2UgKG9yIG51bGwpLCByZXR1cm5zIHNvbWV0aGluZyB0aGF0IGlzIHN0cmljdGx5IGFuXG4vLyBhcnJheS4gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IGFycmF5LWxpa2Ugb2JqZWN0cyBwYXNzZWQgdG8gZDMuc2VsZWN0QWxsXG4vLyBvciBzZWxlY3Rpb24uc2VsZWN0QWxsIGFyZSBjb252ZXJ0ZWQgaW50byBwcm9wZXIgYXJyYXlzIHdoZW4gY3JlYXRpbmcgYVxuLy8gc2VsZWN0aW9uOyB3ZSBkb27igJl0IGV2ZXIgd2FudCB0byBjcmVhdGUgYSBzZWxlY3Rpb24gYmFja2VkIGJ5IGEgbGl2ZVxuLy8gSFRNTENvbGxlY3Rpb24gb3IgTm9kZUxpc3QuIEhvd2V2ZXIsIG5vdGUgdGhhdCBzZWxlY3Rpb24uc2VsZWN0QWxsIHdpbGwgdXNlIGFcbi8vIHN0YXRpYyBOb2RlTGlzdCBhcyBhIGdyb3VwLCBzaW5jZSBpdCBzYWZlbHkgZGVyaXZlZCBmcm9tIHF1ZXJ5U2VsZWN0b3JBbGwuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcnJheSh4KSB7XG4gIHJldHVybiB4ID09IG51bGwgPyBbXSA6IEFycmF5LmlzQXJyYXkoeCkgPyB4IDogQXJyYXkuZnJvbSh4KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi9uYW1lc3BhY2UuanNcIjtcbmltcG9ydCB7eGh0bWx9IGZyb20gXCIuL25hbWVzcGFjZXMuanNcIjtcblxuZnVuY3Rpb24gY3JlYXRvckluaGVyaXQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LFxuICAgICAgICB1cmkgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModXJpLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxuICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkTWF0Y2hlcihzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufVxuXG4iLCJpbXBvcnQgbmFtZXNwYWNlcyBmcm9tIFwiLi9uYW1lc3BhY2VzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHByZWZpeCA9IG5hbWUgKz0gXCJcIiwgaSA9IHByZWZpeC5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICByZXR1cm4gbmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge3NwYWNlOiBuYW1lc3BhY2VzW3ByZWZpeF0sIGxvY2FsOiBuYW1lfSA6IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG59XG4iLCJleHBvcnQgdmFyIHhodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHhodG1sOiB4aHRtbCxcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbn07XG4iLCJpbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQsIG5vZGUpIHtcbiAgZXZlbnQgPSBzb3VyY2VFdmVudChldmVudCk7XG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIG5vZGUgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBpZiAobm9kZSkge1xuICAgIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuICAgIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFgsIHBvaW50LnkgPSBldmVudC5jbGllbnRZO1xuICAgICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgICB9XG4gICAgaWYgKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gW2V2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBub2RlLmNsaWVudExlZnQsIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIG5vZGUuY2xpZW50VG9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtldmVudC5wYWdlWCwgZXZlbnQucGFnZVldO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb24sIHJvb3R9IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xufVxuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9KTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSBcIi4uL25hbWVzcGFjZS5qc1wiO1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICByZXR1cm4gZnVsbG5hbWUubG9jYWxcbiAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcbiAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZnVuY3Rpb24gY2xhc3NBcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xufVxuXG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSkge1xuICByZXR1cm4gbm9kZS5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChub2RlKTtcbn1cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KG5vZGUpIHtcbiAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gIHRoaXMuX25hbWVzID0gY2xhc3NBcnJheShub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xufVxuXG5DbGFzc0xpc3QucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fbmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpID49IDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNsYXNzZWRBZGQobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QuYWRkKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFJlbW92ZShub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5yZW1vdmUobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZEFkZCh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGYWxzZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZFJlbW92ZSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbihuYW1lcywgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gY2xhc3NBcnJheShuYW1lICsgXCJcIik7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghbGlzdC5jb250YWlucyhuYW1lc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGNsYXNzZWRGdW5jdGlvbiA6IHZhbHVlXG4gICAgICA/IGNsYXNzZWRUcnVlXG4gICAgICA6IGNsYXNzZWRGYWxzZSkobmFtZXMsIHZhbHVlKSk7XG59XG4iLCJmdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KCkge1xuICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZShmYWxzZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZURlZXAoKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKHRydWUpLCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHRTaWJsaW5nKSA6IGNsb25lO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWVwKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChkZWVwID8gc2VsZWN0aW9uX2Nsb25lRGVlcCA6IHNlbGVjdGlvbl9jbG9uZVNoYWxsb3cpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge0VudGVyTm9kZX0gZnJvbSBcIi4vZW50ZXIuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi4vY29uc3RhbnQuanNcIjtcblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSBuZXcgTWFwLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpLFxuICAgICAga2V5VmFsdWU7XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXG4gIC8vIElmIG11bHRpcGxlIG5vZGVzIGhhdmUgdGhlIHNhbWUga2V5LCB0aGUgZHVwbGljYXRlcyBhcmUgYWRkZWQgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBrZXlWYWx1ZXNbaV0gPSBrZXlWYWx1ZSA9IGtleS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSArIFwiXCI7XG4gICAgICBpZiAobm9kZUJ5S2V5VmFsdWUuaGFzKGtleVZhbHVlKSkge1xuICAgICAgICBleGl0W2ldID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVCeUtleVZhbHVlLnNldChrZXlWYWx1ZSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIGRhdHVtLlxuICAvLyBJZiB0aGVyZSBhIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LCBqb2luIGFuZCBhZGQgaXQgdG8gdXBkYXRlLlxuICAvLyBJZiB0aGVyZSBpcyBub3QgKG9yIHRoZSBrZXkgaXMgYSBkdXBsaWNhdGUpLCBhZGQgaXQgdG8gZW50ZXIuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBrZXlWYWx1ZSA9IGtleS5jYWxsKHBhcmVudCwgZGF0YVtpXSwgaSwgZGF0YSkgKyBcIlwiO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlKSkge1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgbm9kZUJ5S2V5VmFsdWUuZGVsZXRlKGtleVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGFueSByZW1haW5pbmcgbm9kZXMgdGhhdCB3ZXJlIG5vdCBib3VuZCB0byBkYXRhIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWVzW2ldKSA9PT0gbm9kZSkpIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXR1bShub2RlKSB7XG4gIHJldHVybiBub2RlLl9fZGF0YV9fO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIEFycmF5LmZyb20odGhpcywgZGF0dW0pO1xuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgZm9yICh2YXIgbSA9IGdyb3Vwcy5sZW5ndGgsIHVwZGF0ZSA9IG5ldyBBcnJheShtKSwgZW50ZXIgPSBuZXcgQXJyYXkobSksIGV4aXQgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgICAgZGF0YSA9IGFycmF5bGlrZSh2YWx1ZS5jYWxsKHBhcmVudCwgcGFyZW50ICYmIHBhcmVudC5fX2RhdGFfXywgaiwgcGFyZW50cykpLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgdXBkYXRlR3JvdXAgPSB1cGRhdGVbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xuXG4gICAgYmluZChwYXJlbnQsIGdyb3VwLCBlbnRlckdyb3VwLCB1cGRhdGVHcm91cCwgZXhpdEdyb3VwLCBkYXRhLCBrZXkpO1xuXG4gICAgLy8gTm93IGNvbm5lY3QgdGhlIGVudGVyIG5vZGVzIHRvIHRoZWlyIGZvbGxvd2luZyB1cGRhdGUgbm9kZSwgc3VjaCB0aGF0XG4gICAgLy8gYXBwZW5kQ2hpbGQgY2FuIGluc2VydCB0aGUgbWF0ZXJpYWxpemVkIGVudGVyIG5vZGUgYmVmb3JlIHRoaXMgbm9kZSxcbiAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMCwgcHJldmlvdXMsIG5leHQ7IGkwIDwgZGF0YUxlbmd0aDsgKytpMCkge1xuICAgICAgaWYgKHByZXZpb3VzID0gZW50ZXJHcm91cFtpMF0pIHtcbiAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IHVwZGF0ZUdyb3VwW2kxXSkgJiYgKytpMSA8IGRhdGFMZW5ndGgpO1xuICAgICAgICBwcmV2aW91cy5fbmV4dCA9IG5leHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUgPSBuZXcgU2VsZWN0aW9uKHVwZGF0ZSwgcGFyZW50cyk7XG4gIHVwZGF0ZS5fZW50ZXIgPSBlbnRlcjtcbiAgdXBkYXRlLl9leGl0ID0gZXhpdDtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuLy8gR2l2ZW4gc29tZSBkYXRhLCB0aGlzIHJldHVybnMgYW4gYXJyYXktbGlrZSB2aWV3IG9mIGl0OiBhbiBvYmplY3QgdGhhdFxuLy8gZXhwb3NlcyBhIGxlbmd0aCBwcm9wZXJ0eSBhbmQgYWxsb3dzIG51bWVyaWMgaW5kZXhpbmcuIE5vdGUgdGhhdCB1bmxpa2Vcbi8vIHNlbGVjdEFsbCwgdGhpcyBpc27igJl0IHdvcnJpZWQgYWJvdXQg4oCcbGl2ZeKAnSBjb2xsZWN0aW9ucyBiZWNhdXNlIHRoZSByZXN1bHRpbmdcbi8vIGFycmF5IHdpbGwgb25seSBiZSB1c2VkIGJyaWVmbHkgd2hpbGUgZGF0YSBpcyBiZWluZyBib3VuZC4gKEl0IGlzIHBvc3NpYmxlIHRvXG4vLyBjYXVzZSB0aGUgZGF0YSB0byBjaGFuZ2Ugd2hpbGUgaXRlcmF0aW5nIGJ5IHVzaW5nIGEga2V5IGZ1bmN0aW9uLCBidXQgcGxlYXNlXG4vLyBkb27igJl0OyB3ZeKAmWQgcmF0aGVyIGF2b2lkIGEgZ3JhdHVpdG91cyBjb3B5LilcbmZ1bmN0aW9uIGFycmF5bGlrZShkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIGRhdGFcbiAgICA/IGRhdGEgLy8gQXJyYXksIFR5cGVkQXJyYXksIE5vZGVMaXN0LCBhcnJheS1saWtlXG4gICAgOiBBcnJheS5mcm9tKGRhdGEpOyAvLyBNYXAsIFNldCwgaXRlcmFibGUsIHN0cmluZywgb3IgYW55dGhpbmcgZWxzZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKVxuICAgICAgOiB0aGlzLm5vZGUoKS5fX2RhdGFfXztcbn1cbiIsImltcG9ydCBkZWZhdWx0VmlldyBmcm9tIFwiLi4vd2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQobm9kZSwgdHlwZSwgcGFyYW1zKSB7XG4gIHZhciB3aW5kb3cgPSBkZWZhdWx0Vmlldyhub2RlKSxcbiAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGV2ZW50ID0gbmV3IGV2ZW50KHR5cGUsIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBpZiAocGFyYW1zKSBldmVudC5pbml0RXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlKSwgZXZlbnQuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgICBlbHNlIGV2ZW50LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICB9XG5cbiAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDb25zdGFudCh0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZGlzcGF0Y2hGdW5jdGlvblxuICAgICAgOiBkaXNwYXRjaENvbnN0YW50KSh0eXBlLCBwYXJhbXMpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59XG4iLCJpbXBvcnQgc3BhcnNlIGZyb20gXCIuL3NwYXJzZS5qc1wiO1xuaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9lbnRlciB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRW50ZXJOb2RlKHBhcmVudCwgZGF0dW0pIHtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2RhdGFfXyA9IGRhdHVtO1xufVxuXG5FbnRlck5vZGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRW50ZXJOb2RlLFxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX25leHQpOyB9LFxuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkLCBuZXh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTsgfSxcbiAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfSxcbiAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfVxufTtcbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlLmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2V4aXQgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IG1hdGNoZXIgZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJmdW5jdGlvbiBodG1sUmVtb3ZlKCkge1xuICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGh0bWxDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHRtbEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IGh0bWxSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGh0bWxGdW5jdGlvblxuICAgICAgICAgIDogaHRtbENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLmlubmVySFRNTDtcbn1cbiIsImltcG9ydCBzZWxlY3Rpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RBbGwgZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdENoaWxkIGZyb20gXCIuL3NlbGVjdENoaWxkLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdENoaWxkcmVuIGZyb20gXCIuL3NlbGVjdENoaWxkcmVuLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0YSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VudGVyIGZyb20gXCIuL2VudGVyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2V4aXQgZnJvbSBcIi4vZXhpdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9qb2luIGZyb20gXCIuL2pvaW4uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbWVyZ2UgZnJvbSBcIi4vbWVyZ2UuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fb3JkZXIgZnJvbSBcIi4vb3JkZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc29ydCBmcm9tIFwiLi9zb3J0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2NhbGwgZnJvbSBcIi4vY2FsbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlcyBmcm9tIFwiLi9ub2Rlcy5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlIGZyb20gXCIuL25vZGUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2l6ZSBmcm9tIFwiLi9zaXplLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VtcHR5IGZyb20gXCIuL2VtcHR5LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VhY2ggZnJvbSBcIi4vZWFjaC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9hdHRyIGZyb20gXCIuL2F0dHIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcHJvcGVydHkgZnJvbSBcIi4vcHJvcGVydHkuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xhc3NlZCBmcm9tIFwiLi9jbGFzc2VkLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3RleHQgZnJvbSBcIi4vdGV4dC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9odG1sIGZyb20gXCIuL2h0bWwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmFpc2UgZnJvbSBcIi4vcmFpc2UuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbG93ZXIgZnJvbSBcIi4vbG93ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fYXBwZW5kIGZyb20gXCIuL2FwcGVuZC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9pbnNlcnQgZnJvbSBcIi4vaW5zZXJ0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3JlbW92ZSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xvbmUgZnJvbSBcIi4vY2xvbmUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0dW0gZnJvbSBcIi4vZGF0dW0uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fb24gZnJvbSBcIi4vb24uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGlzcGF0Y2ggZnJvbSBcIi4vZGlzcGF0Y2guanNcIjtcbmltcG9ydCBzZWxlY3Rpb25faXRlcmF0b3IgZnJvbSBcIi4vaXRlcmF0b3IuanNcIjtcblxuZXhwb3J0IHZhciByb290ID0gW251bGxdO1xuXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0aW9uKGdyb3VwcywgcGFyZW50cykge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XV0sIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblxuU2VsZWN0aW9uLnByb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb24sXG4gIHNlbGVjdDogc2VsZWN0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiBzZWxlY3Rpb25fc2VsZWN0QWxsLFxuICBzZWxlY3RDaGlsZDogc2VsZWN0aW9uX3NlbGVjdENoaWxkLFxuICBzZWxlY3RDaGlsZHJlbjogc2VsZWN0aW9uX3NlbGVjdENoaWxkcmVuLFxuICBmaWx0ZXI6IHNlbGVjdGlvbl9maWx0ZXIsXG4gIGRhdGE6IHNlbGVjdGlvbl9kYXRhLFxuICBlbnRlcjogc2VsZWN0aW9uX2VudGVyLFxuICBleGl0OiBzZWxlY3Rpb25fZXhpdCxcbiAgam9pbjogc2VsZWN0aW9uX2pvaW4sXG4gIG1lcmdlOiBzZWxlY3Rpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogc2VsZWN0aW9uX3NlbGVjdGlvbixcbiAgb3JkZXI6IHNlbGVjdGlvbl9vcmRlcixcbiAgc29ydDogc2VsZWN0aW9uX3NvcnQsXG4gIGNhbGw6IHNlbGVjdGlvbl9jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX25vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fbm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3NpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9lYWNoLFxuICBhdHRyOiBzZWxlY3Rpb25fYXR0cixcbiAgc3R5bGU6IHNlbGVjdGlvbl9zdHlsZSxcbiAgcHJvcGVydHk6IHNlbGVjdGlvbl9wcm9wZXJ0eSxcbiAgY2xhc3NlZDogc2VsZWN0aW9uX2NsYXNzZWQsXG4gIHRleHQ6IHNlbGVjdGlvbl90ZXh0LFxuICBodG1sOiBzZWxlY3Rpb25faHRtbCxcbiAgcmFpc2U6IHNlbGVjdGlvbl9yYWlzZSxcbiAgbG93ZXI6IHNlbGVjdGlvbl9sb3dlcixcbiAgYXBwZW5kOiBzZWxlY3Rpb25fYXBwZW5kLFxuICBpbnNlcnQ6IHNlbGVjdGlvbl9pbnNlcnQsXG4gIHJlbW92ZTogc2VsZWN0aW9uX3JlbW92ZSxcbiAgY2xvbmU6IHNlbGVjdGlvbl9jbG9uZSxcbiAgZGF0dW06IHNlbGVjdGlvbl9kYXR1bSxcbiAgb246IHNlbGVjdGlvbl9vbixcbiAgZGlzcGF0Y2g6IHNlbGVjdGlvbl9kaXNwYXRjaCxcbiAgW1N5bWJvbC5pdGVyYXRvcl06IHNlbGVjdGlvbl9pdGVyYXRvclxufTtcblxuZXhwb3J0IGRlZmF1bHQgc2VsZWN0aW9uO1xuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3IuanNcIjtcbmltcG9ydCBzZWxlY3RvciBmcm9tIFwiLi4vc2VsZWN0b3IuanNcIjtcblxuZnVuY3Rpb24gY29uc3RhbnROdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSksXG4gICAgICBzZWxlY3QgPSBiZWZvcmUgPT0gbnVsbCA/IGNvbnN0YW50TnVsbCA6IHR5cGVvZiBiZWZvcmUgPT09IFwiZnVuY3Rpb25cIiA/IGJlZm9yZSA6IHNlbGVjdG9yKGJlZm9yZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKigpIHtcbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHlpZWxkIG5vZGU7XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvbmVudGVyLCBvbnVwZGF0ZSwgb25leGl0KSB7XG4gIHZhciBlbnRlciA9IHRoaXMuZW50ZXIoKSwgdXBkYXRlID0gdGhpcywgZXhpdCA9IHRoaXMuZXhpdCgpO1xuICBpZiAodHlwZW9mIG9uZW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGVudGVyID0gb25lbnRlcihlbnRlcik7XG4gICAgaWYgKGVudGVyKSBlbnRlciA9IGVudGVyLnNlbGVjdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIGVudGVyID0gZW50ZXIuYXBwZW5kKG9uZW50ZXIgKyBcIlwiKTtcbiAgfVxuICBpZiAob251cGRhdGUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZSA9IG9udXBkYXRlKHVwZGF0ZSk7XG4gICAgaWYgKHVwZGF0ZSkgdXBkYXRlID0gdXBkYXRlLnNlbGVjdGlvbigpO1xuICB9XG4gIGlmIChvbmV4aXQgPT0gbnVsbCkgZXhpdC5yZW1vdmUoKTsgZWxzZSBvbmV4aXQoZXhpdCk7XG4gIHJldHVybiBlbnRlciAmJiB1cGRhdGUgPyBlbnRlci5tZXJnZSh1cGRhdGUpLm9yZGVyKCkgOiB1cGRhdGU7XG59XG4iLCJmdW5jdGlvbiBsb3dlcigpIHtcbiAgaWYgKHRoaXMucHJldmlvdXNTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gobG93ZXIpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGNvbnRleHQuc2VsZWN0aW9uID8gY29udGV4dC5zZWxlY3Rpb24oKSA6IGNvbnRleHQ7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG59XG4iLCJmdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCwgdGhpcy5fX2RhdGFfXyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uUmVtb3ZlKHR5cGVuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb247XG4gICAgaWYgKCFvbikgcmV0dXJuO1xuICAgIGZvciAodmFyIGogPSAwLCBpID0gLTEsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGlmIChvID0gb25bal0sICghdHlwZW5hbWUudHlwZSB8fCBvLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUpICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25bKytpXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgrK2kpIG9uLmxlbmd0aCA9IGk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fX29uO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFkZCh0eXBlbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbiwgbywgbGlzdGVuZXIgPSBjb250ZXh0TGlzdGVuZXIodmFsdWUpO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgIGlmICgobyA9IG9uW2pdKS50eXBlID09PSB0eXBlbmFtZS50eXBlICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyID0gbGlzdGVuZXIsIG8ub3B0aW9ucyA9IG9wdGlvbnMpO1xuICAgICAgICBvLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGVuYW1lLnR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICBvID0ge3R5cGU6IHR5cGVuYW1lLnR5cGUsIG5hbWU6IHR5cGVuYW1lLm5hbWUsIHZhbHVlOiB2YWx1ZSwgbGlzdGVuZXI6IGxpc3RlbmVyLCBvcHRpb25zOiBvcHRpb25zfTtcbiAgICBpZiAoIW9uKSB0aGlzLl9fb24gPSBbb107XG4gICAgZWxzZSBvbi5wdXNoKG8pO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0eXBlbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHR5cGVuYW1lcyA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiksIGksIG4gPSB0eXBlbmFtZXMubGVuZ3RoLCB0O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBvbiA9IHRoaXMubm9kZSgpLl9fb247XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgZm9yIChpID0gMCwgbyA9IG9uW2pdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICgodCA9IHR5cGVuYW1lc1tpXSkudHlwZSA9PT0gby50eXBlICYmIHQubmFtZSA9PT0gby5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb24gPSB2YWx1ZSA/IG9uQWRkIDogb25SZW1vdmU7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBvcHRpb25zKSk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gLTEsIG0gPSBncm91cHMubGVuZ3RoOyArK2ogPCBtOykge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gZ3JvdXAubGVuZ3RoIC0gMSwgbmV4dCA9IGdyb3VwW2ldLCBub2RlOyAtLWkgPj0gMDspIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgaWYgKG5leHQgJiYgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuZXh0KSBeIDQpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZnVuY3Rpb24gcHJvcGVydHlSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIGVsc2UgdGhpc1tuYW1lXSA9IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHByb3BlcnR5UmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHByb3BlcnR5RnVuY3Rpb25cbiAgICAgICAgICA6IHByb3BlcnR5Q29uc3RhbnQpKG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKClbbmFtZV07XG59XG4iLCJmdW5jdGlvbiByYWlzZSgpIHtcbiAgaWYgKHRoaXMubmV4dFNpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmFpc2UpO1xufVxuIiwiZnVuY3Rpb24gcmVtb3ZlKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJlbW92ZSk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzZWxlY3RvciBmcm9tIFwiLi4vc2VsZWN0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBhcnJheSBmcm9tIFwiLi4vYXJyYXkuanNcIjtcbmltcG9ydCBzZWxlY3RvckFsbCBmcm9tIFwiLi4vc2VsZWN0b3JBbGwuanNcIjtcblxuZnVuY3Rpb24gYXJyYXlBbGwoc2VsZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJyYXkoc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgPT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gYXJyYXlBbGwoc2VsZWN0KTtcbiAgZWxzZSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtjaGlsZE1hdGNoZXJ9IGZyb20gXCIuLi9tYXRjaGVyLmpzXCI7XG5cbnZhciBmaW5kID0gQXJyYXkucHJvdG90eXBlLmZpbmQ7XG5cbmZ1bmN0aW9uIGNoaWxkRmluZChtYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZpbmQuY2FsbCh0aGlzLmNoaWxkcmVuLCBtYXRjaCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoaWxkRmlyc3QoKSB7XG4gIHJldHVybiB0aGlzLmZpcnN0RWxlbWVudENoaWxkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3QobWF0Y2ggPT0gbnVsbCA/IGNoaWxkRmlyc3RcbiAgICAgIDogY2hpbGRGaW5kKHR5cGVvZiBtYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gbWF0Y2ggOiBjaGlsZE1hdGNoZXIobWF0Y2gpKSk7XG59XG4iLCJpbXBvcnQge2NoaWxkTWF0Y2hlcn0gZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxudmFyIGZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXI7XG5cbmZ1bmN0aW9uIGNoaWxkcmVuKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gY2hpbGRyZW5GaWx0ZXIobWF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmaWx0ZXIuY2FsbCh0aGlzLmNoaWxkcmVuLCBtYXRjaCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdEFsbChtYXRjaCA9PSBudWxsID8gY2hpbGRyZW5cbiAgICAgIDogY2hpbGRyZW5GaWx0ZXIodHlwZW9mIG1hdGNoID09PSBcImZ1bmN0aW9uXCIgPyBtYXRjaCA6IGNoaWxkTWF0Y2hlcihtYXRjaCkpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICBsZXQgc2l6ZSA9IDA7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzKSArK3NpemU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoIWNvbXBhcmUpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgZnVuY3Rpb24gY29tcGFyZU5vZGUoYSwgYikge1xuICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJlKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHNvcnRncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHNvcnRncm91cCA9IHNvcnRncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNvcnRncm91cFtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvcnRncm91cC5zb3J0KGNvbXBhcmVOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHNvcnRncm91cHMsIHRoaXMuX3BhcmVudHMpLm9yZGVyKCk7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHVwZGF0ZSkge1xuICByZXR1cm4gbmV3IEFycmF5KHVwZGF0ZS5sZW5ndGgpO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3cuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2LCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHN0eWxlUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxuICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICA6IHN0eWxlVmFsdWUodGhpcy5ub2RlKCksIG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVWYWx1ZShub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSlcbiAgICAgIHx8IGRlZmF1bHRWaWV3KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRSZW1vdmUoKSB7XG4gIHRoaXMudGV4dENvbnRlbnQgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gdGV4dFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gdGV4dEZ1bmN0aW9uXG4gICAgICAgICAgOiB0ZXh0Q29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG59XG4iLCJmdW5jdGlvbiBub25lKCkge31cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJmdW5jdGlvbiBlbXB0eSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBsZXQgc291cmNlRXZlbnQ7XG4gIHdoaWxlIChzb3VyY2VFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50KSBldmVudCA9IHNvdXJjZUV2ZW50O1xuICByZXR1cm4gZXZlbnQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgLy8gbm9kZSBpcyBhIE5vZGVcbiAgICAgIHx8IChub2RlLmRvY3VtZW50ICYmIG5vZGUpIC8vIG5vZGUgaXMgYSBXaW5kb3dcbiAgICAgIHx8IG5vZGUuZGVmYXVsdFZpZXc7IC8vIG5vZGUgaXMgYSBEb2N1bWVudFxufVxuIiwiaW1wb3J0IHtUaW1lcn0gZnJvbSBcIi4vdGltZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICBkZWxheSA9IGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5O1xuICB0LnJlc3RhcnQoZWxhcHNlZCA9PiB7XG4gICAgdC5zdG9wKCk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCArIGRlbGF5KTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cbiIsInZhciBmcmFtZSA9IDAsIC8vIGlzIGFuIGFuaW1hdGlvbiBmcmFtZSBwZW5kaW5nP1xuICAgIHRpbWVvdXQgPSAwLCAvLyBpcyBhIHRpbWVvdXQgcGVuZGluZz9cbiAgICBpbnRlcnZhbCA9IDAsIC8vIGFyZSBhbnkgdGltZXJzIGFjdGl2ZT9cbiAgICBwb2tlRGVsYXkgPSAxMDAwLCAvLyBob3cgZnJlcXVlbnRseSB3ZSBjaGVjayBmb3IgY2xvY2sgc2tld1xuICAgIHRhc2tIZWFkLFxuICAgIHRhc2tUYWlsLFxuICAgIGNsb2NrTGFzdCA9IDAsXG4gICAgY2xvY2tOb3cgPSAwLFxuICAgIGNsb2NrU2tldyA9IDAsXG4gICAgY2xvY2sgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwib2JqZWN0XCIgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2UgOiBEYXRlLFxuICAgIHNldEZyYW1lID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbihmKSB7IHNldFRpbWVvdXQoZiwgMTcpOyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xuICBjbG9ja05vdyA9IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUaW1lcigpIHtcbiAgdGhpcy5fY2FsbCA9XG4gIHRoaXMuX3RpbWUgPVxuICB0aGlzLl9uZXh0ID0gbnVsbDtcbn1cblxuVGltZXIucHJvdG90eXBlID0gdGltZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGltZXIsXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIHRpbWUgPSAodGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZSkgKyAoZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXkpO1xuICAgIGlmICghdGhpcy5fbmV4dCAmJiB0YXNrVGFpbCAhPT0gdGhpcykge1xuICAgICAgaWYgKHRhc2tUYWlsKSB0YXNrVGFpbC5fbmV4dCA9IHRoaXM7XG4gICAgICBlbHNlIHRhc2tIZWFkID0gdGhpcztcbiAgICAgIHRhc2tUYWlsID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fY2FsbCA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHNsZWVwKCk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jYWxsKSB7XG4gICAgICB0aGlzLl9jYWxsID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWUgPSBJbmZpbml0eTtcbiAgICAgIHNsZWVwKCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZXIoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lckZsdXNoKCkge1xuICBub3coKTsgLy8gR2V0IHRoZSBjdXJyZW50IHRpbWUsIGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgKytmcmFtZTsgLy8gUHJldGVuZCB3ZeKAmXZlIHNldCBhbiBhbGFybSwgaWYgd2UgaGF2ZW7igJl0IGFscmVhZHkuXG4gIHZhciB0ID0gdGFza0hlYWQsIGU7XG4gIHdoaWxlICh0KSB7XG4gICAgaWYgKChlID0gY2xvY2tOb3cgLSB0Ll90aW1lKSA+PSAwKSB0Ll9jYWxsLmNhbGwodW5kZWZpbmVkLCBlKTtcbiAgICB0ID0gdC5fbmV4dDtcbiAgfVxuICAtLWZyYW1lO1xufVxuXG5mdW5jdGlvbiB3YWtlKCkge1xuICBjbG9ja05vdyA9IChjbG9ja0xhc3QgPSBjbG9jay5ub3coKSkgKyBjbG9ja1NrZXc7XG4gIGZyYW1lID0gdGltZW91dCA9IDA7XG4gIHRyeSB7XG4gICAgdGltZXJGbHVzaCgpO1xuICB9IGZpbmFsbHkge1xuICAgIGZyYW1lID0gMDtcbiAgICBuYXAoKTtcbiAgICBjbG9ja05vdyA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9rZSgpIHtcbiAgdmFyIG5vdyA9IGNsb2NrLm5vdygpLCBkZWxheSA9IG5vdyAtIGNsb2NrTGFzdDtcbiAgaWYgKGRlbGF5ID4gcG9rZURlbGF5KSBjbG9ja1NrZXcgLT0gZGVsYXksIGNsb2NrTGFzdCA9IG5vdztcbn1cblxuZnVuY3Rpb24gbmFwKCkge1xuICB2YXIgdDAsIHQxID0gdGFza0hlYWQsIHQyLCB0aW1lID0gSW5maW5pdHk7XG4gIHdoaWxlICh0MSkge1xuICAgIGlmICh0MS5fY2FsbCkge1xuICAgICAgaWYgKHRpbWUgPiB0MS5fdGltZSkgdGltZSA9IHQxLl90aW1lO1xuICAgICAgdDAgPSB0MSwgdDEgPSB0MS5fbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDIgPSB0MS5fbmV4dCwgdDEuX25leHQgPSBudWxsO1xuICAgICAgdDEgPSB0MCA/IHQwLl9uZXh0ID0gdDIgOiB0YXNrSGVhZCA9IHQyO1xuICAgIH1cbiAgfVxuICB0YXNrVGFpbCA9IHQwO1xuICBzbGVlcCh0aW1lKTtcbn1cblxuZnVuY3Rpb24gc2xlZXAodGltZSkge1xuICBpZiAoZnJhbWUpIHJldHVybjsgLy8gU29vbmVzdCBhbGFybSBhbHJlYWR5IHNldCwgb3Igd2lsbCBiZS5cbiAgaWYgKHRpbWVvdXQpIHRpbWVvdXQgPSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIHZhciBkZWxheSA9IHRpbWUgLSBjbG9ja05vdzsgLy8gU3RyaWN0bHkgbGVzcyB0aGFuIGlmIHdlIHJlY29tcHV0ZWQgY2xvY2tOb3cuXG4gIGlmIChkZWxheSA+IDI0KSB7XG4gICAgaWYgKHRpbWUgPCBJbmZpbml0eSkgdGltZW91dCA9IHNldFRpbWVvdXQod2FrZSwgdGltZSAtIGNsb2NrLm5vdygpIC0gY2xvY2tTa2V3KTtcbiAgICBpZiAoaW50ZXJ2YWwpIGludGVydmFsID0gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnRlcnZhbCkgY2xvY2tMYXN0ID0gY2xvY2subm93KCksIGludGVydmFsID0gc2V0SW50ZXJ2YWwocG9rZSwgcG9rZURlbGF5KTtcbiAgICBmcmFtZSA9IDEsIHNldEZyYW1lKHdha2UpO1xuICB9XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmltcG9ydCB7U0NIRURVTEVEfSBmcm9tIFwiLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5cbnZhciByb290ID0gW251bGxdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgaTtcblxuICBpZiAoc2NoZWR1bGVzKSB7XG4gICAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5zdGF0ZSA+IFNDSEVEVUxFRCAmJiBzY2hlZHVsZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNpdGlvbihbW25vZGVdXSwgcm9vdCwgbmFtZSwgK2kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmFuc2l0aW9ufSBmcm9tIFwiLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYWN0aXZlfSBmcm9tIFwiLi9hY3RpdmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnJ1cHR9IGZyb20gXCIuL2ludGVycnVwdC5qc1wiO1xuIiwiaW1wb3J0IHtTVEFSVElORywgRU5ESU5HLCBFTkRFRH0gZnJvbSBcIi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgYWN0aXZlLFxuICAgICAgZW1wdHkgPSB0cnVlLFxuICAgICAgaTtcblxuICBpZiAoIXNjaGVkdWxlcykgcmV0dXJuO1xuXG4gIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG5cbiAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLm5hbWUgIT09IG5hbWUpIHsgZW1wdHkgPSBmYWxzZTsgY29udGludWU7IH1cbiAgICBhY3RpdmUgPSBzY2hlZHVsZS5zdGF0ZSA+IFNUQVJUSU5HICYmIHNjaGVkdWxlLnN0YXRlIDwgRU5ESU5HO1xuICAgIHNjaGVkdWxlLnN0YXRlID0gRU5ERUQ7XG4gICAgc2NoZWR1bGUudGltZXIuc3RvcCgpO1xuICAgIHNjaGVkdWxlLm9uLmNhbGwoYWN0aXZlID8gXCJpbnRlcnJ1cHRcIiA6IFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNjaGVkdWxlLmluZGV4LCBzY2hlZHVsZS5ncm91cCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgfVxuXG4gIGlmIChlbXB0eSkgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBzZWxlY3Rpb25faW50ZXJydXB0IGZyb20gXCIuL2ludGVycnVwdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl90cmFuc2l0aW9uIGZyb20gXCIuL3RyYW5zaXRpb24uanNcIjtcblxuc2VsZWN0aW9uLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBzZWxlY3Rpb25faW50ZXJydXB0O1xuc2VsZWN0aW9uLnByb3RvdHlwZS50cmFuc2l0aW9uID0gc2VsZWN0aW9uX3RyYW5zaXRpb247XG4iLCJpbXBvcnQgaW50ZXJydXB0IGZyb20gXCIuLi9pbnRlcnJ1cHQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIGludGVycnVwdCh0aGlzLCBuYW1lKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb24sIG5ld0lkfSBmcm9tIFwiLi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlIGZyb20gXCIuLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5pbXBvcnQge2Vhc2VDdWJpY0luT3V0fSBmcm9tIFwiZDMtZWFzZVwiO1xuaW1wb3J0IHtub3d9IGZyb20gXCJkMy10aW1lclwiO1xuXG52YXIgZGVmYXVsdFRpbWluZyA9IHtcbiAgdGltZTogbnVsbCwgLy8gU2V0IG9uIHVzZS5cbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2U6IGVhc2VDdWJpY0luT3V0XG59O1xuXG5mdW5jdGlvbiBpbmhlcml0KG5vZGUsIGlkKSB7XG4gIHZhciB0aW1pbmc7XG4gIHdoaWxlICghKHRpbWluZyA9IG5vZGUuX190cmFuc2l0aW9uKSB8fCAhKHRpbWluZyA9IHRpbWluZ1tpZF0pKSB7XG4gICAgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHJhbnNpdGlvbiAke2lkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbWluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgaWQsXG4gICAgICB0aW1pbmc7XG5cbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgaWQgPSBuYW1lLl9pZCwgbmFtZSA9IG5hbWUuX25hbWU7XG4gIH0gZWxzZSB7XG4gICAgaWQgPSBuZXdJZCgpLCAodGltaW5nID0gZGVmYXVsdFRpbWluZykudGltZSA9IG5vdygpLCBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQsIGksIGdyb3VwLCB0aW1pbmcgfHwgaW5oZXJpdChub2RlLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgYXMgaW50ZXJwb2xhdGVUcmFuc2Zvcm19IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtuYW1lc3BhY2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCBpbnRlcnBvbGF0ZSBmcm9tIFwiLi9pbnRlcnBvbGF0ZS5qc1wiO1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSwgc3RyaW5nMTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpLCBpID0gZnVsbG5hbWUgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdGhpcy5hdHRyVHdlZW4obmFtZSwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pKGZ1bGxuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwiYXR0ci5cIiArIG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdmFsdWUgPT0gbnVsbCA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpKGZ1bGxuYW1lKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkoZnVsbG5hbWUsIGksIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge25hbWVzcGFjZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG5mdW5jdGlvbiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuKG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlKG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJhdHRyLlwiICsgbmFtZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgKGZ1bGxuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtnZXQsIGluaXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGRlbGF5RnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWxheUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGRlbGF5RnVuY3Rpb25cbiAgICAgICAgICA6IGRlbGF5Q29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmRlbGF5O1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZHVyYXRpb25GdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Db25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGR1cmF0aW9uRnVuY3Rpb25cbiAgICAgICAgICA6IGR1cmF0aW9uQ29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmR1cmF0aW9uO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZWFzZSA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmVhc2U7XG59XG4iLCJpbXBvcnQge3NldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZWFzZVZhcnlpbmcoaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHR5cGVvZiB2ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgICBzZXQodGhpcywgaWQpLmVhc2UgPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMuZWFjaChlYXNlVmFyeWluZyh0aGlzLl9pZCwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG9uMCwgb24xLCB0aGF0ID0gdGhpcywgaWQgPSB0aGF0Ll9pZCwgc2l6ZSA9IHRoYXQuc2l6ZSgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGNhbmNlbCA9IHt2YWx1ZTogcmVqZWN0fSxcbiAgICAgICAgZW5kID0ge3ZhbHVlOiBmdW5jdGlvbigpIHsgaWYgKC0tc2l6ZSA9PT0gMCkgcmVzb2x2ZSgpOyB9fTtcblxuICAgIHRoYXQuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICAgIGlmIChvbiAhPT0gb24wKSB7XG4gICAgICAgIG9uMSA9IChvbjAgPSBvbikuY29weSgpO1xuICAgICAgICBvbjEuXy5jYW5jZWwucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5pbnRlcnJ1cHQucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5lbmQucHVzaChlbmQpO1xuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBzZWxlY3Rpb24gd2FzIGVtcHR5LCByZXNvbHZlIGVuZCBpbW1lZGlhdGVseVxuICAgIGlmIChzaXplID09PSAwKSByZXNvbHZlKCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHttYXRjaGVyfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHRyYW5zaXRpb25fYXR0ciBmcm9tIFwiLi9hdHRyLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9hdHRyVHdlZW4gZnJvbSBcIi4vYXR0clR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9kZWxheSBmcm9tIFwiLi9kZWxheS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2Vhc2UgZnJvbSBcIi4vZWFzZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZWFzZVZhcnlpbmcgZnJvbSBcIi4vZWFzZVZhcnlpbmcuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXIuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX21lcmdlIGZyb20gXCIuL21lcmdlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9vbiBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0QWxsIGZyb20gXCIuL3NlbGVjdEFsbC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0aW9uIGZyb20gXCIuL3NlbGVjdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3N0eWxlVHdlZW4gZnJvbSBcIi4vc3R5bGVUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90ZXh0VHdlZW4gZnJvbSBcIi4vdGV4dFR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90cmFuc2l0aW9uIGZyb20gXCIuL3RyYW5zaXRpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3R3ZWVuIGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lbmQgZnJvbSBcIi4vZW5kLmpzXCI7XG5cbnZhciBpZCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2l0aW9uKGdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX2lkID0gaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zaXRpb24obmFtZSkge1xuICByZXR1cm4gc2VsZWN0aW9uKCkudHJhbnNpdGlvbihuYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0lkKCkge1xuICByZXR1cm4gKytpZDtcbn1cblxudmFyIHNlbGVjdGlvbl9wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlO1xuXG5UcmFuc2l0aW9uLnByb3RvdHlwZSA9IHRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbixcbiAgc2VsZWN0OiB0cmFuc2l0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiB0cmFuc2l0aW9uX3NlbGVjdEFsbCxcbiAgc2VsZWN0Q2hpbGQ6IHNlbGVjdGlvbl9wcm90b3R5cGUuc2VsZWN0Q2hpbGQsXG4gIHNlbGVjdENoaWxkcmVuOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNlbGVjdENoaWxkcmVuLFxuICBmaWx0ZXI6IHRyYW5zaXRpb25fZmlsdGVyLFxuICBtZXJnZTogdHJhbnNpdGlvbl9tZXJnZSxcbiAgc2VsZWN0aW9uOiB0cmFuc2l0aW9uX3NlbGVjdGlvbixcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbl90cmFuc2l0aW9uLFxuICBjYWxsOiBzZWxlY3Rpb25fcHJvdG90eXBlLmNhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9wcm90b3R5cGUuc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9wcm90b3R5cGUuZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9wcm90b3R5cGUuZWFjaCxcbiAgb246IHRyYW5zaXRpb25fb24sXG4gIGF0dHI6IHRyYW5zaXRpb25fYXR0cixcbiAgYXR0clR3ZWVuOiB0cmFuc2l0aW9uX2F0dHJUd2VlbixcbiAgc3R5bGU6IHRyYW5zaXRpb25fc3R5bGUsXG4gIHN0eWxlVHdlZW46IHRyYW5zaXRpb25fc3R5bGVUd2VlbixcbiAgdGV4dDogdHJhbnNpdGlvbl90ZXh0LFxuICB0ZXh0VHdlZW46IHRyYW5zaXRpb25fdGV4dFR3ZWVuLFxuICByZW1vdmU6IHRyYW5zaXRpb25fcmVtb3ZlLFxuICB0d2VlbjogdHJhbnNpdGlvbl90d2VlbixcbiAgZGVsYXk6IHRyYW5zaXRpb25fZGVsYXksXG4gIGR1cmF0aW9uOiB0cmFuc2l0aW9uX2R1cmF0aW9uLFxuICBlYXNlOiB0cmFuc2l0aW9uX2Vhc2UsXG4gIGVhc2VWYXJ5aW5nOiB0cmFuc2l0aW9uX2Vhc2VWYXJ5aW5nLFxuICBlbmQ6IHRyYW5zaXRpb25fZW5kLFxuICBbU3ltYm9sLml0ZXJhdG9yXTogc2VsZWN0aW9uX3Byb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdXG59O1xuIiwiaW1wb3J0IHtjb2xvcn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQge2ludGVycG9sYXRlTnVtYmVyLCBpbnRlcnBvbGF0ZVJnYiwgaW50ZXJwb2xhdGVTdHJpbmd9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBjO1xuICByZXR1cm4gKHR5cGVvZiBiID09PSBcIm51bWJlclwiID8gaW50ZXJwb2xhdGVOdW1iZXJcbiAgICAgIDogYiBpbnN0YW5jZW9mIGNvbG9yID8gaW50ZXJwb2xhdGVSZ2JcbiAgICAgIDogKGMgPSBjb2xvcihiKSkgPyAoYiA9IGMsIGludGVycG9sYXRlUmdiKVxuICAgICAgOiBpbnRlcnBvbGF0ZVN0cmluZykoYSwgYik7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcbiAgaWYgKHRyYW5zaXRpb24uX2lkICE9PSB0aGlzLl9pZCkgdGhyb3cgbmV3IEVycm9yO1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSB0cmFuc2l0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXQsIGluaXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0YXJ0KG5hbWUpIHtcbiAgcmV0dXJuIChuYW1lICsgXCJcIikudHJpbSgpLnNwbGl0KC9efFxccysvKS5ldmVyeShmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiAhdCB8fCB0ID09PSBcInN0YXJ0XCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgb24wLCBvbjEsIHNpdCA9IHN0YXJ0KG5hbWUpID8gaW5pdCA6IHNldDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNpdCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub247XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjApIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24obmFtZSwgbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMlxuICAgICAgPyBnZXQodGhpcy5ub2RlKCksIGlkKS5vbi5vbihuYW1lKVxuICAgICAgOiB0aGlzLmVhY2gob25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZUZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5fX3RyYW5zaXRpb24pIGlmICgraSAhPT0gaWQpIHJldHVybjtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vbihcImVuZC5yZW1vdmVcIiwgcmVtb3ZlRnVuY3Rpb24odGhpcy5faWQpKTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHt0aW1lciwgdGltZW91dH0gZnJvbSBcImQzLXRpbWVyXCI7XG5cbnZhciBlbXB0eU9uID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImNhbmNlbFwiLCBcImludGVycnVwdFwiKTtcbnZhciBlbXB0eVR3ZWVuID0gW107XG5cbmV4cG9ydCB2YXIgQ1JFQVRFRCA9IDA7XG5leHBvcnQgdmFyIFNDSEVEVUxFRCA9IDE7XG5leHBvcnQgdmFyIFNUQVJUSU5HID0gMjtcbmV4cG9ydCB2YXIgU1RBUlRFRCA9IDM7XG5leHBvcnQgdmFyIFJVTk5JTkcgPSA0O1xuZXhwb3J0IHZhciBFTkRJTkcgPSA1O1xuZXhwb3J0IHZhciBFTkRFRCA9IDY7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUsIGlkLCBpbmRleCwgZ3JvdXAsIHRpbWluZykge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGVzKSBub2RlLl9fdHJhbnNpdGlvbiA9IHt9O1xuICBlbHNlIGlmIChpZCBpbiBzY2hlZHVsZXMpIHJldHVybjtcbiAgY3JlYXRlKG5vZGUsIGlkLCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBpbmRleDogaW5kZXgsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBncm91cDogZ3JvdXAsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBvbjogZW1wdHlPbixcbiAgICB0d2VlbjogZW1wdHlUd2VlbixcbiAgICB0aW1lOiB0aW1pbmcudGltZSxcbiAgICBkZWxheTogdGltaW5nLmRlbGF5LFxuICAgIGR1cmF0aW9uOiB0aW1pbmcuZHVyYXRpb24sXG4gICAgZWFzZTogdGltaW5nLmVhc2UsXG4gICAgdGltZXI6IG51bGwsXG4gICAgc3RhdGU6IENSRUFURURcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IENSRUFURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IFNUQVJURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZSB8fCAhKHNjaGVkdWxlID0gc2NoZWR1bGVbaWRdKSkgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNpdGlvbiBub3QgZm91bmRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5vZGUsIGlkLCBzZWxmKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHR3ZWVuO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHNlbGYgdGltZXIgd2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLlxuICAvLyBOb3RlIHRoZSBhY3R1YWwgZGVsYXkgaXMgbm90IGtub3duIHVudGlsIHRoZSBmaXJzdCBjYWxsYmFjayFcbiAgc2NoZWR1bGVzW2lkXSA9IHNlbGY7XG4gIHNlbGYudGltZXIgPSB0aW1lcihzY2hlZHVsZSwgMCwgc2VsZi50aW1lKTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XG4gICAgc2VsZi5zdGF0ZSA9IFNDSEVEVUxFRDtcbiAgICBzZWxmLnRpbWVyLnJlc3RhcnQoc3RhcnQsIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG5cbiAgICAvLyBJZiB0aGUgZWxhcHNlZCBkZWxheSBpcyBsZXNzIHRoYW4gb3VyIGZpcnN0IHNsZWVwLCBzdGFydCBpbW1lZGlhdGVseS5cbiAgICBpZiAoc2VsZi5kZWxheSA8PSBlbGFwc2VkKSBzdGFydChlbGFwc2VkIC0gc2VsZi5kZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgdmFyIGksIGosIG4sIG87XG5cbiAgICAvLyBJZiB0aGUgc3RhdGUgaXMgbm90IFNDSEVEVUxFRCwgdGhlbiB3ZSBwcmV2aW91c2x5IGVycm9yZWQgb24gc3RhcnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNDSEVEVUxFRCkgcmV0dXJuIHN0b3AoKTtcblxuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIG8gPSBzY2hlZHVsZXNbaV07XG4gICAgICBpZiAoby5uYW1lICE9PSBzZWxmLm5hbWUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBXaGlsZSB0aGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYSBzdGFydGluZyB0cmFuc2l0aW9uIGR1cmluZyB0aGlzIGZyYW1lLFxuICAgICAgLy8gZGVmZXIgc3RhcnRpbmcgYW4gaW50ZXJydXB0aW5nIHRyYW5zaXRpb24gdW50aWwgdGhhdCB0cmFuc2l0aW9uIGhhcyBhXG4gICAgICAvLyBjaGFuY2UgdG8gdGljayAoYW5kIHBvc3NpYmx5IGVuZCk7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzU0IVxuICAgICAgaWYgKG8uc3RhdGUgPT09IFNUQVJURUQpIHJldHVybiB0aW1lb3V0KHN0YXJ0KTtcblxuICAgICAgLy8gSW50ZXJydXB0IHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgaWYgYW55LlxuICAgICAgaWYgKG8uc3RhdGUgPT09IFJVTk5JTkcpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBDYW5jZWwgYW55IHByZS1lbXB0ZWQgdHJhbnNpdGlvbnMuXG4gICAgICBlbHNlIGlmICgraSA8IGlkKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZlciB0aGUgZmlyc3QgdGljayB0byBlbmQgb2YgdGhlIGN1cnJlbnQgZnJhbWU7IHNlZSBkMy9kMyMxNTc2LlxuICAgIC8vIE5vdGUgdGhlIHRyYW5zaXRpb24gbWF5IGJlIGNhbmNlbGVkIGFmdGVyIHN0YXJ0IGFuZCBiZWZvcmUgdGhlIGZpcnN0IHRpY2shXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgc2NoZWR1bGVkIGJlZm9yZSB0aGUgc3RhcnQgZXZlbnQ7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzE2IVxuICAgIC8vIEFzc3VtaW5nIHRoaXMgaXMgc3VjY2Vzc2Z1bCwgc3Vic2VxdWVudCBjYWxsYmFja3MgZ28gc3RyYWlnaHQgdG8gdGljay5cbiAgICB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFNUQVJURUQpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9IFJVTk5JTkc7XG4gICAgICAgIHNlbGYudGltZXIucmVzdGFydCh0aWNrLCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuICAgICAgICB0aWNrKGVsYXBzZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIHN0YXJ0IGV2ZW50LlxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSB0d2VlbiBhcmUgaW5pdGlhbGl6ZWQuXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJUSU5HO1xuICAgIHNlbGYub24uY2FsbChcInN0YXJ0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTVEFSVElORykgcmV0dXJuOyAvLyBpbnRlcnJ1cHRlZFxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVEVEO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHdlZW4sIGRlbGV0aW5nIG51bGwgdHdlZW4uXG4gICAgdHdlZW4gPSBuZXcgQXJyYXkobiA9IHNlbGYudHdlZW4ubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBqID0gLTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChvID0gc2VsZi50d2VlbltpXS52YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApKSB7XG4gICAgICAgIHR3ZWVuWysral0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICB0d2Vlbi5sZW5ndGggPSBqICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIHZhciB0ID0gZWxhcHNlZCA8IHNlbGYuZHVyYXRpb24gPyBzZWxmLmVhc2UuY2FsbChudWxsLCBlbGFwc2VkIC8gc2VsZi5kdXJhdGlvbikgOiAoc2VsZi50aW1lci5yZXN0YXJ0KHN0b3ApLCBzZWxmLnN0YXRlID0gRU5ESU5HLCAxKSxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gdHdlZW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHR3ZWVuW2ldLmNhbGwobm9kZSwgdCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIGVuZCBldmVudC5cbiAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gRU5ESU5HKSB7XG4gICAgICBzZWxmLm9uLmNhbGwoXCJlbmRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzZWxmLnN0YXRlID0gRU5ERUQ7XG4gICAgc2VsZi50aW1lci5zdG9wKCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpZF07XG4gICAgZm9yICh2YXIgaSBpbiBzY2hlZHVsZXMpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgfVxufVxuIiwiaW1wb3J0IHtzZWxlY3Rvcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgICAgc2NoZWR1bGUoc3ViZ3JvdXBbaV0sIG5hbWUsIGlkLCBpLCBzdWJncm91cCwgZ2V0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3RvckFsbH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApLCBjaGlsZCwgaW5oZXJpdCA9IGdldChub2RlLCBpZCksIGsgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBrIDwgbDsgKytrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID0gY2hpbGRyZW5ba10pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGNoaWxkLCBuYW1lLCBpZCwgaywgY2hpbGRyZW4sIGluaGVyaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG52YXIgU2VsZWN0aW9uID0gc2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2dyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtQ3NzIGFzIGludGVycG9sYXRlVHJhbnNmb3JtfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7c3R5bGV9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IGludGVycG9sYXRlIGZyb20gXCIuL2ludGVycG9sYXRlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0eWxlTnVsbChuYW1lLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHN0cmluZzEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCBzdHJpbmcxMCA9IHN0cmluZzEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9IHZhbHVlKHRoaXMpLFxuICAgICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHN0cmluZzEgPSB2YWx1ZTEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVNYXliZVJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgb24wLCBvbjEsIGxpc3RlbmVyMCwga2V5ID0gXCJzdHlsZS5cIiArIG5hbWUsIGV2ZW50ID0gXCJlbmQuXCIgKyBrZXksIHJlbW92ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub24sXG4gICAgICAgIGxpc3RlbmVyID0gc2NoZWR1bGUudmFsdWVba2V5XSA9PSBudWxsID8gcmVtb3ZlIHx8IChyZW1vdmUgPSBzdHlsZVJlbW92ZShuYW1lKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjAgfHwgbGlzdGVuZXIwICE9PSBsaXN0ZW5lcikgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihldmVudCwgbGlzdGVuZXIwID0gbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgaSA9IChuYW1lICs9IFwiXCIpID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZU51bGwobmFtZSwgaSkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBzdHlsZVJlbW92ZShuYW1lKSlcbiAgICA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVGdW5jdGlvbihuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwic3R5bGUuXCIgKyBuYW1lLCB2YWx1ZSkpKVxuICAgICAgLmVhY2goc3R5bGVNYXliZVJlbW92ZSh0aGlzLl9pZCwgbmFtZSkpXG4gICAgOiB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUNvbnN0YW50KG5hbWUsIGksIHZhbHVlKSwgcHJpb3JpdHkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBudWxsKTtcbn1cbiIsImZ1bmN0aW9uIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkuY2FsbCh0aGlzLCB0KSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgdCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQgPSAoaTAgPSBpKSAmJiBzdHlsZUludGVycG9sYXRlKG5hbWUsIGksIHByaW9yaXR5KTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleSA9IFwic3R5bGUuXCIgKyAobmFtZSArPSBcIlwiKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKTtcbn1cbiIsImltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTEgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnR3ZWVuKFwidGV4dFwiLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyB0ZXh0RnVuY3Rpb24odHdlZW5WYWx1ZSh0aGlzLCBcInRleHRcIiwgdmFsdWUpKVxuICAgICAgOiB0ZXh0Q29uc3RhbnQodmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCIpKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRJbnRlcnBvbGF0ZShpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IGkuY2FsbCh0aGlzLCB0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dFR3ZWVuKHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgdGV4dEludGVycG9sYXRlKGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJ0ZXh0XCI7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCB0ZXh0VHdlZW4odmFsdWUpKTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbiwgbmV3SWR9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZDAgPSB0aGlzLl9pZCxcbiAgICAgIGlkMSA9IG5ld0lkKCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgdmFyIGluaGVyaXQgPSBnZXQobm9kZSwgaWQwKTtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQxLCBpLCBncm91cCwge1xuICAgICAgICAgIHRpbWU6IGluaGVyaXQudGltZSArIGluaGVyaXQuZGVsYXkgKyBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZDEpO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gdHdlZW5SZW1vdmUoaWQsIG5hbWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9IHR3ZWVuMCA9IHR3ZWVuO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMSA9IHR3ZWVuMS5zbGljZSgpO1xuICAgICAgICAgIHR3ZWVuMS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHdlZW5GdW5jdGlvbihpZCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSAodHdlZW4wID0gdHdlZW4pLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciB0ID0ge25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0sIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjFbaV0gPSB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gbikgdHdlZW4xLnB1c2godCk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIG5hbWUgKz0gXCJcIjtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgdHdlZW4gPSBnZXQodGhpcy5ub2RlKCksIGlkKS50d2VlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuLmxlbmd0aCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh0ID0gdHdlZW5baV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbCA/IHR3ZWVuUmVtb3ZlIDogdHdlZW5GdW5jdGlvbikoaWQsIG5hbWUsIHZhbHVlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0d2VlblZhbHVlKHRyYW5zaXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRyYW5zaXRpb24uX2lkO1xuXG4gIHRyYW5zaXRpb24uZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpO1xuICAgIChzY2hlZHVsZS52YWx1ZSB8fCAoc2NoZWR1bGUudmFsdWUgPSB7fSkpW25hbWVdID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0KG5vZGUsIGlkKS52YWx1ZVtuYW1lXTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFpvb21FdmVudCh0eXBlLCB7XG4gIHNvdXJjZUV2ZW50LFxuICB0YXJnZXQsXG4gIHRyYW5zZm9ybSxcbiAgZGlzcGF0Y2hcbn0pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHR5cGU6IHt2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBzb3VyY2VFdmVudDoge3ZhbHVlOiBzb3VyY2VFdmVudCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB0YXJnZXQ6IHt2YWx1ZTogdGFyZ2V0LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHRyYW5zZm9ybToge3ZhbHVlOiB0cmFuc2Zvcm0sIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgXzoge3ZhbHVlOiBkaXNwYXRjaH1cbiAgfSk7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgem9vbX0gZnJvbSBcIi4vem9vbS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHpvb21UcmFuc2Zvcm0sIGlkZW50aXR5IGFzIHpvb21JZGVudGl0eSwgVHJhbnNmb3JtIGFzIFpvb21UcmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybShrLCB4LCB5KSB7XG4gIHRoaXMuayA9IGs7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm0sXG4gIHNjYWxlOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgPT09IDEgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmsgKiBrLCB0aGlzLngsIHRoaXMueSk7XG4gIH0sXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4ID09PSAwICYgeSA9PT0gMCA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuaywgdGhpcy54ICsgdGhpcy5rICogeCwgdGhpcy55ICsgdGhpcy5rICogeSk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBbcG9pbnRbMF0gKiB0aGlzLmsgKyB0aGlzLngsIHBvaW50WzFdICogdGhpcy5rICsgdGhpcy55XTtcbiAgfSxcbiAgYXBwbHlYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggKiB0aGlzLmsgKyB0aGlzLng7XG4gIH0sXG4gIGFwcGx5WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5ICogdGhpcy5rICsgdGhpcy55O1xuICB9LFxuICBpbnZlcnQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIFsobG9jYXRpb25bMF0gLSB0aGlzLngpIC8gdGhpcy5rLCAobG9jYXRpb25bMV0gLSB0aGlzLnkpIC8gdGhpcy5rXTtcbiAgfSxcbiAgaW52ZXJ0WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAoeCAtIHRoaXMueCkgLyB0aGlzLms7XG4gIH0sXG4gIGludmVydFk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gKHkgLSB0aGlzLnkpIC8gdGhpcy5rO1xuICB9LFxuICByZXNjYWxlWDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4LmNvcHkoKS5kb21haW4oeC5yYW5nZSgpLm1hcCh0aGlzLmludmVydFgsIHRoaXMpLm1hcCh4LmludmVydCwgeCkpO1xuICB9LFxuICByZXNjYWxlWTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5LmNvcHkoKS5kb21haW4oeS5yYW5nZSgpLm1hcCh0aGlzLmludmVydFksIHRoaXMpLm1hcCh5LmludmVydCwgeSkpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIikgc2NhbGUoXCIgKyB0aGlzLmsgKyBcIilcIjtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCk7XG5cbnRyYW5zZm9ybS5wcm90b3R5cGUgPSBUcmFuc2Zvcm0ucHJvdG90eXBlO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSkge1xuICB3aGlsZSAoIW5vZGUuX196b29tKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuIGlkZW50aXR5O1xuICByZXR1cm4gbm9kZS5fX3pvb207XG59XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7ZHJhZ0Rpc2FibGUsIGRyYWdFbmFibGV9IGZyb20gXCJkMy1kcmFnXCI7XG5pbXBvcnQge2ludGVycG9sYXRlWm9vbX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge3NlbGVjdCwgcG9pbnRlcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtpbnRlcnJ1cHR9IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBab29tRXZlbnQgZnJvbSBcIi4vZXZlbnQuanNcIjtcbmltcG9ydCB7VHJhbnNmb3JtLCBpZGVudGl0eX0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5pbXBvcnQgbm9ldmVudCwge25vcHJvcGFnYXRpb259IGZyb20gXCIuL25vZXZlbnQuanNcIjtcblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG4vLyBleGNlcHQgZm9yIHBpbmNoLXRvLXpvb20sIHdoaWNoIGlzIHNlbnQgYXMgYSB3aGVlbCtjdHJsS2V5IGV2ZW50XG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKGV2ZW50KSB7XG4gIHJldHVybiAoIWV2ZW50LmN0cmxLZXkgfHwgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykgJiYgIWV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIGUgPSB0aGlzO1xuICBpZiAoZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICBlID0gZS5vd25lclNWR0VsZW1lbnQgfHwgZTtcbiAgICBpZiAoZS5oYXNBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIpKSB7XG4gICAgICBlID0gZS52aWV3Qm94LmJhc2VWYWw7XG4gICAgICByZXR1cm4gW1tlLngsIGUueV0sIFtlLnggKyBlLndpZHRoLCBlLnkgKyBlLmhlaWdodF1dO1xuICAgIH1cbiAgICByZXR1cm4gW1swLCAwXSwgW2Uud2lkdGguYmFzZVZhbC52YWx1ZSwgZS5oZWlnaHQuYmFzZVZhbC52YWx1ZV1dO1xuICB9XG4gIHJldHVybiBbWzAsIDBdLCBbZS5jbGllbnRXaWR0aCwgZS5jbGllbnRIZWlnaHRdXTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybSgpIHtcbiAgcmV0dXJuIHRoaXMuX196b29tIHx8IGlkZW50aXR5O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V2hlZWxEZWx0YShldmVudCkge1xuICByZXR1cm4gLWV2ZW50LmRlbHRhWSAqIChldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqIChldmVudC5jdHJsS2V5ID8gMTAgOiAxKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnN0cmFpbih0cmFuc2Zvcm0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XG4gIHZhciBkeDAgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMF1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzBdLFxuICAgICAgZHgxID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzFdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVswXSxcbiAgICAgIGR5MCA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFswXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMV0sXG4gICAgICBkeTEgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMV1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzFdO1xuICByZXR1cm4gdHJhbnNmb3JtLnRyYW5zbGF0ZShcbiAgICBkeDEgPiBkeDAgPyAoZHgwICsgZHgxKSAvIDIgOiBNYXRoLm1pbigwLCBkeDApIHx8IE1hdGgubWF4KDAsIGR4MSksXG4gICAgZHkxID4gZHkwID8gKGR5MCArIGR5MSkgLyAyIDogTWF0aC5taW4oMCwgZHkwKSB8fCBNYXRoLm1heCgwLCBkeTEpXG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQsXG4gICAgICBjb25zdHJhaW4gPSBkZWZhdWx0Q29uc3RyYWluLFxuICAgICAgd2hlZWxEZWx0YSA9IGRlZmF1bHRXaGVlbERlbHRhLFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIHNjYWxlRXh0ZW50ID0gWzAsIEluZmluaXR5XSxcbiAgICAgIHRyYW5zbGF0ZUV4dGVudCA9IFtbLUluZmluaXR5LCAtSW5maW5pdHldLCBbSW5maW5pdHksIEluZmluaXR5XV0sXG4gICAgICBkdXJhdGlvbiA9IDI1MCxcbiAgICAgIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVab29tLFxuICAgICAgbGlzdGVuZXJzID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcInpvb21cIiwgXCJlbmRcIiksXG4gICAgICB0b3VjaHN0YXJ0aW5nLFxuICAgICAgdG91Y2hmaXJzdCxcbiAgICAgIHRvdWNoZW5kaW5nLFxuICAgICAgdG91Y2hEZWxheSA9IDUwMCxcbiAgICAgIHdoZWVsRGVsYXkgPSAxNTAsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDAsXG4gICAgICB0YXBEaXN0YW5jZSA9IDEwO1xuXG4gIGZ1bmN0aW9uIHpvb20oc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKVxuICAgICAgICAub24oXCJ3aGVlbC56b29tXCIsIHdoZWVsZWQsIHtwYXNzaXZlOiBmYWxzZX0pXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi56b29tXCIsIG1vdXNlZG93bmVkKVxuICAgICAgICAub24oXCJkYmxjbGljay56b29tXCIsIGRibGNsaWNrZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC56b29tXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLnpvb21cIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuem9vbSB0b3VjaGNhbmNlbC56b29tXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cblxuICB6b29tLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGNvbGxlY3Rpb24uc2VsZWN0aW9uID8gY29sbGVjdGlvbi5zZWxlY3Rpb24oKSA6IGNvbGxlY3Rpb247XG4gICAgc2VsZWN0aW9uLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pO1xuICAgIGlmIChjb2xsZWN0aW9uICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgIHNjaGVkdWxlKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLmludGVycnVwdCgpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGdlc3R1cmUodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIC5ldmVudChldmVudClcbiAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgIC56b29tKG51bGwsIHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIiA/IHRyYW5zZm9ybS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdHJhbnNmb3JtKVxuICAgICAgICAgIC5lbmQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB6b29tLnNjYWxlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHAsIGV2ZW50KSB7XG4gICAgem9vbS5zY2FsZVRvKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgazAgPSB0aGlzLl9fem9vbS5rLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gazAgKiBrMTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS5zY2FsZVRvID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBrLCBwLCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwLFxuICAgICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgICBrMSA9IHR5cGVvZiBrID09PSBcImZ1bmN0aW9uXCIgPyBrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodDAsIGsxKSwgcDAsIHAxKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0aGlzLl9fem9vbS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB4LFxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8geS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeVxuICAgICAgKSwgZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgbnVsbCwgZXZlbnQpO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIHgsIHksIHAsIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcDtcbiAgICAgIHJldHVybiBjb25zdHJhaW4oaWRlbnRpdHkudHJhbnNsYXRlKHAwWzBdLCBwMFsxXSkuc2NhbGUodC5rKS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyAteC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyAteS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXlcbiAgICAgICksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCwgZXZlbnQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHRyYW5zZm9ybSwgaykge1xuICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIGspKTtcbiAgICByZXR1cm4gayA9PT0gdHJhbnNmb3JtLmsgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKGssIHRyYW5zZm9ybS54LCB0cmFuc2Zvcm0ueSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUodHJhbnNmb3JtLCBwMCwgcDEpIHtcbiAgICB2YXIgeCA9IHAwWzBdIC0gcDFbMF0gKiB0cmFuc2Zvcm0uaywgeSA9IHAwWzFdIC0gcDFbMV0gKiB0cmFuc2Zvcm0uaztcbiAgICByZXR1cm4geCA9PT0gdHJhbnNmb3JtLnggJiYgeSA9PT0gdHJhbnNmb3JtLnkgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKHRyYW5zZm9ybS5rLCB4LCB5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRyb2lkKGV4dGVudCkge1xuICAgIHJldHVybiBbKCtleHRlbnRbMF1bMF0gKyArZXh0ZW50WzFdWzBdKSAvIDIsICgrZXh0ZW50WzBdWzFdICsgK2V4dGVudFsxXVsxXSkgLyAyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKHRyYW5zaXRpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgdHJhbnNpdGlvblxuICAgICAgICAub24oXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZXZlbnQoZXZlbnQpLnN0YXJ0KCk7IH0pXG4gICAgICAgIC5vbihcImludGVycnVwdC56b29tIGVuZC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZXZlbnQoZXZlbnQpLmVuZCgpOyB9KVxuICAgICAgICAudHdlZW4oXCJ6b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgZyA9IGdlc3R1cmUodGhhdCwgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICAgICAgICBlID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpLFxuICAgICAgICAgICAgICBwID0gcG9pbnQgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHBvaW50ID09PSBcImZ1bmN0aW9uXCIgPyBwb2ludC5hcHBseSh0aGF0LCBhcmdzKSA6IHBvaW50LFxuICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgoZVsxXVswXSAtIGVbMF1bMF0sIGVbMV1bMV0gLSBlWzBdWzFdKSxcbiAgICAgICAgICAgICAgYSA9IHRoYXQuX196b29tLFxuICAgICAgICAgICAgICBiID0gdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoYXQsIGFyZ3MpIDogdHJhbnNmb3JtLFxuICAgICAgICAgICAgICBpID0gaW50ZXJwb2xhdGUoYS5pbnZlcnQocCkuY29uY2F0KHcgLyBhLmspLCBiLmludmVydChwKS5jb25jYXQodyAvIGIuaykpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gMSkgdCA9IGI7IC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yIG9uIGVuZC5cbiAgICAgICAgICAgIGVsc2UgeyB2YXIgbCA9IGkodCksIGsgPSB3IC8gbFsyXTsgdCA9IG5ldyBUcmFuc2Zvcm0oaywgcFswXSAtIGxbMF0gKiBrLCBwWzFdIC0gbFsxXSAqIGspOyB9XG4gICAgICAgICAgICBnLnpvb20obnVsbCwgdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXN0dXJlKHRoYXQsIGFyZ3MsIGNsZWFuKSB7XG4gICAgcmV0dXJuICghY2xlYW4gJiYgdGhhdC5fX3pvb21pbmcpIHx8IG5ldyBHZXN0dXJlKHRoYXQsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gR2VzdHVyZSh0aGF0LCBhcmdzKSB7XG4gICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICB0aGlzLnNvdXJjZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB0aGlzLnRhcHMgPSAwO1xuICB9XG5cbiAgR2VzdHVyZS5wcm90b3R5cGUgPSB7XG4gICAgZXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQpIHRoaXMuc291cmNlRXZlbnQgPSBldmVudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHtcbiAgICAgICAgdGhpcy50aGF0Ll9fem9vbWluZyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbihrZXksIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRoaXMubW91c2UgJiYga2V5ICE9PSBcIm1vdXNlXCIpIHRoaXMubW91c2VbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMubW91c2VbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gwICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMFsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDBbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gxICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDFbMF0pO1xuICAgICAgdGhpcy50aGF0Ll9fem9vbSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuZW1pdChcInpvb21cIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy50aGF0Ll9fem9vbWluZztcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgZCA9IHNlbGVjdCh0aGlzLnRoYXQpLmRhdHVtKCk7XG4gICAgICBsaXN0ZW5lcnMuY2FsbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy50aGF0LFxuICAgICAgICBuZXcgWm9vbUV2ZW50KHR5cGUsIHtcbiAgICAgICAgICBzb3VyY2VFdmVudDogdGhpcy5zb3VyY2VFdmVudCxcbiAgICAgICAgICB0YXJnZXQ6IHpvb20sXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMudGhhdC5fX3pvb20sXG4gICAgICAgICAgZGlzcGF0Y2g6IGxpc3RlbmVyc1xuICAgICAgICB9KSxcbiAgICAgICAgZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gd2hlZWxlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIHQuayAqIE1hdGgucG93KDIsIHdoZWVsRGVsdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSxcbiAgICAgICAgcCA9IHBvaW50ZXIoZXZlbnQpO1xuXG4gICAgLy8gSWYgdGhlIG1vdXNlIGlzIGluIHRoZSBzYW1lIGxvY2F0aW9uIGFzIGJlZm9yZSwgcmV1c2UgaXQuXG4gICAgLy8gSWYgdGhlcmUgd2VyZSByZWNlbnQgd2hlZWwgZXZlbnRzLCByZXNldCB0aGUgd2hlZWwgaWRsZSB0aW1lb3V0LlxuICAgIGlmIChnLndoZWVsKSB7XG4gICAgICBpZiAoZy5tb3VzZVswXVswXSAhPT0gcFswXSB8fCBnLm1vdXNlWzBdWzFdICE9PSBwWzFdKSB7XG4gICAgICAgIGcubW91c2VbMV0gPSB0LmludmVydChnLm1vdXNlWzBdID0gcCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQoZy53aGVlbCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3aGVlbCBldmVudCB3b27igJl0IHRyaWdnZXIgYSB0cmFuc2Zvcm0gY2hhbmdlLCBpZ25vcmUgaXQuXG4gICAgZWxzZSBpZiAodC5rID09PSBrKSByZXR1cm47XG5cbiAgICAvLyBPdGhlcndpc2UsIGNhcHR1cmUgdGhlIG1vdXNlIHBvaW50IGFuZCBsb2NhdGlvbiBhdCB0aGUgc3RhcnQuXG4gICAgZWxzZSB7XG4gICAgICBnLm1vdXNlID0gW3AsIHQuaW52ZXJ0KHApXTtcbiAgICAgIGludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBnLndoZWVsID0gc2V0VGltZW91dCh3aGVlbGlkbGVkLCB3aGVlbERlbGF5KTtcbiAgICBnLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQsIGspLCBnLm1vdXNlWzBdLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuXG4gICAgZnVuY3Rpb24gd2hlZWxpZGxlZCgpIHtcbiAgICAgIGcud2hlZWwgPSBudWxsO1xuICAgICAgZy5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZWRvd25lZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MsIHRydWUpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdiA9IHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS56b29tXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC56b29tXCIsIG1vdXNldXBwZWQsIHRydWUpLFxuICAgICAgICBwID0gcG9pbnRlcihldmVudCwgY3VycmVudFRhcmdldCksXG4gICAgICAgIHgwID0gZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTAgPSBldmVudC5jbGllbnRZO1xuXG4gICAgZHJhZ0Rpc2FibGUoZXZlbnQudmlldyk7XG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgZy5tb3VzZSA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCldO1xuICAgIGludGVycnVwdCh0aGlzKTtcbiAgICBnLnN0YXJ0KCk7XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmVkKGV2ZW50KSB7XG4gICAgICBub2V2ZW50KGV2ZW50KTtcbiAgICAgIGlmICghZy5tb3ZlZCkge1xuICAgICAgICB2YXIgZHggPSBldmVudC5jbGllbnRYIC0geDAsIGR5ID0gZXZlbnQuY2xpZW50WSAtIHkwO1xuICAgICAgICBnLm1vdmVkID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICAgIH1cbiAgICAgIGcuZXZlbnQoZXZlbnQpXG4gICAgICAgLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKGcudGhhdC5fX3pvb20sIGcubW91c2VbMF0gPSBwb2ludGVyKGV2ZW50LCBjdXJyZW50VGFyZ2V0KSwgZy5tb3VzZVsxXSksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwcGVkKGV2ZW50KSB7XG4gICAgICB2Lm9uKFwibW91c2Vtb3ZlLnpvb20gbW91c2V1cC56b29tXCIsIG51bGwpO1xuICAgICAgZHJhZ0VuYWJsZShldmVudC52aWV3LCBnLm1vdmVkKTtcbiAgICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgICAgZy5ldmVudChldmVudCkuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGJsY2xpY2tlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgcDAgPSBwb2ludGVyKGV2ZW50LmNoYW5nZWRUb3VjaGVzID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudCwgdGhpcyksXG4gICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgazEgPSB0MC5rICogKGV2ZW50LnNoaWZ0S2V5ID8gMC41IDogMiksXG4gICAgICAgIHQxID0gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBleHRlbnQuYXBwbHkodGhpcywgYXJncyksIHRyYW5zbGF0ZUV4dGVudCk7XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBpZiAoZHVyYXRpb24gPiAwKSBzZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKHNjaGVkdWxlLCB0MSwgcDAsIGV2ZW50KTtcbiAgICBlbHNlIHNlbGVjdCh0aGlzKS5jYWxsKHpvb20udHJhbnNmb3JtLCB0MSwgcDAsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJncywgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSBuKS5ldmVudChldmVudCksXG4gICAgICAgIHN0YXJ0ZWQsIGksIHQsIHA7XG5cbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICBwID0gW3AsIHRoaXMuX196b29tLmludmVydChwKSwgdC5pZGVudGlmaWVyXTtcbiAgICAgIGlmICghZy50b3VjaDApIGcudG91Y2gwID0gcCwgc3RhcnRlZCA9IHRydWUsIGcudGFwcyA9IDEgKyAhIXRvdWNoc3RhcnRpbmc7XG4gICAgICBlbHNlIGlmICghZy50b3VjaDEgJiYgZy50b3VjaDBbMl0gIT09IHBbMl0pIGcudG91Y2gxID0gcCwgZy50YXBzID0gMDtcbiAgICB9XG5cbiAgICBpZiAodG91Y2hzdGFydGluZykgdG91Y2hzdGFydGluZyA9IGNsZWFyVGltZW91dCh0b3VjaHN0YXJ0aW5nKTtcblxuICAgIGlmIChzdGFydGVkKSB7XG4gICAgICBpZiAoZy50YXBzIDwgMikgdG91Y2hmaXJzdCA9IHBbMF0sIHRvdWNoc3RhcnRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaHN0YXJ0aW5nID0gbnVsbDsgfSwgdG91Y2hEZWxheSk7XG4gICAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2htb3ZlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fX3pvb21pbmcpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdCwgcCwgbDtcblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMFswXSA9IHA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMVswXSA9IHA7XG4gICAgfVxuICAgIHQgPSBnLnRoYXQuX196b29tO1xuICAgIGlmIChnLnRvdWNoMSkge1xuICAgICAgdmFyIHAwID0gZy50b3VjaDBbMF0sIGwwID0gZy50b3VjaDBbMV0sXG4gICAgICAgICAgcDEgPSBnLnRvdWNoMVswXSwgbDEgPSBnLnRvdWNoMVsxXSxcbiAgICAgICAgICBkcCA9IChkcCA9IHAxWzBdIC0gcDBbMF0pICogZHAgKyAoZHAgPSBwMVsxXSAtIHAwWzFdKSAqIGRwLFxuICAgICAgICAgIGRsID0gKGRsID0gbDFbMF0gLSBsMFswXSkgKiBkbCArIChkbCA9IGwxWzFdIC0gbDBbMV0pICogZGw7XG4gICAgICB0ID0gc2NhbGUodCwgTWF0aC5zcXJ0KGRwIC8gZGwpKTtcbiAgICAgIHAgPSBbKHAwWzBdICsgcDFbMF0pIC8gMiwgKHAwWzFdICsgcDFbMV0pIC8gMl07XG4gICAgICBsID0gWyhsMFswXSArIGwxWzBdKSAvIDIsIChsMFsxXSArIGwxWzFdKSAvIDJdO1xuICAgIH1cbiAgICBlbHNlIGlmIChnLnRvdWNoMCkgcCA9IGcudG91Y2gwWzBdLCBsID0gZy50b3VjaDBbMV07XG4gICAgZWxzZSByZXR1cm47XG5cbiAgICBnLnpvb20oXCJ0b3VjaFwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHQsIHAsIGwpLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaGVuZGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0O1xuXG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDE7XG4gICAgfVxuICAgIGlmIChnLnRvdWNoMSAmJiAhZy50b3VjaDApIGcudG91Y2gwID0gZy50b3VjaDEsIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICBpZiAoZy50b3VjaDApIGcudG91Y2gwWzFdID0gdGhpcy5fX3pvb20uaW52ZXJ0KGcudG91Y2gwWzBdKTtcbiAgICBlbHNlIHtcbiAgICAgIGcuZW5kKCk7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBhIGRibHRhcCwgcmVyb3V0ZSB0byB0aGUgKG9wdGlvbmFsKSBkYmxjbGljay56b29tIGhhbmRsZXIuXG4gICAgICBpZiAoZy50YXBzID09PSAyKSB7XG4gICAgICAgIHQgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgICBpZiAoTWF0aC5oeXBvdCh0b3VjaGZpcnN0WzBdIC0gdFswXSwgdG91Y2hmaXJzdFsxXSAtIHRbMV0pIDwgdGFwRGlzdGFuY2UpIHtcbiAgICAgICAgICB2YXIgcCA9IHNlbGVjdCh0aGlzKS5vbihcImRibGNsaWNrLnpvb21cIik7XG4gICAgICAgICAgaWYgKHApIHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHpvb20ud2hlZWxEZWx0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh3aGVlbERlbHRhID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHpvb20pIDogd2hlZWxEZWx0YTtcbiAgfTtcblxuICB6b29tLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIHpvb20pIDogZmlsdGVyO1xuICB9O1xuXG4gIHpvb20udG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgem9vbS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbWytfWzBdWzBdLCArX1swXVsxXV0sIFsrX1sxXVswXSwgK19bMV1bMV1dXSksIHpvb20pIDogZXh0ZW50O1xuICB9O1xuXG4gIHpvb20uc2NhbGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGVFeHRlbnRbMF0gPSArX1swXSwgc2NhbGVFeHRlbnRbMV0gPSArX1sxXSwgem9vbSkgOiBbc2NhbGVFeHRlbnRbMF0sIHNjYWxlRXh0ZW50WzFdXTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2xhdGVFeHRlbnRbMF1bMF0gPSArX1swXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzBdID0gK19bMV1bMF0sIHRyYW5zbGF0ZUV4dGVudFswXVsxXSA9ICtfWzBdWzFdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV0gPSArX1sxXVsxXSwgem9vbSkgOiBbW3RyYW5zbGF0ZUV4dGVudFswXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdXSwgW3RyYW5zbGF0ZUV4dGVudFsxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzFdXV07XG4gIH07XG5cbiAgem9vbS5jb25zdHJhaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29uc3RyYWluID0gXywgem9vbSkgOiBjb25zdHJhaW47XG4gIH07XG5cbiAgem9vbS5kdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkdXJhdGlvbiA9ICtfLCB6b29tKSA6IGR1cmF0aW9uO1xuICB9O1xuXG4gIHpvb20uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCB6b29tKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHpvb20ub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gem9vbSA6IHZhbHVlO1xuICB9O1xuXG4gIHpvb20uY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgem9vbSkgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHpvb20udGFwRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGFwRGlzdGFuY2UgPSArXywgem9vbSkgOiB0YXBEaXN0YW5jZTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLy8gaW50ZXJuYWwgaW1wb3J0c1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi9HZW9DYW52YXMuanMnXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4vTGF5ZXIuanMnXG5pbXBvcnQgeyBEYXRhc2V0IH0gZnJvbSAnLi9EYXRhc2V0LmpzJ1xuaW1wb3J0IHsgVG9vbHRpcCB9IGZyb20gJy4vVG9vbHRpcC5qcydcbmltcG9ydCB7IENTVkdyaWQgfSBmcm9tICcuL2RhdGFzZXQvQ1NWR3JpZC5qcydcbmltcG9ydCB7IExHcmlkIH0gZnJvbSAnLi9kYXRhc2V0L0xHcmlkLmpzJ1xuaW1wb3J0IHsgVGlsZWRHcmlkIH0gZnJvbSAnLi9kYXRhc2V0L1RpbGVkR3JpZC5qcydcbmltcG9ydCB7IEJhY2tncm91bmRMYXllciB9IGZyb20gJy4vQmFja2dyb3VuZExheWVyLmpzJ1xuaW1wb3J0IHsgQmFja2dyb3VuZExheWVyV01TIH0gZnJvbSAnLi9CYWNrZ3JvdW5kTGF5ZXJXTVMuanMnXG5pbXBvcnQgeyBMYWJlbExheWVyIH0gZnJvbSAnLi9MYWJlbExheWVyLmpzJ1xuaW1wb3J0IHsgTGluZUxheWVyIH0gZnJvbSAnLi9MaW5lTGF5ZXIuanMnXG5pbXBvcnQgeyBtb25pdG9yLCBtb25pdG9yRHVyYXRpb24gfSBmcm9tICcuL3V0aWxzL1V0aWxzLmpzJ1xuaW1wb3J0IHsgWm9vbUJ1dHRvbnMgfSBmcm9tICcuL2J1dHRvbi9ab29tQnV0dG9ucy5qcydcbmltcG9ydCB7IEZ1bGxzY3JlZW5CdXR0b24gfSBmcm9tICcuL2J1dHRvbi9GdWxsc2NyZWVuQnV0dG9uLmpzJ1xuXG4vLyBleHRlcm5hbCBpbXBvcnRzXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXG5cbi8qKlxuICogQSBncmlkdml6IGFwcGxpY2F0aW9uLlxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIEFwcCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxheWVycy5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxMYXllcj59XG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMubGF5ZXJzID0gW11cblxuICAgICAgICAvL2dldCBjb250YWluZXIgZWxlbWVudFxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ3JpZHZpeicpXG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBmaW5kIGdyaWR2aXogY29udGFpbmVyIGVsZW1lbnQuJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy9odHRwczovL2Nzcy10cmlja3MuY29tL2Fic29sdXRlLXBvc2l0aW9uaW5nLWluc2lkZS1yZWxhdGl2ZS1wb3NpdGlvbmluZy9cbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7IC8vIGNvbnRhaW5lciBlbGVtZW50IG11c3QgaGF2ZSByZWxhdGl2ZSBwb3NpdGlvbmluZ1xuXG4gICAgICAgIC8vc2V0IGRpbWVuc2lvbnNcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gb3B0cy5oIHx8IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodFxuXG4gICAgICAgIC8vY3JlYXRlIGNhbnZhcyBlbGVtZW50IGlmIHVzZXIgZG9lc250IHNwZWNpZnkgb25lXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovXG4gICAgICAgIGxldCBjYW52YXMgPSBvcHRzLmNhbnZhcyB8fCBudWxsXG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnJyArIHRoaXMudylcbiAgICAgICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcnICsgdGhpcy5oKVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIE1ha2UgZ2VvIGNhbnZhc1xuICAgICAgICAgKiBAdHlwZSB7R2VvQ2FudmFzfVxuICAgICAgICAgKiBAcHJpdmF0ZSAqL1xuICAgICAgICB0aGlzLmNnID0gbmV3IEdlb0NhbnZhcyhjYW52YXMsIHVuZGVmaW5lZCwgMSwgb3B0cylcbiAgICAgICAgdGhpcy5jZy5yZWRyYXcgPSAoc3Ryb25nID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignU3RhcnQgcmVkcmF3JylcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCI/eD1cIiArIHRoaXMuY2cuZ2V0Q2VudGVyKCkueCArIFwiJnk9XCIgKyB0aGlzLmNnLmdldENlbnRlcigpLnkgKyBcIiZ6PVwiICsgdGhpcy5jZy5nZXRaZigpKVxuXG4gICAgICAgICAgICAvL3JlbW92ZSBsZWdlbmQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZ2VuZCAmJiBzdHJvbmcpIHRoaXMubGVnZW5kLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXG5cbiAgICAgICAgICAgIC8vY2xlYXJcbiAgICAgICAgICAgIHRoaXMuY2cuaW5pdENhbnZhc1RyYW5zZm9ybSgpXG4gICAgICAgICAgICB0aGlzLmNnLmNsZWFyKHRoaXMuY2cuYmFja2dyb3VuZENvbG9yKVxuXG4gICAgICAgICAgICBjb25zdCB6ZiA9IHRoaXMuZ2V0Wm9vbUZhY3RvcigpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXG5cbiAgICAgICAgICAgIC8vZ28gdGhyb3VnaCB0aGUgYmFja2dyb3VuZCBsYXllcnNcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dCZ0xheWVycylcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuYmdMYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBsYXllciBpcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGF5ZXIudmlzaWJsZSkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpmID4gbGF5ZXIubWF4Wm9vbSkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpmIDwgbGF5ZXIubWluWm9vbSkgY29udGludWVcblxuICAgICAgICAgICAgICAgICAgICAvL2RyYXcgbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZHJhdyh0aGlzLmNnKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9nbyB0aHJvdWdoIHRoZSBsYXllcnNcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIGxheWVyIGlzIHZpc2libGVcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyLnZpc2libGUpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgaWYgKHpmID4gbGF5ZXIubWF4Wm9vbSkgY29udGludWVcbiAgICAgICAgICAgICAgICBpZiAoemYgPCBsYXllci5taW5ab29tKSBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgLy9nZXQgbGF5ZXIgZGF0YXNldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9EYXRhc2V0Q29tcG9uZW50JykuRGF0YXNldENvbXBvbmVudHx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICAgICAgY29uc3QgZHNjID0gbGF5ZXIuZ2V0RGF0YXNldENvbXBvbmVudCh6ZilcbiAgICAgICAgICAgICAgICBpZiAoIWRzYykgY29udGludWVcblxuICAgICAgICAgICAgICAgIC8vbGF1bmNoIGRhdGEgZG93bmxvYWQsIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmIChzdHJvbmcpXG4gICAgICAgICAgICAgICAgICAgIGRzYy5nZXREYXRhKHRoaXMuY2cuZXh0R2VvLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNnLnJlZHJhdygpXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAvL3VwZGF0ZSBkYXRhc2V0IHZpZXcgY2FjaGVcbiAgICAgICAgICAgICAgICBpZiAoc3Ryb25nKSBkc2MudXBkYXRlVmlld0NhY2hlKHRoaXMuY2cuZXh0R2VvKVxuXG4gICAgICAgICAgICAgICAgLy9zZXQgbGF5ZXIgYWxwaGEgYW5kIGJsZW5kIG1vZGVcbiAgICAgICAgICAgICAgICB0aGlzLmNnLmN0eC5nbG9iYWxBbHBoYSA9IGxheWVyLmFscGhhID8gbGF5ZXIuYWxwaGEoemYpIDogMS4wXG4gICAgICAgICAgICAgICAgdGhpcy5jZy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbGF5ZXIuYmxlbmRPcGVyYXRpb24oemYpXG5cbiAgICAgICAgICAgICAgICAvL2RyYXcgY2VsbHMsIHN0eWxlIGJ5IHN0eWxlXG4gICAgICAgICAgICAgICAgaWYgKHN0cm9uZylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIGxheWVyLnN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBzdHlsZSBpcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXMudmlzaWJsZSkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6ZiA+IHMubWF4Wm9vbSkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6ZiA8IHMubWluWm9vbSkgY29udGludWVcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXQgc3R5bGUgYWxwaGEgYW5kIGJsZW5kIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogbXVsdGlwbHkgYnkgbGF5ZXIgYWxwaGEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jZy5jdHguZ2xvYmFsQWxwaGEgPSBzLmFscGhhID8gcy5hbHBoYSh6ZikgOiAxLjBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2cuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHMuYmxlbmRPcGVyYXRpb24oemYpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHMuZHJhdyhkc2MuZ2V0Vmlld0NhY2hlKCksIGRzYy5nZXRSZXNvbHV0aW9uKCksIHRoaXMuY2cpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vYWRkIGxlZ2VuZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVnZW5kICYmIHN0cm9uZykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgbGF5ZXIuc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoemYgPiBzLm1heFpvb20pIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoemYgPCBzLm1pblpvb20pIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxnIG9mIHMubGVnZW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocywgbGcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLmxlZ2VuZC5hcHBlbmQobGcuZGl2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vczEubm9kZSgpLmFwcGVuZENoaWxkKHMyLm5vZGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZ2VuZC5ub2RlKCkuYXBwZW5kKGxnLmRpdi5ub2RlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FzZSBmb3Igc3R5bGVzIG9mIHN0eWxlcywgbGlrZSBrZXJuZWwgc21vb3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gZG8gYmV0dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc1snc3R5bGVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMyIG9mIHMuc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6ZiA+IHMyLm1heFpvb20pIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6ZiA8IHMyLm1pblpvb20pIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGcgb2YgczIubGVnZW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzLCBsZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5sZWdlbmQuYXBwZW5kKGxnLmRpdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vczEubm9kZSgpLmFwcGVuZENoaWxkKHMyLm5vZGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVnZW5kLm5vZGUoKS5hcHBlbmQobGcuZGl2Lm5vZGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vcmVzdG9yZSBkZWZhdWx0IGFscGhhIGFuZCBibGVuZCBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLmNnLmN0eC5nbG9iYWxBbHBoYSA9IDEuMFxuICAgICAgICAgICAgICAgIHRoaXMuY2cuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuZGVmYXVsdEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2RyYXcgYm91bmRhcnkgbGF5ZXJcbiAgICAgICAgICAgIC8vaWYgKHN0cm9uZylcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dCb3VuZGFyaWVzICYmIHRoaXMuYm91bmRhcnlMYXllcikgdGhpcy5ib3VuZGFyeUxheWVyLmRyYXcodGhpcy5jZylcblxuICAgICAgICAgICAgLy9kcmF3IGxhYmVsIGxheWVyXG4gICAgICAgICAgICAvL2lmIChzdHJvbmcpXG4gICAgICAgICAgICBpZiAodGhpcy5zaG93TGFiZWxzICYmIHRoaXMubGFiZWxMYXllcikgdGhpcy5sYWJlbExheWVyLmRyYXcodGhpcy5jZylcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZSA9IG51bGxcblxuICAgICAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignRW5kIHJlZHJhdycpXG5cbiAgICAgICAgICAgIC8vIGxpc3RlbiBmb3IgcmVzaXplIGV2ZW50cyBvbiB0aGUgQXBwJ3MgY29udGFpbmVyIGFuZCBoYW5kbGUgdGhlbVxuICAgICAgICAgICAgdGhpcy5kZWZpbmVSZXNpemVPYnNlcnZlcih0aGlzLmNvbnRhaW5lciwgY2FudmFzKVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QmFja2dyb3VuZExheWVyfEJhY2tncm91bmRMYXllcldNUz59ICovXG4gICAgICAgIHRoaXMuYmdMYXllcnMgPSBbXVxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuc2hvd0JnTGF5ZXJzID0gdHJ1ZVxuXG4gICAgICAgIC8qKiBAdHlwZSB7TGFiZWxMYXllciB8IHVuZGVmaW5lZH0gKi9cbiAgICAgICAgdGhpcy5sYWJlbExheWVyID0gdW5kZWZpbmVkXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5zaG93TGFiZWxzID0gdHJ1ZVxuXG4gICAgICAgIC8qKiBAdHlwZSB7TGluZUxheWVyIHwgdW5kZWZpbmVkfSAqL1xuICAgICAgICB0aGlzLmJvdW5kYXJ5TGF5ZXIgPSB1bmRlZmluZWRcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnNob3dCb3VuZGFyaWVzID0gdHJ1ZVxuXG4gICAgICAgIC8vIGxlZ2VuZCBkaXZcbiAgICAgICAgdGhpcy5sZWdlbmREaXZJZCA9IG9wdHMubGVnZW5kRGl2SWQgfHwgJ2d2aXpMZWdlbmQnXG4gICAgICAgIHRoaXMubGVnZW5kID0gc2VsZWN0KCcjJyArIHRoaXMubGVnZW5kRGl2SWQpXG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZC5lbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLmxlZ2VuZCA9IHNlbGVjdChcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5pZCAmJiB0aGlzLmNvbnRhaW5lci5pZCAhPSAnJyA/ICcjJyArIHRoaXMuY29udGFpbmVyLmlkIDogJ2JvZHknXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCB0aGlzLmxlZ2VuZERpdklkKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnd2lkdGgnLCAnYXV0bycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdoZWlnaHQnLCAnYXV0bycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kJywgJyNGRkZGRkYnKVxuICAgICAgICAgICAgICAgIC8vLnN0eWxlKFwicGFkZGluZ1wiLCB0aGlzLnBhZGRpbmcpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3JkZXInLCAnMHB4JylcbiAgICAgICAgICAgICAgICAvLy5zdHlsZSgnYm9yZGVyLXJhZGl1cycsICc1cHgnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYm94LXNoYWRvdycsICczcHggM3B4IDNweCBncmV5LCAtM3B4IC0zcHggM3B4ICNkZGQnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1mYW1pbHknLCAnSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZicpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3R0b20nLCAnMTVweCcpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdyaWdodCcsICcxNXB4JylcbiAgICAgICAgICAgIC8vaGlkZVxuICAgICAgICAgICAgLy8uc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpXG4gICAgICAgIH1cblxuICAgICAgICAvL3Rvb2x0aXBcblxuICAgICAgICAvLyBzZXQgQXBwIGNvbnRhaW5lciBhcyBkZWZhdWx0IHBhcmVudCBlbGVtZW50IGZvciB0b29sdGlwXG4gICAgICAgIGlmICghb3B0cy50b29sdGlwKSBvcHRzLnRvb2x0aXAgPSB7fVxuICAgICAgICBpZiAoIW9wdHMudG9vbHRpcC5wYXJlbnRFbGVtZW50KSBvcHRzLnRvb2x0aXAucGFyZW50RWxlbWVudCA9IHRoaXMuY29udGFpbmVyXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtUb29sdGlwfSAqL1xuICAgICAgICB0aGlzLnRvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRzLnRvb2x0aXApXG5cbiAgICAgICAgLyoqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAqL1xuICAgICAgICBjb25zdCBmb2N1c0NlbGwgPSAoZSkgPT4ge1xuICAgICAgICAgICAgLy9jb21wdXRlIG1vdXNlIGdlbyBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgbW91c2VQb3NpdGlvbkdlbyA9IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmNnLnBpeFRvR2VvWChlLm9mZnNldFggKyB0aGlzLnRvb2x0aXAueE1vdXNlT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmNnLnBpeFRvR2VvWShlLm9mZnNldFkgKyB0aGlzLnRvb2x0aXAueU1vdXNlT2Zmc2V0KSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7e2NlbGw6aW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsLGh0bWw6c3RyaW5nLHJlc29sdXRpb246bnVtYmVyfSB8IHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIGNvbnN0IGZvY3VzID0gdGhpcy5nZXRDZWxsRm9jdXNJbmZvKG1vdXNlUG9zaXRpb25HZW8pXG5cbiAgICAgICAgICAgIC8vIHRyYW5zcGFyZW50IGJhY2tncm91bmQgKGUuZy4gbGVhZmxldCkgJ3JlZCBwYWludGluZycgZml4XG4gICAgICAgICAgICBpZiAob3B0cy50cmFuc3BhcmVudEJhY2tncm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29sdGlwLmh0bWwoZm9jdXMuaHRtbClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29sdGlwLnNldFBvc2l0aW9uKGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zaG93KClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuaGlkZSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnJyArIHRoaXMudylcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnJyArIHRoaXMuaClcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGhpcy5jZy5jYW52YXMsIDAsIDApXG4gICAgICAgICAgICAgICAgdGhpcy5jZy5pbml0Q2FudmFzVHJhbnNmb3JtKClcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwLmh0bWwoZm9jdXMuaHRtbClcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuc2V0UG9zaXRpb24oZSlcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuc2hvdygpXG5cbiAgICAgICAgICAgICAgICAvL3Nob3cgY2VsbCBwb3NpdGlvbiBhcyBhIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYW52YXNTYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJycgKyB0aGlzLncpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcnICsgdGhpcy5oKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGhpcy5jZy5jYW52YXMsIDAsIDApXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZy5jdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzU2F2ZSwgMCwgMClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2RyYXcgaW1hZ2Ugc2F2ZWQgKyBkcmF3IHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3RXUGl4ID0gdGhpcy5zZWxlY3Rpb25SZWN0YW5nbGVXaWR0aFBpeFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuc2VsZWN0aW9uUmVjdGFuZ2xlV2lkdGhQaXgoZm9jdXMucmVzb2x1dGlvbiwgdGhpcy5nZXRab29tRmFjdG9yKCkpXG4gICAgICAgICAgICAgICAgICAgIDogNFxuICAgICAgICAgICAgICAgIHRoaXMuY2cuaW5pdENhbnZhc1RyYW5zZm9ybSgpXG4gICAgICAgICAgICAgICAgdGhpcy5jZy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnNlbGVjdGlvblJlY3RhbmdsZUNvbG9yXG4gICAgICAgICAgICAgICAgdGhpcy5jZy5jdHgubGluZVdpZHRoID0gcmVjdFdQaXhcbiAgICAgICAgICAgICAgICB0aGlzLmNnLmN0eC5iZWdpblBhdGgoKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jZy5jdHgucmVjdChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZy5nZW9Ub1BpeFgoZm9jdXMuY2VsbC54KSAtIHJlY3RXUGl4IC8gMixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZy5nZW9Ub1BpeFkoZm9jdXMuY2VsbC55KSArIHJlY3RXUGl4IC8gMixcbiAgICAgICAgICAgICAgICAgICAgZm9jdXMucmVzb2x1dGlvbiAvIHRoaXMuZ2V0Wm9vbUZhY3RvcigpICsgcmVjdFdQaXgsXG4gICAgICAgICAgICAgICAgICAgIC1mb2N1cy5yZXNvbHV0aW9uIC8gdGhpcy5nZXRab29tRmFjdG9yKCkgLSByZWN0V1BpeFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aGlzLmNnLmN0eC5zdHJva2UoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuaGlkZSgpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzU2F2ZSkgdGhpcy5jZy5jdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzU2F2ZSwgMCwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lcnMgdG8gY29udGFpbmVyXG4gICAgICAgIHRoaXMubW91c2VPdmVySGFuZGxlciA9IChlKSA9PiBmb2N1c0NlbGwoZSlcbiAgICAgICAgdGhpcy5tb3VzZU1vdmVIYW5kbGVyID0gKGUpID0+IGZvY3VzQ2VsbChlKVxuICAgICAgICB0aGlzLm1vdXNlT3V0SGFuZGxlciA9IChlKSA9PiB0aGlzLnRvb2x0aXAuaGlkZSgpXG4gICAgICAgIHRoaXMuY2cuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMubW91c2VPdmVySGFuZGxlcilcbiAgICAgICAgdGhpcy5jZy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKVxuICAgICAgICB0aGlzLmNnLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMubW91c2VPdXRIYW5kbGVyKVxuXG4gICAgICAgIC8vIGFkZCBleHRyYSBsb2dpYyB0byBvblpvb21TdGFydEZ1blxuICAgICAgICB0aGlzLmNnLm9uWm9vbVN0YXJ0RnVuID0gKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRzLm9uWm9vbVN0YXJ0RnVuKSBvcHRzLm9uWm9vbVN0YXJ0RnVuKGUpXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuaGlkZSgpXG4gICAgICAgIH1cblxuICAgICAgICAvL2ZvciBtb3VzZSBvdmVyXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR8bnVsbH0gKi9cbiAgICAgICAgdGhpcy5jYW52YXNTYXZlID0gbnVsbFxuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmVjdGFuZ2xlQ29sb3IgPSBvcHRzLnNlbGVjdGlvblJlY3RhbmdsZUNvbG9yIHx8ICdyZWQnXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmVjdGFuZ2xlV2lkdGhQaXggPSBvcHRzLnNlbGVjdGlvblJlY3RhbmdsZVdpZHRoUGl4IHx8ICgoKSA9PiA0KSAvLyhyLHpmKSA9PiB7fVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGUgPT4geyBjb25zb2xlLmxvZyhhcmd1bWVudHMpIH0pO1xuXG4gICAgICAgIC8vc2V0IGRlZmF1bHQgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICAgIHRoaXMuZGVmYXVsdEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9XG4gICAgICAgICAgICBvcHRzLmRlZmF1bHRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gfHwgdGhpcy5jZy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hcmdpblB4XG4gICAgICogQHJldHVybnMge2ltcG9ydCgnLi9EYXRhc2V0JykuRW52ZWxvcGV9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVwZGF0ZUV4dGVudEdlbyhtYXJnaW5QeCA9IDIwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNnLnVwZGF0ZUV4dGVudEdlbyhtYXJnaW5QeClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNlbGwgSFRNTCBpbmZvIGF0IGEgZ2l2ZW4gZ2VvIHBvc2l0aW9uLlxuICAgICAqIFRoaXMgaXMgdXNlZnVsbCBmb3IgdXNlciBpbnRlcmFjdGlvbnMsIHRvIHNob3cgdGhpcyBpbmZvIHdoZXJlIHRoZSB1c2VyIGNsaWNrcyBmb3IgZXhhbXBsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gcG9zR2VvXG4gICAgICogQHJldHVybnMge3tjZWxsOmltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCxodG1sOnN0cmluZyxyZXNvbHV0aW9uOm51bWJlcn0gfCB1bmRlZmluZWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldENlbGxGb2N1c0luZm8ocG9zR2VvKSB7XG4gICAgICAgIC8vZ28gdGhyb3VnaCB0aGUgbGF5ZXJzLCBzdGFydGluZyBmcm9tIHRvcFxuICAgICAgICBjb25zdCB6ZiA9IHRoaXMuZ2V0Wm9vbUZhY3RvcigpXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtMYXllcn0gKi9cbiAgICAgICAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNbaV1cbiAgICAgICAgICAgIGlmICghbGF5ZXIudmlzaWJsZSkgY29udGludWVcbiAgICAgICAgICAgIGlmICghbGF5ZXIuY2VsbEluZm9IVE1MKSBjb250aW51ZVxuICAgICAgICAgICAgLy9pZiAobGF5ZXIuY2VsbEluZm9IVE1MID09PSAnbm9uZScpIGNvbnRpbnVlXG4gICAgICAgICAgICBjb25zdCBkc2MgPSBsYXllci5nZXREYXRhc2V0Q29tcG9uZW50KHpmKVxuICAgICAgICAgICAgaWYgKCFkc2MpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vZ2V0IGNlbGwgYXQgbW91c2UgcG9zaXRpb25cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBkc2MuZ2V0Q2VsbEZyb21Qb3NpdGlvbihwb3NHZW8sIGRzYy5nZXRWaWV3Q2FjaGUoKSlcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY2VsbCwgZHNjLnJlc29sdXRpb24pXG4gICAgICAgICAgICBpZiAoIWNlbGwpIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSBsYXllci5jZWxsSW5mb0hUTUwoY2VsbCwgZHNjLmdldFJlc29sdXRpb24oKSlcbiAgICAgICAgICAgIGlmICghaHRtbCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIHsgY2VsbDogY2VsbCwgaHRtbDogaHRtbCwgcmVzb2x1dGlvbjogZHNjLmdldFJlc29sdXRpb24oKSB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL2dldHRlcnMgYW5kIHNldHRlcnNcblxuICAgIC8qKiBAcmV0dXJucyB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gKi9cbiAgICBnZXRHZW9DZW50ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNnLmdldENlbnRlcigpXG4gICAgfVxuICAgIC8qKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IHZhbCBAcmV0dXJucyB7dGhpc30gKi9cbiAgICBzZXRHZW9DZW50ZXIodmFsKSB7XG4gICAgICAgIHRoaXMuY2cuc2V0Q2VudGVyKHZhbClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKiogQHJldHVybnMge251bWJlcn0gKi9cbiAgICBnZXRab29tRmFjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZy5nZXRaZigpXG4gICAgfVxuICAgIC8qKiBAcGFyYW0ge251bWJlcn0gdmFsIEByZXR1cm5zIHt0aGlzfSAqL1xuICAgIHNldFpvb21GYWN0b3IodmFsKSB7XG4gICAgICAgIHRoaXMuY2cuc2V0WmYodmFsKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59ICovXG4gICAgZ2V0Wm9vbUZhY3RvckV4dGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2cuZ2V0WmZFeHRlbnQoKVxuICAgIH1cbiAgICAvKiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsIEByZXR1cm5zIHt0aGlzfSAqL1xuICAgIHNldFpvb21GYWN0b3JFeHRlbnQodmFsKSB7XG4gICAgICAgIHRoaXMuY2cuc2V0WmZFeHRlbnQodmFsKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuICAgIGdldEJhY2tncm91bmRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2cuYmFja2dyb3VuZENvbG9yXG4gICAgfVxuICAgIC8qKiBAcGFyYW0ge3N0cmluZ30gdmFsIEByZXR1cm5zIHt0aGlzfSAqL1xuICAgIHNldEJhY2tncm91bmRDb2xvcih2YWwpIHtcbiAgICAgICAgdGhpcy5jZy5iYWNrZ3JvdW5kQ29sb3IgPSB2YWxcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKiogQHJldHVybnMge0xpbmVMYXllciB8IHVuZGVmaW5lZH0gKi9cbiAgICBnZXRCb3VuZGFyeUxheWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGFyeUxheWVyXG4gICAgfVxuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyBAcmV0dXJucyB7dGhpc30gKi9cbiAgICBzZXRCb3VuZGFyeUxheWVyKG9wdHMpIHtcbiAgICAgICAgdGhpcy5ib3VuZGFyeUxheWVyID0gbmV3IExpbmVMYXllcihvcHRzKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKiBAcmV0dXJucyB7TGFiZWxMYXllciB8IHVuZGVmaW5lZH0gKi9cbiAgICBnZXRMYWJlbExheWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbExheWVyXG4gICAgfVxuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyBAcmV0dXJucyB7dGhpc30gKi9cbiAgICBzZXRMYWJlbExheWVyKG9wdHMpIHtcbiAgICAgICAgdGhpcy5sYWJlbExheWVyID0gbmV3IExhYmVsTGF5ZXIob3B0cylcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKiogQHJldHVybnMge3RoaXN9ICovXG4gICAgcmVkcmF3KCkge1xuICAgICAgICB0aGlzLmNnLnJlZHJhdygpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGF5ZXIgdG8gdGhlIGFwcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldCBUaGUgZGF0YXNldCBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoJy4vU3R5bGUnKS5TdHlsZT59IHN0eWxlcyBUaGUgc3R5bGVzIG9mIHRoZSBsYXllclxuICAgICAqIEBwYXJhbSB7e3Zpc2libGU/OmJvb2xlYW4sbWluWm9vbT86bnVtYmVyLG1heFpvb20/Om51bWJlcixwaXhOYj86bnVtYmVyLGNlbGxJbmZvSFRNTD86ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsKTpzdHJpbmd9fSBvcHRzIFRoZSBsYXllciBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGFkZExheWVyRnJvbURhdGFzZXQoZGF0YXNldCwgc3R5bGVzLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IGxheSA9IG5ldyBMYXllcihkYXRhc2V0LCBzdHlsZXMsIG9wdHMpXG4gICAgICAgIHRoaXMubGF5ZXJzLnB1c2gobGF5KVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vZGF0YXNldCBjcmVhdGlvblxuXG4gICAgLyoqXG4gICAgICogTWFrZSBhIGxvY2FsIGdyaWQgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBkYXRhc2V0IHJlc29sdXRpb24gaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2VsbHMgVGhlIGNlbGxzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0cyBUaGUgcGFyYW1ldGVycyBvZiB0aGUgZGF0YXNldC5cbiAgICAgKiBAcmV0dXJucyB7RGF0YXNldH1cbiAgICAgKi9cbiAgICBtYWtlTEdyaWREYXRhc2V0KHJlc29sdXRpb24sIGNlbGxzLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YXNldChbbmV3IExHcmlkKHJlc29sdXRpb24sIGNlbGxzKV0sIFtdLCBvcHRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2UgYSBDU1YgZ3JpZCBkYXRhc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoZSBkYXRhc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBkYXRhc2V0IHJlc29sdXRpb24gaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRzIFRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBkYXRhc2V0LlxuICAgICAqIEByZXR1cm5zIHtEYXRhc2V0fVxuICAgICAqL1xuICAgIG1ha2VDU1ZHcmlkRGF0YXNldCh1cmwsIHJlc29sdXRpb24sIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhc2V0KFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIG5ldyBDU1ZHcmlkKHVybCwgcmVzb2x1dGlvbiwgb3B0cykuZ2V0RGF0YSh1bmRlZmluZWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZy5yZWRyYXcoKVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgb3B0c1xuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSBhIHRpbGVkIGdyaWQgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge3twcmVwcm9jZXNzPzpmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwpOmJvb2xlYW59fSBvcHRzXG4gICAgICogQHJldHVybnMge0RhdGFzZXR9XG4gICAgICovXG4gICAgbWFrZVRpbGVkR3JpZERhdGFzZXQodXJsLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YXNldChcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBuZXcgVGlsZWRHcmlkKHVybCwgdGhpcywgb3B0cykubG9hZEluZm8oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNnLnJlZHJhdygpXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW10sXG4gICAgICAgICAgICBvcHRzXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvL211bHRpIHNjYWxlIGRhdGFzZXQgY3JlYXRpb25cblxuICAgIC8qKlxuICAgICAqIE1ha2UgYSBtdWx0aSBzY2FsZSBDU1YgZ3JpZCBkYXRhc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmVzb2x1dGlvbnNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6c3RyaW5nfSByZXNUb1VSTFxuICAgICAqIEBwYXJhbSB7e3ByZXByb2Nlc3M/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCk6Ym9vbGVhbn19IG9wdHNcbiAgICAgKiBAcmV0dXJucyB7RGF0YXNldH1cbiAgICAgKi9cbiAgICBtYWtlTXVsdGlTY2FsZUNTVkdyaWREYXRhc2V0KHJlc29sdXRpb25zLCByZXNUb1VSTCwgb3B0cykge1xuICAgICAgICByZXR1cm4gRGF0YXNldC5tYWtlKFxuICAgICAgICAgICAgcmVzb2x1dGlvbnMsXG4gICAgICAgICAgICAocmVzKSA9PlxuICAgICAgICAgICAgICAgIG5ldyBDU1ZHcmlkKHJlc1RvVVJMKHJlcyksIHJlcywgb3B0cykuZ2V0RGF0YSh1bmRlZmluZWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZy5yZWRyYXcoKVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb3B0c1xuICAgICAgICApXG4gICAgfVxuXG4gICAgLy90aWxlZCBtdWx0aXNjYWxlXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGEgbXVsdGkgc2NhbGUgdGlsZWQgZ3JpZCBkYXRhc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmVzb2x1dGlvbnNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6c3RyaW5nfSByZXNUb1VSTFxuICAgICAqIEBwYXJhbSB7e3ByZXByb2Nlc3M/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCk6Ym9vbGVhbn19IG9wdHNcbiAgICAgKiBAcmV0dXJucyB7RGF0YXNldH1cbiAgICAgKi9cbiAgICBtYWtlTXVsdGlTY2FsZVRpbGVkR3JpZERhdGFzZXQocmVzb2x1dGlvbnMsIHJlc1RvVVJMLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBEYXRhc2V0Lm1ha2UoXG4gICAgICAgICAgICByZXNvbHV0aW9ucyxcbiAgICAgICAgICAgIChyZXMpID0+XG4gICAgICAgICAgICAgICAgbmV3IFRpbGVkR3JpZChyZXNUb1VSTChyZXMpLCB0aGlzLCBvcHRzKS5sb2FkSW5mbygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2cucmVkcmF3KClcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9wdHNcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8vIGRpcmVjdCBsYXllciBjcmVhdGlvblxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGF5ZXIgZnJvbSBhIENTViBncmlkIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgb2YgdGhlIGRhdGFzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIGRhdGFzZXQgcmVzb2x1dGlvbiBpbiBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoJy4vU3R5bGUnKS5TdHlsZT59IHN0eWxlcyBUaGUgc3R5bGVzLCBvcmRlcmVkIGluIGRyYXdpbmcgb3JkZXIuXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRzIFRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBkYXRhc2V0IGFuZCBsYXllci5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBhZGRDU1ZHcmlkTGF5ZXIodXJsLCByZXNvbHV0aW9uLCBzdHlsZXMsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgZHMgPSB0aGlzLm1ha2VDU1ZHcmlkRGF0YXNldCh1cmwsIHJlc29sdXRpb24sIG9wdHMpXG4gICAgICAgIHJldHVybiB0aGlzLmFkZExheWVyRnJvbURhdGFzZXQoZHMsIHN0eWxlcywgb3B0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoJy4vU3R5bGUnKS5TdHlsZT59IHN0eWxlc1xuICAgICAqIEBwYXJhbSB7e3Zpc2libGU/OmJvb2xlYW4sbWluWm9vbT86bnVtYmVyLG1heFpvb20/Om51bWJlcixwaXhOYj86bnVtYmVyLGNlbGxJbmZvSFRNTD86ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsKTpzdHJpbmcsIHByZXByb2Nlc3M/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCk6Ym9vbGVhbn19IG9wdHNcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBhZGRUaWxlZEdyaWRMYXllcih1cmwsIHN0eWxlcywgb3B0cykge1xuICAgICAgICBjb25zdCBkcyA9IHRoaXMubWFrZVRpbGVkR3JpZERhdGFzZXQodXJsLCBvcHRzKVxuICAgICAgICByZXR1cm4gdGhpcy5hZGRMYXllckZyb21EYXRhc2V0KGRzLCBzdHlsZXMsIG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGF5ZXIgZnJvbSBhIENTViBncmlkIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZXNvbHV0aW9uc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKTpzdHJpbmd9IHJlc1RvVVJMXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KCcuL1N0eWxlJykuU3R5bGU+fSBzdHlsZXMgVGhlIHN0eWxlcywgb3JkZXJlZCBpbiBkcmF3aW5nIG9yZGVyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0cyBUaGUgcGFyYW1ldGVycyBvZiB0aGUgZGF0YXNldCBhbmQgbGF5ZXIuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgYWRkTXVsdGlTY2FsZUNTVkdyaWRMYXllcihyZXNvbHV0aW9ucywgcmVzVG9VUkwsIHN0eWxlcywgb3B0cykge1xuICAgICAgICBjb25zdCBkcyA9IHRoaXMubWFrZU11bHRpU2NhbGVDU1ZHcmlkRGF0YXNldChyZXNvbHV0aW9ucywgcmVzVG9VUkwsIG9wdHMpXG4gICAgICAgIHJldHVybiB0aGlzLmFkZExheWVyRnJvbURhdGFzZXQoZHMsIHN0eWxlcywgb3B0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZXNvbHV0aW9uc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKTpzdHJpbmd9IHJlc1RvVVJMXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KCcuL1N0eWxlJykuU3R5bGU+fSBzdHlsZXNcbiAgICAgKiBAcGFyYW0ge3t2aXNpYmxlPzpib29sZWFuLG1pblpvb20/Om51bWJlcixtYXhab29tPzpudW1iZXIscGl4TmI/Om51bWJlcixjZWxsSW5mb0hUTUw/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCk6c3RyaW5nLCBwcmVwcm9jZXNzPzpmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwpOmJvb2xlYW59fSBvcHRzXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgYWRkTXVsdGlTY2FsZVRpbGVkR3JpZExheWVyKHJlc29sdXRpb25zLCByZXNUb1VSTCwgc3R5bGVzLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IGRzID0gdGhpcy5tYWtlTXVsdGlTY2FsZVRpbGVkR3JpZERhdGFzZXQocmVzb2x1dGlvbnMsIHJlc1RvVVJMLCBvcHRzKVxuICAgICAgICByZXR1cm4gdGhpcy5hZGRMYXllckZyb21EYXRhc2V0KGRzLCBzdHlsZXMsIG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgYmFja2dyb3VuZCBsYXllciB0byB0aGUgYXBwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBhZGRCYWNrZ3JvdW5kTGF5ZXIob3B0cykge1xuICAgICAgICB0aGlzLmJnTGF5ZXJzLnB1c2gobmV3IEJhY2tncm91bmRMYXllcihvcHRzKSlcbiAgICAgICAgdGhpcy5yZWRyYXcoKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIFdNUyBiYWNrZ3JvdW5kIGxheWVyIHRvIHRoZSBhcHAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGFkZEJhY2tncm91bmRMYXllcldNUyhvcHRzKSB7XG4gICAgICAgIHRoaXMuYmdMYXllcnMucHVzaChuZXcgQmFja2dyb3VuZExheWVyV01TKG9wdHMpKVxuICAgICAgICB0aGlzLnJlZHJhdygpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGFkZFpvb21TbGlkZXIoaWQsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5jZy5hZGRab29tU2xpZGVyKGlkLCBvcHRzKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzZXQgb2Ygem9vbSBidXR0b25zIHRvIHRoZSBhcHBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgYWRkWm9vbUJ1dHRvbnMob3B0cykge1xuICAgICAgICAvLyAqIG9wdHMuaWRcbiAgICAgICAgLy8gKiBvcHRzLm9uWm9vbSAtIGN1c3RvbSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICAgIC8vICogb3B0cy54XG4gICAgICAgIC8vICogb3B0cy55XG4gICAgICAgIC8vICogb3B0cy5kZWx0YSAtIHpvb20gZGVsdGEgYXBwbGllZCBvbiBlYWNoIGNsaWNrXG5cbiAgICAgICAgdGhpcy56b29tQnV0dG9ucyA9IG5ldyBab29tQnV0dG9ucyh7XG4gICAgICAgICAgICBhcHA6IHRoaXMsXG4gICAgICAgICAgICBpZDogb3B0cz8uaWQgfHwgJ2dyaWR2aXotem9vbS1idXR0b25zJyxcbiAgICAgICAgICAgIGNsYXNzOiBvcHRzPy5jbGFzcyxcbiAgICAgICAgICAgIHg6IG9wdHM/LngsXG4gICAgICAgICAgICB5OiBvcHRzPy55LFxuICAgICAgICAgICAgb25ab29tOiBvcHRzPy5vblpvb20sXG4gICAgICAgICAgICBkZWx0YTogb3B0cz8uZGVsdGEgfHwgMC4yXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZnVsbHNjcmVlbiB0b2dnbGUgYnV0dG9uIHRvIHRoZSBhcHBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgYWRkRnVsbHNjcmVlbkJ1dHRvbihvcHRzKSB7XG4gICAgICAgIC8vICogb3B0cy5hcHAgLSB0aGUgZ3JpZHZpeiBhcHBcbiAgICAgICAgLy8gKiBvcHRzLmlkXG4gICAgICAgIC8vICogb3B0cy54XG4gICAgICAgIC8vICogb3B0cy55XG5cbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuQnV0dG9uID0gbmV3IEZ1bGxzY3JlZW5CdXR0b24oe1xuICAgICAgICAgICAgYXBwOiB0aGlzLFxuICAgICAgICAgICAgaWQ6IG9wdHM/LmlkIHx8ICdncmlkdml6LWZ1bGxzY3JlZW4tYnV0dG9uJyxcbiAgICAgICAgICAgIGNsYXNzOiBvcHRzPy5jbGFzcyxcbiAgICAgICAgICAgIHg6IG9wdHM/LngsXG4gICAgICAgICAgICB5OiBvcHRzPy55XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKiogQHJldHVybnMge3RoaXN9ICovXG4gICAgc2V0Vmlld0Zyb21VUkwoKSB7XG4gICAgICAgIHRoaXMuY2cuc2V0Vmlld0Zyb21VUkwoKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGQgYSByZXNpemUgZXZlbnQgb2JzZXJ2ZXIgdG8gdGhlIEFwcHMgY29udGFpbmVyIGFuZCB1cGRhdGUgdGhlIGNhbnZhcyBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGNvbnRhaW5lciBUaGUgQXBwJ3MgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgVGhlIEFwcCBjYW52YXMgZWxlbWVudFxuICAgICAqIEBtZW1iZXJvZiBBcHBcbiAgICAgKi9cbiAgICBkZWZpbmVSZXNpemVPYnNlcnZlcihjb250YWluZXIsIGNhbnZhcykge1xuICAgICAgICAvLyBsaXN0ZW4gdG8gcmVzaXplIGV2ZW50c1xuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNhbnZhcyBoYXMgYmVlbiBidWlsdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5jbGllbnRXaWR0aCA+IDAgJiYgY29udGFpbmVyLmNsaWVudEhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZG9udCBleGNlZWQgbG9vcCBsaW1pdCBmaXJzdFxuICAgICAgICAgICAgICAgIC8vIHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDkzODQxMjAvcmVzaXplb2JzZXJ2ZXItbG9vcC1saW1pdC1leGNlZWRlZFxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50cmllcykgfHwgIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGFwcCBhbmQgY2FudmFzIHNpemVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaCAhPT0gY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCB0aGlzLncgIT09IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oID0gY29udGFpbmVyLmNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53ID0gY29udGFpbmVyLmNsaWVudFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNnLmggPSBjb250YWluZXIuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNnLncgPSBjb250YWluZXIuY2xpZW50V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJycgKyB0aGlzLncpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnJyArIHRoaXMuaClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVkcmF3KClcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgYnV0dG9uIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuem9vbUJ1dHRvbnMpIHRoaXMuem9vbUJ1dHRvbnMubm9kZS5zdHlsZS5sZWZ0ID0gdGhpcy53IC0gNTAgKyAncHgnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5mdWxsc2NyZWVuQnV0dG9uKSB0aGlzLmZ1bGxzY3JlZW5CdXR0b24ubm9kZS5zdHlsZS5sZWZ0ID0gdGhpcy53IC0gNTAgKyAncHgnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBEZXN0cm95IHRoZSBhcHAgYW5kIGl0J3MgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogVGhpcyBzaG91bGQgc2lnbmlmaWNhbnRseSByZWR1Y2UgdGhlIG1lbW9yeSB1c2VkIHdoZW4gY3JlYXRpbmcgYW5kIGRlc3Ryb3lpbmcgZ3JpZHZpeiBhcHAgaW5zdGFuY2VzIChmb3IgZXhhbXBsZSBpbiBsZWFmbGV0LWdyaWR2aXopXG4gICAgICogQG1lbWJlcm9mIEFwcFxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIGNsZWFyIGxheWVyc1xuICAgICAgICB0aGlzLmxheWVycyA9IFtdXG4gICAgICAgIHRoaXMuYmdMYXllcnMgPSBbXVxuXG4gICAgICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZnJvbSBjb250YWluZXJcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5tb3VzZU92ZXJIYW5kbGVyKVxuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXIpXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5tb3VzZU91dEhhbmRsZXIpXG5cbiAgICAgICAgLy8gcmVtb3ZlIGNhbnZhc1xuICAgICAgICB0aGlzLmNnLmNhbnZhcy5yZW1vdmUoKVxuXG4gICAgICAgIC8vIHJlbW92ZSBsZWdlbmRcbiAgICAgICAgdGhpcy5sZWdlbmQ/LnJlbW92ZSgpXG5cbiAgICAgICAgLy8gcmVtb3ZlIHRvb2x0aXBcbiAgICAgICAgdGhpcy50b29sdGlwLnRvb2x0aXA/LnJlbW92ZSgpXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqXG4gKiBBIG1hcCBiYWNrZ3JvdW5kIGxheWVyIGluIFwiU2xpcHB5IG1hcFwiIFhZWiBzdGFuZGFyZC5cbiAqIFNlZSBodHRwczovL3dpa2kub3BlbnN0cmVldG1hcC5vcmcvd2lraS9TbGlwcHlfbWFwX3RpbGVuYW1lc1xuICogaHR0cHM6Ly93d3cubWFwdGlsZXIuY29tL2dvb2dsZS1tYXBzLWNvb3JkaW5hdGVzLXRpbGUtYm91bmRzLXByb2plY3Rpb24vIzYvMjcuODgvNDQuNDhcbiAqIFxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgQmFja2dyb3VuZExheWVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQW4gYXR0cmlidXRlIHRvIHNwZWNpZnkgaWYgYSBsYXllciBzaG91bGQgYmUgZHJhd24gb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnZpc2libGUgPSBvcHRzLnZpc2libGUgPT0gZmFsc2UgPyBmYWxzZSA6IHRydWVcblxuICAgICAgICAvKiogVGhlIG1pbmltdW0gem9vbSBmYWN0b3I6IEJlbG93IHRoaXMgbGV2ZWwsIHRoZSBsYXllciBpcyBub3Qgc2hvd24uXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMubWluWm9vbSA9IG9wdHMubWluWm9vbSB8fCAwXG5cbiAgICAgICAgLyoqIFRoZSBtYXhpbXVtIHpvb20gZmFjdG9yOiBBYm92ZSB0aGlzIGxldmVsLCB0aGUgbGF5ZXIgaXMgbm90IHNob3duLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm1heFpvb20gPSBvcHRzLm1heFpvb20gfHwgSW5maW5pdHlcblxuICAgICAgICAvL2Vuc3VyZSBhY2NlcHRhYmxlIHZhbHVlcyBmb3IgdGhlIHpvb20gbGltaXRzLlxuICAgICAgICBpZiAodGhpcy5taW5ab29tID49IHRoaXMubWF4Wm9vbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB6b29tIGxpbWl0cyBmb3IgbGF5ZXIuIFpvb20gbWluIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gem9vbSBtYXguJylcblxuICAgICAgICAvKiogVGhlIGltYWdlIGNhY2hlLCBpbmRleGVkIGJ5IHoveS94ICovXG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnVybCA9IG9wdHMudXJsXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixudW1iZXIpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy51cmxGdW4gPSBvcHRzLnVybEZ1biB8fCAoKHgsIHksIHopID0+IHRoaXMudXJsICsgeiArICcvJyArIHggKyAnLycgKyB5ICsgJy5wbmcnKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbnMgPSBvcHRzLnJlc29sdXRpb25zXG4gICAgICAgIGlmICghdGhpcy5yZXNvbHV0aW9ucyB8fCB0aGlzLnJlc29sdXRpb25zLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNvbHV0aW9ucyBwcm92aWRlZCBmb3IgYmFja2dyb3VuZCBsYXllcicpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMubmJQaXggPSBvcHRzLm5iUGl4IHx8IDI1NlxuICAgICAgICAvKiogQ1JTIGNvb3JkaW5hdGVzIG9mIHRvcCBsZWZ0IGNvcm5lclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXG4gICAgICAgIHRoaXMub3JpZ2luID0gb3B0cy5vcmlnaW4gfHwgWzAsIDBdXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnowID0gb3B0cy56MCB8fCAwXG5cbiAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5maWx0ZXJDb2xvciA9IG9wdHMuZmlsdGVyQ29sb3IgLy8gKHpmKSA9PiBcIiNlZWU3XCJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgei94L3kgY2FjaGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gelxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudHxzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0KHosIHgsIHkpIHtcbiAgICAgICAgbGV0IGQgPSB0aGlzLmNhY2hlW3pdXG4gICAgICAgIGlmICghZCkgcmV0dXJuXG4gICAgICAgIGQgPSBkW3hdXG4gICAgICAgIGlmICghZCkgcmV0dXJuXG4gICAgICAgIHJldHVybiBkW3ldXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHoveC95IGNhY2hlIGRhdGEuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fHN0cmluZ30gaW1nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1dChpbWcsIHosIHgsIHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlW3pdKSB0aGlzLmNhY2hlW3pdID0ge31cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlW3pdW3hdKSB0aGlzLmNhY2hlW3pdW3hdID0ge31cbiAgICAgICAgdGhpcy5jYWNoZVt6XVt4XVt5XSA9IGltZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9DYW52YXNcIikuR2VvQ2FudmFzfSBjZyBUaGUgY2FudmFzIHdoZXJlIHRvIGRyYXcgdGhlIGxheWVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGRyYXcoY2cpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdXRpb25zIHx8IHRoaXMucmVzb2x1dGlvbnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHJlc29sdXRpb25zIHByb3ZpZGVkIGZvciBiYWNrZ3JvdW5kIGxheWVyJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXG4gICAgICAgIGNvbnN0IHgwID0gdGhpcy5vcmlnaW5bMF0sXG4gICAgICAgICAgICB5MCA9IHRoaXMub3JpZ2luWzFdXG5cbiAgICAgICAgLy9nZXQgem9vbSBsZXZlbCBhbmQgcmVzb2x1dGlvblxuICAgICAgICBsZXQgeiA9IDBcbiAgICAgICAgZm9yICh6ID0gMDsgeiA8IHRoaXMucmVzb2x1dGlvbnMubGVuZ3RoOyB6KyspIGlmICh0aGlzLnJlc29sdXRpb25zW3pdIDwgemYpIGJyZWFrXG4gICAgICAgIHogLT0gMVxuICAgICAgICB6ID0gTWF0aC5tYXgoMCwgeilcbiAgICAgICAgeiA9IE1hdGgubWluKHosIHRoaXMucmVzb2x1dGlvbnMubGVuZ3RoIC0gMSlcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLnJlc29sdXRpb25zLmxlbmd0aCwgeilcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5yZXNvbHV0aW9uc1t6XVxuXG4gICAgICAgIHogKz0gdGhpcy56MFxuXG4gICAgICAgIGNvbnN0IHNpemVHID0gdGhpcy5uYlBpeCAqIHJlc1xuICAgICAgICBjb25zdCBzaXplID0gc2l6ZUcgLyB6ZlxuXG4gICAgICAgIC8vZ2V0IHRpbGUgbnVtYmVyc1xuICAgICAgICBjb25zdCB4R2VvVG9UTVMgPSAoeCkgPT4gTWF0aC5jZWlsKCh4IC0geDApIC8gc2l6ZUcpXG4gICAgICAgIGNvbnN0IHlHZW9Ub1RNUyA9ICh5KSA9PiBNYXRoLmNlaWwoLSh5IC0geTApIC8gc2l6ZUcpXG4gICAgICAgIGNvbnN0IHhNaW4gPSB4R2VvVG9UTVMoY2cuZXh0R2VvLnhNaW4pIC0gMVxuICAgICAgICBjb25zdCB4TWF4ID0geEdlb1RvVE1TKGNnLmV4dEdlby54TWF4KVxuICAgICAgICBjb25zdCB5TWF4ID0geUdlb1RvVE1TKGNnLmV4dEdlby55TWluKVxuICAgICAgICBjb25zdCB5TWluID0geUdlb1RvVE1TKGNnLmV4dEdlby55TWF4KSAtIDFcblxuICAgICAgICAvL1RPRE8gP1xuICAgICAgICAvL2NnLnNldENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgLy9oYW5kbGUgaW1hZ2VzXG4gICAgICAgIGZvciAobGV0IHggPSB4TWluOyB4IDwgeE1heDsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0geU1pbjsgeSA8IHlNYXg7IHkrKykge1xuICAgICAgICAgICAgICAgIC8vZ2V0IGltYWdlXG4gICAgICAgICAgICAgICAgbGV0IGltZyA9IHRoaXMuZ2V0KHosIHgsIHkpXG5cbiAgICAgICAgICAgICAgICAvL2xvYWQgaW1hZ2VcbiAgICAgICAgICAgICAgICBpZiAoIWltZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1dChpbWcsIHosIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5yZWRyYXcoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlIHdoZW4gbm8gaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHV0KCdmYWlsZWQnLCB6LCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSB0aGlzLnVybEZ1bih4LCB5LCB6KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY2FzZSB3aGVuIG5vIGltYWdlXG4gICAgICAgICAgICAgICAgaWYgKGltZyA9PT0gJ2ZhaWxlZCcpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgaWYgKCEoaW1nIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW1nKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW1nLndpZHRoID09IDAgfHwgaW1nLmhlaWdodCA9PSAwKSBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgLy9kcmF3IGltYWdlXG4gICAgICAgICAgICAgICAgY29uc3QgeEdlbyA9IHgwICsgeCAqIHNpemVHXG4gICAgICAgICAgICAgICAgY29uc3QgeUdlbyA9IHkwIC0geSAqIHNpemVHXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmRyYXdJbWFnZShpbWcsIGNnLmdlb1RvUGl4WCh4R2VvKSwgY2cuZ2VvVG9QaXhZKHlHZW8pLCBzaXplLCBzaXplKVxuICAgICAgICAgICAgICAgICAgICAvL2NnLmN0eC5kcmF3SW1hZ2UoaW1nLCB4R2VvLCB5R2VvLCBzaXplRywgLXNpemVHKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9hcHBseSBmaWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyQ29sb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZjID0gdGhpcy5maWx0ZXJDb2xvcih6ZilcbiAgICAgICAgICAgIGlmIChmYyAmJiBmYyAhPSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gZmNcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoMCwgMCwgY2cudywgY2cuaClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKlxuICogQSBtYXAgV01TIGJhY2tncm91bmQgbGF5ZXIuXG4gKiBcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIEJhY2tncm91bmRMYXllcldNUyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIEFuIGF0dHJpYnV0ZSB0byBzcGVjaWZ5IGlmIGEgbGF5ZXIgc2hvdWxkIGJlIGRyYXduIG9yIG5vdFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy52aXNpYmxlID0gb3B0cy52aXNpYmxlID09IGZhbHNlID8gZmFsc2UgOiB0cnVlXG5cbiAgICAgICAgLyoqIFRoZSBtaW5pbXVtIHpvb20gZmFjdG9yOiBCZWxvdyB0aGlzIGxldmVsLCB0aGUgbGF5ZXIgaXMgbm90IHNob3duLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm1pblpvb20gPSBvcHRzLm1pblpvb20gfHwgMFxuXG4gICAgICAgIC8qKiBUaGUgbWF4aW11bSB6b29tIGZhY3RvcjogQWJvdmUgdGhpcyBsZXZlbCwgdGhlIGxheWVyIGlzIG5vdCBzaG93bi5cbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5tYXhab29tID0gb3B0cy5tYXhab29tIHx8IEluZmluaXR5XG5cbiAgICAgICAgLy9lbnN1cmUgYWNjZXB0YWJsZSB2YWx1ZXMgZm9yIHRoZSB6b29tIGxpbWl0cy5cbiAgICAgICAgaWYgKHRoaXMubWluWm9vbSA+PSB0aGlzLm1heFpvb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgem9vbSBsaW1pdHMgZm9yIGxheWVyLiBab29tIG1pbiBzaG91bGQgYmUgc21hbGxlciB0aGFuIHpvb20gbWF4LicpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMudXJsID0gb3B0cy51cmxcblxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKG51bWJlcik6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmZpbHRlckNvbG9yID0gb3B0cy5maWx0ZXJDb2xvciAvLyAoemYpID0+IFwiI2VlZTdcIlxuXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudHx1bmRlZmluZWR9ICovXG4gICAgICAgIHRoaXMuaW1nID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgdGhpcy54TWluID0gdW5kZWZpbmVkO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgICAgIHRoaXMueE1heCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICB0aGlzLnlNaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgdGhpcy55TWF4ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKiBDaGVjayBpZiB0aGUgdmlldyBoYXMgbW92ZWQgYW5kIGEgbmV3IGltYWdlIG5lZWRzIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcHJpdmF0ZSAqL1xuICAgIGhhc01vdmVkKGV4dEdlbykge1xuICAgICAgICBpZiAoKGV4dEdlby54TWluKSAhPSB0aGlzLnhNaW4pIHJldHVybiB0cnVlXG4gICAgICAgIGVsc2UgaWYgKChleHRHZW8ueE1heCkgIT0gdGhpcy54TWF4KSByZXR1cm4gdHJ1ZVxuICAgICAgICBlbHNlIGlmICgoZXh0R2VvLnlNaW4pICE9IHRoaXMueU1pbikgcmV0dXJuIHRydWVcbiAgICAgICAgZWxzZSBpZiAoKGV4dEdlby55TWF4KSAhPSB0aGlzLnlNYXgpIHJldHVybiB0cnVlXG4gICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2cgVGhlIGNhbnZhcyB3aGVyZSB0byBkcmF3IHRoZSBsYXllci5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBkcmF3KGNnKSB7XG5cbiAgICAgICAgLy91cGRhdGUgbWFwIGV4dGVudFxuICAgICAgICBjZy51cGRhdGVFeHRlbnRHZW8oMClcblxuICAgICAgICBpZiAoIXRoaXMuaGFzTW92ZWQoY2cuZXh0R2VvKSAmJiB0aGlzLmltZykge1xuICAgICAgICAgICAgLy90aGUgbWFwIGRpZCBub3QgbW92ZSBhbmQgdGhlIGltYWdlIHdhcyBhbHJlYWR5IGRvd25sb2FkZWQ6IGRyYXcgdGhlIGltYWdlXG4gICAgICAgICAgICBjZy5jdHguZHJhd0ltYWdlKHRoaXMuaW1nLCAwLCAwLCBjZy53LCBjZy5oKVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3RoZSBtYXAgbW92ZWQ6IHJldHJpZXZlIG5ldyBpbWFnZVxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdGhpcy54TWluID0gY2cuZXh0R2VvLnhNaW5cbiAgICAgICAgICAgIHRoaXMueE1heCA9IGNnLmV4dEdlby54TWF4XG4gICAgICAgICAgICB0aGlzLnlNaW4gPSBjZy5leHRHZW8ueU1pblxuICAgICAgICAgICAgdGhpcy55TWF4ID0gY2cuZXh0R2VvLnlNYXhcblxuICAgICAgICAgICAgLy9idWlsZCBXTVMgVVJMXG4gICAgICAgICAgICBjb25zdCB1cmwgPSBbXVxuICAgICAgICAgICAgdXJsLnB1c2godGhpcy51cmwpXG4gICAgICAgICAgICB1cmwucHVzaChcIiZ3aWR0aD1cIilcbiAgICAgICAgICAgIHVybC5wdXNoKGNnLncpXG4gICAgICAgICAgICB1cmwucHVzaChcIiZoZWlnaHQ9XCIpXG4gICAgICAgICAgICB1cmwucHVzaChjZy5oKVxuICAgICAgICAgICAgLy9iYm94OiB4bWluIHltaW4geG1heCB5bWF4XG4gICAgICAgICAgICB1cmwucHVzaChcIiZiYm94PVwiKVxuICAgICAgICAgICAgdXJsLnB1c2goY2cuZXh0R2VvLnhNaW4pXG4gICAgICAgICAgICB1cmwucHVzaChcIixcIilcbiAgICAgICAgICAgIHVybC5wdXNoKGNnLmV4dEdlby55TWluKVxuICAgICAgICAgICAgdXJsLnB1c2goXCIsXCIpXG4gICAgICAgICAgICB1cmwucHVzaChjZy5leHRHZW8ueE1heClcbiAgICAgICAgICAgIHVybC5wdXNoKFwiLFwiKVxuICAgICAgICAgICAgdXJsLnB1c2goY2cuZXh0R2VvLnlNYXgpXG5cbiAgICAgICAgICAgIGNvbnN0IHVybFMgPSB1cmwuam9pbihcIlwiKVxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh1cmxTKVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaW1nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWcgPSBuZXcgSW1hZ2UoKVxuICAgICAgICAgICAgICAgIHRoaXMuaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2cucmVkcmF3KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy9jYXNlIHdoZW4gbm8gaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IHJldHJpZXZlIFdNUyBiYWNrZ3JvdW5kIGltYWdlIGZyb21cIiwgdXJsUylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vc2V0IFVSTCB0byBsYXVuY2ggdGhlIGRvd25sb2FkXG4gICAgICAgICAgICB0aGlzLmltZy5zcmMgPSB1cmxTXG4gICAgICAgIH1cblxuICAgICAgICAvL2FwcGx5IGZpbHRlclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyQ29sb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZjID0gdGhpcy5maWx0ZXJDb2xvcih6ZilcbiAgICAgICAgICAgIGlmIChmYyAmJiBmYyAhPSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gZmNcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoMCwgMCwgY2cudywgY2cuaClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBBIGdyaWQgY2VsbC5cbiAqIEB0eXBlZGVmIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBDZWxsICovXG4vKipcbiAqIEFuIGVudmVsb3BlLlxuICogQHR5cGVkZWYgeyB7eE1pbjogbnVtYmVyLCB4TWF4OiBudW1iZXIsIHlNaW46IG51bWJlciwgeU1heDogbnVtYmVyfSB9IEVudmVsb3BlICovXG5cbi8qKlxuICogQSBtdWx0aSByZXNvbHV0aW9uIGRhdGFzZXQgb2YgZ3JpZCBjZWxscy5cbiAqIEl0IGNvbnNpc3RzIG9mIGRpZmZlcmVudCB7QGxpbmsgRGF0YXNldENvbXBvbmVudH1zIGZvciBlYWNoIHJlc29sdXRpb24uXG4gKlxuICogQGFic3RyYWN0XG4gKlxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgRGF0YXNldCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi9EYXRhc2V0Q29tcG9uZW50XCIpLkRhdGFzZXRDb21wb25lbnQ+fSBkYXRhc2V0Q29tcG9uZW50cyBUaGUgZGF0YXNldCBjb21wb25lbnRzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmVzb2x1dGlvbnMgVGhlIHJlc29sdXRpb25zIG9mIHRoZSBkYXRhc2V0IGNvbXBvbmVudHMsIGluIENSUyBnZW9ncmFwaGljYWwgdW5pdFxuICAgICAqIEBwYXJhbSB7IHtwcmVwcm9jZXNzPzpmdW5jdGlvbihDZWxsKTpib29sZWFufSB9IG9wdHMgT3B0aW9ucy4gcHJlcHJvY2VzczogQSBmdW5jdGlvbiB0byBhcHBseSBvbiBlYWNoIGRhdGFzZXQgY2VsbCB0byBwcmVwYXJlIGl0cyB2YWx1ZXMuIENhbiBiZSB1c2VkIGFsc28gdG8gc2VsZWN0IGNlbGxzIHRvIGtlZXAuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YXNldENvbXBvbmVudHMsIHJlc29sdXRpb25zLCBvcHRzID0ge30pIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogVGhlIGRhdGFzZXQgY29tcG9uZW50cy5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxpbXBvcnQoXCIuL0RhdGFzZXRDb21wb25lbnRcIikuRGF0YXNldENvbXBvbmVudD59ICovXG4gICAgICAgIHRoaXMuZGF0YXNldENvbXBvbmVudHMgPSBkYXRhc2V0Q29tcG9uZW50c1xuXG4gICAgICAgIC8qKiBUaGUgcmVzb2x1dGlvbnMgb2YgdGhlIGRhdGFzZXQgY29tcG9uZW50cywgaW4gQ1JTIGdlb2dyYXBoaWNhbCB1bml0LlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbnMgPSByZXNvbHV0aW9uc1xuXG4gICAgICAgIC8vdGhlcmUgbXVzdCBiZSBhcyBtYW55IGRhdGFzZXQgY29tcG9uZW50cyBhcyByZXNvbHV0aW9uc1xuICAgICAgICBpZiAodGhpcy5kYXRhc2V0Q29tcG9uZW50cy5sZW5ndGggPiAxICYmIHRoaXMuZGF0YXNldENvbXBvbmVudHMubGVuZ3RoICE9IHRoaXMucmVzb2x1dGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdVbmNvbXBhdGlibGUgbnVtYmVyIG9mIGRhdGFzZXRzIGFuZCByZXNvbHV0aW9uczogJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YXNldENvbXBvbmVudHMubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHV0aW9ucy5sZW5ndGhcbiAgICAgICAgICAgIClcblxuICAgICAgICAvL3NldCBkYXRhc2V0IHByZXByb2Nlc3NlcyBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdHMucHJlcHJvY2VzcykgdGhpcy5zZXRQcmVwb2Nlc3NlcyhvcHRzLnByZXByb2Nlc3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgcHJlcHJvY2VzcyBmdW5jdGlvbiBmb3IgYWxsIGRhdGFzZXQgY29tcG9uZW50cy5cbiAgICAgKiBUaGlzIGlzIGEgZnVuY3Rpb24gYXBwbGllZCBvbiBlYWNoIGNlbGwgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihDZWxsKTpib29sZWFufSBwcmVwcm9jZXNzXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc2V0UHJlcG9jZXNzZXMocHJlcHJvY2Vzcykge1xuICAgICAgICBmb3IgKGxldCBkcyBvZiB0aGlzLmRhdGFzZXRDb21wb25lbnRzKSBkcy5wcmVwcm9jZXNzID0gcHJlcHJvY2Vzc1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdG8gZWFzZSB0aGUgY3JlYXRpb24gb2YgZGF0YXNldHMgZnJvbSB0aGVpciBjb21wb25lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmVzb2x1dGlvbnMgVGhlIHJlc29sdXRpb25zIG9mIHRoZSBkYXRhc2V0IGNvbXBvbmVudHMsIGluIENSUyBnZW9ncmFwaGljYWwgdW5pdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKTppbXBvcnQoXCIuL0RhdGFzZXRDb21wb25lbnRcIikuRGF0YXNldENvbXBvbmVudH0gcmVzVG9EYXRhc2V0Q29tcG9uZW50IEZ1bmN0aW9uIHJldHVybmluZyBhIGRhdGFzZXQgY29tcG9uZW50IGZyb20gYSByZXNvbHV0aW9uXG4gICAgICogQHBhcmFtIHsge3ByZXByb2Nlc3M/OmZ1bmN0aW9uKENlbGwpOmJvb2xlYW59IH0gb3B0cyBPcHRpb25zLiBwcmVwcm9jZXNzOiBBIGZ1bmN0aW9uIHRvIGFwcGx5IG9uIGVhY2ggZGF0YXNldCBjZWxsIHRvIHByZXBhcmUgaXRzIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHtEYXRhc2V0fVxuICAgICAqL1xuICAgIHN0YXRpYyBtYWtlKHJlc29sdXRpb25zLCByZXNUb0RhdGFzZXRDb21wb25lbnQsIG9wdHMpIHtcbiAgICAgICAgLy9tYWtlIGRhdGFzZXQgY29tcG9uZW50c1xuICAgICAgICBjb25zdCBkc2MgPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IHJlcyBvZiByZXNvbHV0aW9ucykgZHNjLnB1c2gocmVzVG9EYXRhc2V0Q29tcG9uZW50KHJlcykpXG4gICAgICAgIC8vbWFrZSBkYXRhc2V0XG4gICAgICAgIHJldHVybiBuZXcgRGF0YXNldChkc2MsIHJlc29sdXRpb25zLCBvcHRzKVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBBIGRhdGFzZXQgY29tcG9uZW50LCBvZiBncmlkIGNlbGxzLlxuICogQGFic3RyYWN0XG4gKlxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgRGF0YXNldENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoZSBkYXRhc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBkYXRhc2V0IHJlc29sdXRpb24sIGluIHRoZSBDUlMgZ2VvZ3JhcGhpY2FsIHVuaXQuXG4gICAgICogQHBhcmFtIHt7cHJlcHJvY2Vzcz86ZnVuY3Rpb24oaW1wb3J0KFwiLi9EYXRhc2V0XCIpLkNlbGwpOmJvb2xlYW59fSBvcHRzXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsLCByZXNvbHV0aW9uLCBvcHRzID0ge30pIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVybCBvZiB0aGUgZGF0YXNldC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnVybCA9IHVybFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YXNldCByZXNvbHV0aW9uIGluIGdlb2dyYXBoaWNhbCB1bml0LlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb25cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBwcmVwcm9jZXNzIHRvIHJ1biBvbiBlYWNoIGNlbGwgYWZ0ZXIgbG9hZGluZy4gSXQgY2FuIGJlIHVzZWQgdG8gYXBwbHkgc29tZSBzcGVjaWZpYyB0cmVhdG1lbnQgYmVmb3JlIG9yIGNvbXB1dGUgYSBuZXcgY29sdW1uLiBBbmQgYWxzbyB0byBkZXRlcm1pbmUgd2hpY2ggY2VsbHMgdG8ga2VlcCBhZnRlciBsb2FkaW5nLlxuICAgICAgICAgKiBAdHlwZSB7KGZ1bmN0aW9uKGltcG9ydChcIi4vRGF0YXNldFwiKS5DZWxsKTpib29sZWFuICl8IHVuZGVmaW5lZCB9ICovXG4gICAgICAgIHRoaXMucHJlcHJvY2VzcyA9IG9wdHMucHJlcHJvY2VzcyB8fCB1bmRlZmluZWRcblxuICAgICAgICAvKiogVGhlIGNlbGxzIHdpdGhpbiB0aGUgdmlld1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48aW1wb3J0KFwiLi9EYXRhc2V0XCIpLkNlbGw+fSAqL1xuICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlID0gW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGRhdGEgd2l0aGluIGEgZ2VvZ3JhcGhpYyBlbnZlbG9wZS5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9EYXRhc2V0XCIpLkVudmVsb3BlfHVuZGVmaW5lZH0gZXh0R2VvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgZ2V0RGF0YShleHRHZW8sIGNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIGdldERhdGEgbm90IGltcGxlbWVudGVkLicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbCB0aGUgdmlldyBjYWNoZSB3aXRoIGFsbCBjZWxscyB3aGljaCBhcmUgd2l0aGluIGEgZ2VvZ3JhcGhpY2FsIGVudmVsb3BlLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9EYXRhc2V0XCIpLkVudmVsb3BlfSBleHRHZW8gVGhlIHZpZXcgZ2VvZ3JhcGhpY2FsIGVudmVsb3BlLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHVwZGF0ZVZpZXdDYWNoZShleHRHZW8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgdXBkYXRlVmlld0NhY2hlIG5vdCBpbXBsZW1lbnRlZC4nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIGNlbGwgdW5kZXIgYSBnaXZlbiBwb3NpdGlvbiwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBwb3NHZW9cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzIFNvbWUgY2VsbHMgZnJvbSB0aGUgZGF0YXNldCAoYSBzdWJzZXQgaWYgbmVjZXNzYXJ5LCB1c3VhbGx5IHRoZSB2aWV3IGNhY2hlKS5cbiAgICAgKiBAcmV0dXJucyB7aW1wb3J0KFwiLi9EYXRhc2V0XCIpLkNlbGx8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldENlbGxGcm9tUG9zaXRpb24ocG9zR2VvLCBjZWxscykge1xuICAgICAgICAvL2NvbXB1dGUgY2FuZGlkYXRlIGNlbGwgcG9zaXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIC8vY29uc3QgciA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAvL2NvbnN0IGNlbGxYID0gciAqIE1hdGguZmxvb3IocG9zR2VvLnggLyByKVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgLy9jb25zdCBjZWxsWSA9IHIgKiBNYXRoLmZsb29yKHBvc0dlby55IC8gcilcblxuICAgICAgICAvKi9nZXQgY2VsbFxuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgIGlmIChjZWxsLnggIT0gY2VsbFgpIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoY2VsbC55ICE9IGNlbGxZKSBjb250aW51ZVxuICAgICAgICAgICAgcmV0dXJuIGNlbGxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkKi9cblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgY29uc3QgciA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpXG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiBjZWxscykge1xuICAgICAgICAgICAgaWYgKHBvc0dlby54IDwgY2VsbC54KSBjb250aW51ZVxuICAgICAgICAgICAgZWxzZSBpZiAoY2VsbC54ICsgciA8IHBvc0dlby54KSBjb250aW51ZVxuICAgICAgICAgICAgZWxzZSBpZiAocG9zR2VvLnkgPCBjZWxsLnkpIGNvbnRpbnVlXG4gICAgICAgICAgICBlbHNlIGlmIChjZWxsLnkgKyByIDwgcG9zR2VvLnkpIGNvbnRpbnVlXG4gICAgICAgICAgICBlbHNlIHJldHVybiBjZWxsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuXG4gICAgfVxuXG4gICAgLy9nZXR0ZXJzIGFuZCBzZXR0ZXJzXG5cbiAgICAvKiogQHJldHVybnMge251bWJlcn0gKi9cbiAgICBnZXRSZXNvbHV0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uXG4gICAgfVxuXG4gICAgLyoqIEByZXR1cm5zIHtBcnJheS48aW1wb3J0KFwiLi9EYXRhc2V0XCIpLkNlbGw+fSAqL1xuICAgIGdldFZpZXdDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbHNWaWV3Q2FjaGVcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7IHt4TWluOiBudW1iZXIsIHhNYXg6IG51bWJlciwgeU1pbjogbnVtYmVyLCB5TWF4OiBudW1iZXJ9IH0gRW52ZWxvcGUgKi9cblxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xuaW1wb3J0IHsgem9vbSwgem9vbUlkZW50aXR5IH0gZnJvbSAnZDMtem9vbSdcblxuLyoqXG4gKiBBIEhUTUwgY2FudmFzIGZvciBnZW8gZGF0YSBkaXNwbGF5LCBlbmhhbmNlZCB3aXRoIHpvb20gYW5kIHBhbiBjYXBhYmlsaXRpZXMuXG4gKlxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgR2VvQ2FudmFzIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2VudGVyIEdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpmIFRoZSB6b29tIGZhY3RvciAocGl4ZWwgc2l6ZSwgaW4gZ3JvdW5kIG0pXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYW52YXMsIGNlbnRlciwgemYsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovXG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IHRoaXMuY2FudmFzLm9mZnNldFdpZHRoXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHRcblxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMud1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmhcblxuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgIGlmICghY3R4KSB0aHJvdyAnSW1wb3NzaWJsZSB0byBjcmVhdGUgY2FudmFzIDJEIGNvbnRleHQnXG4gICAgICAgIC8qKkB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4XG5cbiAgICAgICAgLy8gc2V0IGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyXG4gICAgICAgIHRoaXMuY2VudGVyID0gY2VudGVyIHx8IHsgeDogdGhpcy53ICogMC41LCB5OiB0aGlzLmggKiAwLjUgfVxuXG4gICAgICAgIC8vIHpvb20gZmFjdG9yOiBwaXhlbCBzaXplLCBpbiBtL3BpeFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy56ZiA9IHpmXG5cbiAgICAgICAgLyoqIEJhY2tncm91bmQgY29sb3IuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3IgfHwgJ3doaXRlJ1xuXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKTp2b2lkfSAqL1xuICAgICAgICB0aGlzLm9uWm9vbVN0YXJ0RnVuID0gb3B0cy5vblpvb21TdGFydEZ1blxuXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKTp2b2lkfSAqL1xuICAgICAgICB0aGlzLm9uWm9vbUVuZEZ1biA9IG9wdHMub25ab29tRW5kRnVuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbigpOnZvaWR9ICovXG4gICAgICAgIHRoaXMub25ab29tRnVuID0gb3B0cy5vblpvb21GdW5cblxuICAgICAgICAvL2N1cnJlbnQgZXh0ZW50XG4gICAgICAgIC8qKiBAdHlwZSB7RW52ZWxvcGV9ICovXG4gICAgICAgIHRoaXMuZXh0R2VvID0geyB4TWluOiBOYU4sIHhNYXg6IE5hTiwgeU1pbjogTmFOLCB5TWF4OiBOYU4gfVxuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXG5cbiAgICAgICAgLy9yZWx5IG9uIGQzIHpvb20gZm9yIHBhbi96b29tXG4gICAgICAgIGlmICghb3B0cy5kaXNhYmxlWm9vbSkge1xuICAgICAgICAgICAgbGV0IHRQID0gem9vbUlkZW50aXR5XG4gICAgICAgICAgICBjb25zdCB6ID0gem9vbSgpXG4gICAgICAgICAgICAgICAgLy90byBtYWtlIHRoZSB6b29taW5nIGEgYml0IGZhc3RlclxuICAgICAgICAgICAgICAgIC53aGVlbERlbHRhKChlKSA9PiAtZS5kZWx0YVkgKiAoZS5kZWx0YU1vZGUgPT09IDEgPyAwLjA3IDogZS5kZWx0YU1vZGUgPyAxIDogMC4wMDQpKVxuICAgICAgICAgICAgICAgIC5vbignem9vbScsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlLnRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmID0gdFAuayAvIHQua1xuICAgICAgICAgICAgICAgICAgICBpZiAoZiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHggPSB0UC54IC0gdC54XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkeSA9IHRQLnkgLSB0LnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFuKGR4ICogdGhpcy5nZXRaZigpLCAtZHkgKiB0aGlzLmdldFpmKCkpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZSA9IGUuc291cmNlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZSBpbnN0YW5jZW9mIFdoZWVsRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3pvb20gYXQgdGhlIG1vdXNlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBpeFRvR2VvWChlLnNvdXJjZUV2ZW50Lm9mZnNldFgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBpeFRvR2VvWShlLnNvdXJjZUV2ZW50Lm9mZnNldFkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZSBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgYXZlcmFnZSBwb3NpdGlvbiBvZiB0aGUgdG91Y2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eCA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5ID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHR0IG9mIHNlLnRhcmdldFRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHggKz0gdHQuY2xpZW50WFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eSArPSB0dC5jbGllbnRZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4IC89IHNlLnRhcmdldFRvdWNoZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHkgLz0gc2UudGFyZ2V0VG91Y2hlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3pvb20gYXQgdGhpcyBhdmVyYWdlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tKGYsIHRoaXMucGl4VG9HZW9YKHR4KSwgdGhpcy5waXhUb0dlb1kodHkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRQID0gdFxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uWm9vbUZ1bikgdGhpcy5vblpvb21GdW4oZSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5jLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnJyArIHRoaXMudylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnJyArIHRoaXMuaClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGhpcy5jYW52YXMsIDAsIDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5keCA9IDBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmR5ID0gMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZiA9IDFcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vblpvb21TdGFydEZ1bikgdGhpcy5vblpvb21TdGFydEZ1bihlKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdlbmQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZHJhdyh0cnVlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUgPSB7IGM6IG51bGwsIGR4OiAwLCBkeTogMCwgZjogMSB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25ab29tRW5kRnVuKSB0aGlzLm9uWm9vbUVuZEZ1bihlKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB6KHNlbGVjdCh0aGlzLmNhbnZhcykpXG4gICAgICAgIH1cbiAgICAgICAgLy9zZWxlY3QodGhpcy5jYW52YXMpLmNhbGwoeik7XG5cbiAgICAgICAgLyoqIFpvb20gZXh0ZW50LCB0byBsaW1pdCB6b29tIGluIGFuZCBvdXRcbiAgICAgICAgICogIEB0eXBlIHtBcnJheS48bnVtYmVyPn0gKi9cbiAgICAgICAgdGhpcy56ZkV4dGVudCA9IFswLCBJbmZpbml0eV1cblxuICAgICAgICAvKiogQ2FudmFzIHN0YXRlLCB0byBiZSB1c2VkIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlZHJhd3Mgb24gem9vbS9wYW5cbiAgICAgICAgICogIEB0eXBlIHt7YzpIVE1MQ2FudmFzRWxlbWVudHxudWxsLGR4Om51bWJlcixkeTpudW1iZXIsZjpudW1iZXJ9fSAqL1xuICAgICAgICB0aGlzLmNhbnZhc1NhdmUgPSB7IGM6IG51bGwsIGR4OiAwLCBkeTogMCwgZjogMSB9XG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gdiBHZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciAqL1xuICAgIHNldENlbnRlcih2KSB7XG4gICAgICAgIHRoaXMuY2VudGVyID0gdlxuICAgIH1cbiAgICAvKiogQHJldHVybnMge3t4Om51bWJlcix5Om51bWJlcn19IEdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyICovXG4gICAgZ2V0Q2VudGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXJcbiAgICB9XG5cbiAgICAvKiogQHBhcmFtIHtudW1iZXJ9IHYgVGhlIHpvb20gZmFjdG9yIChwaXhlbCBzaXplLCBpbiBncm91bmQgbSkgKi9cbiAgICBzZXRaZih2KSB7XG4gICAgICAgIHRoaXMuemYgPSB2XG4gICAgICAgIGlmICh0aGlzLnNsaWRlcikgdGhpcy5zbGlkZXIuYXR0cigndmFsdWUnLCArdGhpcy56ZilcbiAgICB9XG4gICAgLyoqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB6b29tIGZhY3RvciAocGl4ZWwgc2l6ZSwgaW4gZ3JvdW5kIG0pICovXG4gICAgZ2V0WmYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpmXG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHYgKi9cbiAgICBzZXRaZkV4dGVudCh2KSB7XG4gICAgICAgIHRoaXMuemZFeHRlbnQgPSB2XG4gICAgfVxuICAgIC8qKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59ICovXG4gICAgZ2V0WmZFeHRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpmRXh0ZW50XG4gICAgfVxuXG4gICAgLyoqIEluaXRpYWxpc2UgY2FudmFzIHRyYW5zZm9ybSB3aXRoIGlkZW50aXR5IHRyYW5zZm9ybWF0aW9uLiAqL1xuICAgIGluaXRDYW52YXNUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKVxuICAgIH1cblxuICAgIC8qKiBJbml0aWFsaXNlIGNhbnZhcyB0cmFuc2Zvcm0gd2l0aCBnZW8gdG8gc2NyZWVuIHRyYW5zZm9ybWF0aW9uLCBzbyB0aGF0IGdlbyBvYmplY3RzIGNhbiBiZSBkcmF3biBkaXJlY3RseSBpbiBnZW8gY29vcmRpbmF0ZXMuICovXG4gICAgc2V0Q2FudmFzVHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBrID0gMSAvIHRoaXMuZ2V0WmYoKVxuICAgICAgICBjb25zdCB0eCA9IC10aGlzLmNlbnRlci54IC8gdGhpcy5nZXRaZigpICsgdGhpcy53ICogMC41XG4gICAgICAgIGNvbnN0IHR5ID0gdGhpcy5jZW50ZXIueSAvIHRoaXMuZ2V0WmYoKSArIHRoaXMuaCAqIDAuNVxuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oaywgMCwgMCwgLWssIHR4LCB0eSlcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gd2ViR0wgc2NyZWVuIGNvb3JkaW5hdGVzLCB3aXRoaW4gWy0xLDFdKlstMSwxXSAqL1xuICAgIGdldFdlYkdMVHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBreCA9IDIuMCAvICh0aGlzLncgKiB0aGlzLmdldFpmKCkpXG4gICAgICAgIGNvbnN0IGt5ID0gMi4wIC8gKHRoaXMuaCAqIHRoaXMuZ2V0WmYoKSlcbiAgICAgICAgcmV0dXJuIFtreCwgMC4wLCAwLjAsIDAuMCwga3ksIDAuMCwgLWt4ICogdGhpcy5jZW50ZXIueCwgLWt5ICogdGhpcy5jZW50ZXIueSwgMS4wXVxuICAgIH1cblxuICAgIC8qKiBUaGUgZnVuY3Rpb24gc3BlY2lmeWluZyBob3cgdG8gZHJhdyB0aGUgbWFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3Ryb25nICovXG4gICAgcmVkcmF3KHN0cm9uZyA9IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgcmVkcmF3IG5vdCBpbXBsZW1lbnRlZC4nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyLiBUbyBiZSB1c2VkIGJlZm9yZSBhIHJlZHJhdyBmb3IgZXhhbXBsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKi9cbiAgICBjbGVhcihjb2xvciA9ICd3aGl0ZScpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy50cmFuc3BhcmVudEJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN0eCkgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3JcbiAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4R2VvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR5R2VvXG4gICAgICovXG4gICAgcGFuKGR4R2VvID0gMCwgZHlHZW8gPSAwKSB7XG4gICAgICAgIC8vVE9ETyBmb3JjZSBleHRlbmQgdG8gcmVtYWluXG4gICAgICAgIHRoaXMuY2VudGVyLnggKz0gZHhHZW9cbiAgICAgICAgdGhpcy5jZW50ZXIueSArPSBkeUdlb1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXG5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzU2F2ZS5jKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHggLT0gZHhHZW8gLyB0aGlzLmdldFpmKClcbiAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5keSArPSBkeUdlbyAvIHRoaXMuZ2V0WmYoKVxuICAgICAgICAgICAgdGhpcy5jbGVhcih0aGlzLmJhY2tncm91bmRDb2xvcilcbiAgICAgICAgICAgIC8vIHRoaXMgZG9lc250IHdvcmsgb24gbW9iaWxlIGh0dHBzOi8vZ2l0aHViLmNvbS9ldXJvc3RhdC9ncmlkdml6L2lzc3Vlcy85OFxuICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzU2F2ZS5jLCB0aGlzLmNhbnZhc1NhdmUuZHgsIHRoaXMuY2FudmFzU2F2ZS5keSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFpvb20uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGYgVGhlIHpvb20gZmFjdG9yLCB3aXRoaW4gXTAsIEluZmluaXR5XS4gMSBpcyBmb3Igbm8gY2hhbmdlLiA8MSB0byB6b29tLWluLCA+MSB0byB6b29tLW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geEdlbyBUaGUgeCBnZW8gcG9zaXRpb24gZml4ZWQgaW4gdGhlIHNjcmVlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geUdlbyBUaGUgeSBnZW8gcG9zaXRpb24gZml4ZWQgaW4gdGhlIHNjcmVlbi5cbiAgICAgKi9cbiAgICB6b29tKGYgPSAxLCB4R2VvID0gdGhpcy5jZW50ZXIueCwgeUdlbyA9IHRoaXMuY2VudGVyLnkpIHtcbiAgICAgICAgLy9UT0RPIGZvcmNlIGdlbyBleHRlbmQgdG8gcmVtYWluXG5cbiAgICAgICAgLy90cnlpbmcgdG8gem9vbSBpbi9vdXQgYmV5b25kIGxpbWl0XG4gICAgICAgIGlmICh0aGlzLnpmRXh0ZW50WzBdID09IHRoaXMuZ2V0WmYoKSAmJiBmIDw9IDEpIHJldHVyblxuICAgICAgICBpZiAodGhpcy56ZkV4dGVudFsxXSA9PSB0aGlzLmdldFpmKCkgJiYgZiA+PSAxKSByZXR1cm5cblxuICAgICAgICAvL2Vuc3VyZSB6b29tIGV4dGVudCBwcmVzZXJ2ZWRcbiAgICAgICAgY29uc3QgbmV3WmYgPSBmICogdGhpcy5nZXRaZigpXG4gICAgICAgIGlmIChuZXdaZiA8IHRoaXMuemZFeHRlbnRbMF0pIGYgPSB0aGlzLnpmRXh0ZW50WzBdIC8gdGhpcy5nZXRaZigpXG4gICAgICAgIGlmIChuZXdaZiA+IHRoaXMuemZFeHRlbnRbMV0pIGYgPSB0aGlzLnpmRXh0ZW50WzFdIC8gdGhpcy5nZXRaZigpXG5cbiAgICAgICAgdGhpcy5zZXRaZihmICogdGhpcy5nZXRaZigpKVxuICAgICAgICBjb25zdCBkeEdlbyA9ICh4R2VvIC0gdGhpcy5jZW50ZXIueCkgKiAoMSAtIGYpXG4gICAgICAgIHRoaXMuY2VudGVyLnggKz0gZHhHZW9cbiAgICAgICAgY29uc3QgZHlHZW8gPSAoeUdlbyAtIHRoaXMuY2VudGVyLnkpICogKDEgLSBmKVxuICAgICAgICB0aGlzLmNlbnRlci55ICs9IGR5R2VvXG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZW50R2VvKClcblxuICAgICAgICAvL1RPRE9cbiAgICAgICAgLy90aGlzLnJlZHJhdyhmYWxzZSlcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzU2F2ZS5jKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKHRoaXMuYmFja2dyb3VuZENvbG9yKVxuICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmYgLz0gZlxuICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmR4ID0gdGhpcy5nZW9Ub1BpeFgoeEdlbykgKiAoMSAtIHRoaXMuY2FudmFzU2F2ZS5mKVxuICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmR5ID0gdGhpcy5nZW9Ub1BpeFkoeUdlbykgKiAoMSAtIHRoaXMuY2FudmFzU2F2ZS5mKVxuICAgICAgICAgICAgdGhpcy5jbGVhcih0aGlzLmJhY2tncm91bmRDb2xvcilcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuYyxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHgsXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmR5LFxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5mICogdGhpcy5jYW52YXNTYXZlLmMud2lkdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmYgKiB0aGlzLmNhbnZhc1NhdmUuYy5oZWlnaHRcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXJnaW5QeFxuICAgICAqIEByZXR1cm5zIHtFbnZlbG9wZX0gVGhlIGVudmVsb3BlIG9mIHRoZSB2aWV3LCBpbiBnZW8gY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgdXBkYXRlRXh0ZW50R2VvKG1hcmdpblB4ID0gMjApIHtcbiAgICAgICAgdGhpcy5leHRHZW8gPSB7XG4gICAgICAgICAgICB4TWluOiB0aGlzLnBpeFRvR2VvWCgtbWFyZ2luUHgpLFxuICAgICAgICAgICAgeE1heDogdGhpcy5waXhUb0dlb1godGhpcy53ICsgbWFyZ2luUHgpLFxuICAgICAgICAgICAgeU1pbjogdGhpcy5waXhUb0dlb1kodGhpcy5oICsgbWFyZ2luUHgpLFxuICAgICAgICAgICAgeU1heDogdGhpcy5waXhUb0dlb1koLW1hcmdpblB4KSxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHRHZW9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgb2JqZWN0IGhhcyB0byBiZSBkcmF3blxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBvYmpcbiAgICAgKi9cbiAgICB0b0RyYXcob2JqKSB7XG4gICAgICAgIGlmIChvYmoueCA8IHRoaXMuZXh0R2VvLnhNaW4pIHJldHVybiBmYWxzZVxuICAgICAgICBpZiAob2JqLnggPiB0aGlzLmV4dEdlby54TWF4KSByZXR1cm4gZmFsc2VcbiAgICAgICAgaWYgKG9iai55IDwgdGhpcy5leHRHZW8ueU1pbikgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmIChvYmoueSA+IHRoaXMuZXh0R2VvLnlNYXgpIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vY29udmVyc2lvbiBmdW5jdGlvbnNcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geEdlbyBHZW8geCBjb29yZGluYXRlLCBpbiBtLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNjcmVlbiB4IGNvb3JkaW5hdGUsIGluIHBpeC5cbiAgICAgKi9cbiAgICBnZW9Ub1BpeFgoeEdlbykge1xuICAgICAgICByZXR1cm4gKHhHZW8gLSB0aGlzLmNlbnRlci54KSAvIHRoaXMuZ2V0WmYoKSArIHRoaXMudyAqIDAuNVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geUdlbyBHZW8geSBjb29yZGluYXRlLCBpbiBtLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNjcmVlbiB5IGNvb3JkaW5hdGUsIGluIHBpeC5cbiAgICAgKi9cbiAgICBnZW9Ub1BpeFkoeUdlbykge1xuICAgICAgICByZXR1cm4gLSh5R2VvIC0gdGhpcy5jZW50ZXIueSkgLyB0aGlzLmdldFpmKCkgKyB0aGlzLmggKiAwLjVcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggU2NyZWVuIHggY29vcmRpbmF0ZSwgaW4gcGl4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEdlbyB4IGNvb3JkaW5hdGUsIGluIG0uXG4gICAgICovXG4gICAgcGl4VG9HZW9YKHgpIHtcbiAgICAgICAgcmV0dXJuICh4IC0gdGhpcy53ICogMC41KSAqIHRoaXMuZ2V0WmYoKSArIHRoaXMuY2VudGVyLnhcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgU2NyZWVuIHkgY29vcmRpbmF0ZSwgaW4gcGl4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEdlbyB5IGNvb3JkaW5hdGUsIGluIG0uXG4gICAgICovXG4gICAgcGl4VG9HZW9ZKHkpIHtcbiAgICAgICAgcmV0dXJuIC0oeSAtIHRoaXMuaCAqIDAuNSkgKiB0aGlzLmdldFpmKCkgKyB0aGlzLmNlbnRlci55XG4gICAgfVxuXG4gICAgLyoqIEdldCB4LHkseiBlbGVtZW50cyBmcm9tIFVSTCBhbmQgYXNzaWduIHRoZW0gdG8gdGhlIHZpZXcgY2VudGVyIGFuZCB6b29tIGxldmVsLiAqL1xuICAgIHNldFZpZXdGcm9tVVJMKCkge1xuICAgICAgICBjb25zdCB4ID0gR2VvQ2FudmFzLmdldFBhcmFtZXRlckJ5TmFtZSgneCcpLFxuICAgICAgICAgICAgeSA9IEdlb0NhbnZhcy5nZXRQYXJhbWV0ZXJCeU5hbWUoJ3knKSxcbiAgICAgICAgICAgIHogPSBHZW9DYW52YXMuZ2V0UGFyYW1ldGVyQnlOYW1lKCd6JylcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q2VudGVyKClcbiAgICAgICAgaWYgKHggIT0gbnVsbCAmJiB4ICE9IHVuZGVmaW5lZCAmJiAhaXNOYU4oK3gpKSBjLnggPSAreFxuICAgICAgICBpZiAoeSAhPSBudWxsICYmIHkgIT0gdW5kZWZpbmVkICYmICFpc05hTigreSkpIGMueSA9ICt5XG4gICAgICAgIGlmICh6ICE9IG51bGwgJiYgeiAhPSB1bmRlZmluZWQgJiYgIWlzTmFOKCt6KSkgdGhpcy5zZXRaZigreilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgYWRkWm9vbVNsaWRlcihpZCwgb3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuICAgICAgICBvcHRzLndpZHRoID0gb3B0cy53aWR0aCB8fCAnMzBweCdcbiAgICAgICAgb3B0cy5oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCAnMzAwcHgnXG5cbiAgICAgICAgLy90aGUgZGl2IGVsZW1lbnRcbiAgICAgICAgY29uc3QgZGl2ID0gc2VsZWN0KCcjJyArIGlkKVxuICAgICAgICBpZiAoZGl2LmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGRpdiBlbGVtZW50IHRvIGJ1aWxkIHpvb20gc2xpZGVyLiBJZDogJyArIGlkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRoID0gdGhpc1xuICAgICAgICAvKiogKi9cbiAgICAgICAgdGhpcy5zbGlkZXIgPSBkaXZcbiAgICAgICAgICAgIC5hcHBlbmQoJ2lucHV0JylcbiAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ3JhbmdlJylcbiAgICAgICAgICAgIC5hdHRyKCdtaW4nLCB0aGlzLmdldFpmRXh0ZW50KClbMF0pXG4gICAgICAgICAgICAuYXR0cignbWF4JywgdGhpcy5nZXRaZkV4dGVudCgpWzFdKVxuICAgICAgICAgICAgLmF0dHIoJ3ZhbHVlJywgdGhpcy5nZXRaZigpKVxuICAgICAgICAgICAgLm9uKCdpbnB1dCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICF0aGlzLnZhbHVlKSByZXR1cm5cbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gK3RoaXMudmFsdWVcbiAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cigndmFsdWUnLCB2KVxuICAgICAgICAgICAgICAgIHRoLnNldFpmKHYpXG4gICAgICAgICAgICAgICAgLy9yZWRyYXdcbiAgICAgICAgICAgICAgICB0aC5yZWRyYXcoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnd2lkdGgnLCBvcHRzLndpZHRoKVxuICAgICAgICAgICAgLnN0eWxlKCdoZWlnaHQnLCBvcHRzLmhlaWdodClcbiAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuNylcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAxKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsIDAuNylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoJy13ZWJraXQtYXBwZWFyYW5jZScsICdzbGlkZXItdmVydGljYWwnKSAvL2ZvciBjaHJvbWVcbiAgICAgICAgICAgIC5zdHlsZSgnd3JpdGluZy1tb2RlJywgJ2J0LWxyJykgLy9mb3IgSUUvZWRnZVxuICAgICAgICAgICAgLmF0dHIoJ29yaWVudCcsICd2ZXJ0aWNhbCcpIC8vZm9yIGZpcmVmb3hcbiAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZCcsICdsaWdodGdyYXknKVxuICAgICAgICAgICAgLnN0eWxlKCdvdXRsaW5lJywgJ25vbmUnKVxuICAgICAgICAgICAgLnN0eWxlKCctd2Via2l0LXRyYW5zaXRpb24nLCAnLjJzJylcbiAgICAgICAgICAgIC5zdHlsZSgndHJhbnNpdGlvbicsICdvcGFjaXR5IC4ycycpXG5cbiAgICAgICAgLy9UT0RPXG4gICAgICAgIC8qc2VsZWN0KFwiLnNsaWRlcjo6LXdlYmtpdC1zbGlkZXItdGh1bWJcIilcbiAgICAgICAgICAgIC5zdHlsZShcIi13ZWJraXQtYXBwZWFyYW5jZVwiLCBcIm5vbmVcIilcbiAgICAgICAgICAgIC5zdHlsZShcImFwcGVhcmFuY2VcIiwgXCJub25lXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCBcIjMwcHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBcIjQwcHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImJhY2tncm91bmRcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKSovXG5cbiAgICAgICAgLypzZWxlY3QoXCJzbGlkZXI6Oi1tb3otcmFuZ2UtdGh1bWJcIilcbiAgICAgICAgICAgIC5zdHlsZShcIi13ZWJraXQtYXBwZWFyYW5jZVwiLCBcIm5vbmVcIilcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIFwiMzBweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIFwiNDBweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZFwiLCBcIiMwNEFBNkRcIilcbiAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIikqL1xuICAgICAgICAvKlxuICAgICAgICAgICAgLnNsaWRlcjo6bXMtdGh1bWIsXG4gICAgICAgIC5zbGlkZXI6Oi1tb3otcmFuZ2UtdGh1bWIge1xuICAgICAgICB9Ki9cblxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIFVSTCBwYXJhbWV0ZXIgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XG4gICAgICovXG4gICAgc3RhdGljIGdldFBhcmFtZXRlckJ5TmFtZShuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtdLywgJ1xcXFxbJykucmVwbGFjZSgvW1xcXV0vLCAnXFxcXF0nKVxuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdbXFxcXD8mXScgKyBuYW1lICsgJz0oW14mI10qKScpLFxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlZ2V4LmV4ZWMobG9jYXRpb24uc2VhcmNoKVxuICAgICAgICByZXR1cm4gIXJlc3VsdHMgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMV0ucmVwbGFjZSgvXFwrL2csICcgJykpXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBjc3YgfSBmcm9tICdkMy1mZXRjaCdcblxuLyoqIEEgbGFiZWwuIFRoZSBuYW1lIGlzIHRoZSB0ZXh0IHRvIHNob3cuICh4LHkpIGFyZSB0aGUgY29vcmRpbmF0ZXMgaW4gdGhlIHNhbWUgQ1JTIGFzIHRoZSBncmlkLlxuICogQHR5cGVkZWYge3tuYW1lOiBzdHJpbmcsIHg6bnVtYmVyLCB5Om51bWJlciB9fSBMYWJlbCAqL1xuXG4vKipcbiAqIEEgKGdlbmVyaWMpIGxheWVyIGZvciBwbGFjZW5hbWUgbGFiZWxzLCB0byBiZSBzaG93biBvbiB0b3Agb2YgdGhlIGdyaWQgbGF5ZXJzLlxuICogVGhlIGlucHV0IGlzIGEgQ1NWIGZpbGUgd2l0aCB0aGUgcG9zaXRpb24gKHgsIHkpIG9mIHRoZSBsYWJlbHMgYW5kIG5hbWUgKyBzb21lIG90aGVyIGluZm8gb24gdGhlIGxhYmVsIGltcG9ydGFuY2UuXG4gKiBJZiB0aGUgbGFiZWwgZGF0YSBpcyBub3QgaW4gdGhlIGV4cGVjdGVkIGZvcm1hdCBvciBpbiB0aGUgc2FtZSBDUlMgYXMgdGhlIGdyaWQsIGl0IGNhbiBiZSBjb3JyZWN0ZWQgd2l0aCB0aGUgXCJwcmVwcm9jZXNzXCIgZnVuY3Rpb24uXG4gKiBUaGUgc2VsZWN0aW9uIG9mIHRoZSBsYWJlbCwgdGhlaXIgc3R5bGUgKGZvbnQsIHdlaWdodCwgZXRjLikgYW5kIGNvbG9yIGNhbiBiZSBzcGVjaWZpZWQgZGVwZW5kaW5nIG9uIHRoZWlyIGltcG9ydGFuY2UgYW5kIHRoZSB6b29tIGxldmVsLlxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIExhYmVsTGF5ZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIG9mIHRoZSBsYWJlbCBkYXRhLCBhcyBDU1YgZmlsZS5cbiAgICAgICAgICogVGhlIGZpbGUgc2hvdWxkIGNvbnRhaW4gdGhlIGluZm9ybWF0aW9uIGZvciBlYWNoIGxhYmVsIHN1Y2ggYXMgdGhlIHRleHQsIHRoZSBwb3NpdGlvbiBhbmQgb3RoZXIgaW5mb3JtYXRpb24gZm9yIHRoZSBkaXNwbGF5IG9mIHRoZSBsYWJlbCBhY2NvcmRpbmcgdG8gdGhlIHpvb20gbGV2ZWwuXG4gICAgICAgICAqIElmIG5lY2Vzc2FyeSwgdGhpcyBkYXRhIGNhbiBiZSByZWZvcm1hdGVkIHdpdGggdGhlICdwcmVwcm9jZXNzJyBwYXJhbWV0ZXIuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMudXJsID0gb3B0cy51cmxcblxuICAgICAgICAvKiogU3BlY2lmeSBpZiBhbmQgaG93IGEgbGFiZWwgc2hvdWxkIGJlIGRyYXduLCBkZXBlbmRpbmcgb24gaXRzIGltcG9ydGFuY2UgYW5kIHRoZSB6b29tIGxldmVsLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oTGFiZWwsbnVtYmVyKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuc3R5bGUgPSBvcHRzLnN0eWxlIHx8ICgoKSA9PiAnYm9sZCAxZW0gQXJpYWwnKVxuXG4gICAgICAgIC8qKiBTcGVjaWZ5IHRoZSBsYWJlbCBjb2xvciwgZGVwZW5kaW5nIG9uIGl0cyBpbXBvcnRhbmNlIGFuZCB0aGUgem9vbSBsZXZlbC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKExhYmVsLG51bWJlcik6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAob3B0cy5kYXJrID8gKCkgPT4gJyNkZGQnIDogKCkgPT4gJyMyMjInKVxuXG4gICAgICAgIC8qKiBTcGVjaWZ5IHRoZSBsYWJlbCBoYWxvIGNvbG9yLCBkZXBlbmRpbmcgb24gaXRzIGltcG9ydGFuY2UgYW5kIHRoZSB6b29tIGxldmVsLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oTGFiZWwsbnVtYmVyKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuaGFsb0NvbG9yID0gb3B0cy5oYWxvQ29sb3IgfHwgKG9wdHMuZGFyayA/ICgpID0+ICcjMDAwMDAwQkInIDogKCkgPT4gJyNGRkZGRkZCQicpXG5cbiAgICAgICAgLyoqIFNwZWNpZnkgdGhlIGxhYmVsIGhhbG8gd2lkdGgsIGRlcGVuZGluZyBvbiBpdHMgaW1wb3J0YW5jZSBhbmQgdGhlIHpvb20gbGV2ZWwuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihMYWJlbCxudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oYWxvV2lkdGggPSBvcHRzLmhhbG9XaWR0aCB8fCAoKCkgPT4gNClcblxuICAgICAgICAvKiogVGhlIGFuY2hvciB3aGVyZSB0byBkcmF3IHRoZSB0ZXh0LCBmcm9tIGxhYmVsIHBvc2l0aW9uLiBTZWUgSFRNTC1jYW52YXMgdGV4dEFsaWduIHByb3BlcnR5LlxuICAgICAgICAgKiBcImxlZnRcIiB8fCBcInJpZ2h0XCIgfHwgXCJjZW50ZXJcIiB8fCBcInN0YXJ0XCIgfHwgXCJlbmRcIlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqL1xuICAgICAgICB0aGlzLnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduIHx8ICdzdGFydCdcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgICAgICB0aGlzLm9mZnNldFBpeCA9IG9wdHMub2Zmc2V0UGl4IHx8IFs1LCA1XVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHByZXByb2Nlc3MgdG8gcnVuIG9uIGVhY2ggbGFiZWwgYWZ0ZXIgbG9hZGluZy5cbiAgICAgICAgICogSXQgY2FuIGJlIHVzZWQgdG8gYXBwbHkgc29tZSBzcGVjaWZpYyB0cmVhdG1lbnQgYmVmb3JlLCBmb3JtYXQgdGhlIGxhYmVsIGRhdGEsIHByb2plY3QgY29vcmRpbmF0ZXMsIGV0Yy5cbiAgICAgICAgICogUmV0dXJuIGZhbHNlIGlmIHRoZSBsYWJlbCBzaG91bGQgbm90IGJlIGtlcHQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihMYWJlbCk6Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5wcmVwcm9jZXNzID0gb3B0cy5wcmVwcm9jZXNzXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48TGFiZWw+IHwgdW5kZWZpbmVkfSAqL1xuICAgICAgICB0aGlzLmxhYmVscyA9IHVuZGVmaW5lZFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnbm90TG9hZGVkJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGxhYmVsIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGNnIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGUgbGF5ZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZHJhdyhjZykge1xuICAgICAgICAvL2xvYWQgbGFiZWxzLCBpZiBub3QgZG9uZSB5ZXQuXG4gICAgICAgIGlmICghdGhpcy5sYWJlbHMpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZChjZy5yZWRyYXcpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vem9vbSBmYWN0b3JcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXG5cbiAgICAgICAgLy90ZXh0IGFsaWduXG4gICAgICAgIGNnLmN0eC50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbiB8fCAnc3RhcnQnXG5cbiAgICAgICAgLy9saW5lIGpvaW4gYW5kIGNhcFxuICAgICAgICBjZy5jdHgubGluZUpvaW4gPSAnYmV2ZWwnIC8vfHwgXCJyb3VuZFwiIHx8IFwibWl0ZXJcIjtcbiAgICAgICAgY2cuY3R4LmxpbmVDYXAgPSAnYnV0dCcgLy98fCBcInJvdW5kXCIgfHwgXCJzcXVhcmVcIjtcblxuICAgICAgICAvL2RyYXcgaW4gcGl4IGNvb3JkaW5hdGVzXG4gICAgICAgIGNnLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgIC8vZHJhdyBsYWJlbHMsIG9uZSBieSBvbmVcbiAgICAgICAgZm9yIChjb25zdCBsYiBvZiB0aGlzLmxhYmVscykge1xuICAgICAgICAgICAgLy9nZXQgbGFiZWwgc3R5bGVcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gdGhpcy5zdHlsZShsYiwgemYpXG4gICAgICAgICAgICBpZiAoIXN0KSBjb250aW51ZVxuICAgICAgICAgICAgY2cuY3R4LmZvbnQgPSBzdFxuXG4gICAgICAgICAgICAvL2NoZWNrIGxhYmVsIHdpdGhpbiB0aGUgdmlldywgdG8gYmUgZHJhd25cbiAgICAgICAgICAgIGlmICghY2cudG9EcmF3KGxiKSkgY29udGludWVcblxuICAgICAgICAgICAgLy9wb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgeFAgPSBjZy5nZW9Ub1BpeFgobGIueCkgKyB0aGlzLm9mZnNldFBpeFswXVxuICAgICAgICAgICAgY29uc3QgeVAgPSBjZy5nZW9Ub1BpeFkobGIueSkgLSB0aGlzLm9mZnNldFBpeFsxXVxuXG4gICAgICAgICAgICAvL2xhYmVsIHN0cm9rZSwgZm9yIHRoZSBoYWxvXG4gICAgICAgICAgICBpZiAodGhpcy5oYWxvQ29sb3IgJiYgdGhpcy5oYWxvV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYyA9IHRoaXMuaGFsb0NvbG9yKGxiLCB6ZilcbiAgICAgICAgICAgICAgICBjb25zdCBodyA9IHRoaXMuaGFsb1dpZHRoKGxiLCB6ZilcbiAgICAgICAgICAgICAgICBpZiAoaGMgJiYgaHcgJiYgaHcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IGhjXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSBod1xuICAgICAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlVGV4dChsYi5uYW1lLCB4UCwgeVApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2xhYmVsIGZpbGxcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvcihsYiwgemYpXG4gICAgICAgICAgICAgICAgaWYgKGNvbCkge1xuICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsVGV4dChsYi5uYW1lLCB4UCwgeVApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBkYXRhIGZvciBsYWJlbHMsIGZyb20gVVJMIHRoaXMudXJsXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IGNhbGxiYWNrXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBsb2FkKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy51cmwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgbG9hZGluZyBsYWJlbHM6IE5vIFVSTCBzcGVjaWZpZWQuICcgKyB0aGlzLnVybClcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdmYWlsZWQnXG4gICAgICAgICAgICB0aGlzLmxhYmVscyA9IFtdXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgaWYgZGF0YSBhbHJlYWR5IGxvYWRlZFxuICAgICAgICBpZiAodGhpcy5sb2FkaW5nU3RhdHVzICE9ICdub3RMb2FkZWQnKSByZXR1cm5cblxuICAgICAgICAvL2xvYWQgZGF0YVxuICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnbG9hZGluZydcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHsgQXJyYXkuPExhYmVsPiB9ICovXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY3N2KHRoaXMudXJsKVxuXG4gICAgICAgICAgICAvL3ByZXByb2Nlc3MvZmlsdGVyXG4gICAgICAgICAgICBpZiAodGhpcy5wcmVwcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLnByZXByb2Nlc3MoYylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gZmFsc2UpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzLnB1c2goYylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vc3RvcmUgbGFiZWxzXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBkYXRhXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdsb2FkZWQnXG5cbiAgICAgICAgICAgIC8vcmVkcmF3XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKClcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgbG9hZGluZyBsYWJlbHMgZnJvbSAnICsgdGhpcy51cmwpXG4gICAgICAgICAgICB0aGlzLmxhYmVscyA9IFtdXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnZmFpbGVkJ1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEEgbGF5ZXIsIHdoaWNoIHNwZWNpZmllcyBhIGRhdGFzZXQgdG8gYmUgc2hvd24gd2l0aCBzcGVjaWZpZWQgc3R5bGVzLlxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIExheWVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRGF0YXNldFwiKS5EYXRhc2V0fSBkYXRhc2V0IFRoZSBtdWx0aSByZXNvbHV0aW9uIGRhdGFzZXQgdG8gc2hvdy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuL1N0eWxlXCIpLlN0eWxlPn0gc3R5bGVzIFRoZSBzdHlsZXMsIG9yZGVyZWQgaW4gZHJhd2luZyBvcmRlci5cbiAgICAgKiBAcGFyYW0ge3t2aXNpYmxlPzpib29sZWFuLGFscGhhPzpudW1iZXIsYmxlbmRPcGVyYXRpb24/Okdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbixtaW5ab29tPzpudW1iZXIsbWF4Wm9vbT86bnVtYmVyLHBpeE5iPzpudW1iZXIsY2VsbEluZm9IVE1MPzpmdW5jdGlvbihpbXBvcnQoXCIuL0RhdGFzZXRcIikuQ2VsbCk6c3RyaW5nfX0gb3B0c1xuICAgICAqICAgICAgbWluWm9vbTogVGhlIG1pbmltdW0gem9vbSBsZXZlbCB3aGVuIHRvIHNob3cgdGhlIGxheWVyLiBtYXhab29tOiBUaGUgbWF4aW11bSB6b29tIGxldmVsIHdoZW4gdG8gc2hvdyB0aGUgbGF5ZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhc2V0LCBzdHlsZXMsIG9wdHMgPSB7fSkge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9EYXRhc2V0XCIpLkRhdGFzZXR9ICovXG4gICAgICAgIHRoaXMuZGF0YXNldCA9IGRhdGFzZXRcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48aW1wb3J0KFwiLi9TdHlsZVwiKS5TdHlsZT59ICovXG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzXG5cbiAgICAgICAgLyoqIEFuIGF0dHJpYnV0ZSB0byBzcGVjaWZ5IGlmIGEgbGF5ZXIgc2hvdWxkIGJlIGRyYXduIG9yIG5vdFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy52aXNpYmxlID0gb3B0cy52aXNpYmxlID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgYWxwaGEgKHRyYW5zcGFyZW5jeS9vcGFjaXR5KSwgYmV0d2VlbiAwLjAgKGZ1bGx5IHRyYW5zcGFyZW50KSBhbmQgMS4wIChmdWxseSBvcGFxdWUpLlxuICAgICAgICAgKiAgVGhlIGZ1bmN0aW9uIHBhcmFtZXRlciBpcyB0aGUgem9vbSBmYWN0b3IuXG4gICAgICAgICAqIChzZWUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiBnbG9iYWxBbHBoYSBwcm9wZXJ0eSlcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgdGhpcy5hbHBoYSA9IG9wdHMuYWxwaGFcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGJsZW5kIG9wZXJhdGlvbi4gVGhlIGZ1bmN0aW9uIHBhcmFtZXRlciBpcyB0aGUgem9vbSBmYWN0b3IuXG4gICAgICAgICAqIChzZWUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gcHJvcGVydHkpXG4gICAgICAgICAqIEB0eXBlIHtHbG9iYWxDb21wb3NpdGVPcGVyYXRpb259ICovXG4gICAgICAgIHRoaXMuYmxlbmRPcGVyYXRpb24gPSBvcHRzLmJsZW5kT3BlcmF0aW9uIHx8ICh6ZiA9PiBcInNvdXJjZS1vdmVyXCIpXG5cbiAgICAgICAgLyoqIFRoZSBtaW5pbXVtIHpvb20gZmFjdG9yOiBCZWxvdyB0aGlzIGxldmVsLCB0aGUgbGF5ZXIgaXMgbm90IHNob3duLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm1pblpvb20gPSBvcHRzLm1pblpvb20gfHwgMFxuXG4gICAgICAgIC8qKiBUaGUgbWF4aW11bSB6b29tIGZhY3RvcjogQWJvdmUgdGhpcyBsZXZlbCwgdGhlIGxheWVyIGlzIG5vdCBzaG93bi5cbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5tYXhab29tID0gb3B0cy5tYXhab29tIHx8IEluZmluaXR5XG5cbiAgICAgICAgLy9lbnN1cmUgYWNjZXB0YWJsZSB2YWx1ZXMgZm9yIHRoZSB6b29tIGxpbWl0cy5cbiAgICAgICAgaWYgKHRoaXMubWluWm9vbSA+PSB0aGlzLm1heFpvb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgem9vbSBsaW1pdHMgZm9yIGxheWVyLiBab29tIG1pbiBzaG91bGQgYmUgc21hbGxlciB0aGFuIHpvb20gbWF4LicpXG5cbiAgICAgICAgLyoqIFVuaXQ6IG51bWJlciBvZiBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5waXhOYiA9IG9wdHMucGl4TmIgfHwgM1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJuaW5nIGNlbGwgaW5mb3JtYXRpb24gYXMgSFRNTC5cbiAgICAgICAgICogVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCBmb3IgdG9vbHRpcCBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4vRGF0YXNldFwiKS5DZWxsLCBudW1iZXIpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jZWxsSW5mb0hUTUwgPSBvcHRzLmNlbGxJbmZvSFRNTCB8fCBMYXllci5kZWZhdWx0Q2VsbEluZm9IVE1MXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByZWxldmFudCBkYXRhc2V0IGNvbXBvbmVudCBmb3IgYSBzcGVjaWZpZWQgem9vbSBmYWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gemZcbiAgICAgKiBAcmV0dXJucyB7aW1wb3J0KFwiLi9EYXRhc2V0Q29tcG9uZW50XCIpLkRhdGFzZXRDb21wb25lbnR8dW5kZWZpbmVkfVxuICAgICAqICovXG4gICAgZ2V0RGF0YXNldENvbXBvbmVudCh6Zikge1xuICAgICAgICBpZiAoemYgPCB0aGlzLm1pblpvb20gfHwgemYgPiB0aGlzLm1heFpvb20pIHJldHVyblxuXG4gICAgICAgIC8vc3BlY2lhbCBjYXNlIHdoaXRoIHNpbmdsZSBjb21wb25lbnQgZGF0YXNldFxuICAgICAgICBpZiAodGhpcy5kYXRhc2V0LmRhdGFzZXRDb21wb25lbnRzLmxlbmd0aCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhc2V0LmRhdGFzZXRDb21wb25lbnRzWzBdXG5cbiAgICAgICAgY29uc3QgcnMgPSB0aGlzLmRhdGFzZXQucmVzb2x1dGlvbnNcbiAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgIGxldCB6ID0gcnNbaV0gLyB0aGlzLnBpeE5iXG4gICAgICAgIHdoaWxlICh6IDwgemYgJiYgaSA8IHJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICB6ID0gcnNbaV0gLyB0aGlzLnBpeE5iXG4gICAgICAgIH1cbiAgICAgICAgLy9pZiAoaSA9PSAwKSByZXR1cm4gdGhpcy5kYXRhc2V0LmRhdGFzZXRDb21wb25lbnRzWzBdO1xuICAgICAgICAvL3JldHVybiB0aGlzLmRhdGFzZXQuZGF0YXNldENvbXBvbmVudHNbaSAtIDFdO1xuICAgICAgICBpZiAoaSA9PSBycy5sZW5ndGgpIHJldHVybiB0aGlzLmRhdGFzZXQuZGF0YXNldENvbXBvbmVudHNbcnMubGVuZ3RoIC0gMV1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YXNldC5kYXRhc2V0Q29tcG9uZW50c1tpXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHJldHVybmluZyBjZWxsIGluZm9ybWF0aW9uIGFzIEhUTUwuXG4gICAgICogVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCBmb3IgdG9vbHRpcCBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9EYXRhc2V0XCIpLkNlbGx9IGNlbGxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZWZhdWx0Q2VsbEluZm9IVE1MKGNlbGwpIHtcbiAgICAgICAgY29uc3QgYnVmID0gW11cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY2VsbCkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICd4JykgY29udGludWVcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICd5JykgY29udGludWVcbiAgICAgICAgICAgIGJ1Zi5wdXNoKCc8Yj4nLCBrZXksICc8L2I+JywgJyA6ICcsIGNlbGxba2V5XSwgJzxicj4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWYuam9pbignJylcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcblxuLyoqXG4gKiBBIGxlZ2VuZCBjb250YWluZXIuXG4gKlxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgTGVnZW5kIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5pZCA9IG9wdHMuaWRcblxuICAgICAgICAvL1RPRE8gc3RvcCB1c2luZyBpdC4gVXNlIHN0eWxlIG1ldGhvZCBiZWxvdyBpbnN0ZWFkLlxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBAZGVwcmVjYXRlZCAqL1xuICAgICAgICB0aGlzLnRvcCA9IG9wdHMudG9wXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBAZGVwcmVjYXRlZCAqL1xuICAgICAgICB0aGlzLmJvdHRvbSA9IG9wdHMuYm90dG9tXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBAZGVwcmVjYXRlZCAqL1xuICAgICAgICB0aGlzLmxlZnQgPSBvcHRzLmxlZnRcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IEBkZXByZWNhdGVkICovXG4gICAgICAgIHRoaXMucmlnaHQgPSBvcHRzLnJpZ2h0XG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBAZGVwcmVjYXRlZCAqL1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBvcHRzLmJhY2tncm91bmQgfHwgJ25vbmUnXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBAZGVwcmVjYXRlZCAqL1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSBvcHRzLnBhZGRpbmcgfHwgJzVweCdcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXG4gICAgICAgIHRoaXMuYm9yZGVyID0gb3B0cy5ib3JkZXIgfHwgJzBweCdcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXG4gICAgICAgIHRoaXNbJ2JvcmRlci1yYWRpdXMnXSA9IG9wdHNbJ2JvcmRlci1yYWRpdXMnXSB8fCAnbm9uZSdcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXG4gICAgICAgIHRoaXNbJ2JveC1zaGFkb3cnXSA9IG9wdHNbJ2JveC1zaGFkb3cnXSB8fCAnbm9uZSdcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXG4gICAgICAgIHRoaXNbJ2ZvbnQtZmFtaWx5J10gPSBvcHRzWydmb250LWZhbWlseSddIHx8ICdIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJ1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdHMud2lkdGhcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0cy5oZWlnaHRcblxuICAgICAgICAvL3RoZSBkaXYgZWxlbWVudFxuICAgICAgICBpZiAodGhpcy5pZCkgdGhpcy5kaXYgPSBzZWxlY3QoJyMnICsgdGhpcy5pZClcblxuICAgICAgICBpZiAoIXRoaXMuZGl2IHx8IHRoaXMuZGl2LmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2ID0gc2VsZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgICAgICAgICAgaWYgKHRoaXMuaWQpIHRoaXMuZGl2LmF0dHIoJ2lkJywgdGhpcy5pZClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2V0IHN0eWxlXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKCdiYWNrZ3JvdW5kJywgdGhpcy5iYWNrZ3JvdW5kKVxuICAgICAgICB0aGlzLmRpdi5zdHlsZSgncGFkZGluZycsIHRoaXMucGFkZGluZylcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUoJ2JvcmRlcicsIHRoaXMuYm9yZGVyKVxuICAgICAgICB0aGlzLmRpdi5zdHlsZSgnYm9yZGVyLXJhZGl1cycsIHRoaXNbJ2JvcmRlci1yYWRpdXMnXSlcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUoJ2JveC1zaGFkb3cnLCB0aGlzWydib3gtc2hhZG93J10pXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKCdmb250LWZhbWlseScsIHRoaXNbJ2ZvbnQtZmFtaWx5J10pXG5cbiAgICAgICAgaWYgKHRoaXMud2lkdGgpIHRoaXMuZGl2LnN0eWxlKCd3aWR0aCcsIHRoaXMud2lkdGgpXG4gICAgICAgIGlmICh0aGlzLmhlaWdodCkgdGhpcy5kaXYuc3R5bGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgc3R5bGUgdG8gdGhlIGxlZ2VuZCBkaXYuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0eWxlKGssIHYpIHtcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUoaywgdilcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHVwZGF0ZShvcHRzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xlZ2VuZCB1cGRhdGUgbm90IGltcGxlbWVudGVkIHlldC4nKVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsganNvbiB9IGZyb20gJ2QzLWZldGNoJ1xuXG4vKipcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIExpbmVMYXllciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMudXJsID0gb3B0cy51cmxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBwcmVwcm9jZXNzIHRvIHJ1biBvbiBlYWNoIGZlYXR1cmUgYWZ0ZXIgbG9hZGluZy5cbiAgICAgICAgICogSXQgY2FuIGJlIHVzZWQgdG8gYXBwbHkgc29tZSBzcGVjaWZpYyB0cmVhdG1lbnQgYmVmb3JlLCBmb3JtYXQgdGhlIGxhYmVsIGRhdGEsIHByb2plY3QgY29vcmRpbmF0ZXMsIGV0Yy5cbiAgICAgICAgICogUmV0dXJuIGZhbHNlIGlmIHRoZSBsYWJlbCBzaG91bGQgbm90IGJlIGtlcHQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihvYmplY3QpOmJvb2xlYW59ICovXG4gICAgICAgIHRoaXMucHJlcHJvY2VzcyA9IG9wdHMucHJlcHJvY2Vzc1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24ob2JqZWN0LG51bWJlcik6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKGYsIHpmKSA9PiAnZ3JheScpXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24ob2JqZWN0LG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKGYsIHpmKSA9PiAyKVxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG9iamVjdCxudW1iZXIpOkFycmF5LjxudW1iZXI+fHVuZGVmaW5lZH0gKi9cbiAgICAgICAgdGhpcy5saW5lRGFzaCA9IG9wdHMubGluZURhc2ggfHwgKChmLCB6ZikgPT4gdW5kZWZpbmVkKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG9iamVjdD4gfCB1bmRlZmluZWR9ICovXG4gICAgICAgIHRoaXMuZnMgPSB1bmRlZmluZWRcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ25vdExvYWRlZCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoZSBsYXllci5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2cgVGhlIGNhbnZhcyB3aGVyZSB0byBkcmF3IHRoZSBsYXllci5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBkcmF3KGNnKSB7XG4gICAgICAgIC8vbG9hZCBkYXRhLCBpZiBub3QgZG9uZSB5ZXQuXG4gICAgICAgIGlmICghdGhpcy5mcykge1xuICAgICAgICAgICAgdGhpcy5sb2FkKGNnLnJlZHJhdylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy9UT0RPIHNvcnQgbGluZXMgYnkgd2lkdGggP1xuXG4gICAgICAgIC8vem9vbSBmYWN0b3JcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXG5cbiAgICAgICAgLy9kcmF3IGluIGdlbyBjb29yZGluYXRlc1xuICAgICAgICBjZy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmZzKSB7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIGlmIChjcy5sZW5ndGggPCAyKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL3NldCBjb2xvclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvcihmLCB6ZilcbiAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PSAnbm9uZScpIGNvbnRpbnVlXG4gICAgICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xcblxuICAgICAgICAgICAgLy9zZXQgbGluZXdpZHRoXG4gICAgICAgICAgICBjb25zdCB3UCA9IHRoaXMud2lkdGgoZiwgemYpXG4gICAgICAgICAgICBpZiAoIXdQIHx8IHdQIDwgMCkgY29udGludWVcbiAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3UCAqIHpmXG5cbiAgICAgICAgICAgIC8vc2V0IGxpbmUgZGFzaFxuICAgICAgICAgICAgY29uc3QgbGRQID0gdGhpcy5saW5lRGFzaChmLCB6ZilcbiAgICAgICAgICAgIGlmIChsZFApIGNnLmN0eC5zZXRMaW5lRGFzaChsZFApXG5cbiAgICAgICAgICAgIC8vZHJhdyBsaW5lXG4gICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oY3NbMF1bMF0sIGNzWzBdWzFdKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjcy5sZW5ndGg7IGkrKykgY2cuY3R4LmxpbmVUbyhjc1tpXVswXSwgY3NbaV1bMV0pXG4gICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLi4uXG4gICAgICAgIGNnLmN0eC5zZXRMaW5lRGFzaChbXSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGRhdGEgZm9yIGxhYmVscywgZnJvbSBVUkwgdGhpcy51cmxcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gY2FsbGJhY2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGxvYWQoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLnVybCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBsb2FkaW5nIGJvdW5kYXJpZXM6IE5vIFVSTCBzcGVjaWZpZWQuICcgKyB0aGlzLnVybClcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdmYWlsZWQnXG4gICAgICAgICAgICB0aGlzLmxhYmVscyA9IFtdXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgaWYgZGF0YSBhbHJlYWR5IGxvYWRlZFxuICAgICAgICBpZiAodGhpcy5sb2FkaW5nU3RhdHVzICE9ICdub3RMb2FkZWQnKSByZXR1cm5cblxuICAgICAgICAvL2xvYWQgZGF0YVxuICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnbG9hZGluZydcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YV8gPSBhd2FpdCBqc29uKHRoaXMudXJsKVxuXG4gICAgICAgICAgICAvKiogQHR5cGUgeyBBcnJheS48b2JqZWN0PiB9ICovXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZGF0YV8uZmVhdHVyZXNcblxuICAgICAgICAgICAgLy9wcmVwcm9jZXNzL2ZpbHRlclxuICAgICAgICAgICAgaWYgKHRoaXMucHJlcHJvY2Vzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZnMgPSBbXVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLnByZXByb2Nlc3MoYylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gZmFsc2UpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnMucHVzaChjKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9zdG9yZSBsYWJlbHNcbiAgICAgICAgICAgICAgICB0aGlzLmZzID0gZGF0YVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnbG9hZGVkJ1xuXG4gICAgICAgICAgICAvL3JlZHJhd1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIGxvYWRpbmcgYm91bmRhcmllcyBmcm9tICcgKyB0aGlzLnVybClcbiAgICAgICAgICAgIHRoaXMuZnMgPSBbXVxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBTdGF0aXN0aWNzIG9mIGEgc2V0IG9mIHZhbHVlc1xuICogQHR5cGVkZWYge3ttaW46bnVtYmVyLG1heDpudW1iZXJ9fSBTdGF0ICovXG5cbi8qKiBAdHlwZWRlZiB7XCJzcXVhcmVcInxcImNpcmNsZVwifFwiZGlhbW9uZFwifFwiZG9udXRcInxcIm5vbmVcIn0gU2hhcGUgKi9cblxuLyoqXG4gKiBBIHN0eWxlLCB0byBzaG93IGEgZ3JpZCBkYXRhc2V0LlxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFN0eWxlIHtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge3tmaWx0ZXI/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCk6Ym9vbGVhbixvZmZzZXQ/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCxudW1iZXIsbnVtYmVyKTp7ZHg6bnVtYmVyLGR5Om51bWJlcn0sdmlzaWJsZT86Ym9vbGVhbixhbHBoYT86ZnVuY3Rpb24obnVtYmVyKTpudW1iZXIsYmxlbmRPcGVyYXRpb24/OmZ1bmN0aW9uKG51bWJlcik6R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLG1pblpvb20/Om51bWJlcixtYXhab29tPzpudW1iZXIsZHJhd0Z1bj86ZnVuY3Rpb259fSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBBIGZpbHRlciBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgY2VsbCBsaXN0LCB0byBmaWx0ZXIgb3V0IHNvbWUgY2VsbHMgbm90IHRvIGJlIGRyYXduIChzdWNoIGFzIGZvciBleGFtcGxlIHRoZSBjZWxscyB3aXRoIHZhbHVlPTApLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwpOmJvb2xlYW59ICovXG4gICAgICAgIHRoaXMuZmlsdGVyID0gb3B0cy5maWx0ZXIgfHwgKCgpID0+IHRydWUpXG5cbiAgICAgICAgLyoqIEFuIG9mZnNldC4gVGhpcyBpcyB0byBhbHRlciB0aGUgcG9zaXRpb24gb2YgYWxsIHN5bWJvbHMgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIEluIGdlb2dyYXBoaWNhbCB1bml0LlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwsbnVtYmVyLG51bWJlcik6e2R4Om51bWJlcixkeTpudW1iZXJ9fSAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9wdHMub2Zmc2V0IHx8ICgoYywgciwgemYpID0+ICh7IGR4OiAwLCBkeTogMCB9KSlcblxuICAgICAgICAvKiogQW4gYXR0cmlidXRlIHRvIHNwZWNpZnkgaWYgYSBzdHlsZSBzaG91bGQgYmUgZHJhd24gb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnZpc2libGUgPSBvcHRzLnZpc2libGUgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhbHBoYSAodHJhbnNwYXJlbmN5L29wYWNpdHkpLCBiZXR3ZWVuIDAuMCAoZnVsbHkgdHJhbnNwYXJlbnQpIGFuZCAxLjAgKGZ1bGx5IG9wYXF1ZSkuXG4gICAgICAgICAqICBUaGUgZnVuY3Rpb24gcGFyYW1ldGVyIGlzIHRoZSB6b29tIGZhY3Rvci5cbiAgICAgICAgICogKHNlZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ6IGdsb2JhbEFscGhhIHByb3BlcnR5KVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICB0aGlzLmFscGhhID0gb3B0cy5hbHBoYVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgYmxlbmQgb3BlcmF0aW9uLiBUaGUgZnVuY3Rpb24gcGFyYW1ldGVyIGlzIHRoZSB6b29tIGZhY3Rvci5cbiAgICAgICAgICogKHNlZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ6IGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBwcm9wZXJ0eSlcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcik6R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9ufSAqL1xuICAgICAgICB0aGlzLmJsZW5kT3BlcmF0aW9uID0gb3B0cy5ibGVuZE9wZXJhdGlvbiB8fCAoemYgPT4gXCJzb3VyY2Utb3ZlclwiKVxuXG4gICAgICAgIC8qKiBUaGUgbWluaW11bSB6b29tIGZhY3RvcjogQmVsb3cgdGhpcyBsZXZlbCwgdGhlIGxheWVyIGlzIG5vdCBzaG93bi5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5taW5ab29tID0gb3B0cy5taW5ab29tIHx8IDBcblxuICAgICAgICAvKiogVGhlIG1heGltdW0gem9vbSBmYWN0b3I6IEFib3ZlIHRoaXMgbGV2ZWwsIHRoZSBsYXllciBpcyBub3Qgc2hvd24uXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMubWF4Wm9vbSA9IG9wdHMubWF4Wm9vbSB8fCBJbmZpbml0eVxuXG4gICAgICAgIC8qKiBBIGRyYXcgZnVuY3Rpb24gZm9yIHRoZSBzdHlsZS5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9ufSAqL1xuICAgICAgICB0aGlzLmRyYXdGdW4gPSBvcHRzLmRyYXdGdW5cblxuICAgICAgICAvL2Vuc3VyZSBhY2NlcHRhYmxlIHZhbHVlcyBmb3IgdGhlIHpvb20gbGltaXRzLlxuICAgICAgICBpZiAodGhpcy5taW5ab29tID49IHRoaXMubWF4Wm9vbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB6b29tIGxpbWl0cyBmb3IgbGF5ZXIuIFpvb20gbWluIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gem9vbSBtYXguJylcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4vTGVnZW5kXCIpLkxlZ2VuZD59ICovXG4gICAgICAgIHRoaXMubGVnZW5kcyA9IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBjZWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbD59IGNlbGxzIFRoZSBjZWxscyB0byBkcmF3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZWlyIHJlc29sdXRpb24gKGluIGdlb2dyYXBoaWMgdW5pdClcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2cgVGhlIGNhbnZhcyB3aGVyZSB0byBkcmF3IHRoZW0uXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgZHJhdyhjZWxscywgcmVzb2x1dGlvbiwgY2cpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhd0Z1bikgdGhpcy5kcmF3RnVuKGNlbGxzLCByZXNvbHV0aW9uLCBjZylcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBkcmF3IG5vdCBpbXBsZW1lbnRlZC4nKVxuICAgIH1cblxuICAgIC8vZ2V0dGVycyBhbmQgc2V0dGVyc1xuXG4gICAgLyoqIEByZXR1cm5zIHtmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwsbnVtYmVyLG51bWJlcik6e2R4Om51bWJlcixkeTpudW1iZXJ9fSAqL1xuICAgIGdldE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0XG4gICAgfVxuICAgIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCxudW1iZXIsbnVtYmVyKTp7ZHg6bnVtYmVyLGR5Om51bWJlcn19IHZhbCBAcmV0dXJucyB7dGhpc30gKi9cbiAgICBzZXRPZmZzZXQodmFsKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gdmFsXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqIEhpZGUgYWxsIGxlZ2VuZCBlbGVtZW50cyBvZiB0aGUgc3R5bGUsIGlmIGFueVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICogQHJldHVybnMge3RoaXN9ICovXG4gICAgdXBkYXRlTGVnZW5kcyhvcHRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbGcgb2YgdGhpcy5sZWdlbmRzKSBsZy51cGRhdGUob3B0cylcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHNvbWUgc3RhdGlzdGljcyBvbiBhIHZhbHVlIG9mIHNvbWUgY2VsbHMuXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIGRlZmluZSBob3cgdG8gZHJhdyBzcGVjaWZpY2FsbHkgdGhlIGNlbGxzIHdpdGhpbiB0aGUgdmlldy5cbiAgICAgKiBUT0RPOiBjb21wdXRlIG1lZGlhbiA/XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGw+fSBjZWxsc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsKTpudW1iZXJ9IHZhbEZ1blxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWdub3JlWmVyb3NcbiAgICAgKiBAcmV0dXJucyB7U3RhdCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U3RhdGlzdGljcyhjZWxscywgdmFsRnVuLCBpZ25vcmVaZXJvcykge1xuICAgICAgICBpZiAoIWNlbGxzIHx8IGNlbGxzLmxlbmd0aCA9PSAwKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGxldCBtaW4gPSBJbmZpbml0eVxuICAgICAgICBsZXQgbWF4ID0gLUluZmluaXR5XG4gICAgICAgIC8vbGV0IHN1bSA9IDBcbiAgICAgICAgLy9sZXQgbmIgPSAwXG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiBjZWxscykge1xuICAgICAgICAgICAgY29uc3QgdiA9ICt2YWxGdW4oY2VsbClcbiAgICAgICAgICAgIGlmIChpZ25vcmVaZXJvcyAmJiAhdikgY29udGludWVcbiAgICAgICAgICAgIGlmICh2IDwgbWluKSBtaW4gPSB2XG4gICAgICAgICAgICBpZiAodiA+IG1heCkgbWF4ID0gdlxuICAgICAgICAgICAgLy9zdW0gKz0gdlxuICAgICAgICAgICAgLy9uYisrXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWluOiBtaW4sIG1heDogbWF4IH1cbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcbi8vaW1wb3J0IHsgdHJhbnNpdGlvbiB9IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XG5cbi8qKlxuICogQSBnZW5lcmljIGNsYXNzIHRvIG1ha2UgYSB0b29sdGlwLlxuICogSXQgaXMgYSBkaXYgZWxlbWVudCwgd2hpY2ggY2FuIGJlIG1vdmVkIHVuZGVyIHRoZSBtb3VzZSBwb2ludGVyIGFuZCBmaWxsZWQgd2l0aCBzb21lIGluZm9ybWF0aW9uIGluIGh0bWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBUb29sdGlwIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5kaXYgPSBvcHRzLmRpdiB8fCAndG9vbHRpcF9ldXJvc3RhdCdcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMubWF4V2lkdGggPSBvcHRzLm1heFdpZHRoIHx8ICcyMGVtJ1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IG9wdHMuZm9udFNpemUgfHwgJzEuMmVtJ1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gb3B0cy5iYWNrZ3JvdW5kIHx8ICd3aGl0ZSdcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMucGFkZGluZyA9IG9wdHMucGFkZGluZyB8fCAnNXB4J1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5ib3JkZXIgPSBvcHRzLmJvcmRlciB8fCAnMHB4J1xuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpc1snYm9yZGVyLXJhZGl1cyddID0gb3B0c1snYm9yZGVyLXJhZGl1cyddIHx8ICcwcHgnXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzWydib3gtc2hhZG93J10gPSBvcHRzWydib3gtc2hhZG93J10gfHwgJzVweCA1cHggNXB4IGdyZXknXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzWydmb250LWZhbWlseSddID0gb3B0c1snZm9udC1mYW1pbHknXSB8fCAnSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZidcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gPSBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbiB8fCAxMDBcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueE9mZnNldCA9IG9wdHMueE9mZnNldCB8fCAzMFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy55T2Zmc2V0ID0gb3B0cy55T2Zmc2V0IHx8IDIwXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAvLyBlLmcuIHRvIHByZXZlbnQgbW91c2UgY3Vyc29yIGNvdmVyaW5nIGNlbGwgYmVpbmcgaGlnaGxpZ2h0ZWRcbiAgICAgICAgdGhpcy55TW91c2VPZmZzZXQgPSBvcHRzLnlNb3VzZU9mZnNldCB8fCAwXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnhNb3VzZU9mZnNldCA9IG9wdHMueE1vdXNlT2Zmc2V0IHx8IDBcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gb3B0cy5wYXJlbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHlcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAdHlwZSB7aW1wb3J0KFwiZDMtc2VsZWN0aW9uXCIpLlNlbGVjdGlvbn0gKi9cbiAgICAgICAgdGhpcy50b29sdGlwID0gc2VsZWN0KCcjJyArIHRoaXMuZGl2KVxuXG4gICAgICAgIGlmICh0aGlzLnRvb2x0aXAuZW1wdHkoKSkge1xuICAgICAgICAgICAgLy9jcmVhdGUgdG9vbHRpcCBET00gbm9kZVxuICAgICAgICAgICAgLy8gdGhpcy50b29sdGlwID0gc2VsZWN0KFxuICAgICAgICAgICAgLy8gICAgICcjJyArIHRoaXMucGFyZW50RWxlbWVudC5pZCAmJiB0aGlzLnBhcmVudEVsZW1lbnQuaWQgIT0gJydcbiAgICAgICAgICAgIC8vICAgICAgICAgPyAnIycgKyB0aGlzLnBhcmVudEVsZW1lbnQuaWRcbiAgICAgICAgICAgIC8vICAgICAgICAgOiAnYm9keSdcbiAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcCA9IHNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JykuYXR0cignaWQnLCB0aGlzLmRpdilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaW5pdGlhbGlzZVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ21heC13aWR0aCcsIHRoaXMubWF4V2lkdGgpXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnb3ZlcmZsb3cnLCAnaGlkZGVuJylcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmZvbnRTaXplKVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2JhY2tncm91bmQnLCB0aGlzLmJhY2tncm91bmQpXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgncGFkZGluZycsIHRoaXMucGFkZGluZylcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdib3JkZXInLCB0aGlzLmJvcmRlcilcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdib3JkZXItcmFkaXVzJywgdGhpc1snYm9yZGVyLXJhZGl1cyddKVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2JveC1zaGFkb3cnLCB0aGlzWydib3gtc2hhZG93J10pXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnZm9udC1mYW1pbHknLCB0aGlzWydmb250LWZhbWlseSddKVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJylcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdvcGFjaXR5JywgJzAnKVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ3RleHQtd3JhcCcsICdub3dyYXAnKVxuXG4gICAgICAgIC8vIGFyaWEtbGFiZWxzICh0aGFua3MgdG8gd2FobGF0bGFzKVxuICAgICAgICB0aGlzLnRvb2x0aXAuYXR0cigncm9sZScsICd0b29sdGlwJykuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpXG4gICAgfVxuXG4gICAgLyoqIFNob3cgdGhlIHRvb2x0aXAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMudG9vbHRpcC50cmFuc2l0aW9uKCkuZHVyYXRpb24odGhpcy50cmFuc2l0aW9uRHVyYXRpb24pLnN0eWxlKCdvcGFjaXR5JywgMSlcbiAgICB9XG5cbiAgICAvKiogSGlkZSB0aGUgdG9vbHRpcCAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy50b29sdGlwLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25EdXJhdGlvbikuc3R5bGUoJ29wYWNpdHknLCAwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAqL1xuICAgIGh0bWwoaHRtbCkge1xuICAgICAgICB0aGlzLnRvb2x0aXAuaHRtbChodG1sKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAgYXQgdGhlIG1vdXNlIGV2ZW50IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbihldmVudCkge1xuICAgICAgICBsZXQgcGFyZW50UmVjdCA9IHRoaXMucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICAgIGxldCB4ID0gZXZlbnQucGFnZVggKyB0aGlzLnhPZmZzZXRcbiAgICAgICAgbGV0IHkgPSBldmVudC5wYWdlWSAtIHRoaXMueU9mZnNldFxuXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnbGVmdCcsIHggKyAncHgnKS5zdHlsZSgndG9wJywgeSArICdweCcpXG5cbiAgICAgICAgdGhpcy5lbnN1cmVUb29sdGlwSW5zaWRlQ29udGFpbmVyKGV2ZW50LCBwYXJlbnRSZWN0KVxuICAgIH1cblxuICAgIC8qXG5cdG15Lm1vdXNlb3ZlciA9IGZ1bmN0aW9uIChldmVudCwgaHRtbCkge1xuXHRcdGlmIChodG1sKSBteS5odG1sKGh0bWwpO1xuXHRcdG15LnNldFBvc2l0aW9uKGV2ZW50KTtcblx0XHRteS5zaG93KClcblx0XHQvL3RoaXMuZW5zdXJlVG9vbHRpcEluc2lkZUNvbnRhaW5lcigpO1xuXHR9O1xuXHRcblx0bXkubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0bXkuc2V0UG9zaXRpb24oZXZlbnQpO1xuXHRcdC8vdGhpcy5lbnN1cmVUb29sdGlwSW5zaWRlQ29udGFpbmVyKCk7XG5cdH07XG5cdFxuXHRteS5tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcblx0XHRteS5oaWRlKCk7XG5cdH07Ki9cblxuICAgIHN0eWxlKGssIHYpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIHRoaXMudG9vbHRpcC5zdHlsZShrKVxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoaywgdilcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBhdHRyKGssIHYpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIHRoaXMudG9vbHRpcC5hdHRyKGspXG4gICAgICAgIHRoaXMudG9vbHRpcC5hdHRyKGssIHYpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGVuc3VyZVRvb2x0aXBJbnNpZGVDb250YWluZXJcbiAgICAgKiBAZGVzY3JpcHRpb24gUHJldmVudHMgdGhlIHRvb2x0aXAgZnJvbSBvdmVyZmxvd2luZyBvdXQgb2YgdGhlIEFwcCBjb250YWluZXIgKGVuc3VyZXMgdGhhdCB0aGUgdG9vbHRpcCBpcyBpbnNpZGUgdGhlIGdyaWR2aXogY29udGFpbmVyKVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0RPTVJlY3R9IHBhcmVudFJlY3RcbiAgICAgKi9cbiAgICBlbnN1cmVUb29sdGlwSW5zaWRlQ29udGFpbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBwYXJlbnRSZWN0KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy50b29sdGlwLm5vZGUoKVxuICAgICAgICBsZXQgcGFyZW50V2lkdGggPSBwYXJlbnRSZWN0LndpZHRoXG4gICAgICAgIGxldCBwYXJlbnRIZWlnaHQgPSBwYXJlbnRSZWN0LmhlaWdodFxuXG4gICAgICAgIC8vdG9vIGZhciByaWdodFxuICAgICAgICBpZiAobm9kZS5vZmZzZXRMZWZ0ID4gcGFyZW50UmVjdC5sZWZ0ICsgcGFyZW50V2lkdGggLSBub2RlLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGV2ZW50LnggLSBub2RlLmNsaWVudFdpZHRoIC0gdGhpcy54T2Zmc2V0XG4gICAgICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4J1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgbW91c2UgY292ZXJzIHRvb2x0aXBcbiAgICAgICAgICAgIGlmIChub2RlLm9mZnNldExlZnQgKyBub2RlLmNsaWVudFdpZHRoID4gZXZlbnQueCkge1xuICAgICAgICAgICAgICAgIC8vbW92ZSB0b29sdGlwIGxlZnQgc28gaXQgZG9lc250IGNvdmVyIG1vdXNlXG4gICAgICAgICAgICAgICAgbGV0IGxlZnQyID0gZXZlbnQueCAtIG5vZGUuY2xpZW50V2lkdGggLSB0aGlzLnhPZmZzZXRcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBsZWZ0MiArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vZGUuc3R5bGUudG9wID0gbm9kZS5vZmZzZXRUb3AgKyBjb25maWcueU9mZnNldCArIFwicHhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdG9vIGZhciBkb3duXG4gICAgICAgIGlmIChub2RlLm9mZnNldFRvcCArIG5vZGUuY2xpZW50SGVpZ2h0ID4gcGFyZW50UmVjdC50b3AgKyBwYXJlbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUudG9wID0gbm9kZS5vZmZzZXRUb3AgLSBub2RlLmNsaWVudEhlaWdodCArICdweCdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdG9vIGZhciB1cFxuICAgICAgICBpZiAobm9kZS5vZmZzZXRUb3AgPCBwYXJlbnRSZWN0LnRvcCkge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS50b3AgPSBwYXJlbnRSZWN0LnRvcCArIHRoaXMueU9mZnNldCArICdweCdcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcblxuLyoqXG4gKiBQYXJlbnQgY2xhc3MgZm9yIGJ1dHRvbiBlbGVtZW50cyB1c2VkIHRvIGludGVyYWN0IHdpdGggdGhlIGdyaWR2aXogdmlld2VyLlxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIEJ1dHRvbiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBvcHRzLnBhcmVudE5vZGVcbiAgICAgKiBvcHRzLmlkXG4gICAgICogb3B0cy50aXRsZVxuICAgICAqIG9wdHMuY2xhc3NcbiAgICAgKiBvcHRzLm9uQ2xpY2tGdW5jdGlvblxuICAgICAqIG9wdHMueFxuICAgICAqIG9wdHMueVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICB0aGlzLmFwcCA9IG9wdHMuYXBwXG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IG9wdHMucGFyZW50Tm9kZSB8fCBvcHRzLmFwcC5jb250YWluZXJcblxuICAgICAgICAvLyB0aGUgZGl2IGVsZW1lbnRcbiAgICAgICAgaWYgKHRoaXMuaWQpIHRoaXMuZGl2ID0gc2VsZWN0KCcjJyArIHRoaXMuaWQpXG5cbiAgICAgICAgaWYgKCF0aGlzLmRpdiB8fCB0aGlzLmRpdi5lbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLmRpdiA9IHNlbGVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcbiAgICAgICAgICAgIGlmICh0aGlzLmlkKSB0aGlzLmRpdi5hdHRyKCdpZCcsIHRoaXMuaWQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy50aXRsZSkgdGhpcy5kaXYuYXR0cigndGl0bGUnLG9wdHMudGl0bGUpXG4gICAgICAgIGlmIChvcHRzLmNsYXNzKSB0aGlzLmRpdi5hdHRyKCdjbGFzcycsb3B0cy5jbGFzcylcblxuICAgICAgICAvLyBhZGQgZXZlbnRzXG4gICAgICAgIGlmIChvcHRzLm9uQ2xpY2tGdW5jdGlvbikgdGhpcy5kaXYub24oJ2NsaWNrJywgb3B0cy5vbkNsaWNrRnVuY3Rpb24pXG5cbiAgICAgICAgLy9zZXQgc3R5bGVzXG4gICAgICAgIHRoaXMuc3R5bGUoJ2JveC1zaGFkb3cnLCcwIDdweCA4cHggcmdiYSgwLDQ3LDEwMywuMDgpLCAwIDAgMjJweCByZ2JhKDAsNDcsMTAzLC4wNCksIDAgMTJweCAxN3B4IHJnYmEoMCw0NywxMDMsLjA0KSwgMCAtNHB4IDRweCByZ2JhKDAsNDcsMTAzLC4wNCknKSAvLy5lY2wtdS1zaGFkb3ctM1xuICAgICAgICB0aGlzLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywnI2ZmZmZmZicpXG4gICAgICAgIHRoaXMuc3R5bGUoJ3Bvc2l0aW9uJyAsICdhYnNvbHV0ZScpXG4gICAgICAgIHRoaXMuc3R5bGUoJ2N1cnNvcicgLCAncG9pbnRlcicpXG4gICAgICAgIHRoaXMuc3R5bGUoJ2Rpc3BsYXknICwgJ2ZsZXgnKVxuICAgICAgICB0aGlzLnN0eWxlKCdqdXN0aWZ5LWNvbnRlbnQnICwgJ2NlbnRlcicpXG4gICAgICAgIHRoaXMuc3R5bGUoJ2FsaWduLWl0ZW1zJyAsICdjZW50ZXInKVxuICAgICAgICB0aGlzLnN0eWxlKCd3aWR0aCcgLCAnMzBweCcpXG4gICAgICAgIHRoaXMuc3R5bGUoJ2hlaWdodCcgLCAnMzBweCcpXG4gICAgICAgIC8vIHRoaXMuc3R5bGUocGFkZGluZyAsICc0cHgnXG5cblxuICAgICAgICAvLyBhcHBlbmQgdG8gcGFyZW50XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmRpdi5ub2RlKCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBzdHlsZSB0byB0aGUgYnV0dG9uIGRpdi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2XG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc3R5bGUoaywgdikge1xuICAgICAgICB0aGlzLmRpdi5zdHlsZShrLCB2KVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJy4vQnV0dG9uLmpzJ1xuXG4vKipcbiAqIEJ1dHRvbiBmb3IgdG9nZ2xpbmcgZnVsbHNjcmVlbiBtb2RlXG4gKlxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgRnVsbHNjcmVlbkJ1dHRvbiBleHRlbmRzIEJ1dHRvbiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBvcHRzLnBhcmVudE5vZGUgLSB0aGUgbm9kZSB0aGF0IHRoZSBidXR0b24gaXMgYXBwZW5kZWQgdG9cbiAgICAgKiBvcHRzLmNhbnZhcyAtIHRoZSBncmlkdml6IGNhbnZhc1xuICAgICAqIG9wdHMuaWRcbiAgICAgKiBvcHRzLnRpdGxlIC0gSFRNTCB0aXRsZSBhdHRyaWJ1dGVcbiAgICAgKiBvcHRzLmNsYXNzIC0gY3NzIGNsYXNzXG4gICAgICogb3B0cy5vbkNsaWNrRnVuY3Rpb25cbiAgICAgKiBvcHRzLnggLSB4IHBvc2l0aW9uIG9mIHRoZSBidXR0b25cbiAgICAgKiBvcHRzLnkgLSB5IHBvc2l0aW9uIG9mIHRoZSBidXR0b25cbiAgICAgKi9cblxuICAgIC8vIGRlZmF1bHQgc3RhdGVcbiAgICBpc0Z1bGxzY3JlZW4gPSBmYWxzZVxuXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuXG4gICAgICAgIC8vIGFwcGVuZCBmdWxsc2NyZWVuIGljb24gdG8gYnV0dG9uIGNvbnRhaW5lclxuICAgICAgICB0aGlzLmRpdi5ub2RlKCkuaW5uZXJIVE1MID0gYFxuICAgICAgICA8c3ZnXG4gICAgICAgICAgICBzdHlsZT1cImhlaWdodDogMS4ycmVtOyB3aWR0aDogMS4ycmVtOyBmaWxsOmJsYWNrOyBtYXJnaW46MDtcIlxuICAgICAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPHN2ZyBmaWxsPVwiIzAwMDAwMFwiIHZpZXdCb3g9XCIwIDAgOTYgOTZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgICAgICA8dGl0bGUvPlxuICAgICAgICAgICAgPGc+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTMwLDBINkE1Ljk5NjYsNS45OTY2LDAsMCwwLDAsNlYzMGE2LDYsMCwwLDAsMTIsMFYxMkgzMEE2LDYsMCwwLDAsMzAsMFpcIi8+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTkwLDBINjZhNiw2LDAsMCwwLDAsMTJIODRWMzBhNiw2LDAsMCwwLDEyLDBWNkE1Ljk5NjYsNS45OTY2LDAsMCwwLDkwLDBaXCIvPlxuICAgICAgICAgICAgPHBhdGggZD1cIk0zMCw4NEgxMlY2NkE2LDYsMCwwLDAsMCw2NlY5MGE1Ljk5NjYsNS45OTY2LDAsMCwwLDYsNkgzMGE2LDYsMCwwLDAsMC0xMlpcIi8+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTkwLDYwYTUuOTk2Niw1Ljk5NjYsMCwwLDAtNiw2Vjg0SDY2YTYsNiwwLDAsMCwwLDEySDkwYTUuOTk2Niw1Ljk5NjYsMCwwLDAsNi02VjY2QTUuOTk2Niw1Ljk5NjYsMCwwLDAsOTAsNjBaXCIvPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICBgXG5cbiAgICAgICAgLy9zYXZlIGluaXRpYWwgYXBwIGRpbWVuc2lvbnNcbiAgICAgICAgdGhpcy5kZWZhdWx0SGVpZ2h0ID0gdGhpcy5hcHAuaFxuICAgICAgICB0aGlzLmRlZmF1bHRXaWR0aCA9IHRoaXMuYXBwLndcblxuICAgICAgICAvLyBldmVudCBoYW5kbGVyXG4gICAgICAgIHRoaXMuZGl2Lm9uKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xpY2tGdW5jdGlvbihlKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLmRpdi5vbignbW91c2VvdmVyJywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCAnbGlnaHRncmV5JylcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5kaXYub24oJ21vdXNlb3V0JywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCAnI2ZmZmZmZicpXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy9zZXQgcG9zaXRpb25cbiAgICAgICAgaWYgKG9wdHMueCkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSgnbGVmdCcsIG9wdHMueCArICdweCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKCdyaWdodCcsICcxMHB4JylcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy55KSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKCd0b3AnLCBvcHRzLnkgKyAncHgnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSgndG9wJywgJzkwcHgnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DbGlja0Z1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlRnVsbHNjcmVlbih0aGlzLmFwcC5jb250YWluZXIpXG4gICAgICAgICAgICAvL3Jlc2l6ZSBjYW52YXMgdG8gZGVmYXVsdFxuICAgICAgICAgICAgdGhpcy5hcHAuaCA9IHRoaXMuZGVmYXVsdEhlaWdodFxuICAgICAgICAgICAgdGhpcy5hcHAudyA9IHRoaXMuZGVmYXVsdFdpZHRoXG4gICAgICAgICAgICB0aGlzLmFwcC5jZy5oID0gdGhpcy5kZWZhdWx0SGVpZ2h0XG4gICAgICAgICAgICB0aGlzLmFwcC5jZy53ID0gdGhpcy5kZWZhdWx0V2lkdGhcbiAgICAgICAgICAgIHRoaXMuYXBwLmNnLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJycgKyB0aGlzLmRlZmF1bHRXaWR0aClcbiAgICAgICAgICAgIHRoaXMuYXBwLmNnLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcnICsgdGhpcy5kZWZhdWx0SGVpZ2h0KVxuICAgICAgICAgICAgdGhpcy5hcHAucmVkcmF3KClcbiAgICAgICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkZ1bGxzY3JlZW4odGhpcy5hcHAuY29udGFpbmVyKVxuICAgICAgICAgICAgLy9yZXNpemUgY2FudmFzIHRvIGZ1bGxzY3JlZW5cbiAgICAgICAgICAgIHRoaXMuYXBwLmggPSB3aW5kb3cuc2NyZWVuLmhlaWdodFxuICAgICAgICAgICAgdGhpcy5hcHAudyA9IHdpbmRvdy5zY3JlZW4ud2lkdGhcbiAgICAgICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogT3BlbiBmdWxsc2NyZWVuICovXG4gICAgb3BlbkZ1bGxzY3JlZW4oZWxlbSkge1xuICAgICAgICBpZiAoZWxlbS5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgZWxlbS5yZXF1ZXN0RnVsbHNjcmVlbigpXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgLyogU2FmYXJpICovXG4gICAgICAgICAgICBlbGVtLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtLm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIC8qIElFMTEgKi9cbiAgICAgICAgICAgIGVsZW0ubXNSZXF1ZXN0RnVsbHNjcmVlbigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBDbG9zZSBmdWxsc2NyZWVuICovXG4gICAgY2xvc2VGdWxsc2NyZWVuKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKClcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgLyogU2FmYXJpICovXG4gICAgICAgICAgICBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpXG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgLyogSUUxMSAqL1xuICAgICAgICAgICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBCdXR0b24gfSBmcm9tICcuL0J1dHRvbi5qcydcblxuLyoqXG4gKiBCdXR0b24gZm9yIHRvZ2dsaW5nIGZ1bGxzY3JlZW4gbW9kZVxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFpvb21CdXR0b25zIGV4dGVuZHMgQnV0dG9uIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcblxuICAgICAgICB0aGlzLm9uWm9vbSA9IG9wdHMub25ab29tIC8vIGN1c3RvbSB1c2VyIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgdGhpcy5kZWx0YSA9IG9wdHMuZGVsdGEgfHwgMC4yXG5cbiAgICAgICAgLy8gem9vbSBpbiBidG5cbiAgICAgICAgdGhpcy56b29tSW5CdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgICAgdGhpcy56b29tSW5CdG4uaW5uZXJIVE1MID0gYDxhIGlkPVwiem9vbWluXCIgY2xhc3M9XCJncmlkdml6LXpvb20tYnV0dG9uXCIgdGl0bGU9XCJab29tIGluXCI+KzwvYT5gXG4gICAgICAgIHRoaXMuem9vbUluQnRuLnRpdGxlID0gJ1pvb20gaW4nXG4gICAgICAgIHRoaXMuem9vbUluQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuem9vbUluKGUpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuem9vbUluQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnpvb21JbkJ0bi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnbGlnaHRncmV5J1xuICAgICAgICB9KVxuICAgICAgICB0aGlzLnpvb21JbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnpvb21JbkJ0bi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZmZmZidcbiAgICAgICAgfSlcblxuICAgICAgICAvLyB6b29tIG91dCBidG5cbiAgICAgICAgdGhpcy56b29tT3V0QnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICAgIHRoaXMuem9vbU91dEJ0bi5pbm5lckhUTUwgPSBgPGEgaWQ9XCJ6b29taW5cIiBjbGFzcz1cImdyaWR2aXotem9vbS1idXR0b25cIiB0aXRsZT1cIlpvb20gb3V0XCI+LTwvYT5gXG4gICAgICAgIHRoaXMuem9vbU91dEJ0bi50aXRsZSA9ICdab29tIG91dCdcbiAgICAgICAgdGhpcy56b29tT3V0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuem9vbU91dChlKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnpvb21PdXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuem9vbU91dEJ0bi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnbGlnaHRncmV5J1xuICAgICAgICB9KVxuICAgICAgICB0aGlzLnpvb21PdXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy56b29tT3V0QnRuLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZmZmZmZmJ1xuICAgICAgICB9KVxuXG4gICAgICAgIC8vc2V0IHN0eWxlc1xuICAgICAgICBsZXQgYnRucyA9IFt0aGlzLnpvb21JbkJ0biwgdGhpcy56b29tT3V0QnRuXVxuICAgICAgICBidG5zLmZvckVhY2goKGJ0biwgaSkgPT4ge1xuICAgICAgICAgICAgYnRuLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJ1xuICAgICAgICAgICAgYnRuLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2NlbnRlcidcbiAgICAgICAgICAgIGJ0bi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgICAgICAgICBidG4uc3R5bGUuYm9yZGVyID0gJ25vbmUnXG4gICAgICAgICAgICBidG4uc3R5bGUuY29sb3IgPSAnYmxhY2snXG4gICAgICAgICAgICBidG4uc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcidcbiAgICAgICAgICAgIGJ0bi5zdHlsZS50ZXh0RGVjb3JhdGlvbiA9ICdub25lJ1xuICAgICAgICAgICAgYnRuLnN0eWxlLnBhZGRpbmcgPSAnNHB4J1xuICAgICAgICAgICAgYnRuLnN0eWxlLmZvbnRTaXplID0gJzIwcHgnXG4gICAgICAgICAgICBidG4uc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJ1xuICAgICAgICAgICAgYnRuLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSdcbiAgICAgICAgICAgIGlmIChpID09IDApIGJ0bi5zdHlsZS5ib3JkZXJCb3R0b20gPSAnMXB4IHNvbGlkIGdyZXknXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gdW5zZXQgcGFyZW50IGNsYXNzIGhlaWdodCBhbmQgZGlzcGxheSBmb3IgZHVhbCBidXR0b25zXG4gICAgICAgIHRoaXMuc3R5bGUoJ2hlaWdodCcsICd1bnNldCcpXG4gICAgICAgIHRoaXMuc3R5bGUoJ2Rpc3BsYXknLCAndW5zZXQnKVxuXG4gICAgICAgIC8vc2V0IHBvc2l0aW9uXG4gICAgICAgIGlmIChvcHRzLngpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ2xlZnQnLCBvcHRzLnggKyAncHgnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSgncmlnaHQnLCAnMTBweCcpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMueSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSgndG9wJywgb3B0cy55ICsgJ3B4JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ3RvcCcsICcxMHB4JylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGVuZCB0byBidXR0b24gY29udGFpbmVyXG4gICAgICAgIHRoaXMuZGl2Lm5vZGUoKS5hcHBlbmRDaGlsZCh0aGlzLnpvb21JbkJ0bilcbiAgICAgICAgdGhpcy5kaXYubm9kZSgpLmFwcGVuZENoaWxkKHRoaXMuem9vbU91dEJ0bilcbiAgICB9XG5cbiAgICAvKiBab29tIGluICovXG4gICAgem9vbUluKGUpIHtcbiAgICAgICAgdGhpcy5hcHAuc2V0Wm9vbUZhY3Rvcih0aGlzLmFwcC5nZXRab29tRmFjdG9yKCkgKiAoMSAtIHRoaXMuZGVsdGEpKS5yZWRyYXcoKVxuICAgICAgICBpZiAodGhpcy5vblpvb20pIHRoaXMub25ab29tKGUpXG4gICAgfVxuXG4gICAgLyogWm9vbSBvdXQgKi9cbiAgICB6b29tT3V0KGUpIHtcbiAgICAgICAgdGhpcy5hcHAuc2V0Wm9vbUZhY3Rvcih0aGlzLmFwcC5nZXRab29tRmFjdG9yKCkgKiAoMSArIHRoaXMuZGVsdGEpKS5yZWRyYXcoKVxuICAgICAgICBpZiAodGhpcy5vblpvb20pIHRoaXMub25ab29tKGUpXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge3sgZGltczogb2JqZWN0LCBjcnM6IHN0cmluZywgdGlsZVNpemVDZWxsOiBudW1iZXIsIG9yaWdpblBvaW50OiB7eDpudW1iZXIseTpudW1iZXJ9LCByZXNvbHV0aW9uR2VvOiBudW1iZXIsIHRpbGluZ0JvdW5kczppbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkVudmVsb3BlIH19IEdyaWRJbmZvICovXG5cbmltcG9ydCB7IGNzdiB9IGZyb20gJ2QzLWZldGNoJ1xuaW1wb3J0IHsgRGF0YXNldENvbXBvbmVudCB9IGZyb20gJy4uL0RhdGFzZXRDb21wb25lbnQuanMnXG5cbi8qKlxuICogQSBkYXRhc2V0IGNvbXBvc2VkIG9mIGEgc2luZ2xlIENTViBmaWxlIChub3QgdGlsZWQpLlxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIENTVkdyaWQgZXh0ZW5kcyBEYXRhc2V0Q29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgb2YgdGhlIGRhdGFzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIGRhdGFzZXQgcmVzb2x1dGlvbiBpbiBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgKiBAcGFyYW0ge3twcmVwcm9jZXNzPzooZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsKTpib29sZWFuKX19IG9wdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHJlc29sdXRpb24sIG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcih1cmwsIHJlc29sdXRpb24sIG9wdHMpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gKi9cbiAgICAgICAgdGhpcy5jZWxscyA9IFtdXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlICAqL1xuICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ25vdExvYWRlZCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGRhdGEgd2l0aGluIGEgZ2VvZ3JhcGhpYyBlbnZlbG9wZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5FbnZlbG9wZXx1bmRlZmluZWR9IGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gcmVkcmF3XG4gICAgICovXG4gICAgZ2V0RGF0YShlLCByZWRyYXcpIHtcbiAgICAgICAgLy9jaGVjayBpZiBkYXRhIGFscmVhZHkgbG9hZGVkXG4gICAgICAgIGlmICh0aGlzLmluZm9Mb2FkaW5nU3RhdHVzICE9ICdub3RMb2FkZWQnKSByZXR1cm4gdGhpc1xuXG4gICAgICAgIC8vbG9hZCBkYXRhXG4gICAgICAgIHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPSAnbG9hZGluZydcbiAgICAgICAgOyhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjc3YodGhpcy51cmwpXG5cbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgY29vcmRpbmF0ZXMgaW4gbnVtYmVyc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGMueCA9ICtjLnhcbiAgICAgICAgICAgICAgICAgICAgYy55ID0gK2MueVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vcHJlcHJvY2Vzcy9maWx0ZXJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmVwcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2VsbHMgPSBbXVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMucHJlcHJvY2VzcyhjKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gZmFsc2UpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzLnB1c2goYylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2VsbHMgPSBkYXRhXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9UT0RPIGNoZWNrIGlmIHJlZHJhdyBpcyBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAvL3RoYXQgaXMgaWYgdGhlIGRhdGFzZXQgYmVsb25ncyB0byBhIGxheWVyIHdoaWNoIGlzIHZpc2libGUgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuXG4gICAgICAgICAgICAgICAgLy9leGVjdXRlIHRoZSBjYWxsYmFjaywgdXN1YWxseSBhIGRyYXcgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3KSByZWRyYXcoKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9ICdsb2FkZWQnXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vbWFyayBhcyBmYWlsZWRcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzID0gW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKVxuXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbCB0aGUgdmlldyBjYWNoZSB3aXRoIGFsbCBjZWxscyB3aGljaCBhcmUgd2l0aGluIGEgZ2VvZ3JhcGhpY2FsIGVudmVsb3BlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkVudmVsb3BlfSBleHRHZW9cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVWaWV3Q2FjaGUoZXh0R2VvKSB7XG4gICAgICAgIC8vZGF0YSBub3QgbG9hZGVkIHlldFxuICAgICAgICBpZiAoIXRoaXMuY2VsbHMpIHJldHVyblxuXG4gICAgICAgIHRoaXMuY2VsbHNWaWV3Q2FjaGUgPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGhpcy5jZWxscykge1xuICAgICAgICAgICAgaWYgKCtjZWxsLnggKyB0aGlzLnJlc29sdXRpb24gPCBleHRHZW8ueE1pbikgY29udGludWVcbiAgICAgICAgICAgIGlmICgrY2VsbC54IC0gdGhpcy5yZXNvbHV0aW9uID4gZXh0R2VvLnhNYXgpIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoK2NlbGwueSArIHRoaXMucmVzb2x1dGlvbiA8IGV4dEdlby55TWluKSBjb250aW51ZVxuICAgICAgICAgICAgaWYgKCtjZWxsLnkgLSB0aGlzLnJlc29sdXRpb24gPiBleHRHZW8ueU1heCkgY29udGludWVcbiAgICAgICAgICAgIHRoaXMuY2VsbHNWaWV3Q2FjaGUucHVzaChjZWxsKVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEEgZ3JpZCB0aWxlLlxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIEdyaWRUaWxlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxscyBUaGUgdGlsZSBjZWxscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFQgVGhlIFggcG9zaXRpb24gb2YgdGhlIHRpbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlUIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSB0aWxlLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9DU1ZHcmlkXCIpLkdyaWRJbmZvfSBncmlkSW5mbyBUaGUgZ3JpZCBpbmZvIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjZWxscywgeFQsIHlULCBncmlkSW5mbykge1xuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSAqL1xuICAgICAgICB0aGlzLmNlbGxzID0gY2VsbHNcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHhUXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnkgPSB5VFxuXG4gICAgICAgIGNvbnN0IHIgPSBncmlkSW5mby5yZXNvbHV0aW9uR2VvXG4gICAgICAgIGNvbnN0IHMgPSBncmlkSW5mby50aWxlU2l6ZUNlbGxcblxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL0RhdGFzZXRcIikuRW52ZWxvcGV9ICovXG4gICAgICAgIHRoaXMuZXh0R2VvID0ge1xuICAgICAgICAgICAgeE1pbjogZ3JpZEluZm8ub3JpZ2luUG9pbnQueCArIHIgKiBzICogdGhpcy54LFxuICAgICAgICAgICAgeE1heDogZ3JpZEluZm8ub3JpZ2luUG9pbnQueCArIHIgKiBzICogKHRoaXMueCArIDEpLFxuICAgICAgICAgICAgeU1pbjogZ3JpZEluZm8ub3JpZ2luUG9pbnQueSArIHIgKiBzICogdGhpcy55LFxuICAgICAgICAgICAgeU1heDogZ3JpZEluZm8ub3JpZ2luUG9pbnQueSArIHIgKiBzICogKHRoaXMueSArIDEpLFxuICAgICAgICB9XG5cbiAgICAgICAgLy9jb252ZXJ0IGNlbGwgY29vcmRpbmF0ZXMgaW50byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiB0aGlzLmNlbGxzKSB7XG4gICAgICAgICAgICBjZWxsLnggPSB0aGlzLmV4dEdlby54TWluICsgY2VsbC54ICogclxuICAgICAgICAgICAgY2VsbC55ID0gdGhpcy5leHRHZW8ueU1pbiArIGNlbGwueSAqIHJcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHt7IGRpbXM6IG9iamVjdCwgY3JzOiBzdHJpbmcsIHRpbGVTaXplQ2VsbDogbnVtYmVyLCBvcmlnaW5Qb2ludDoge3g6bnVtYmVyLHk6bnVtYmVyfSwgcmVzb2x1dGlvbkdlbzogbnVtYmVyLCB0aWxpbmdCb3VuZHM6aW1wb3J0KFwiLi4vRGF0YXNldC5qc1wiKS5FbnZlbG9wZSB9fSBHcmlkSW5mbyAqL1xuXG5pbXBvcnQgeyBEYXRhc2V0Q29tcG9uZW50IH0gZnJvbSAnLi4vRGF0YXNldENvbXBvbmVudC5qcydcblxuLyoqXG4gKiBBIGRhdGFzZXQgY29tcG9zZWQgb2YgYSBzaW5nbGUgQ1NWIGZpbGUgKG5vdCB0aWxlZCkuXG4gKlxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgTEdyaWQgZXh0ZW5kcyBEYXRhc2V0Q29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBUaGUgZGF0YXNldCByZXNvbHV0aW9uIGluIGdlb2dyYXBoaWNhbCB1bml0LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNlbGxzIFRoZSBjZWxscy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXNvbHV0aW9uLCBjZWxscykge1xuICAgICAgICBzdXBlcihcIlwiLCByZXNvbHV0aW9uKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXQuanNcIikuQ2VsbD59ICovXG4gICAgICAgIHRoaXMuY2VsbHMgPSBjZWxscyB8fCBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgZGF0YSB3aXRoaW4gYSBnZW9ncmFwaGljIGVudmVsb3BlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9EYXRhc2V0LmpzXCIpLkVudmVsb3BlfHVuZGVmaW5lZH0gZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSByZWRyYXdcbiAgICAgKi9cbiAgICBnZXREYXRhKGUsIHJlZHJhdykgeyByZXR1cm4gdGhpcyB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxsIHRoZSB2aWV3IGNhY2hlIHdpdGggYWxsIGNlbGxzIHdoaWNoIGFyZSB3aXRoaW4gYSBnZW9ncmFwaGljYWwgZW52ZWxvcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0RhdGFzZXQuanNcIikuRW52ZWxvcGV9IGV4dEdlb1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHVwZGF0ZVZpZXdDYWNoZShleHRHZW8pIHtcbiAgICAgICAgLy9kYXRhIG5vdCBsb2FkZWQgeWV0XG4gICAgICAgIGlmICghdGhpcy5jZWxscykgcmV0dXJuXG5cbiAgICAgICAgdGhpcy5jZWxsc1ZpZXdDYWNoZSA9IFtdXG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB0aGlzLmNlbGxzKSB7XG4gICAgICAgICAgICBpZiAoK2NlbGwueCArIHRoaXMucmVzb2x1dGlvbiA8IGV4dEdlby54TWluKSBjb250aW51ZVxuICAgICAgICAgICAgaWYgKCtjZWxsLnggLSB0aGlzLnJlc29sdXRpb24gPiBleHRHZW8ueE1heCkgY29udGludWVcbiAgICAgICAgICAgIGlmICgrY2VsbC55ICsgdGhpcy5yZXNvbHV0aW9uIDwgZXh0R2VvLnlNaW4pIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoK2NlbGwueSAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby55TWF4KSBjb250aW51ZVxuICAgICAgICAgICAgdGhpcy5jZWxsc1ZpZXdDYWNoZS5wdXNoKGNlbGwpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7eyBkaW1zOiBvYmplY3QsIGNyczogc3RyaW5nLCB0aWxlU2l6ZUNlbGw6IG51bWJlciwgb3JpZ2luUG9pbnQ6IHt4Om51bWJlcix5Om51bWJlcn0sIHJlc29sdXRpb25HZW86IG51bWJlciwgdGlsaW5nQm91bmRzOmltcG9ydChcIi4uL0RhdGFzZXRcIikuRW52ZWxvcGUsIGZvcm1hdDppbXBvcnQoXCIuLi9EYXRhc2V0Q29tcG9uZW50XCIpLkZvcm1hdCB9fSBHcmlkSW5mbyAqL1xuXG4vLyBpbnRlcm5hbFxuaW1wb3J0IHsgR3JpZFRpbGUgfSBmcm9tICcuL0dyaWRUaWxlLmpzJ1xuaW1wb3J0IHsgQXBwIH0gZnJvbSAnLi4vQXBwLmpzJ1xuaW1wb3J0IHsgRGF0YXNldENvbXBvbmVudCB9IGZyb20gJy4uL0RhdGFzZXRDb21wb25lbnQuanMnXG5pbXBvcnQgeyBtb25pdG9yLCBtb25pdG9yRHVyYXRpb24gfSBmcm9tICcuLi91dGlscy9VdGlscy5qcydcblxuLy8gZXh0ZXJuYWxcbmltcG9ydCB7IGpzb24sIGNzdiB9IGZyb20gJ2QzLWZldGNoJ1xuXG4vKipcbiAqIEEgdGlsZWQgZGF0YXNldCwgY29tcG9zZWQgb2YgQ1NWIHRpbGVzLlxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFRpbGVkR3JpZCBleHRlbmRzIERhdGFzZXRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgZGF0YXNldC5cbiAgICAgKiBAcGFyYW0ge0FwcH0gYXBwIFRoZSBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3twcmVwcm9jZXNzPzooZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsKTpib29sZWFuKSB9fSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsLCBhcHAsIG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcih1cmwsIDAsIG9wdHMpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcHAgYmVpbmcgdXNlZC5cbiAgICAgICAgICogQHR5cGUge0FwcH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXBwID0gYXBwXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBncmlkIGluZm8gb2JqZWN0LCBmcm9tIHRoZSBpbmZvLmpzb24gZmlsZS5cbiAgICAgICAgICogIEB0eXBlIHtHcmlkSW5mbyB8IHVuZGVmaW5lZH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogICovXG4gICAgICAgIHRoaXMuaW5mbyA9IHVuZGVmaW5lZFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZSAgKi9cbiAgICAgICAgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9ICdub3RMb2FkZWQnXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWNoZSBvZiB0aGUgbG9hZGVkIHRpbGVzLiBJdCBpcyBkb3VibGUgaW5kZXhlZDogYnkgeFQgYW5kIHRoZW4geVQuXG4gICAgICAgICAqIEV4YW1wbGU6IHRoaXMuY2FjaGVbeFRdW3lUXSByZXR1cm5zIHRoZSB0aWxlIGF0IFt4VF1beVRdIGxvY2F0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmNhY2hlID0ge31cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIGluZm8uanNvbiBmcm9tIHRoZSB1cmwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB0aGlzXG4gICAgICovXG4gICAgbG9hZEluZm8oY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmluZm8gJiYgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9PT0gJ25vdExvYWRlZCcpIHtcbiAgICAgICAgICAgIDsgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQganNvbih0aGlzLnVybCArICdpbmZvLmpzb24nKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm8gPSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IGRhdGEucmVzb2x1dGlvbkdlb1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2xvYWRlZCdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9tYXJrIGFzIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpXG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2sgJiYgKHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPT09ICdsb2FkZWQnIHx8IHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPT09ICdmYWlsZWQnKSlcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGEgdGlsaW5nIGVudmVsb3BlIGZyb20gYSBnZW9ncmFwaGljYWwgZW52ZWxvcGUuXG4gICAgICogVGhpcyBpcyB0aGUgZnVuY3Rpb24gdG8gdXNlIHRvIGtub3cgd2hpY2ggdGlsZXMgdG8gZG93bmxvYWQgZm9yIGEgZ2VvZ3JhcGhpY2FsIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0RhdGFzZXRcIikuRW52ZWxvcGV9IGVcbiAgICAgKiBAcmV0dXJucyB7aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5FbnZlbG9wZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0VGlsaW5nRW52ZWxvcGUoZSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5mbykge1xuICAgICAgICAgICAgdGhpcy5sb2FkSW5mbygoKSA9PiB7IH0pXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvID0gdGhpcy5pbmZvLm9yaWdpblBvaW50LFxuICAgICAgICAgICAgciA9IHRoaXMuaW5mby5yZXNvbHV0aW9uR2VvLFxuICAgICAgICAgICAgcyA9IHRoaXMuaW5mby50aWxlU2l6ZUNlbGxcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeE1pbjogTWF0aC5mbG9vcigoZS54TWluIC0gcG8ueCkgLyAociAqIHMpKSxcbiAgICAgICAgICAgIHhNYXg6IE1hdGguZmxvb3IoKGUueE1heCAtIHBvLngpIC8gKHIgKiBzKSksXG4gICAgICAgICAgICB5TWluOiBNYXRoLmZsb29yKChlLnlNaW4gLSBwby55KSAvIChyICogcykpLFxuICAgICAgICAgICAgeU1heDogTWF0aC5mbG9vcigoZS55TWF4IC0gcG8ueSkgLyAociAqIHMpKSxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgZGF0YSB3aXRoaW4gYSBnZW9ncmFwaGljIGVudmVsb3BlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkVudmVsb3BlfSBleHRHZW9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gcmVkcmF3RnVuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgZ2V0RGF0YShleHRHZW8sIHJlZHJhd0Z1bikge1xuICAgICAgICAvL1RPRE8gZW1wdHkgY2FjaGUgd2hlbiBpdCBnZXRzIHRvbyBiaWcgP1xuXG4gICAgICAgIC8vY2hlY2sgaWYgaW5mbyBoYXMgYmVlbiBsb2FkZWRcbiAgICAgICAgaWYgKCF0aGlzLmluZm8pIHJldHVybiB0aGlzXG5cbiAgICAgICAgLy90aWxlcyB3aXRoaW4gdGhlIHNjb3BlXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5FbnZlbG9wZXx1bmRlZmluZWR9ICovXG4gICAgICAgIGNvbnN0IHRiID0gdGhpcy5nZXRUaWxpbmdFbnZlbG9wZShleHRHZW8pXG4gICAgICAgIGlmICghdGIpIHJldHVybiB0aGlzXG5cbiAgICAgICAgLy9ncmlkIGJvdW5kc1xuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL0RhdGFzZXRcIikuRW52ZWxvcGV9ICovXG4gICAgICAgIGNvbnN0IGdiID0gdGhpcy5pbmZvLnRpbGluZ0JvdW5kc1xuXG4gICAgICAgIGZvciAobGV0IHhUID0gTWF0aC5tYXgodGIueE1pbiwgZ2IueE1pbik7IHhUIDw9IE1hdGgubWluKHRiLnhNYXgsIGdiLnhNYXgpOyB4VCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5VCA9IE1hdGgubWF4KHRiLnlNaW4sIGdiLnlNaW4pOyB5VCA8PSBNYXRoLm1pbih0Yi55TWF4LCBnYi55TWF4KTsgeVQrKykge1xuICAgICAgICAgICAgICAgIC8vcHJlcGFyZSBjYWNoZVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZVt4VF0pIHRoaXMuY2FjaGVbeFRdID0ge31cblxuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgdGlsZSBleGlzdHMgaW4gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtHcmlkVGlsZX0gKi9cbiAgICAgICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMuY2FjaGVbeFRdW3lUXVxuICAgICAgICAgICAgICAgIGlmICh0aWxlKSBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgLy9tYXJrIHRpbGUgYXMgbG9hZGluZ1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVbeFRdW3lUXSA9IFwibG9hZGluZ1wiO1xuICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vcmVxdWVzdCB0aWxlXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbD59ICAqL1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbHNcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gICovXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY3N2KHRoaXMudXJsICsgeFQgKyAnLycgKyB5VCArICcuY3N2JylcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcqKiogVGlsZWRHcmlkIHBhcnNlIHN0YXJ0JylcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9wcmVwcm9jZXNzL2ZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJlcHJvY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzID0gW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5wcmVwcm9jZXNzKGMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiID09IGZhbHNlKSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxscy5wdXNoKGMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxscyA9IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCdwcmVwcm9jZXNzIC8gZmlsdGVyJylcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFyayBhcyBmYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVbeFRdW3lUXSA9ICdmYWlsZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vc3RvcmUgdGlsZSBpbiBjYWNoZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGlsZSBpbmZvIGlua25vd24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlsZV8gPSBuZXcgR3JpZFRpbGUoY2VsbHMsIHhULCB5VCwgdGhpcy5pbmZvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlW3hUXVt5VF0gPSB0aWxlX1xuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignc3RvcmFnZScpXG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZiBubyByZWRyYXcgaXMgc3BlY2lmaWVkLCB0aGVuIGxlYXZlXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVkcmF3RnVuKSByZXR1cm5cblxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHJlZHJhdyBpcyByZWFsbHkgbmVlZGVkLCB0aGF0IGlzIGlmOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIHRoZSBkYXRhc2V0IGJlbG9uZ3MgdG8gYSBsYXllciB3aGljaCBpcyB2aXNpYmxlIGF0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlZHJhdyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vZ28gdGhyb3VnaCB0aGUgbGF5ZXJzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHpmID0gdGhpcy5hcHAuZ2V0Wm9vbUZhY3RvcigpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGF5IG9mIHRoaXMuYXBwLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXkudmlzaWJsZSkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXkuZ2V0RGF0YXNldENvbXBvbmVudCh6ZikgIT0gdGhpcykgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZm91bmQgb25lIGxheWVyLiBObyBuZWVkIHRvIHNlZWsgbW9yZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZHJhdyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9pZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCdjaGVjayByZWRyYXcgMScpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWRyYXcpIHJldHVyblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIHRoZSB0aWxlIGlzIHdpdGhpbiB0aGUgdmlldywgdGhhdCBpcyBpdHMgZ2VvIGVudmVsb3BlIGludGVyc2VjdHMgdGhlIHZpZXdlciBnZW8gZW52ZWxvcGUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudiA9IHRoaXMuYXBwLnVwZGF0ZUV4dGVudEdlbygpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudlQgPSB0aWxlXy5leHRHZW9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudi54TWF4IDw9IGVudlQueE1pbikgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnYueE1pbiA+PSBlbnZULnhNYXgpIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBpZiAoZW52LnlNYXggPD0gZW52VC55TWluKSByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudi55TWluID49IGVudlQueU1heCkgcmV0dXJuXG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCdjaGVjayByZWRyYXcgMicpXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignKioqIFRpbGVkR3JpZCBwYXJzZSBlbmQnKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vcmVkcmF3XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhd0Z1bigpXG4gICAgICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbCB0aGUgdmlldyBjYWNoZSB3aXRoIGFsbCBjZWxscyB3aGljaCBhcmUgd2l0aGluIGEgZ2VvZ3JhcGhpY2FsIGVudmVsb3BlLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5FbnZlbG9wZX0gZXh0R2VvXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlVmlld0NhY2hlKGV4dEdlbykge1xuICAgICAgICAvL1xuICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlID0gW11cblxuICAgICAgICAvL2NoZWNrIGlmIGluZm8gaGFzIGJlZW4gbG9hZGVkXG4gICAgICAgIGlmICghdGhpcy5pbmZvKSByZXR1cm5cblxuICAgICAgICAvL3RpbGVzIHdpdGhpbiB0aGUgc2NvcGVcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkVudmVsb3BlfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgY29uc3QgdGIgPSB0aGlzLmdldFRpbGluZ0VudmVsb3BlKGV4dEdlbylcbiAgICAgICAgaWYgKCF0YikgcmV0dXJuXG5cbiAgICAgICAgLy9ncmlkIGJvdW5kc1xuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL0RhdGFzZXRcIikuRW52ZWxvcGV9ICovXG4gICAgICAgIGNvbnN0IGdiID0gdGhpcy5pbmZvLnRpbGluZ0JvdW5kc1xuXG4gICAgICAgIGZvciAobGV0IHhUID0gTWF0aC5tYXgodGIueE1pbiwgZ2IueE1pbik7IHhUIDw9IE1hdGgubWluKHRiLnhNYXgsIGdiLnhNYXgpOyB4VCsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FjaGVbeFRdKSBjb250aW51ZVxuICAgICAgICAgICAgZm9yIChsZXQgeVQgPSBNYXRoLm1heCh0Yi55TWluLCBnYi55TWluKTsgeVQgPD0gTWF0aC5taW4odGIueU1heCwgZ2IueU1heCk7IHlUKyspIHtcbiAgICAgICAgICAgICAgICAvL2dldCB0aWxlXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtHcmlkVGlsZX0gKi9cbiAgICAgICAgICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5jYWNoZVt4VF1beVRdXG4gICAgICAgICAgICAgICAgaWYgKCF0aWxlIHx8IHR5cGVvZiB0aWxlID09PSAnc3RyaW5nJykgY29udGludWVcblxuICAgICAgICAgICAgICAgIC8vZ2V0IGNlbGxzXG4gICAgICAgICAgICAgICAgLy90aGlzLmNlbGxzVmlld0NhY2hlID0gdGhpcy5jZWxsc1ZpZXdDYWNoZS5jb25jYXQodGlsZS5jZWxscylcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB0aWxlLmNlbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrY2VsbC54ICsgdGhpcy5yZXNvbHV0aW9uIDwgZXh0R2VvLnhNaW4pIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGlmICgrY2VsbC54IC0gdGhpcy5yZXNvbHV0aW9uID4gZXh0R2VvLnhNYXgpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGlmICgrY2VsbC55ICsgdGhpcy5yZXNvbHV0aW9uIDwgZXh0R2VvLnlNaW4pIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGlmICgrY2VsbC55IC0gdGhpcy5yZXNvbHV0aW9uID4gZXh0R2VvLnlNYXgpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2VsbHNWaWV3Q2FjaGUucHVzaChjZWxsKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLy8gdGhlIGFwcGxpY2F0aW9uXG5leHBvcnQgeyBBcHAgfSBmcm9tICcuL0FwcC5qcydcbmV4cG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4vR2VvQ2FudmFzLmpzJ1xuZXhwb3J0IHsgU3R5bGUgfSBmcm9tICcuL1N0eWxlLmpzJ1xuZXhwb3J0IHsgTGF5ZXIgfSBmcm9tICcuL0xheWVyLmpzJ1xuZXhwb3J0IHsgRGF0YXNldCB9IGZyb20gJy4vRGF0YXNldC5qcydcbmV4cG9ydCB7IERhdGFzZXRDb21wb25lbnQgfSBmcm9tICcuL0RhdGFzZXRDb21wb25lbnQuanMnXG5cbi8vIGV4cG9ydCBkYXRhc2V0IHR5cGVzXG5leHBvcnQgeyBUaWxlZEdyaWQgfSBmcm9tICcuL2RhdGFzZXQvVGlsZWRHcmlkLmpzJ1xuZXhwb3J0IHsgR3JpZFRpbGUgfSBmcm9tICcuL2RhdGFzZXQvR3JpZFRpbGUuanMnXG5leHBvcnQgeyBDU1ZHcmlkIH0gZnJvbSAnLi9kYXRhc2V0L0NTVkdyaWQuanMnXG5leHBvcnQgeyBMR3JpZCB9IGZyb20gJy4vZGF0YXNldC9MR3JpZC5qcydcbi8vZXhwb3J0IHsgR2VvVElGRiB9IGZyb20gXCIuL2RhdGFzZXQvR2VvVElGRlwiXG5cbi8vIGV4cG9ydCBzdHlsZXNcbmV4cG9ydCB7IFNoYXBlQ29sb3JTaXplU3R5bGUgfSBmcm9tICcuL3N0eWxlL1NoYXBlQ29sb3JTaXplU3R5bGUuanMnXG5leHBvcnQgeyBTaGFwZUNvbG9yU2l6ZVN0eWxlXyB9IGZyb20gJy4vc3R5bGUvU2hhcGVDb2xvclNpemVTdHlsZV8uanMnXG5leHBvcnQgeyBTdHJva2VTdHlsZSB9IGZyb20gJy4vc3R5bGUvU3Ryb2tlU3R5bGUuanMnXG5leHBvcnQgeyBKb3lQbG90U3R5bGUgfSBmcm9tICcuL3N0eWxlL0pveVBsb3RTdHlsZS5qcydcbmV4cG9ydCB7IENvbXBvc2l0aW9uU3R5bGUgfSBmcm9tICcuL3N0eWxlL0NvbXBvc2l0aW9uU3R5bGUuanMnXG5leHBvcnQgeyBDb21wb3NpdGlvblN0eWxlXyB9IGZyb20gJy4vc3R5bGUvQ29tcG9zaXRpb25TdHlsZV8uanMnXG5leHBvcnQgeyBTZWdtZW50U3R5bGUgfSBmcm9tICcuL3N0eWxlL1NlZ21lbnRTdHlsZS5qcydcbmV4cG9ydCB7IFRleHRTdHlsZSB9IGZyb20gJy4vc3R5bGUvVGV4dFN0eWxlLmpzJ1xuZXhwb3J0IHsgUGlsbGFyU3R5bGUgfSBmcm9tICcuL3N0eWxlL1BpbGxhclN0eWxlLmpzJ1xuZXhwb3J0IHsgU2lkZVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9TaWRlU3R5bGUuanMnXG5leHBvcnQgeyBDb250b3VyU3R5bGUgfSBmcm9tICcuL3N0eWxlL0NvbnRvdXJTdHlsZS5qcydcbmV4cG9ydCB7IFNpZGVDYXRTdHlsZSB9IGZyb20gJy4vc3R5bGUvU2lkZUNhdFN0eWxlLmpzJ1xuZXhwb3J0IHsgRG90RGVuc2l0eVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9Eb3REZW5zaXR5U3R5bGUuanMnXG5leHBvcnQgeyBUYW5ha2FTdHlsZSB9IGZyb20gJy4vc3R5bGUvVGFuYWthU3R5bGUuanMnXG5leHBvcnQgeyBMZWdvU3R5bGUgfSBmcm9tICcuL3N0eWxlL0xlZ29TdHlsZS5qcydcbmV4cG9ydCB7IFNxdWFyZUNvbG9yV0dMU3R5bGUgfSBmcm9tICcuL3N0eWxlL1NxdWFyZUNvbG9yV0dMU3R5bGUuanMnXG5leHBvcnQgeyBTcXVhcmVDb2xvckNhdFdHTFN0eWxlIH0gZnJvbSAnLi9zdHlsZS9TcXVhcmVDb2xvckNhdFdHTFN0eWxlLmpzJ1xuZXhwb3J0IHsgTW9zYWljU3R5bGUgfSBmcm9tICcuL3N0eWxlL01vc2FpY1N0eWxlLmpzJ1xuZXhwb3J0IHsgTmluamFTdGFyU3R5bGUgfSBmcm9tICcuL3N0eWxlL05pbmphU3RhclN0eWxlLmpzJ1xuZXhwb3J0IHsgVGltZVNlcmllc1N0eWxlIH0gZnJvbSAnLi9zdHlsZS9UaW1lU2VyaWVzU3R5bGUuanMnXG5leHBvcnQgeyBJc29GZW5jZVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9Jc29GZW5jZVN0eWxlLmpzJ1xuXG4vLyBleHBvcnQgYWRkaXRpb25hbCBsYXllcnNcbmV4cG9ydCB7IEJhY2tncm91bmRMYXllciB9IGZyb20gJy4vQmFja2dyb3VuZExheWVyLmpzJ1xuZXhwb3J0IHsgQmFja2dyb3VuZExheWVyV01TIH0gZnJvbSAnLi9CYWNrZ3JvdW5kTGF5ZXJXTVMuanMnXG5leHBvcnQgeyBMYWJlbExheWVyIH0gZnJvbSAnLi9MYWJlbExheWVyLmpzJ1xuZXhwb3J0IHsgTGluZUxheWVyIGFzIEJvdW5kYXJ5TGF5ZXIgfSBmcm9tICcuL0xpbmVMYXllci5qcydcblxuLy8gZXhwb3J0IGxlZ2VuZHNcbmV4cG9ydCB7IENvbG9yTGVnZW5kIH0gZnJvbSAnLi9sZWdlbmQvQ29sb3JMZWdlbmQuanMnXG5leHBvcnQgeyBDb2xvckRpc2NyZXRlTGVnZW5kIH0gZnJvbSAnLi9sZWdlbmQvQ29sb3JEaXNjcmV0ZUxlZ2VuZC5qcydcbmV4cG9ydCB7IENvbG9yQ2F0ZWdvcnlMZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC9Db2xvckNhdGVnb3J5TGVnZW5kLmpzJ1xuZXhwb3J0IHsgU2l6ZUxlZ2VuZCB9IGZyb20gJy4vbGVnZW5kL1NpemVMZWdlbmQuanMnXG5leHBvcnQgeyBTZWdtZW50V2lkdGhMZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC9TZWdtZW50V2lkdGhMZWdlbmQuanMnXG5leHBvcnQgeyBTZWdtZW50T3JpZW50YXRpb25MZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC9TZWdtZW50T3JpZW50YXRpb25MZWdlbmQuanMnXG5cbi8vIGV4cG9ydCB7IGdvVG9TdHJhaWdodCwgem9vbVRvIH0gZnJvbSBcIi4vdXRpbHMvem9vbVV0aWxzXCJcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvc3RyZXRjaGluZy5qcydcblxuZXhwb3J0IHsgZ2V0Q2xhc3MgfSBmcm9tICcuL3V0aWxzL1V0aWxzLmpzJ1xuXG5cblxuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi9HZW9DYW52YXMuanMnXG5leHBvcnQgY29uc3QgZ2V0UGFyYW1ldGVyQnlOYW1lID0gR2VvQ2FudmFzLmdldFBhcmFtZXRlckJ5TmFtZVxuXG4vLyBzZXQgZGVmYXVsdCBkMyBsb2NhbGVcbmltcG9ydCB7IGZvcm1hdERlZmF1bHRMb2NhbGUgfSBmcm9tICdkMy1mb3JtYXQnXG5mb3JtYXREZWZhdWx0TG9jYWxlKHtcbiAgICBkZWNpbWFsOiAnLicsXG4gICAgdGhvdXNhbmRzOiAnICcsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogWycnLCAn4oKsJ10sXG59KVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9MZWdlbmQuanMnXG5cbi8qKlxuICogQSBsZWdlbmQgZWxlbWVudCBmb3IgY29sb3IgY2F0ZWdyb3JpZXMuXG4gKlxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgQ29sb3JDYXRlZ29yeUxlZ2VuZCBleHRlbmRzIExlZ2VuZCB7XG4gICAgLyoqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8vY29sL2NhdGVnb3JpZXMgYXJyYXksIGluIGRpc3BsYXkgb3JkZXJcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPHN0cmluZz4+fSAqL1xuICAgICAgICB0aGlzLmNvbENhdCA9IG9wdHMuY29sQ2F0IHx8IFtbJ2dyYXknLCAnLSddXVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vU3R5bGVcIikuU2hhcGV9ICovXG4gICAgICAgIHRoaXMuc2hhcGUgPSBvcHRzLnNoYXBlIHx8ICdjaXJjbGUnXG4gICAgICAgIHRoaXMuZGltZW5zaW9uID0gb3B0cy5kaW1lbnNpb24gfHwgeyByOiA4IH1cbiAgICAgICAgdGhpcy5zdHJva2VDb2xvciA9IG9wdHMuc3Ryb2tlQ29sb3IgfHwgJ2dyYXknXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoIHx8IDFcblxuICAgICAgICB0aGlzLnRpdGxlID0gb3B0cy50aXRsZVxuICAgICAgICB0aGlzLnRpdGxlRm9udFNpemUgPSBvcHRzLnRpdGxlRm9udFNpemUgfHwgJzAuOGVtJ1xuICAgICAgICB0aGlzLnRpdGxlRm9udFdlaWdodCA9IG9wdHMudGl0bGVGb250V2VpZ2h0IHx8ICdib2xkJ1xuXG4gICAgICAgIC8vbGFiZWxcbiAgICAgICAgdGhpcy5sYWJlbEZvbnRTaXplID0gb3B0cy5sYWJlbEZvbnRTaXplIHx8ICcwLjhlbSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3sgc3R5bGU6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0eWxlLCByOiBudW1iZXIsIHpmOiBudW1iZXIsIHNTaXplOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0LCBzQ29sb3I6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXQgfX0gb3B0c1xuICAgICAqL1xuICAgIHVwZGF0ZShvcHRzKSB7XG4gICAgICAgIC8vY2xlYXJcbiAgICAgICAgdGhpcy5kaXYuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcblxuICAgICAgICAvL2J1aWxkXG5cbiAgICAgICAgLy90aXRsZVxuICAgICAgICBpZiAodGhpcy50aXRsZSlcbiAgICAgICAgICAgIHRoaXMuZGl2XG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMudGl0bGVGb250U2l6ZSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtd2VpZ2h0JywgdGhpcy50aXRsZUZvbnRXZWlnaHQpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4tYm90dG9tJywgJzdweCcpXG4gICAgICAgICAgICAgICAgLnRleHQodGhpcy50aXRsZSlcblxuICAgICAgICAvL2NhdGVnb3JpZXNcbiAgICAgICAgY29uc3QgbmIgPSB0aGlzLmNvbENhdC5sZW5ndGhcbiAgICAgICAgaWYgKG5iID09IDApIHJldHVyblxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdGhpcy5jb2xDYXRbaV1cblxuICAgICAgICAgICAgLy9tYWtlIGRpdiBmb3IgY2F0ZWdvcnlcbiAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLmRpdi5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAvL3RvIGVuYWJsZSB2ZXJ0aWNhbCBjZW50ZXJpbmdcbiAgICAgICAgICAgIC8vLnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKVxuXG4gICAgICAgICAgICBjb25zdCBzdyA9IHRoaXMuc3Ryb2tlV2lkdGhcblxuICAgICAgICAgICAgLy9kcmF3IGdyYXBoaWMgZWxlbWVudDogYm94IC8gY2lyY2xlXG4gICAgICAgICAgICBpZiAodGhpcy5zaGFwZSA9PT0gJ3NxdWFyZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gdGhpcy5kaW1lbnNpb24uaCB8fCAxNVxuICAgICAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLmRpbWVuc2lvbi53IHx8IDIwXG4gICAgICAgICAgICAgICAgZC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICdpbmxpbmUnKVxuXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3N2ZycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHcgKyAyICogc3cpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoICsgMiAqIHN3KVxuXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHN3KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHN3KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB3KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY2F0WzBdKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRoaXMuc3Ryb2tlQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5zdHJva2VXaWR0aClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5kaW1lbnNpb24uciB8fCA4XG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IDIgKiByICsgMiAqIHN3XG4gICAgICAgICAgICAgICAgZC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICdpbmxpbmUnKVxuXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3N2ZycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoKVxuXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIHIgKyBzdylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgciArIHN3KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncicsIHIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGNhdFswXSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB0aGlzLnN0cm9rZUNvbG9yKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHRoaXMuc3Ryb2tlV2lkdGgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzaGFwZTonICsgdGhpcy5zaGFwZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy93cml0ZSBsYWJlbCB0ZXh0XG4gICAgICAgICAgICBkLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAvL3Nob3cgb24gcmlnaHQgb2YgZ3JhcGhpY1xuICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICdpbmxpbmUnKVxuXG4gICAgICAgICAgICAgICAgLy9jZW50ZXIgdmVydGljYWxseVxuICAgICAgICAgICAgICAgIC8vLnN0eWxlKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKS5zdHlsZShcInRvcFwiLCBcIjBcIikuc3R5bGUoXCJib3R0b21cIiwgXCIwXCIpXG5cbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3BhZGRpbmctbGVmdCcsICc1cHgnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy5sYWJlbEZvbnRTaXplKVxuICAgICAgICAgICAgICAgIC50ZXh0KGNhdFsxXSlcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vTGVnZW5kLmpzJ1xuXG4vKipcbiAqIEEgbGVnZW5kIGVsZW1lbnQgZm9yIGRpc2NyZXRlIGNvbG9yIHN0eWxlLlxuICogSW5zcGlyYXRpb246IGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AZDMvY29sb3ItbGVnZW5kXG4gKlxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgQ29sb3JEaXNjcmV0ZUxlZ2VuZCBleHRlbmRzIExlZ2VuZCB7XG4gICAgLyoqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBAcHJpdmF0ZSBAdHlwZSB7QXJyYXkuPEFycmF5LjxzdHJpbmc+Pn0gKi9cbiAgICAgICAgdGhpcy5jb2xvcnMgPSBvcHRzLmNvbG9yc1xuICAgICAgICAvKiogQHByaXZhdGUgQHR5cGUge0FycmF5LjxBcnJheS48c3RyaW5nPj59ICovXG4gICAgICAgIHRoaXMuYnJlYWtzVGV4dCA9IG9wdHMuYnJlYWtzVGV4dFxuXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8IDMwMFxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8IDE1XG5cbiAgICAgICAgdGhpcy50aXRsZSA9IG9wdHMudGl0bGVcbiAgICAgICAgdGhpcy50aXRsZUZvbnRTaXplID0gb3B0cy50aXRsZUZvbnRTaXplIHx8ICcwLjhlbSdcbiAgICAgICAgdGhpcy50aXRsZUZvbnRXZWlnaHQgPSBvcHRzLnRpdGxlRm9udFdlaWdodCB8fCAnYm9sZCdcblxuICAgICAgICB0aGlzLnRpY2tTaXplID0gb3B0cy50aWNrU2l6ZSB8fCAzXG5cbiAgICAgICAgLy9sYWJlbFxuICAgICAgICB0aGlzLmxhYmVsRm9udFNpemUgPSBvcHRzLmxhYmVsRm9udFNpemUgfHwgJzAuOGVtJ1xuICAgICAgICB0aGlzLmludmVydCA9IG9wdHMuaW52ZXJ0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt7IHN0eWxlOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdHlsZSwgcjogbnVtYmVyLCB6ZjogbnVtYmVyLCBzU2l6ZTogaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCwgc0NvbG9yOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0IH19IG9wdHNcbiAgICAgKi9cbiAgICB1cGRhdGUob3B0cykge1xuICAgICAgICAvL2NsZWFyXG4gICAgICAgIHRoaXMuZGl2LnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXG5cbiAgICAgICAgLy9idWlsZFxuXG4gICAgICAgIC8vdGl0bGVcbiAgICAgICAgaWYgKHRoaXMudGl0bGUpXG4gICAgICAgICAgICB0aGlzLmRpdlxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLnRpdGxlRm9udFNpemUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsIHRoaXMudGl0bGVGb250V2VpZ2h0KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLWJvdHRvbScsICc3cHgnKVxuICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMudGl0bGUpXG5cbiAgICAgICAgLy9jbGFzc2VzXG4gICAgICAgIGNvbnN0IG5iID0gdGhpcy5jb2xvcnMubGVuZ3RoXG4gICAgICAgIGlmIChuYiA9PSAwKSByZXR1cm5cbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggLyBuYlxuXG4gICAgICAgIC8vbWFrZSBzdmcgZWxlbWVudFxuICAgICAgICBjb25zdCBzdmcgPSB0aGlzLmRpdlxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMud2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQgKyB0aGlzLnRpY2tTaXplICsgMiArIDEwKVxuXG4gICAgICAgIC8vZHJhdyBncmFwaGljIGVsZW1lbnRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKykge1xuICAgICAgICAgICAgc3ZnLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBpICogdylcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdylcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgdGhpcy5jb2xvcnNbaV0pXG4gICAgICAgIH1cblxuICAgICAgICAvL3RpY2sgbGluZVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5iOyBpKyspIHtcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHcgKiBpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgdyAqIGkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgdGhpcy5oZWlnaHQgKyB0aGlzLnRpY2tTaXplKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbGFiZWxzXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmI7IGkrKykge1xuICAgICAgICAgICAgLy9wcmVwYXJlIGxhYmVsXG4gICAgICAgICAgICBzdmcuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAndGlja2xhYmVsXycgKyBpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgdyAqIGkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB0aGlzLmhlaWdodCArIHRoaXMudGlja1NpemUgKyAyKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy5sYWJlbEZvbnRTaXplKVxuICAgICAgICAgICAgICAgIC8vLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpXG4gICAgICAgICAgICAgICAgLy8uc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIkFyaWFsXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIGkgPT0gMCA/ICdzdGFydCcgOiBpID09IHRoaXMudGlja3MgLSAxID8gJ2VuZCcgOiAnbWlkZGxlJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2FsaWdubWVudC1iYXNlbGluZScsICd0b3AnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZG9taW5hbnQtYmFzZWxpbmUnLCAnaGFuZ2luZycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcbiAgICAgICAgICAgICAgICAudGV4dCh0aGlzLmJyZWFrc1RleHRbaSAtIDFdKVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9MZWdlbmQuanMnXG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdkMy1mb3JtYXQnXG5cbi8qKlxuICogQSBsZWdlbmQgZWxlbWVudCBmb3IgY29udGludW91cyBjb2xvciBzdHlsZS5cbiAqIEluc3BpcmF0aW9uOiBodHRwczovL29ic2VydmFibGVocS5jb20vQGQzL2NvbG9yLWxlZ2VuZFxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIENvbG9yTGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcbiAgICAvKiogQHBhcmFtIHtPYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgdGhpcy5jb2xvclJhbXAgPSBvcHRzLmNvbG9yUmFtcFxuXG4gICAgICAgIC8vZnVuY3Rpb24gKHRbMCwxXSwgciwgcykgLT4gdiAoZm9yIGxhYmVsIHRleHQpXG4gICAgICAgIHRoaXMuZnVuID0gb3B0cy5mdW5cblxuICAgICAgICB0aGlzLnRpdGxlID0gb3B0cy50aXRsZVxuICAgICAgICB0aGlzLnRpY2tTaXplID0gb3B0cy50aWNrU2l6ZSB8fCA2XG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8IDMwMFxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8IDE1XG4gICAgICAgIHRoaXMubWFyZ2luID0gb3B0cy5tYXJnaW4gfHwgNVxuICAgICAgICB0aGlzLnRpY2tzID0gb3B0cy50aWNrcyB8fCBNYXRoLmZsb29yKHRoaXMud2lkdGggLyA1MClcbiAgICAgICAgdGhpcy50aWNrRm9ybWF0ID0gb3B0cy50aWNrRm9ybWF0IHx8ICcsLjBmJ1xuICAgICAgICB0aGlzLnRpY2tVbml0ID0gb3B0cy50aWNrVW5pdFxuXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSBvcHRzLmZvbnRTaXplIHx8ICcwLjhlbSdcbiAgICAgICAgdGhpcy5pbnZlcnQgPSBvcHRzLmludmVydFxuXG4gICAgICAgIC8vdG8gYmUgdXNlZCBhcyBvcHRzID0+IG9wdHMuc0FscGhhIHRvIHNob3cgbGVnZW5kIG9uIGFscGhhIGNoYW5uZWxcbiAgICAgICAgdGhpcy5nZXRTdGF0cyA9IG9wdHMuZ2V0U3RhdHMgfHwgKG9wdHMgPT4gb3B0cy5zQ29sb3IpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt7IHN0eWxlOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdHlsZSwgcjogbnVtYmVyLCB6ZjogbnVtYmVyLCBzU2l6ZTogaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCwgc0NvbG9yOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0LCBzQWxwaGE6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXQgfX0gb3B0c1xuICAgICAqL1xuICAgIHVwZGF0ZShvcHRzKSB7XG4gICAgICAgIC8vY291bGQgaGFwcGVuIHdoZW4gZGF0YSBpcyBzdGlsbCBsb2FkaW5nXG4gICAgICAgIGlmICghb3B0cy5zQ29sb3IpIHJldHVyblxuXG4gICAgICAgIC8vY2xlYXJcbiAgICAgICAgdGhpcy5kaXYuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcblxuICAgICAgICBjb25zdCB0aXRsZUhlaWdodCA9IDEyXG5cbiAgICAgICAgY29uc3Qgc3ZnVyA9IHRoaXMud2lkdGggKyAyICogdGhpcy5tYXJnaW5cbiAgICAgICAgY29uc3Qgc3ZnSCA9IHRoaXMuaGVpZ2h0ICsgMyAqIHRoaXMubWFyZ2luICsgdGl0bGVIZWlnaHQgKyB0aGlzLnRpY2tTaXplICsgMTBcbiAgICAgICAgY29uc3Qgc3ZnID0gdGhpcy5kaXYuYXBwZW5kKCdzdmcnKS5hdHRyKCd3aWR0aCcsIHN2Z1cpLmF0dHIoJ2hlaWdodCcsIHN2Z0gpXG4gICAgICAgIC8vICA8cmVjdCB3aWR0aD1cIjMwMFwiIGhlaWdodD1cIjEwMFwiIHN0eWxlPVwiZmlsbDpyZ2IoMCwwLDI1NSk7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlOnJnYigwLDAsMClcIiAvPlxuXG4gICAgICAgIC8vdGl0bGVcbiAgICAgICAgc3ZnLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAuYXR0cigneCcsIHRoaXMubWFyZ2luKVxuICAgICAgICAgICAgLmF0dHIoJ3knLCB0aGlzLm1hcmdpbilcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzAuOGVtJylcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC13ZWlnaHQnLCAnYm9sZCcpXG4gICAgICAgICAgICAuc3R5bGUoJ2FsaWdubWVudC1iYXNlbGluZScsICd0b3AnKVxuICAgICAgICAgICAgLnN0eWxlKCdkb21pbmFudC1iYXNlbGluZScsICdoYW5naW5nJylcbiAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG4gICAgICAgICAgICAudGV4dCh0aGlzLnRpdGxlKVxuXG4gICAgICAgIGNvbnN0IGcgPSBzdmdcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHRoaXMubWFyZ2luICsgJyAnICsgKDIgKiB0aGlzLm1hcmdpbiArIHRpdGxlSGVpZ2h0KSArICcpJylcblxuICAgICAgICAvL2RyYXcgY29sb3IgYmFyXG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0XG4gICAgICAgIGNvbnN0IHN0ZXAgPSA1XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICBsZXQgdCA9IGkgLyAodyAtIDEpXG4gICAgICAgICAgICBpZiAodGhpcy5pbnZlcnQpIHQgPSAxIC0gdFxuICAgICAgICAgICAgZy5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgaSlcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc3RlcClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaClcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCB0aGlzLmNvbG9yUmFtcCh0KSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50aWNrczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdCA9IGkgLyAodGhpcy50aWNrcyAtIDEpXG5cbiAgICAgICAgICAgIC8vdGljayBsaW5lXG4gICAgICAgICAgICBnLmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgdyAqIHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMClcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3ICogdClcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBoICsgdGhpcy50aWNrU2l6ZSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdibGFjaycpXG5cbiAgICAgICAgICAgIC8vcHJlcGFyZSB0aWNrIGxhYmVsXG4gICAgICAgICAgICBnLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3RpY2tsYWJlbF8nICsgaSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHcgKiB0KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgaCArIHRoaXMudGlja1NpemUgKyAyKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy5mb250U2l6ZSlcbiAgICAgICAgICAgICAgICAvLy5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxuICAgICAgICAgICAgICAgIC8vLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJBcmlhbFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCBpID09IDAgPyAnc3RhcnQnIDogaSA9PSB0aGlzLnRpY2tzIC0gMSA/ICdlbmQnIDogJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAndG9wJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2RvbWluYW50LWJhc2VsaW5lJywgJ2hhbmdpbmcnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG4gICAgICAgICAgICAvLy50ZXh0KFwiLVwiKVxuICAgICAgICB9XG5cbiAgICAgICAgLy91cGRhdGUgdGljayBsYWJlbHNcblxuICAgICAgICAvL2xhYmVsIHRleHQgZm9ybWF0XG4gICAgICAgIGNvbnN0IGYgPSB0aGlzLnRpY2tGb3JtYXQgJiYgdGhpcy50aWNrRm9ybWF0ICE9ICd0ZXh0JyA/IGZvcm1hdCh0aGlzLnRpY2tGb3JtYXQpIDogKHYpID0+IHZcbiAgICAgICAgY29uc3Qgc3RhdCA9IHRoaXMuZ2V0U3RhdHMob3B0cylcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRpY2tzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0ID0gaSAvICh0aGlzLnRpY2tzIC0gMSlcblxuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuZnVuKHQsIG9wdHMuciwgc3RhdClcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSAodiA/IGYodikgOiAnMCcpICsgKHRoaXMudGlja1VuaXQgPyB0aGlzLnRpY2tVbml0IDogJycpXG5cbiAgICAgICAgICAgIC8vdGljayBsYWJlbFxuICAgICAgICAgICAgdGhpcy5kaXYuc2VsZWN0KCcjJyArICd0aWNrbGFiZWxfJyArIGkpLnRleHQodGV4dClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vTGVnZW5kLmpzJ1xuXG4vKipcbiAqIEEgbGVnZW5kIGVsZW1lbnQgZm9yIHNlZ21lbnQgb3JpZW50YXRpb24uXG4gKlxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgU2VnbWVudE9yaWVudGF0aW9uTGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcbiAgICAvKiogQHBhcmFtIHtPYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLy90aXRsZVxuICAgICAgICB0aGlzLnRpdGxlID0gb3B0cy50aXRsZVxuICAgICAgICB0aGlzLnRpdGxlRm9udFNpemUgPSBvcHRzLnRpdGxlRm9udFNpemUgfHwgJzAuOGVtJ1xuICAgICAgICB0aGlzLnRpdGxlRm9udFdlaWdodCA9IG9wdHMudGl0bGVGb250V2VpZ2h0IHx8ICdib2xkJ1xuXG4gICAgICAgIC8vZXhhZ2VyYXRpb25cbiAgICAgICAgdGhpcy5leGFnZ2VyYXRpb25GYWN0b3IgPSBvcHRzLmV4YWdnZXJhdGlvbkZhY3RvciB8fCAwLjVcblxuICAgICAgICAvL2NvbG9yXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICdncmF5J1xuICAgICAgICAvL29yaWVudGF0aW9uXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSBvcHRzLm9yaWVudGF0aW9uIHx8IDBcbiAgICAgICAgLy93aWR0aFxuICAgICAgICB0aGlzLndpZHRoUGl4ID0gb3B0cy53aWR0aFBpeCB8fCAzXG5cbiAgICAgICAgLy9sYWJlbFxuICAgICAgICB0aGlzLmxhYmVsRm9udFNpemUgPSBvcHRzLmxhYmVsRm9udFNpemUgfHwgJzAuOGVtJ1xuICAgICAgICB0aGlzLmxhYmVsVW5pdFRleHQgPSBvcHRzLmxhYmVsVW5pdFRleHQgfHwgJydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3sgc3R5bGU6IGltcG9ydChcIi4uL3N0eWxlL1NlZ21lbnRTdHlsZVwiKS5TZWdtZW50U3R5bGUsIHI6IG51bWJlciwgemY6IG51bWJlciwgc0NvbG9yOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0LCBzTGVuZ3RoOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0LCBzV2lkdGg6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXQgfX0gb3B0c1xuICAgICAqL1xuICAgIHVwZGF0ZShvcHRzKSB7XG4gICAgICAgIC8vY291bGQgaGFwcGVuIHdoZW4gZGF0YSBpcyBzdGlsbCBsb2FkaW5nXG4gICAgICAgIGlmICghb3B0cy5zV2lkdGgpIHJldHVyblxuXG4gICAgICAgIC8vY2xlYXJcbiAgICAgICAgdGhpcy5kaXYuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcblxuICAgICAgICBjb25zdCBkID0gdGhpcy5kaXYuYXBwZW5kKCdkaXYnKVxuXG4gICAgICAgIC8vdGl0bGVcbiAgICAgICAgaWYgKHRoaXMudGl0bGUpIHtcbiAgICAgICAgICAgIGQuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd0aXRsZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLnRpdGxlRm9udFNpemUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsIHRoaXMudGl0bGVGb250V2VpZ2h0KVxuICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMudGl0bGUpXG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbXB1dGUgc2VnbWVudCB3aWR0aCBhbmQgbGVuZ3RoLCBpbiBwaXhcbiAgICAgICAgY29uc3Qgc1dpZHRoID0gdGhpcy53aWR0aFBpeFxuICAgICAgICBjb25zdCBzTGVuZ3RoID0gKDEgKiBvcHRzLnIpIC8gb3B0cy56ZlxuXG4gICAgICAgIC8vZHJhdyBTVkcgc2VnbWVudFxuICAgICAgICBjb25zdCBzdmdTID0gTWF0aC5tYXgoc0xlbmd0aCwgc1dpZHRoKVxuICAgICAgICBjb25zdCBzdmcgPSBkLmFwcGVuZCgnc3ZnJykuYXR0cignd2lkdGgnLCBzdmdTKS5hdHRyKCdoZWlnaHQnLCBzdmdTKS5zdHlsZSgnJywgJ2lubGluZS1ibG9jaycpXG5cbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoKC10aGlzLm9yaWVudGF0aW9uICogTWF0aC5QSSkgLyAxODApXG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKCgtdGhpcy5vcmllbnRhdGlvbiAqIE1hdGguUEkpIC8gMTgwKVxuICAgICAgICBjb25zdCBkYyA9IHN2Z1MgKiAwLjUsXG4gICAgICAgICAgICBsMiA9IHNMZW5ndGggKiAwLjVcbiAgICAgICAgc3ZnLmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgICAuYXR0cigneDEnLCBkYyAtIGNvcyAqIGwyKVxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgZGMgLSBzaW4gKiBsMilcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIGRjICsgY29zICogbDIpXG4gICAgICAgICAgICAuYXR0cigneTInLCBkYyArIHNpbiAqIGwyKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB0aGlzLmNvbG9yKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBzV2lkdGgpXG5cbiAgICAgICAgLy90ZXh0IGxhYmVsXG4gICAgICAgIGQuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLy9zaG93IG9uIHJpZ2h0IG9mIHN2Z1xuICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgJ2lubGluZScpXG4gICAgICAgICAgICAuc3R5bGUoJ3BhZGRpbmctbGVmdCcsICc1cHgnKVxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpXG4gICAgICAgICAgICAvLy5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxuICAgICAgICAgICAgLnRleHQodGhpcy5sYWJlbFVuaXRUZXh0KVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vTGVnZW5kLmpzJ1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xuXG4vKipcbiAqIEEgbGVnZW5kIGVsZW1lbnQgZm9yIHNlZ21lbnQgd2lkdGguXG4gKlxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgU2VnbWVudFdpZHRoTGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcbiAgICAvKiogQHBhcmFtIHtPYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLy90aXRsZVxuICAgICAgICB0aGlzLnRpdGxlID0gb3B0cy50aXRsZVxuICAgICAgICB0aGlzLnRpdGxlRm9udFNpemUgPSBvcHRzLnRpdGxlRm9udFNpemUgfHwgJzAuOGVtJ1xuICAgICAgICB0aGlzLnRpdGxlRm9udFdlaWdodCA9IG9wdHMudGl0bGVGb250V2VpZ2h0IHx8ICdib2xkJ1xuXG4gICAgICAgIC8vZXhhZ2VyYXRpb25cbiAgICAgICAgLy9pZiBzZXQgdG8gMSwgdGhlIHNlZ21lbnQgd2lkdGggaW4gdGhlIGxlZ2VuZCB3aWxsIGJlIHRoZSBvbmUgb2YgdGhlIG1heGltdW0gd2lkdGggb24gdGhlIG1hcFxuICAgICAgICB0aGlzLmV4YWdnZXJhdGlvbkZhY3RvciA9IG9wdHMuZXhhZ2dlcmF0aW9uRmFjdG9yIHx8IDAuNVxuXG4gICAgICAgIC8vY29sb3Igb2YgdGhlIHNlZ21lbnQgaW4gdGhlIGxlZ2VuZFxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAnZ3JheSdcbiAgICAgICAgLy9vcmllbnRhdGlvbiBvZiB0aGUgc2VnbWVudCBpbiB0aGUgbGVnZW5kXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSBvcHRzLm9yaWVudGF0aW9uIHx8IDBcblxuICAgICAgICAvL2xhYmVsXG4gICAgICAgIHRoaXMubGFiZWxGb250U2l6ZSA9IG9wdHMubGFiZWxGb250U2l6ZSB8fCAnMC44ZW0nXG4gICAgICAgIHRoaXMubGFiZWxVbml0VGV4dCA9IG9wdHMubGFiZWxVbml0VGV4dCB8fCAnJ1xuXG4gICAgICAgIC8vc2VnbWVudCBsZW5ndGggaW4gZ2VvIHVuaXQgLSBhIGZ1bmN0aW9uIG9mIHRoZSByZXNvbHV0aW9uIHIgYW5kIHpvb20gbGV2ZWwgemZcbiAgICAgICAgdGhpcy5sZW5ndGhGdW4gPSBvcHRzLmxlbmd0aEV4YWdnZXJhdGlvbkZhY3RvciB8fCAoKHIsIHpmKSA9PiByKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7eyBzdHlsZTogaW1wb3J0KFwiLi4vc3R5bGUvU2VnbWVudFN0eWxlXCIpLlNlZ21lbnRTdHlsZSwgcjogbnVtYmVyLCB6ZjogbnVtYmVyLCBzQ29sb3I6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXQsIHNMZW5ndGg6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXQsIHNXaWR0aDogaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCB9fSBvcHRzXG4gICAgICovXG4gICAgdXBkYXRlKG9wdHMpIHtcbiAgICAgICAgLy9jb3VsZCBoYXBwZW4gd2hlbiBkYXRhIGlzIHN0aWxsIGxvYWRpbmdcbiAgICAgICAgaWYgKCFvcHRzLnNXaWR0aCkgcmV0dXJuXG5cbiAgICAgICAgLy9jbGVhclxuICAgICAgICB0aGlzLmRpdi5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxuXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmRpdi5hcHBlbmQoJ2RpdicpXG5cbiAgICAgICAgLy90aXRsZVxuICAgICAgICBpZiAodGhpcy50aXRsZSkge1xuICAgICAgICAgICAgZC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RpdGxlJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMudGl0bGVGb250U2l6ZSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtd2VpZ2h0JywgdGhpcy50aXRsZUZvbnRXZWlnaHQpXG4gICAgICAgICAgICAgICAgLnRleHQodGhpcy50aXRsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZ2V0IHNlZ21lbnQgbWF4IHZhbHVlXG4gICAgICAgIGNvbnN0IHZhbHVlXyA9IG9wdHMuc1dpZHRoLm1heCAqIHRoaXMuZXhhZ2dlcmF0aW9uRmFjdG9yXG4gICAgICAgIC8vbWFrZSAnbmljZScgdmFsdWUgKHBvd2VyIG9mIHRlbiwgb3IgbXVsdGlwbGUpXG4gICAgICAgIGxldCBwb3cxMCA9IE1hdGgubG9nMTAodmFsdWVfKVxuICAgICAgICBwb3cxMCA9IE1hdGguZmxvb3IocG93MTApXG4gICAgICAgIGxldCB2YWx1ZSA9IE1hdGgucG93KDEwLCBwb3cxMClcbiAgICAgICAgaWYgKHZhbHVlICogOCA8PSB2YWx1ZV8pIHZhbHVlICo9IDhcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgKiA2IDw9IHZhbHVlXykgdmFsdWUgKj0gNlxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAqIDUgPD0gdmFsdWVfKSB2YWx1ZSAqPSA1XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICogNCA8PSB2YWx1ZV8pIHZhbHVlICo9IDRcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgKiAyLjUgPD0gdmFsdWVfKSB2YWx1ZSAqPSAyLjVcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgKiAyIDw9IHZhbHVlXykgdmFsdWUgKj0gMlxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAqIDEuNSA8PSB2YWx1ZV8pIHZhbHVlICo9IDEuNVxuXG4gICAgICAgIC8vY29tcHV0ZSBzZWdtZW50IHdpZHRoIGFuZCBsZW5ndGgsIGluIHBpeFxuICAgICAgICBjb25zdCBzV2lkdGggPSBvcHRzLndpZHRoRnVuKHZhbHVlLCBvcHRzLnIsIG9wdHMuc1dpZHRoLCBvcHRzLnpmKSAvIG9wdHMuemZcbiAgICAgICAgY29uc3Qgc0xlbmd0aCA9IHRoaXMubGVuZ3RoRnVuKG9wdHMuciwgb3B0cy56ZikgLyBvcHRzLnpmXG5cbiAgICAgICAgLy9UT0RPIHVzZSBvcmllbnRhdGlvblxuXG4gICAgICAgIGNvbnN0IHN2ZyA9IGQuYXBwZW5kKCdzdmcnKS5hdHRyKCd3aWR0aCcsIHNMZW5ndGgpLmF0dHIoJ2hlaWdodCcsIHNXaWR0aCkuc3R5bGUoJycsICdpbmxpbmUtYmxvY2snKVxuXG4gICAgICAgIC8vPGxpbmUgeDE9XCIwXCIgeTE9XCIwXCIgeDI9XCIyMDBcIiB5Mj1cIjIwMFwiIHN0eWxlPVwic3Ryb2tlOnJnYigyNTUsMCwwKTtzdHJva2Utd2lkdGg6MlwiIC8+XG4gICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIHNXaWR0aCAvIDIpXG4gICAgICAgICAgICAuYXR0cigneDInLCBzTGVuZ3RoKVxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgc1dpZHRoIC8gMilcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgdGhpcy5jb2xvcilcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgc1dpZHRoKVxuXG4gICAgICAgIGNvbnN0IHZhbHVlVCA9IGZvcm1hdCgnLC4ycicpKHZhbHVlKVxuICAgICAgICBkLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC8vc2hvdyBvbiByaWdodCBvZiBncmFwaGljXG4gICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnaW5saW5lJylcbiAgICAgICAgICAgIC5zdHlsZSgncGFkZGluZy1sZWZ0JywgJzVweCcpXG4gICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMubGFiZWxGb250U2l6ZSlcbiAgICAgICAgICAgIC8vLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpXG4gICAgICAgICAgICAudGV4dCh2YWx1ZVQgKyAodGhpcy5sYWJlbFVuaXRUZXh0ID8gJyAnIDogJycpICsgdGhpcy5sYWJlbFVuaXRUZXh0KVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vTGVnZW5kLmpzJ1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xuXG4vKipcbiAqIEEgbGVnZW5kIGVsZW1lbnQgZm9yIHByb3BvcnRpb25hbCBzeW1ib2xzLlxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVMZWdlbmQgZXh0ZW5kcyBMZWdlbmQge1xuICAgIC8qKiBAcGFyYW0ge09iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvL2V4YWdlcmF0aW9uXG4gICAgICAgIHRoaXMuZXhhZ2dlcmF0aW9uRmFjdG9yID0gb3B0cy5leGFnZ2VyYXRpb25GYWN0b3IgfHwgMC44XG5cbiAgICAgICAgLy9pZiB2YWx1ZSBpcyB0byBiZSBmb3JjZWRcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9wdHMudmFsdWUgfHwgdW5kZWZpbmVkXG5cbiAgICAgICAgLy90aXRsZVxuICAgICAgICB0aGlzLnRpdGxlID0gb3B0cy50aXRsZVxuICAgICAgICB0aGlzLnRpdGxlRm9udFNpemUgPSBvcHRzLnRpdGxlRm9udFNpemUgfHwgJzAuOGVtJ1xuICAgICAgICB0aGlzLnRpdGxlRm9udFdlaWdodCA9IG9wdHMudGl0bGVGb250V2VpZ2h0IHx8ICdib2xkJ1xuXG4gICAgICAgIC8vc3ltYm9sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vU3R5bGVcIikuU2hhcGV9ICovXG4gICAgICAgIHRoaXMuc2hhcGUgPSBvcHRzLnNoYXBlIHx8ICdjaXJjbGUnXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gb3B0cy5maWxsQ29sb3IgfHwgJ25vbmUnXG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBvcHRzLnN0cm9rZUNvbG9yIHx8ICdncmF5J1xuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aCB8fCAxXG5cbiAgICAgICAgLy9sYWJlbFxuICAgICAgICB0aGlzLmxhYmVsRm9udFNpemUgPSBvcHRzLmxhYmVsRm9udFNpemUgfHwgJzAuOGVtJ1xuICAgICAgICB0aGlzLmxhYmVsVW5pdFRleHQgPSBvcHRzLmxhYmVsVW5pdFRleHQgfHwgJydcbiAgICAgICAgdGhpcy5sYWJlbEZvcm1hdCA9IG9wdHMubGFiZWxGb3JtYXQgfHwgJywuMnInXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy90aGlzLmRpdi5zdHlsZShcInRleHQtYWxpZ25cIiwgXCJjZW50ZXJcIilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3sgc3R5bGU6IGltcG9ydChcIi4uL3N0eWxlL1NoYXBlQ29sb3JTaXplU3R5bGVcIikuU2hhcGVDb2xvclNpemVTdHlsZSwgcjogbnVtYmVyLCB6ZjogbnVtYmVyLCBzU2l6ZTogaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCwgc0NvbG9yOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0IH19IG9wdHNcbiAgICAgKi9cbiAgICB1cGRhdGUob3B0cykge1xuICAgICAgICAvL2NvdWxkIGhhcHBlbiB3aGVuIGRhdGEgaXMgc3RpbGwgbG9hZGluZ1xuICAgICAgICBpZiAoIW9wdHMuc1NpemUpIHJldHVyblxuXG4gICAgICAgIC8vY2xlYXJcbiAgICAgICAgdGhpcy5kaXYuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcblxuICAgICAgICAvL2dldCB2YWx1ZVxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnZhbHVlXG4gICAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vY29tcHV0ZSAnbmljZSB2YWx1ZVxuXG4gICAgICAgICAgICAvL2dldCBtYXggdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlXyA9IG9wdHMuc1NpemUubWF4ICogdGhpcy5leGFnZ2VyYXRpb25GYWN0b3JcblxuICAgICAgICAgICAgLy90YWtlICduaWNlJyB2YWx1ZSAocG93ZXIgb2YgdGVuLCBvciBtdWx0aXBsZSlcbiAgICAgICAgICAgIGxldCBwb3cxMCA9IE1hdGgubG9nMTAodmFsdWVfKVxuICAgICAgICAgICAgcG93MTAgPSBNYXRoLmZsb29yKHBvdzEwKVxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnBvdygxMCwgcG93MTApXG4gICAgICAgICAgICBpZiAodmFsdWUgKiA4IDw9IHZhbHVlXykgdmFsdWUgKj0gOFxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgKiA2IDw9IHZhbHVlXykgdmFsdWUgKj0gNlxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgKiA1IDw9IHZhbHVlXykgdmFsdWUgKj0gNVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgKiA0IDw9IHZhbHVlXykgdmFsdWUgKj0gNFxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgKiAyLjUgPD0gdmFsdWVfKSB2YWx1ZSAqPSAyLjVcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICogMiA8PSB2YWx1ZV8pIHZhbHVlICo9IDJcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmFsdWUpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmRpdi5hcHBlbmQoJ2RpdicpXG4gICAgICAgIC8vdG8gZW5hYmxlIHZlcnRpY2FsIGNlbnRlcmluZ1xuICAgICAgICAvLy5zdHlsZShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIilcblxuICAgICAgICAvL3RpdGxlXG4gICAgICAgIGlmICh0aGlzLnRpdGxlKSB7XG4gICAgICAgICAgICBkLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndGl0bGUnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy50aXRsZUZvbnRTaXplKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC13ZWlnaHQnLCB0aGlzLnRpdGxlRm9udFdlaWdodClcbiAgICAgICAgICAgICAgICAudGV4dCh0aGlzLnRpdGxlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9jb21wdXRlIHNpemUgb2Ygc3ltYm9sLCBpbiBwaXhcbiAgICAgICAgY29uc3Qgc2l6ZSA9IG9wdHMuc3R5bGUuc2l6ZSh2YWx1ZSwgb3B0cy5yLCBvcHRzLnNTaXplLCBvcHRzLnpmKSAvIG9wdHMuemZcblxuICAgICAgICBjb25zdCBzdmcgPSBkXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc2l6ZSArIHRoaXMuc3Ryb2tlV2lkdGggKyAyKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHNpemUgKyB0aGlzLnN0cm9rZVdpZHRoICsgMilcbiAgICAgICAgICAgIC5zdHlsZSgnJywgJ2lubGluZS1ibG9jaycpXG5cbiAgICAgICAgaWYgKHRoaXMuc2hhcGUgPT09ICdzcXVhcmUnKSB7XG4gICAgICAgICAgICBzdmcuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHNpemUpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHNpemUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgdGhpcy5maWxsQ29sb3IpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB0aGlzLnN0cm9rZUNvbG9yKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5zdHJva2VXaWR0aClcbiAgICAgICAgICAgIC8vVE9ETyB0ZXN0XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgIC8vIDxjaXJjbGUgY3g9XCI1MFwiIGN5PVwiNTBcIiByPVwiNDBcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjNcIiBmaWxsPVwicmVkXCIgLz5cbiAgICAgICAgICAgIGNvbnN0IHIgPSAoc2l6ZSArIHRoaXMuc3Ryb2tlV2lkdGgpICogMC41XG4gICAgICAgICAgICBzdmcuYXBwZW5kKCdjaXJjbGUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIHIgKyAxKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIHIgKyAxKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgcilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCB0aGlzLmZpbGxDb2xvcilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRoaXMuc3Ryb2tlQ29sb3IpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0cm9rZVdpZHRoKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2hhcGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgICAgIC8vVE9ET1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2hhcGUgPT09ICdkaWFtb25kJykge1xuICAgICAgICAgICAgLy9UT0RPXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2hhcGU6JyArIHRoaXMuc2hhcGUpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZVQgPSBmb3JtYXQodGhpcy5sYWJlbEZvcm1hdCkodmFsdWUpXG4gICAgICAgIGQuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLy9zaG93IG9uIHJpZ2h0IG9mIGdyYXBoaWNcbiAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICdpbmxpbmUnKVxuXG4gICAgICAgICAgICAvL2NlbnRlciB2ZXJ0aWNhbGx5XG4gICAgICAgICAgICAvLy5zdHlsZShcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIikuc3R5bGUoXCJ0b3BcIiwgXCIwXCIpLnN0eWxlKFwiYm90dG9tXCIsIFwiMFwiKVxuXG4gICAgICAgICAgICAuc3R5bGUoJ3BhZGRpbmctbGVmdCcsICc1cHgnKVxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpXG4gICAgICAgICAgICAudGV4dCh2YWx1ZVQgKyAodGhpcy5sYWJlbFVuaXRUZXh0ID8gJyAnIDogJycpICsgdGhpcy5sYWJlbFVuaXRUZXh0KVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcblxuLyoqIEB0eXBlZGVmIHtcImZsYWdcInxcInBpZWNoYXJ0XCJ8XCJyaW5nXCJ8XCJzZWdtZW50XCJ8XCJyYWRhclwifFwiYWdlcHlyYW1pZFwifFwiaGFsZnRvbmVcIn0gQ29tcG9zaXRpb25UeXBlICovXG5cbi8qKlxuICogQSBzdHlsZSBzaG93aW5nIHRoZSBjb21wb3NpdGlvbiBvZiBhIHRvdGFsIGluIGRpZmZlcmVudCBjYXRlZ29yaWVzLCB3aXRoIGRpZmZlcmVudCBjb2xvciBodWVzLlxuICogSXQgY29uc2lzdHMgb2YgYSBzeW1ib2wgd2l0aCBkaWZmZXJlbnQgcGFydHMsIHdob3NlIHNpemUgcmVmbGVjdCB0aGUgcHJvcG9ydGlvbiBvZiB0aGUgY29ycmVzcG9uZGluZyBjYXRlZ29yeS5cbiAqIEZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHN5bWJvbHMsIEBzZWUgQ29tcG9zaXRpb25UeXBlXG4gKiBUaGUgc3ltYm9sIGNhbiBiZSBzY2FsZWQgZGVwZW5kaW5nIG9uIHRoZSBjZWxsIGltcG9ydGFuY2UuXG4gKlxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgQ29tcG9zaXRpb25TdHlsZSBleHRlbmRzIFN0eWxlIHtcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaWN0aW9uYXJ5IChzdHJpbmcgLT4gY29sb3IpIHdoaWNoIGdpdmUgdGhlIGNvbG9yIG9mIGVhY2ggY2F0ZWdvcnkuXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9ICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB0eXBlIG9mIGRlY29tcG9zaXRpb24gc3ltYm9sIG9mIGEgY2VsbCwgQHNlZSBDb21wb3NpdGlvblR5cGVcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbCk6Q29tcG9zaXRpb25UeXBlfSAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBvcHRzLnR5cGVcblxuICAgICAgICAvKiogVGhlIGNvbHVtbiB3aGVyZSB0byBnZXQgdGhlIHNpemUgdmFsdWVzLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnNpemVDb2wgPSBvcHRzLnNpemVDb2xcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgYSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplIHx8ICgodiwgciwgcywgemYpID0+IHIpXG5cbiAgICAgICAgLyoqIEZvciBzdHlsZSB0eXBlcyB3aXRoIHN0cmlwZXMgKGZsYWcsIHNlZ21lbnQpLCB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHN0cmlwZXMgKDAgZm9yIGhvcml6b250YWwsIG90aGVyIGZvciB2ZXJ0aWNhbCkuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGwsbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnN0cmlwZXNPcmllbnRhdGlvbiA9IG9wdHMuc3RyaXBlc09yaWVudGF0aW9uIHx8ICgoKSA9PiAwKSAvLyhjLHIsemYpID0+IC4uLlxuXG4gICAgICAgIC8qKiBUaGUgZnVuY3Rpb24gc3BlY2lmeWluZyBhbiBvZmZzZXQgYW5nbGUgZm9yIGEgcmFkYXIsIGhhbGZ0b25lIG9yIHBpZSBjaGFydCBzdHlsZS5cbiAgICAgICAgICogVGhlIGFuZ2xlIGlzIHNwZWNpZmllZCBpbiBkZWdyZWUuIFRoZSByb3RhdGlvbiBpcyBhbnRpLWNsb2Nrd2lzZS5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbCxudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMub2Zmc2V0QW5nbGUgPSBvcHRzLm9mZnNldEFuZ2xlIHx8ICgoKSA9PiAwKSAvLyhjZWxsLHIsemYpID0+IC4uLlxuXG4gICAgICAgIC8qKiBUaGUgZnVuY3Rpb24gc3BlY2lmeWluZyB0aGUgaGVpZ2h0IG9mIHRoZSBhZ2UgcHlyYW1pZCwgaW4gZ2VvIHVuaXQuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGwsbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmFnZVB5cmFtaWRIZWlnaHQgPSBvcHRzLmFnZVB5cmFtaWRIZWlnaHQgfHwgKChjLCByLCB6ZikgPT4gcikgLy8oY2VsbCxyLHpmKSA9PiAuLi5cblxuICAgICAgICAvKiogRm9yIHBpZSBjaGFydCwgdGhpcyBpcyBwYXJhbWV0ZXIgZm9yIGludGVybmFsIHJhZGl1cywgc28gdGhhdCB0aGUgcGllIGNoYXJ0IGxvb2tzIGxpa2UgYSBkb251dC5cbiAgICAgICAgICogMCBmb3Igbm9ybWFsIHBpZSBjaGFydHMsIDAuNSB0byBlbXB0eSBoYWxmIG9mIHRoZSByYWRpdXMuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMucGllQ2hhcnRJbnRlcm5hbFJhZGl1c0ZhY3RvciA9IG9wdHMucGllQ2hhcnRJbnRlcm5hbFJhZGl1c0ZhY3RvciB8fCAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBjZWxscyBhcyBzcXVhcmVzIGRlcGVuZGluZyBvbiB0aGVpciB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGNnXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL3pvb20gZmFjdG9yXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxuXG4gICAgICAgIGxldCBzdGF0XG4gICAgICAgIGlmICh0aGlzLnNpemVDb2wpIHtcbiAgICAgICAgICAgIC8vaWYgc2l6ZSBpcyB1c2VkLCBzb3J0IGNlbGxzIGJ5IHNpemUgc28gdGhhdCB0aGUgYmlnZ2VzdCBhcmUgZHJhd24gZmlyc3RcbiAgICAgICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gYzJbdGhpcy5zaXplQ29sXSAtIGMxW3RoaXMuc2l6ZUNvbF0pXG4gICAgICAgICAgICAvL2FuZCBjb21wdXRlIHN0YXRpc3RpY3NcbiAgICAgICAgICAgIHN0YXQgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLnNpemVDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9uYiBjYXRlZ29yaWVzIC0gdXNlZCBmb3IgcmFkYXIgYW5kIGFnZXB5cmFtaWRcbiAgICAgICAgY29uc3QgbmJDYXQgPSBPYmplY3QuZW50cmllcyh0aGlzLmNvbG9yKS5sZW5ndGhcblxuICAgICAgICAvL2RyYXcgaW4gZ2VvIGNvb3JkaW5hdGVzXG4gICAgICAgIGNnLnNldENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgLy9kcmF3IGNhbGxzXG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgIC8vc2l6ZVxuICAgICAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICAgICAgbGV0IHNfID0gdGhpcy5zaXplIHx8ICgoKSA9PiByKVxuICAgICAgICAgICAgLy9zaXplIC0gaW4gZ2VvXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgIGNvbnN0IHNHID0gc18oY2VsbFt0aGlzLnNpemVDb2xdLCByLCBzdGF0LCB6ZilcblxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjZWxsLCByLCB6ZilcblxuICAgICAgICAgICAgLy9nZXQgc3ltYm9sIHR5cGVcbiAgICAgICAgICAgIGNvbnN0IHR5cGVfID0gdGhpcy50eXBlID8gdGhpcy50eXBlKGNlbGwpIDogJ2ZsYWcnXG5cbiAgICAgICAgICAgIC8vY29tcHV0ZSBjZW50ZXIgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IHhjID0gY2VsbC54ICsgb2Zmc2V0LmR4ICsgKHR5cGVfID09PSAnYWdlcHlyYW1pZCcgPyAwIDogciAqIDAuNSlcbiAgICAgICAgICAgIGNvbnN0IHljID0gY2VsbC55ICsgb2Zmc2V0LmR5ICsgKHR5cGVfID09PSAnYWdlcHlyYW1pZCcgPyAwIDogciAqIDAuNSlcblxuICAgICAgICAgICAgLy9jb21wdXRlIG9mZnNldCBhbmdsZSwgd2hlbiByZWxldmFudFxuICAgICAgICAgICAgY29uc3Qgb2ZmQW5nID0gdGhpcy5vZmZzZXRBbmdsZSA/ICh0aGlzLm9mZnNldEFuZ2xlKGNlbGwsIHIsIHpmKSAqIE1hdGguUEkpIC8gMTgwIDogMFxuXG4gICAgICAgICAgICBpZiAodHlwZV8gPT09ICdhZ2VweXJhbWlkJyB8fCB0eXBlXyA9PT0gJ3JhZGFyJyB8fCB0eXBlXyA9PT0gJ2hhbGZ0b25lJykge1xuICAgICAgICAgICAgICAgIC8vZ2V0IGNlbGwgY2F0ZWdvcnkgbWF4IHZhbHVlXG4gICAgICAgICAgICAgICAgbGV0IG1heFZhbCA9IC1JbmZpbml0eVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmNvbG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gK2NlbGxba2V5XVxuICAgICAgICAgICAgICAgICAgICBpZiAodiA+IG1heFZhbCkgbWF4VmFsID0gdlxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY3VtdWxcbiAgICAgICAgICAgICAgICBsZXQgY3VtdWwgPSAwXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVfID09PSAnYWdlcHlyYW1pZCcgJiYgdGhpcy5hZ2VQeXJhbWlkSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICBjdW11bCA9IChyIC0gdGhpcy5hZ2VQeXJhbWlkSGVpZ2h0KGNlbGwsIHIsIHpmKSkgLyAyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVfID09PSAncmFkYXInIHx8IHR5cGVfID09PSAnaGFsZnRvbmUnKSBjdW11bCA9IE1hdGguUEkgLyAyICsgb2ZmQW5nXG5cbiAgICAgICAgICAgICAgICAvL2NvbXB1dGUgdGhlIGluY3JlbWVudCwgd2hpY2ggaXMgdGhlIHZhbHVlIHRvIGluY3JlbWVudCB0aGUgY3VtdWwgZm9yIGVhY2ggY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNyID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZV8gPT09ICdhZ2VweXJhbWlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAodGhpcy5hZ2VQeXJhbWlkSGVpZ2h0ID8gdGhpcy5hZ2VQeXJhbWlkSGVpZ2h0KGNlbGwsIHIsIHpmKSA6IHIpIC8gbmJDYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZV8gPT09ICdyYWRhcicgfHwgdHlwZV8gPT09ICdoYWxmdG9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKDIgKiBNYXRoLlBJKSAvIG5iQ2F0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGlmIChpbmNyID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzeW1ib2wgdHlwZTonICsgdHlwZV8pXG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbY29sdW1uLCBjb2xvcl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVfID09PSAnYWdlcHlyYW1pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGNhdGVnb3J5IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sb3JcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY2F0ZWdvcnkgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNlbGxbY29sdW1uXVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgY2F0ZWdvcnkgbGVuZ3RoIC0gaW4gZ2VvXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdHID0gKHNHICogdmFsKSAvIG1heFZhbFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgYmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoeGMgKyAociAtIHdHKSAvIDIsIHljICsgY3VtdWwsIHdHLCBpbmNyKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICBjdW11bCArPSBpbmNyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZV8gPT09ICdyYWRhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGNhdGVnb3J5IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sb3JcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY2F0ZWdyb3kgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNlbGxbY29sdW1uXVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgY2F0ZWdvcnkgcmFkaXVzIC0gaW4gZ2VvXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc3QgckcgPSB0aGlzLnJhZGl1cyh2YWwsIHIsIHN0YXQsIGNlbGxTdGF0LCB6ZilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJHID0gKHNHIC8gMikgKiBNYXRoLnNxcnQodmFsIC8gbWF4VmFsKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgYW5ndWxhciBzZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyh4YywgeWMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguYXJjKHhjLCB5YywgckcsIGN1bXVsIC0gaW5jciwgY3VtdWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKHhjLCB5YylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXh0IGFuZ3VsYXIgc2VjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjdW11bCArPSBpbmNyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZV8gPT09ICdoYWxmdG9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGNhdGVnb3J5IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sb3JcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY2F0ZWdyb3kgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNlbGxbY29sdW1uXVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgY2F0ZWdvcnkgcmFkaXVzIC0gaW4gZ2VvXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJHID0gc0cgKiAwLjMzMyAqIE1hdGguc3FydCh2YWwgLyBtYXhWYWwpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyBjaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4YyArIHIgKiAwLjI1ICogTWF0aC5jb3MoY3VtdWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHljICsgciAqIDAuMjUgKiBNYXRoLnNpbihjdW11bCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgckcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyICogTWF0aC5QSVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmZpbGwoKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgYW5ndWxhciBzZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1bXVsICs9IGluY3JcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzeW1ib2wgdHlwZTonICsgdHlwZV8pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSB0b3RhbFxuICAgICAgICAgICAgICAgIGxldCB0b3RhbCA9IDBcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgT2JqZWN0LmtleXModGhpcy5jb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9ICtjZWxsW2NvbHVtbl1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2KSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB2XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdG90YWwgfHwgaXNOYU4odG90YWwpKSBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgLy9kcmF3IGRlY29tcG9zaXRpb24gc3ltYm9sXG4gICAgICAgICAgICAgICAgbGV0IGN1bXVsID0gMFxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSByICogKDEgLSBzRyAvIHIpICogMC41XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpID0gdGhpcy5zdHJpcGVzT3JpZW50YXRpb24oY2VsbCwgciwgemYpXG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbY29sdW1uLCBjb2xvcl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgc2hhcmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmUgPSBjZWxsW2NvbHVtbl0gLyB0b3RhbFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNoYXJlIHx8IGlzTmFOKHNoYXJlKSkgY29udGludWVcblxuICAgICAgICAgICAgICAgICAgICAvL3NldCBjb2xvclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sb3JcblxuICAgICAgICAgICAgICAgICAgICAvL2RyYXcgc3ltYm9sIHBhcnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVfID09PSAnZmxhZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyBmbGFnIHN0cmlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnggKyBkICsgb2Zmc2V0LmR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnkgKyBkICsgY3VtdWwgKiBzRyArIG9mZnNldC5keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlICogc0dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwueCArIGQgKyBjdW11bCAqIHNHICsgb2Zmc2V0LmR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnkgKyBkICsgb2Zmc2V0LmR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZSAqIHNHLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzR1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlXyA9PT0gJ3BpZWNoYXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3IHBpZSBjaGFydCBhbmd1bGFyIHNlY3RvclxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgYW5nbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhMSA9IGN1bXVsICogMiAqIE1hdGguUElcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGEyID0gKGN1bXVsICsgc2hhcmUpICogMiAqIE1hdGguUElcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3XG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oeGMsIHljKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmFyYyh4YywgeWMsIHNHICogMC41LCBhMSArIG9mZkFuZywgYTIgKyBvZmZBbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5waWVDaGFydEludGVybmFsUmFkaXVzRmFjdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5hcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5YyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0cgKiAwLjUgKiB0aGlzLnBpZUNoYXJ0SW50ZXJuYWxSYWRpdXNGYWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGExICsgb2ZmQW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiArIG9mZkFuZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5jbG9zZVBhdGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmZpbGwoKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVfID09PSAncmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyByaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5hcmMoeGMsIHljLCBNYXRoLnNxcnQoMSAtIGN1bXVsKSAqIHNHICogMC41LCAwLCAyICogTWF0aC5QSSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlXyA9PT0gJ3NlZ21lbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgc2VnbWVudCBzZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd0cgPSAoc0cgKiBzRykgLyByXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwueCArIG9mZnNldC5keCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC55ICsgKHIgLSB3RykgLyAyICsgY3VtdWwgKiB3RyArIG9mZnNldC5keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmUgKiB3R1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92ZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC54ICsgY3VtdWwgKiByICsgb2Zmc2V0LmR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnkgKyAociAtIHdHKSAvIDIgKyBvZmZzZXQuZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlICogcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd0dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc3ltYm9sIHR5cGU6JyArIHR5cGVfKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VtdWwgKz0gc2hhcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByOiByLCB6ZjogemYsIHNTaXplOiBzdGF0IH0pXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xuXG4vKiogQHR5cGVkZWYge1wiZmxhZ1wifFwicGllY2hhcnRcInxcInJpbmdcInxcInNlZ21lbnRcInxcInJhZGFyXCJ8XCJhZ2VweXJhbWlkXCJ8XCJoYWxmdG9uZVwifSBDb21wb3NpdGlvblR5cGUgKi9cblxuLyoqXG4gKiBBIHN0eWxlIHNob3dpbmcgdGhlIGNvbXBvc2l0aW9uIG9mIGEgdG90YWwgaW4gZGlmZmVyZW50IGNhdGVnb3JpZXMsIHdpdGggZGlmZmVyZW50IGNvbG9yIGh1ZXMuXG4gKiBJdCBjb25zaXN0cyBvZiBhIHN5bWJvbCB3aXRoIGRpZmZlcmVudCBwYXJ0cywgd2hvc2Ugc2l6ZSByZWZsZWN0IHRoZSBwcm9wb3J0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nIGNhdGVnb3J5LlxuICogRm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgc3ltYm9scywgQHNlZSBDb21wb3NpdGlvblR5cGVcbiAqIFRoZSBzeW1ib2wgY2FuIGJlIHNjYWxlZCBkZXBlbmRpbmcgb24gdGhlIGNlbGwgaW1wb3J0YW5jZS5cbiAqXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21wb3NpdGlvblN0eWxlXyBleHRlbmRzIFN0eWxlIHtcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB2aWV3IHNjYWxlLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oQXJyYXkuPGltcG9ydCgnLi4vRGF0YXNldC5qcycpLkNlbGw+LG51bWJlciwgbnVtYmVyKTpvYmplY3R9ICovXG4gICAgICAgIHRoaXMudmlld1NjYWxlID0gb3B0cy52aWV3U2NhbGVcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpY3Rpb25hcnkgKHN0cmluZyAtPiBjb2xvcikgd2hpY2ggZ2l2ZSB0aGUgY29sb3Igb2YgZWFjaCBjYXRlZ29yeS5cbiAgICAgICAgICogQHR5cGUge29iamVjdH0gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3JcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHR5cGUgb2YgZGVjb21wb3NpdGlvbiBzeW1ib2wgb2YgYSBjZWxsLCBAc2VlIENvbXBvc2l0aW9uVHlwZVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlciwgbnVtYmVyLG9iamVjdCk6Q29tcG9zaXRpb25UeXBlfSAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBvcHRzLnR5cGVcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgYSBjZWxsIGluIGdlb2dyYXBoaWNhbCB1bml0LlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9EYXRhc2V0LmpzJykuQ2VsbCxudW1iZXIsIG51bWJlcixvYmplY3QpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplXG5cbiAgICAgICAgLyoqIEZvciBzdHlsZSB0eXBlcyB3aXRoIHN0cmlwZXMgKGZsYWcsIHNlZ21lbnQpLCB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHN0cmlwZXMgKDAgZm9yIGhvcml6b250YWwsIG90aGVyIGZvciB2ZXJ0aWNhbCkuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0LmpzXCIpLkNlbGwsbnVtYmVyLG51bWJlcixvYmplY3QpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zdHJpcGVzT3JpZW50YXRpb24gPSBvcHRzLnN0cmlwZXNPcmllbnRhdGlvbiB8fCAoKCkgPT4gMCkgLy8oYyxyLHpmLHZjKSA9PiAuLi5cblxuICAgICAgICAvKiogVGhlIGZ1bmN0aW9uIHNwZWNpZnlpbmcgYW4gb2Zmc2V0IGFuZ2xlIGZvciBhIHJhZGFyLCBoYWxmdG9uZSBvciBwaWUgY2hhcnQgc3R5bGUuXG4gICAgICAgICAqIFRoZSBhbmdsZSBpcyBzcGVjaWZpZWQgaW4gZGVncmVlLiBUaGUgcm90YXRpb24gaXMgYW50aS1jbG9ja3dpc2UuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0LmpzXCIpLkNlbGwsbnVtYmVyLG51bWJlcixvYmplY3QpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5vZmZzZXRBbmdsZSA9IG9wdHMub2Zmc2V0QW5nbGUgfHwgKCgpID0+IDApIC8vKGNlbGwscix6Zix2YykgPT4gLi4uXG5cbiAgICAgICAgLyoqIFRoZSBmdW5jdGlvbiBzcGVjaWZ5aW5nIHRoZSBoZWlnaHQgb2YgdGhlIGFnZSBweXJhbWlkLCBpbiBnZW8gdW5pdC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL0RhdGFzZXQuanNcIikuQ2VsbCxudW1iZXIsbnVtYmVyLG9iamVjdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmFnZVB5cmFtaWRIZWlnaHQgPSBvcHRzLmFnZVB5cmFtaWRIZWlnaHQgfHwgKChjLCByLCB6ZikgPT4gcikgLy8oY2VsbCxyLHpmLHZjKSA9PiAuLi5cblxuICAgICAgICAvKiogRm9yIHBpZSBjaGFydCwgdGhpcyBpcyBwYXJhbWV0ZXIgZm9yIGludGVybmFsIHJhZGl1cywgc28gdGhhdCB0aGUgcGllIGNoYXJ0IGxvb2tzIGxpa2UgYSBkb251dC5cbiAgICAgICAgICogMCBmb3Igbm9ybWFsIHBpZSBjaGFydHMsIDAuNSB0byBlbXB0eSBoYWxmIG9mIHRoZSByYWRpdXMuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMucGllQ2hhcnRJbnRlcm5hbFJhZGl1c0ZhY3RvciA9IG9wdHMucGllQ2hhcnRJbnRlcm5hbFJhZGl1c0ZhY3RvciB8fCAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBjZWxscyBhcyBzcXVhcmVzIGRlcGVuZGluZyBvbiB0aGVpciB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0dlb0NhbnZhcy5qc1wiKS5HZW9DYW52YXN9IGNnXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL3pvb20gZmFjdG9yXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxuXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcbiAgICAgICAgY29uc3QgdmMgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByLCB6ZikgOiB1bmRlZmluZWRcblxuICAgICAgICAvL25iIGNhdGVnb3JpZXMgLSB1c2VkIGZvciByYWRhciBhbmQgYWdlcHlyYW1pZFxuICAgICAgICBjb25zdCBuYkNhdCA9IE9iamVjdC5lbnRyaWVzKHRoaXMuY29sb3IpLmxlbmd0aFxuXG4gICAgICAgIC8vZHJhdyBpbiBnZW8gY29vcmRpbmF0ZXNcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICAvL2RyYXcgY2FsbHNcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xuXG4gICAgICAgICAgICAvL3NpemVcbiAgICAgICAgICAgIGNvbnN0IHNHID0gdGhpcy5zaXplID8gdGhpcy5zaXplKGNlbGwsIHIsIHpmLCB2YykgOiByXG4gICAgICAgICAgICBpZiAoIXNHKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGNlbGwsIHIsIHpmKVxuXG4gICAgICAgICAgICAvL2dldCBzeW1ib2wgdHlwZVxuICAgICAgICAgICAgY29uc3QgdHlwZV8gPSB0aGlzLnR5cGUgPyB0aGlzLnR5cGUoY2VsbCwgciwgemYsIHZjKSA6ICdmbGFnJ1xuXG4gICAgICAgICAgICAvL2NvbXB1dGUgY2VudGVyIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCB4YyA9IGNlbGwueCArIG9mZnNldC5keCArICh0eXBlXyA9PT0gJ2FnZXB5cmFtaWQnID8gMCA6IHIgKiAwLjUpXG4gICAgICAgICAgICBjb25zdCB5YyA9IGNlbGwueSArIG9mZnNldC5keSArICh0eXBlXyA9PT0gJ2FnZXB5cmFtaWQnID8gMCA6IHIgKiAwLjUpXG5cbiAgICAgICAgICAgIC8vY29tcHV0ZSBvZmZzZXQgYW5nbGUsIHdoZW4gcmVsZXZhbnRcbiAgICAgICAgICAgIGNvbnN0IG9mZkFuZyA9IHRoaXMub2Zmc2V0QW5nbGUgPyAodGhpcy5vZmZzZXRBbmdsZShjZWxsLCByLCB6ZiwgdmMpICogTWF0aC5QSSkgLyAxODAgOiAwXG5cbiAgICAgICAgICAgIGlmICh0eXBlXyA9PT0gJ2FnZXB5cmFtaWQnIHx8IHR5cGVfID09PSAncmFkYXInIHx8IHR5cGVfID09PSAnaGFsZnRvbmUnKSB7XG4gICAgICAgICAgICAgICAgLy9nZXQgY2VsbCBjYXRlZ29yeSBtYXggdmFsdWVcbiAgICAgICAgICAgICAgICBsZXQgbWF4VmFsID0gLUluZmluaXR5XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSArY2VsbFtrZXldXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ID4gbWF4VmFsKSBtYXhWYWwgPSB2XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9jdW11bFxuICAgICAgICAgICAgICAgIGxldCBjdW11bCA9IDBcbiAgICAgICAgICAgICAgICBpZiAodHlwZV8gPT09ICdhZ2VweXJhbWlkJyAmJiB0aGlzLmFnZVB5cmFtaWRIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIGN1bXVsID0gKHIgLSB0aGlzLmFnZVB5cmFtaWRIZWlnaHQoY2VsbCwgciwgemYsIHZjKSkgLyAyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVfID09PSAncmFkYXInIHx8IHR5cGVfID09PSAnaGFsZnRvbmUnKSBjdW11bCA9IE1hdGguUEkgLyAyICsgb2ZmQW5nXG5cbiAgICAgICAgICAgICAgICAvL2NvbXB1dGUgdGhlIGluY3JlbWVudCwgd2hpY2ggaXMgdGhlIHZhbHVlIHRvIGluY3JlbWVudCB0aGUgY3VtdWwgZm9yIGVhY2ggY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNyID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZV8gPT09ICdhZ2VweXJhbWlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAodGhpcy5hZ2VQeXJhbWlkSGVpZ2h0ID8gdGhpcy5hZ2VQeXJhbWlkSGVpZ2h0KGNlbGwsIHIsIHpmLCB2YykgOiByKSAvIG5iQ2F0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGVfID09PSAncmFkYXInIHx8IHR5cGVfID09PSAnaGFsZnRvbmUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoMiAqIE1hdGguUEkpIC8gbmJDYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGlmIChpbmNyID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzeW1ib2wgdHlwZTonICsgdHlwZV8pXG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbY29sdW1uLCBjb2xvcl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVfID09PSAnYWdlcHlyYW1pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGNhdGVnb3J5IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sb3JcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY2F0ZWdvcnkgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNlbGxbY29sdW1uXVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgY2F0ZWdvcnkgbGVuZ3RoIC0gaW4gZ2VvXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdHID0gKHNHICogdmFsKSAvIG1heFZhbFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgYmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoeGMgKyAociAtIHdHKSAvIDIsIHljICsgY3VtdWwsIHdHLCBpbmNyKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICBjdW11bCArPSBpbmNyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZV8gPT09ICdyYWRhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGNhdGVnb3J5IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sb3JcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY2F0ZWdyb3kgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNlbGxbY29sdW1uXVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgY2F0ZWdvcnkgcmFkaXVzIC0gaW4gZ2VvXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc3QgckcgPSB0aGlzLnJhZGl1cyh2YWwsIHIsIHN0YXQsIGNlbGxTdGF0LCB6ZilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJHID0gKHNHIC8gMikgKiBNYXRoLnNxcnQodmFsIC8gbWF4VmFsKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgYW5ndWxhciBzZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyh4YywgeWMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguYXJjKHhjLCB5YywgckcsIGN1bXVsIC0gaW5jciwgY3VtdWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKHhjLCB5YylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXh0IGFuZ3VsYXIgc2VjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjdW11bCArPSBpbmNyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZV8gPT09ICdoYWxmdG9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGNhdGVnb3J5IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sb3JcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY2F0ZWdyb3kgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNlbGxbY29sdW1uXVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgY2F0ZWdvcnkgcmFkaXVzIC0gaW4gZ2VvXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJHID0gc0cgKiAwLjMzMyAqIE1hdGguc3FydCh2YWwgLyBtYXhWYWwpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyBjaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4YyArIHIgKiAwLjI1ICogTWF0aC5jb3MoY3VtdWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHljICsgciAqIDAuMjUgKiBNYXRoLnNpbihjdW11bCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgckcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyICogTWF0aC5QSVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmZpbGwoKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgYW5ndWxhciBzZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1bXVsICs9IGluY3JcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzeW1ib2wgdHlwZTonICsgdHlwZV8pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSB0b3RhbFxuICAgICAgICAgICAgICAgIGxldCB0b3RhbCA9IDBcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgT2JqZWN0LmtleXModGhpcy5jb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9ICtjZWxsW2NvbHVtbl1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2KSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB2XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdG90YWwgfHwgaXNOYU4odG90YWwpKSBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgLy9kcmF3IGRlY29tcG9zaXRpb24gc3ltYm9sXG4gICAgICAgICAgICAgICAgbGV0IGN1bXVsID0gMFxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSByICogKDEgLSBzRyAvIHIpICogMC41XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpID0gdGhpcy5zdHJpcGVzT3JpZW50YXRpb24oY2VsbCwgciwgemYsIHZjKVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2NvbHVtbiwgY29sb3JdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0IHNoYXJlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlID0gY2VsbFtjb2x1bW5dIC8gdG90YWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaGFyZSB8fCBpc05hTihzaGFyZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxTdHlsZSA9IGNvbG9yXG5cbiAgICAgICAgICAgICAgICAgICAgLy9kcmF3IHN5bWJvbCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlXyA9PT0gJ2ZsYWcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgZmxhZyBzdHJpcGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC54ICsgZCArIG9mZnNldC5keCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC55ICsgZCArIGN1bXVsICogc0cgKyBvZmZzZXQuZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNHLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZSAqIHNHXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnggKyBkICsgY3VtdWwgKiBzRyArIG9mZnNldC5keCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC55ICsgZCArIG9mZnNldC5keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmUgKiBzRyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZV8gPT09ICdwaWVjaGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyBwaWUgY2hhcnQgYW5ndWxhciBzZWN0b3JcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wdXRlIGFuZ2xlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYTEgPSBjdW11bCAqIDIgKiBNYXRoLlBJXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhMiA9IChjdW11bCArIHNoYXJlKSAqIDIgKiBNYXRoLlBJXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhd1xuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKHhjLCB5YylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5hcmMoeGMsIHljLCBzRyAqIDAuNSwgYTEgKyBvZmZBbmcsIGEyICsgb2ZmQW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGllQ2hhcnRJbnRlcm5hbFJhZGl1c0ZhY3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguYXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4YyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNHICogMC41ICogdGhpcy5waWVDaGFydEludGVybmFsUmFkaXVzRmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMSArIG9mZkFuZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYTIgKyBvZmZBbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguY2xvc2VQYXRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlXyA9PT0gJ3JpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgcmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguYXJjKHhjLCB5YywgTWF0aC5zcXJ0KDEgLSBjdW11bCkgKiBzRyAqIDAuNSwgMCwgMiAqIE1hdGguUEkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbCgpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZV8gPT09ICdzZWdtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3IHNlZ21lbnQgc2VjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdHID0gKHNHICogc0cpIC8gclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnggKyBvZmZzZXQuZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwueSArIChyIC0gd0cpIC8gMiArIGN1bXVsICogd0cgKyBvZmZzZXQuZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlICogd0dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwueCArIGN1bXVsICogciArIG9mZnNldC5keCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC55ICsgKHIgLSB3RykgLyAyICsgb2Zmc2V0LmR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZSAqIHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdHXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHN5bWJvbCB0eXBlOicgKyB0eXBlXylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN1bXVsICs9IHNoYXJlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcjogciwgemY6IHpmLCB2aWV3U2NhbGU6IHZjIH0pXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTaWRlU3R5bGUgfSBmcm9tICcuL1NpZGVTdHlsZS5qcydcblxuLyoqIEB0eXBlZGVmIHt7eDpudW1iZXIseTpudW1iZXIsb3I6XCJ2XCJ8XCJoXCIsdmFsdWU6bnVtYmVyfX0gU2lkZSAqL1xuXG4vKipcbiAqXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250b3VyU3R5bGUgZXh0ZW5kcyBTaWRlU3R5bGUge1xuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgLy9vcHRzLmludGVydmFsID0gb3B0cy5pbnRlcnZhbCB8fCAxMDBcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgICAgICBvcHRzLmJyZWFrcyA9IG9wdHMuYnJlYWtzIHx8IFsxMDAsIDEwMDAsIDEwMDAwLCAxMDAwMDAsIDEwMDAwMDBdXG5cbiAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihTaWRlLG51bWJlcixudW1iZXIpOnN0cmluZ30gKi9cbiAgICAgICAgb3B0cy53aWR0aCA9IG9wdHMud2lkdGggfHwgKCgpID0+IDEpIC8vKHMsIHIsIHpmKSA9PiAuLi5cblxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKFNpZGUsbnVtYmVyLG51bWJlcik6c3RyaW5nfSAqL1xuICAgICAgICBvcHRzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKCkgPT4gJyNFN0E5MzUnKSAvLyhzLCByLCB6ZikgPT4gLi4uXG5cbiAgICAgICAgLy9vdmVycmlkZSBtZXRob2QgZm9yIGNvbnRvdXIgZHJhd2luZ1xuXG4gICAgICAgIGNvbnN0IGdldENsYXNzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh2ID09IHVuZGVmaW5lZCkgcmV0dXJuIDBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0cy5icmVha3MubGVuZ3RoOyBpKyspIGlmICh2IDwgb3B0cy5icmVha3NbaV0pIHJldHVybiBpXG4gICAgICAgICAgICByZXR1cm4gb3B0cy5icmVha3MubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbHVlID0gKHYxLCB2MiwgciwgcywgemYpID0+IHtcbiAgICAgICAgICAgIC8vaWYgKCF2MSB8fCAhdjIpIHJldHVybiAwXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZ2V0Q2xhc3ModjIpIC0gZ2V0Q2xhc3ModjEpKVxuXG4gICAgICAgICAgICAvL2NoZWNrIGlmIHYxIC0gdjIgY3Jvc3MgYSBjb250b3VyIGxpbmVcbiAgICAgICAgICAgIC8vY29uc3QgcjEgPSBNYXRoLmZsb29yKHYxIC8gb3B0cy5pbnRlcnZhbCk7XG4gICAgICAgICAgICAvL2NvbnN0IHIyID0gTWF0aC5mbG9vcih2MiAvIG9wdHMuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgLy9yZXR1cm4gTWF0aC5hYnMocjIgLSByMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3NhbWUgY29sb3IgZm9yIGFsbFxuICAgICAgICB0aGlzLmNvbG9yID0gKHNpZGUsIHIsIHMsIHpmKSA9PiAoc2lkZS52YWx1ZSA/IG9wdHMuY29sb3Ioc2lkZSwgciwgemYpIDogdW5kZWZpbmVkKVxuXG4gICAgICAgIC8vd2lkdGg6IG11bHRpcGxlIG9mXG4gICAgICAgIHRoaXMud2lkdGggPSAoc2lkZSwgciwgcywgemYpID0+IHNpZGUudmFsdWUgKiB6ZiAqIG9wdHMud2lkdGgoc2lkZSwgciwgemYpXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xuaW1wb3J0IHsgcmFuZG9tTm9ybWFsIH0gZnJvbSAnZDMtcmFuZG9tJ1xuaW1wb3J0IHsgY2hlY2tXZWJHTFN1cHBvcnQsIG1ha2VXZWJHTENhbnZhcyB9IGZyb20gJy4uL3V0aWxzL3dlYkdMVXRpbHMuanMnXG5pbXBvcnQgeyBXZWJHTFNxdWFyZUNvbG9yaW5nIH0gZnJvbSAnLi4vdXRpbHMvV2ViR0xTcXVhcmVDb2xvcmluZy5qcydcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnZDMtY29sb3InXG5pbXBvcnQgeyBtb25pdG9yLCBtb25pdG9yRHVyYXRpb24gfSBmcm9tICcuLi91dGlscy9VdGlscy5qcydcblxuLyoqXG4gKlxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgRG90RGVuc2l0eVN0eWxlIGV4dGVuZHMgU3R5bGUge1xuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGNvbHVtbi9hdHRyaWJ1dGUgb2YgdGhlIHRhYnVsYXIgZGF0YSB3aGVyZSB0byByZXRyaWV2ZSB0aGUgdmFyaWFibGUgZm9yIGRvdCBudW1iZXIuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMubmJDb2wgPSBvcHRzLm5iQ29sXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBudW1iZXIgb2YgZG90cyBmb3IgYSBjZWxsIHZhbHVlLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0LG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm5iID0gb3B0cy5uYiB8fCAoKHYsIHIsIHMsIHpmKSA9PiAoKCgwLjMgKiByICogcikgLyAoemYgKiB6ZikpICogdikgLyBzLm1heClcblxuICAgICAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBkb3RzLiBTYW1lIGNvbG9yIGZvciBhbGwgZG90cyB3aXRoaW4gYSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiAnI0ZGNTczMycpXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIHRoZSBkb3RzLCBpbiBnZW8gdW5pdC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5kb3RTaXplID0gb3B0cy5kb3RTaXplIC8vfHwgKChyLCB6ZikgPT4gLi4uXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaWdtYSBvZiB0aGUgZGlzdHJpYnV0aW9uIGZyb20gdGhlIHJlc29sdXRpb24sIGluIGdlbyB1bml0LlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnNpZ21hID0gb3B0cy5zaWdtYSAvL3x8ICgocix6ZikgPT4gLi4uXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBjZWxscyBhcyB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCByLCBjZykge1xuICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcqKiogRG90RGVuc2l0eVN0eWxlIGRyYXcnKVxuXG4gICAgICAgIC8vZmlsdGVyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXG5cbiAgICAgICAgLy96b29tIGZhY3RvclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcblxuICAgICAgICBsZXQgc3RhdFxuICAgICAgICBpZiAodGhpcy5uYkNvbCkgc3RhdCA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMubmJDb2xdLCB0cnVlKVxuICAgICAgICBpZiAoIXN0YXQpIHJldHVyblxuXG4gICAgICAgIC8vc2l6ZSBvZiB0aGUgZG90c1xuICAgICAgICBjb25zdCBzR2VvID0gdGhpcy5kb3RTaXplID8gdGhpcy5kb3RTaXplKHIsIHpmKSA6IDIgKiB6ZlxuXG4gICAgICAgIC8vbWFrZSByYW5kb20gZnVuY3Rpb25cbiAgICAgICAgY29uc3Qgc2lnID0gdGhpcy5zaWdtYSA/IHRoaXMuc2lnbWEociwgemYpIDogciAqIDAuNFxuICAgICAgICBjb25zdCByYW5kID0gcmFuZG9tTm9ybWFsKDAsIHNpZylcblxuICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcgcHJlcGFyYXRpb24nKVxuXG4gICAgICAgIGlmIChjaGVja1dlYkdMU3VwcG9ydCgpKSB7XG4gICAgICAgICAgICAvL2NyZWF0ZSBjYW52YXMgYW5kIHdlYmdsIHJlbmRlcmVyXG4gICAgICAgICAgICBjb25zdCBjdldHTCA9IG1ha2VXZWJHTENhbnZhcyhjZy53ICsgJycsIGNnLmggKyAnJylcbiAgICAgICAgICAgIGlmICghY3ZXR0wpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyB3ZWJHTCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vY3JlYXRlIHdlYkdMIHByb2dyYW1cbiAgICAgICAgICAgIGNvbnN0IHByb2cgPSBuZXcgV2ViR0xTcXVhcmVDb2xvcmluZyhjdldHTC5nbCwgc0dlbyAvIHpmKVxuXG4gICAgICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcgd2ViZ2wgY3JlYXRpb24nKVxuXG4gICAgICAgICAgICBjb25zdCByMiA9IHIgLyAyXG5cbiAgICAgICAgICAgIGxldCBjb2wsIG9mZnNldCwgbmIsIGN4LCBjeSwgY2NcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgICAgICAvL2dldCBjb2xvclxuICAgICAgICAgICAgICAgIGNvbCA9IHRoaXMuY29sb3IoYylcbiAgICAgICAgICAgICAgICBpZiAoIWNvbCB8fCBjb2wgPT09ICdub25lJykgY29udGludWVcblxuICAgICAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0KGMsIHIsIHpmKVxuXG4gICAgICAgICAgICAgICAgLy9udW1iZXIgb2YgZG90c1xuICAgICAgICAgICAgICAgIG5iID0gdGhpcy5uYihjW3RoaXMubmJDb2xdLCByLCBzdGF0LCB6ZilcblxuICAgICAgICAgICAgICAgIC8vY2VsbCBjZW50ZXJcbiAgICAgICAgICAgICAgICBjeCA9IGMueCArIG9mZnNldC5keCArIHIyXG4gICAgICAgICAgICAgICAgY3kgPSBjLnkgKyBvZmZzZXQuZHkgKyByMlxuXG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IGNvbG9yXG4gICAgICAgICAgICAgICAgY2MgPSBjb2xvcihjb2wpXG4gICAgICAgICAgICAgICAgaWYgKCFjYykgcmV0dXJuXG5cbiAgICAgICAgICAgICAgICAvL3JhbmRvbSBwb2ludHNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuYjsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBwcm9nLmFkZFBvaW50RGF0YTIoY3ggKyByYW5kKCksIGN5ICsgcmFuZCgpLCBjYy5yLCBjYy5nLCBjYy5iLCBjYy5vcGFjaXR5KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcgZGF0YSBwcmVwYXJhdGlvbicpXG5cbiAgICAgICAgICAgIC8vZHJhd1xuICAgICAgICAgICAgcHJvZy5kcmF3KGNnLmdldFdlYkdMVHJhbnNmb3JtKCkpXG5cbiAgICAgICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyB3ZWJnbCBkcmF3aW5nJylcblxuICAgICAgICAgICAgLy9kcmF3IGluIGNhbnZhcyBnZW9cbiAgICAgICAgICAgIGNnLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICAgICAgY2cuY3R4LmRyYXdJbWFnZShjdldHTC5jYW52YXMsIDAsIDApXG5cbiAgICAgICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyBjYW52YXMgZHJhd2luZycpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2RyYXcgd2l0aCBIVE1MIGNhbnZhc1xuXG4gICAgICAgICAgICAvL2RyYXcgaW4gZ2VvIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICBjZy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XG4gICAgICAgICAgICAgICAgLy9nZXQgY29sb3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yKGMpXG4gICAgICAgICAgICAgICAgaWYgKCFjb2wgfHwgY29sID09PSAnbm9uZScpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgLy9zZXQgY29sb3JcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sXG5cbiAgICAgICAgICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjLCByLCB6ZilcblxuICAgICAgICAgICAgICAgIC8vbnVtYmVyIG9mIGRvdHNcbiAgICAgICAgICAgICAgICBjb25zdCBuYiA9IHRoaXMubmIoY1t0aGlzLm5iQ29sXSwgciwgc3RhdCwgemYpXG5cbiAgICAgICAgICAgICAgICAvL2RyYXcgcmFuZG9tIGRvdHNcbiAgICAgICAgICAgICAgICBjb25zdCBjeCA9IGMueCArIG9mZnNldC5keCArIHIgLyAyLFxuICAgICAgICAgICAgICAgICAgICBjeSA9IGMueSArIG9mZnNldC5keSArIHIgLyAyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbmI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoY3ggKyByYW5kKCksIGN5ICsgcmFuZCgpLCBzR2VvLCBzR2VvKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6ZiB9KVxuXG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyoqKiBEb3REZW5zaXR5U3R5bGUgZW5kIGRyYXcnKVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcblxuLyoqIEB0eXBlZGVmIHt7eDpudW1iZXIseTpudW1iZXIsb3I6XCJ2XCJ8XCJoXCIsYzE6aW1wb3J0KCcuLi9EYXRhc2V0LmpzJykuQ2VsbHx1bmRlZmluZWQsYzI6aW1wb3J0KCcuLi9EYXRhc2V0LmpzJykuQ2VsbHx1bmRlZmluZWR9fSBTaWRlICovXG5cbi8qKlxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgSXNvRmVuY2VTdHlsZSBleHRlbmRzIFN0eWxlIHtcblxuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpY3Rpb25hcnkgKHN0cmluZyAtPiBjb2xvcikgd2hpY2ggZ2l2ZSB0aGUgY29sb3Igb2YgZWFjaCBjYXRlZ29yeS5cbiAgICAgICAgICogQHR5cGUge29iamVjdH0gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3JcblxuICAgICAgICAvKiogVGhlIGNvbHVtbiB3aGVyZSB0byBnZXQgdGhlIGhlaWdodCB2YWx1ZXMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuaGVpZ2h0Q29sID0gb3B0cy5oZWlnaHRDb2xcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGhlaWdodCBvZiBhIGNlbGwuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8ICgodiwgciwgcywgemYpID0+IHIgKiAwLjQpXG5cbiAgICAgICAgLyoqIFRoZSBwZXJzcGVjdGl2ZSBhbmdsZSwgaW4gZGVncmVlLCB3aXRoaW4gWy0xODAsMTgwXSwgZnJvbSBbTyx4XSBheGlzLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmFuZ2xlID0gb3B0cy5hbmdsZSAhPSB1bmRlZmluZWQgPyBvcHRzLmFuZ2xlIDogNTBcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvcm5lciBsaW5lIHN0cm9rZSBzdHlsZS5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vRGF0YXNldC5qcycpLkNlbGwsbnVtYmVyLG51bWJlcixudW1iZXIpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb3JuZXJMaW5lU3Ryb2tlQ29sb3IgPSBvcHRzLmNvcm5lckxpbmVTdHJva2VDb2xvciB8fCAoKGMsIHIsIHpmLCBhbmdsZSkgPT4gXCIjOTk5XCIpXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb3JuZXIgbGluZSB3aWR0aC5cbiAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9EYXRhc2V0LmpzJykuQ2VsbCxudW1iZXIsbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmNvcm5lckxpbmVXaWR0aCA9IG9wdHMuY29ybmVyTGluZVdpZHRoIHx8ICgoYywgciwgemYsIGFuZ2xlKSA9PiAoYW5nbGUgJSA5MCA9PSAwID8gMCA6IDAuOCAqIHpmKSlcblxuICAgICAgICAvKipcbiAgICAgICAgKiBTaG93IHZlcnRpY2FsIGNyb3NzLXNlY3Rpb25zLlxuICAgICAgICAqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnNWZXJ0ID0gb3B0cy5zVmVydCAhPSB1bmRlZmluZWQgPyBvcHRzLnNWZXJ0IDogdHJ1ZVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFNob3cgaG9yaXpvbnRhbCBjcm9zcy1zZWN0aW9ucy5cbiAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5zSG9yID0gb3B0cy5zSG9yICE9IHVuZGVmaW5lZCA/IG9wdHMuc0hvciA6IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGNlbGxzIGFzIHNlZ21lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldC5qc1wiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gY2dcbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCByLCBjZykge1xuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vem9vbSBmYWN0b3JcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXG5cbiAgICAgICAgbGV0IHN0YXRcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0Q29sKSB7XG4gICAgICAgICAgICAvL2lmIHNpemUgaXMgdXNlZCwgc29ydCBjZWxscyBieSBzaXplIHNvIHRoYXQgdGhlIGJpZ2dlc3QgYXJlIGRyYXduIGZpcnN0XG4gICAgICAgICAgICBjZWxscy5zb3J0KChjMSwgYzIpID0+IGMyW3RoaXMuaGVpZ2h0Q29sXSAtIGMxW3RoaXMuaGVpZ2h0Q29sXSlcbiAgICAgICAgICAgIC8vYW5kIGNvbXB1dGUgc3RhdGlzdGljc1xuICAgICAgICAgICAgc3RhdCA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuaGVpZ2h0Q29sXSwgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbmIgY2F0ZWdvcmllcyAtIHVzZWQgZm9yIHJhZGFyIGFuZCBhZ2VweXJhbWlkXG4gICAgICAgIGNvbnN0IGNhdHMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbG9yKVxuXG4gICAgICAgIC8vaGFsZiByZXNvbHV0aW9uXG4gICAgICAgIGNvbnN0IHIyID0gciAvIDJcblxuICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldCh1bmRlZmluZWQsIHIsIHpmKSwgZHggPSBvZmZzZXQuZHgsIGR5ID0gb2Zmc2V0LmR5XG5cbiAgICAgICAgLy9oZWlnaHRcbiAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICBsZXQgaF8gPSB0aGlzLmhlaWdodFxuXG4gICAgICAgIC8vbWFrZSBzaWRlc1xuICAgICAgICAvKiogIEB0eXBlIHtBcnJheS48U2lkZT59ICovXG4gICAgICAgIGNvbnN0IHNpZGVzID0gW11cblxuICAgICAgICAvL21ha2UgaG9yaXpvbnRhbCBzaWRlcyAtIGV4Y2VwdCB3aGVuIGFuZ2xlJTE4MD0wXG4gICAgICAgIC8vc29ydCBjZWxscyBieSB4IGFuZCB5XG4gICAgICAgIGlmICh0aGlzLmFuZ2xlICUgMTgwICE9IDkwICYmIHRoaXMuc1ZlcnQpIHtcbiAgICAgICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gKGMyLnggPT0gYzEueCA/IGMxLnkgLSBjMi55IDogYzEueCAtIGMyLngpKVxuICAgICAgICAgICAgbGV0IGMxID0gY2VsbHNbMF1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYzIgPSBjZWxsc1tpXVxuXG4gICAgICAgICAgICAgICAgaWYgKChjMS55ICsgciA9PSBjMi55KSAmJiAoYzEueCA9PSBjMi54KSlcbiAgICAgICAgICAgICAgICAgICAgLy9jZWxscyBpbiBzYW1lIGNvbHVtbiBhbmQgdG91Y2ggYWxvbmcgaG9yaXpvbnRhbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzaGFyZWQgc2lkZVxuICAgICAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHsgeDogYzEueCArIHIyLCB5OiBjMi55LCBvcjogJ2gnLCBjMTogYzEsIGMyOiBjMiB9KVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2NlbGxzIGRvIG5vdCB0b3VjaCBhbG9uZyBob3Jpem9udGFsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHR3byBzaWRlczogdG9wIG9uZSBmb3IgYzEsIGJvdHRvbSBmb3IgYzJcbiAgICAgICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7IHg6IGMxLnggKyByMiwgeTogYzEueSArIHIsIG9yOiAnaCcsIGMxOiBjMSwgYzI6IHVuZGVmaW5lZCB9KVxuICAgICAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHsgeDogYzIueCArIHIyLCB5OiBjMi55LCBvcjogJ2gnLCBjMTogdW5kZWZpbmVkLCBjMjogYzIgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjMSA9IGMyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL21ha2UgdmVydGljYWwgc2lkZXMgLSBleGNlcHQgd2hlbiBhbmdsZSUxODA9OTBcbiAgICAgICAgLy9zb3J0IGNlbGxzIGJ5IHkgYW5kIHhcbiAgICAgICAgaWYgKHRoaXMuYW5nbGUgJSAxODAgIT0gMCAmJiB0aGlzLnNIb3IpIHtcbiAgICAgICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gKGMyLnkgPT0gYzEueSA/IGMxLnggLSBjMi54IDogYzEueSAtIGMyLnkpKVxuICAgICAgICAgICAgbGV0IGMxID0gY2VsbHNbMF1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYzIgPSBjZWxsc1tpXVxuXG4gICAgICAgICAgICAgICAgaWYgKChjMS54ICsgciA9PSBjMi54KSAmJiAoYzEueSA9PSBjMi55KSlcbiAgICAgICAgICAgICAgICAgICAgLy9jZWxscyBpbiBzYW1lIHJvdyBhbmQgdG91Y2ggYWxvbmcgdmVydGljYWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAvL21ha2Ugc2hhcmVkIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7IHg6IGMyLngsIHk6IGMxLnkgKyByMiwgb3I6ICd2JywgYzE6IGMxLCBjMjogYzIgfSlcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jZWxscyBkbyBub3QgdG91Y2ggYWxvbmcgdmVydGljYWwgc2lkZVxuICAgICAgICAgICAgICAgICAgICAvL21ha2UgdHdvIHNpZGVzOiByaWdodCBvbmUgZm9yIGMxLCBsZWZ0IGZvciBjMlxuICAgICAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHsgeDogYzEueCArIHIsIHk6IGMxLnkgKyByMiwgb3I6ICd2JywgYzE6IGMxLCBjMjogdW5kZWZpbmVkIH0pXG4gICAgICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goeyB4OiBjMi54LCB5OiBjMi55ICsgcjIsIG9yOiAndicsIGMxOiB1bmRlZmluZWQsIGMyOiBjMiB9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGMxID0gYzJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChzaWRlcy5sZW5ndGggPT0gMCkgcmV0dXJuXG5cbiAgICAgICAgLy9hbmdsZSBpbiByYWRpYW5zXG4gICAgICAgIGNvbnN0IGFSYWQgPSB0aGlzLmFuZ2xlICogTWF0aC5QSSAvIDE4MCwgY29zID0gTWF0aC5jb3MoYVJhZCksIHNpbiA9IE1hdGguc2luKGFSYWQpXG5cbiAgICAgICAgLy9zb3J0IHNpZGVzIHNvIHRoYXQgdGhlIGJhY2sgb25lcyBhcmUgZHJhd24gZmlyc3QuIFRoaXMgZGVwZW5kcyBvbiB0aGUgYW5nbGUuXG4gICAgICAgIC8vZGVwZW5kaW5nIG9uIGRpc3RhbmNlIHRvIHRoZSByZWZlcmVuY2UgY29ybmVyIHBvaW50XG4gICAgICAgIGNvbnN0IHhDb3JuZXIgPSBNYXRoLmFicyh0aGlzLmFuZ2xlKSA8IDkwID8gY2cuZXh0R2VvLnhNaW4gOiBjZy5leHRHZW8ueE1heFxuICAgICAgICBjb25zdCB5Q29ybmVyID0gdGhpcy5hbmdsZSA8IDAgPyBjZy5leHRHZW8ueU1heCA6IGNnLmV4dEdlby55TWluXG4gICAgICAgIHNpZGVzLnNvcnQoKHMxLCBzMikgPT4gKE1hdGguaHlwb3QoczIueCAtIHhDb3JuZXIsIHMyLnkgLSB5Q29ybmVyKSAtIE1hdGguaHlwb3QoczEueCAtIHhDb3JuZXIsIHMxLnkgLSB5Q29ybmVyKSkpXG5cbiAgICAgICAgLy9wcmVwYXJlIGZ1bmN0aW9uIHRvIGRyYXcgY29ybmVyIGxpbmUgZm9yIGEgY2VsbCAqYypcbiAgICAgICAgY29uc3QgZHJhd0Nvcm5lckxpbmUgPSAoYykgPT4ge1xuXG4gICAgICAgICAgICBpZiAoIWMpIHJldHVyblxuICAgICAgICAgICAgLy9saW5lIHN0eWxlXG4gICAgICAgICAgICBjb25zdCBsdyA9IHRoaXMuY29ybmVyTGluZVdpZHRoID8gdGhpcy5jb3JuZXJMaW5lV2lkdGgoYywgciwgemYsIHRoaXMuYW5nbGUpIDogMC44ICogemZcbiAgICAgICAgICAgIGlmIChsdyA9PSAwKSByZXR1cm5cbiAgICAgICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29ybmVyTGluZVN0cm9rZUNvbG9yID8gdGhpcy5jb3JuZXJMaW5lU3Ryb2tlQ29sb3IoYywgciwgemYsIHRoaXMuYW5nbGUpIDogXCIjMzMzXCJcbiAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSBsd1xuXG4gICAgICAgICAgICAvL2hlaWdodCAtIGluIGdlb1xuICAgICAgICAgICAgY29uc3QgaEcgPSBoXyhjW3RoaXMuaGVpZ2h0Q29sXSwgciwgc3RhdCwgemYpXG5cbiAgICAgICAgICAgIC8vZHJhdyBsaW5lXG4gICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oYy54ICsgcjIgKyBkeCwgYy55ICsgcjIgKyBkeSlcbiAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oYy54ICsgcjIgKyBoRyAqIGNvcyArIGR4LCBjLnkgKyByMiArIGhHICogc2luICsgZHkpXG4gICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZHJhdyBpbiBnZW8gY29vcmRpbmF0ZXNcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICAvL2RyYXcgc2lkZXNcbiAgICAgICAgY2cuY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgICAgIGZvciAobGV0IHMgb2Ygc2lkZXMpIHtcblxuICAgICAgICAgICAgLy9oZWlnaHRzIC0gaW4gZ2VvXG4gICAgICAgICAgICBjb25zdCBoRzEgPSBzLmMxID8gaF8ocy5jMVt0aGlzLmhlaWdodENvbF0sIHIsIHN0YXQsIHpmKSA6IDAsXG4gICAgICAgICAgICAgICAgaEcyID0gcy5jMiA/IGhfKHMuYzJbdGhpcy5oZWlnaHRDb2xdLCByLCBzdGF0LCB6ZikgOiAwXG5cbiAgICAgICAgICAgIC8vY29tcHV0ZSB0b3RhbHMgZm9yIGJvdGggY2VsbHNcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsMSA9IGNvbXB1dGVUb3RhbChzLmMxLCBjYXRzKSxcbiAgICAgICAgICAgICAgICB0b3RhbDIgPSBjb21wdXRlVG90YWwocy5jMiwgY2F0cylcbiAgICAgICAgICAgIGlmICh0b3RhbDEgPT0gMCAmJiB0b3RhbDIgPT0gMCkgY29udGludWVcblxuICAgICAgICAgICAgbGV0IGN1bXVsMSA9IDAsIGN1bXVsMiA9IDBcbiAgICAgICAgICAgIGZvciAobGV0IFtjb2x1bW4sIGNvbG9yXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmNvbG9yKSkge1xuICAgICAgICAgICAgICAgIC8vZHJhdyBzdHJpcGUgb2Ygc2lkZSBzIGFuZCBjYXRlZ29yeSBjb2x1bW5cblxuICAgICAgICAgICAgICAgIC8vZ2V0IHZhbHVlcyBmb3IgYm90aCBjZWxsc1xuICAgICAgICAgICAgICAgIGxldCB2MSA9IHMuYzEgPyArcy5jMVtjb2x1bW5dIDogMFxuICAgICAgICAgICAgICAgIGxldCB2MiA9IHMuYzIgPyArcy5jMltjb2x1bW5dIDogMFxuICAgICAgICAgICAgICAgIGlmICh2MSA9PSAwICYmIHYyID09IDApIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICAvL2NvbXB1dGUgaGVpZ2h0c1xuICAgICAgICAgICAgICAgIGNvbnN0IGgxID0gaEcxICogY3VtdWwxIC8gdG90YWwxIHx8IDBcbiAgICAgICAgICAgICAgICBjb25zdCBoMW4gPSBoRzEgKiAoY3VtdWwxICsgdjEpIC8gdG90YWwxIHx8IDBcbiAgICAgICAgICAgICAgICBjb25zdCBoMiA9IGhHMiAqIGN1bXVsMiAvIHRvdGFsMiB8fCAwXG4gICAgICAgICAgICAgICAgY29uc3QgaDJuID0gaEcyICogKGN1bXVsMiArIHYyKSAvIHRvdGFsMiB8fCAwXG5cbiAgICAgICAgICAgICAgICAvL21ha2UgcGF0aFxuICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGlmIChzLm9yID09IFwiaFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaG9yaXpvbnRhbCBzaWRlIC0gdmVydGljYWwgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8ocy54ICsgaDEgKiBjb3MgKyBkeCwgcy55IC0gcjIgKyBoMSAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgICAgICAvL3RvcCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8ocy54ICsgaDIgKiBjb3MgKyBkeCwgcy55ICsgcjIgKyBoMiAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgICAgICAvL3RvcCByaWdodFxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKHMueCArIGgybiAqIGNvcyArIGR4LCBzLnkgKyByMiArIGgybiAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKHMueCArIGgxbiAqIGNvcyArIGR4LCBzLnkgLSByMiArIGgxbiAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdmVydGljYWwgc2lkZSAtIGhvcml6b250YWwgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8ocy54IC0gcjIgKyBoMSAqIGNvcyArIGR4LCBzLnkgKyBoMSAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKHMueCArIHIyICsgaDIgKiBjb3MgKyBkeCwgcy55ICsgaDIgKiBzaW4gKyBkeSlcbiAgICAgICAgICAgICAgICAgICAgLy90b3AgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhzLnggKyByMiArIGgybiAqIGNvcyArIGR4LCBzLnkgKyBoMm4gKiBzaW4gKyBkeSlcbiAgICAgICAgICAgICAgICAgICAgLy90b3AgbGVmdFxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKHMueCAtIHIyICsgaDFuICogY29zICsgZHgsIHMueSArIGgxbiAqIHNpbiArIGR5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2NnLmN0eC5jbG9zZVBhdGgoKVxuXG4gICAgICAgICAgICAgICAgLy9maWxsXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxTdHlsZSA9IGNvbG9yXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGwoKVxuXG4gICAgICAgICAgICAgICAgY3VtdWwxICs9IHYxXG4gICAgICAgICAgICAgICAgY3VtdWwyICs9IHYyXG5cbiAgICAgICAgICAgICAgICAvL1RPRE8gZHJhdyBvbmx5IG9uZSBsaW5lXG4gICAgICAgICAgICAgICAgLy9kcmF3IGNvcm5lciBsaW5lXG4gICAgICAgICAgICAgICAgLy9pZiAocy5vciA9PSBcImhcIikge1xuICAgICAgICAgICAgICAgIGRyYXdDb3JuZXJMaW5lKHMuYzEpXG4gICAgICAgICAgICAgICAgZHJhd0Nvcm5lckxpbmUocy5jMilcbiAgICAgICAgICAgICAgICAvL2lmICh0aGlzLmFuZ2xlID4gMCAmJiBzLm9yID09IFwiaFwiKSBkcmF3Q29ybmVyTGluZShzLmMyKVxuICAgICAgICAgICAgICAgIC8vZWxzZSBkcmF3Q29ybmVyTGluZShzLmMyKVxuICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcjogciwgemY6IHpmLCBzU2l6ZTogc3RhdCB9KVxuICAgIH1cbn1cblxuXG5cbmNvbnN0IGNvbXB1dGVUb3RhbCA9IChjZWxsLCBjYXRlZ29yaWVzKSA9PiB7XG4gICAgaWYgKCFjZWxsKSByZXR1cm4gMFxuICAgIGxldCB0b3RhbCA9IDBcbiAgICBmb3IgKGxldCBjb2x1bW4gb2YgY2F0ZWdvcmllcykge1xuICAgICAgICBjb25zdCB2ID0gY2VsbFtjb2x1bW5dXG4gICAgICAgIGlmICghdikgY29udGludWVcbiAgICAgICAgdG90YWwgKz0gK3ZcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsIHx8IDBcbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcblxuLyoqXG4gKlxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgSm95UGxvdFN0eWxlIGV4dGVuZHMgU3R5bGUge1xuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogVGhlIGNlbGwgY29sdW1uIHdoZXJlIHRvIGdldCB0aGUgdmFsdWUgdG8gcmVwcmVzZW50LlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmhlaWdodENvbCA9IG9wdHMuaGVpZ2h0Q29sXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBoZWlnaHQgb2YgYSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCAoKHYpID0+IE1hdGguc3FydCh2KSlcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcix7bWluOm51bWJlciwgbWF4Om51bWJlcn0sbnVtYmVyLG51bWJlcik6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmxpbmVDb2xvciA9IG9wdHMubGluZUNvbG9yIHx8ICgoeSwgeXMsIHIsIHpmKSA9PiAnI0JCQicpXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLHttaW46bnVtYmVyLCBtYXg6bnVtYmVyfSxudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gb3B0cy5saW5lV2lkdGggfHwgKCh5LCB5cywgciwgemYpID0+IHpmKVxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcix7bWluOm51bWJlciwgbWF4Om51bWJlcn0sbnVtYmVyLG51bWJlcik6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmZpbGxDb2xvciA9IG9wdHMuZmlsbENvbG9yIHx8ICgoeSwgeXMsIHIsIHpmKSA9PiAnI2MwOGM1OTY4JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGNlbGxzIGFzIHNxdWFyZXMgZGVwZW5kaW5nIG9uIHRoZWlyIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcbiAgICAgKiAqL1xuICAgIGRyYXcoY2VsbHMsIHIsIGNnKSB7XG4gICAgICAgIC8vZmlsdGVyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXG5cbiAgICAgICAgY2cuY3R4LmxpbmVKb2luID0gJ3JvdW5kJ1xuXG4gICAgICAgIC8vem9vbSBmYWN0b3JcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXG5cbiAgICAgICAgLy9jb21wdXRlIHN0YXRpc3RpY3NcbiAgICAgICAgY29uc3Qgc3RhdCA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuaGVpZ2h0Q29sXSwgdHJ1ZSlcblxuICAgICAgICAvL2luZGV4IGNlbGxzIGJ5IHkgYW5kIHhcbiAgICAgICAgLyoqICBAdHlwZSB7b2JqZWN0fSAqL1xuICAgICAgICBjb25zdCBpbmQgPSB7fVxuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgIGxldCByb3cgPSBpbmRbY2VsbC55XVxuICAgICAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgICAgICByb3cgPSB7fVxuICAgICAgICAgICAgICAgIGluZFtjZWxsLnldID0gcm93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dbY2VsbC54XSA9IHRoaXMuaGVpZ2h0KGNlbGxbdGhpcy5oZWlnaHRDb2xdLCByLCBzdGF0LCB6ZilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29tcHV0ZSBleHRlbnRcbiAgICAgICAgY29uc3QgZSA9IGNnLmV4dEdlb1xuICAgICAgICBpZiAoIWUpIHJldHVyblxuICAgICAgICBjb25zdCB4TWluID0gTWF0aC5mbG9vcihlLnhNaW4gLyByKSAqIHJcbiAgICAgICAgY29uc3QgeE1heCA9IE1hdGguZmxvb3IoZS54TWF4IC8gcikgKiByXG4gICAgICAgIGNvbnN0IHlNaW4gPSBNYXRoLmZsb29yKGUueU1pbiAvIHIpICogclxuICAgICAgICBjb25zdCB5TWF4ID0gTWF0aC5mbG9vcihlLnlNYXggLyByKSAqIHJcblxuICAgICAgICAvKiogIEB0eXBlIHt7bWluOm51bWJlciwgbWF4Om51bWJlcn19ICovXG4gICAgICAgIGNvbnN0IHlzID0geyBtaW46IHlNaW4sIG1heDogeU1heCB9XG5cbiAgICAgICAgLy9kcmF3IGluIGdlbyBjb29yZGluYXRlc1xuICAgICAgICBjZy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgIC8vZHJhdyBsaW5lcywgcm93IGJ5IHJvdywgc3RhdGluZyBmcm9tIHRoZSB0b3BcbiAgICAgICAgZm9yIChsZXQgeSA9IHlNYXg7IHkgPj0geU1pbjsgeSAtPSByKSB7XG4gICAgICAgICAgICAvL2dldCByb3dcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGluZFt5XVxuXG4gICAgICAgICAgICAvL25vIHJvd1xuICAgICAgICAgICAgaWYgKCFyb3cpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vcGxhY2UgZmlyc3QgcG9pbnRcbiAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyh4TWluIC0gciAvIDIsIHkpXG5cbiAgICAgICAgICAgIC8vc3RvcmUgdGhlIHByZXZpb3VzIGhlaWdodFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgbGV0IGhHX1xuXG4gICAgICAgICAgICAvL2dvIHRocm91Z2ggdGhlIGxpbmUgY2VsbHNcbiAgICAgICAgICAgIGZvciAobGV0IHggPSB4TWluOyB4IDw9IHhNYXg7IHggKz0gcikge1xuICAgICAgICAgICAgICAgIC8vZ2V0IGNvbHVtbiB2YWx1ZVxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgICAgIGxldCBoRyA9IHJvd1t4XVxuICAgICAgICAgICAgICAgIGlmICghaEcpIGhHID0gMFxuXG4gICAgICAgICAgICAgICAgaWYgKGhHIHx8IGhHXykge1xuICAgICAgICAgICAgICAgICAgICAvL2RyYXcgbGluZSBvbmx5IHdoZW4gYXQgbGVhc3Qgb25lIG9mIGJvdGggdmFsdWVzIGlzIG5vbi1udWxsXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyB0ZXN0IGJlemllckN1cnZlVG9cbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyh4ICsgciAvIDIsIHkgKyBoRylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2Vsc2UgbW92ZSB0aGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyh4ICsgciAvIDIsIHkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vc3RvcmUgdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgICAgICAgICAgICAgaEdfID0gaEdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9sYXN0IHBvaW50XG4gICAgICAgICAgICBpZiAoaEdfKSBjZy5jdHgubGluZVRvKHhNYXggKyByIC8gMiwgeSlcblxuICAgICAgICAgICAgLy9kcmF3IGZpbGxcbiAgICAgICAgICAgIGNvbnN0IGZjID0gdGhpcy5maWxsQ29sb3IoeSwgeXMsIHIsIHpmKVxuICAgICAgICAgICAgaWYgKGZjICYmIGZjICE9ICdub25lJykge1xuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsU3R5bGUgPSBmY1xuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kcmF3IGxpbmVcbiAgICAgICAgICAgIGNvbnN0IGxjID0gdGhpcy5saW5lQ29sb3IoeSwgeXMsIHIsIHpmKVxuICAgICAgICAgICAgY29uc3QgbHcgPSB0aGlzLmxpbmVXaWR0aCh5LCB5cywgciwgemYpXG4gICAgICAgICAgICBpZiAobGMgJiYgbGMgIT0gJ25vbmUnICYmIGx3ID4gMCkge1xuICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IGxjXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVXaWR0aCA9IGx3XG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IFRhbmFrYVN0eWxlIH0gZnJvbSAnLi9UYW5ha2FTdHlsZS5qcydcbmltcG9ydCB7IFN0cm9rZVN0eWxlIH0gZnJvbSAnLi9TdHJva2VTdHlsZS5qcydcbmltcG9ydCB7IFNxdWFyZUNvbG9yQ2F0V0dMU3R5bGUgfSBmcm9tICcuL1NxdWFyZUNvbG9yQ2F0V0dMU3R5bGUuanMnXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xuXG4vKipcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIExlZ29TdHlsZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAgICogQHJldHVybnMge0FycmF5LjxTdHlsZT59XG4gICAgICovXG4gICAgc3RhdGljIGdldChjb2wsIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvL3RoZSBjb2xvcnNcbiAgICAgICAgLy9odHRwOi8vd3d3Lmplbm55c2NyYXlvbmNvbGxlY3Rpb24uY29tLzIwMjEvMDYvYWxsLWN1cnJlbnQtbGVnby1jb2xvcnMuaHRtbFxuICAgICAgICAvL2h0dHBzOi8vbGVvbmF3aWN6LmdpdGh1Yi5pby9sZWdvY29sb3JzL3JlZmVyZW5jZS9maWd1cmVzL1JFQURNRS1wbG90LTEucG5nXG4gICAgICAgIG9wdHMuY29sb3JzID0gb3B0cy5jb2xvcnMgfHwgW1xuICAgICAgICAgICAgJyMwMDg1MmInLCAvL2RhcmtlciBncmVlblxuICAgICAgICAgICAgJyNhZmQyNDYnLCAvL2xpZ2h0IGdyZWVuXG4gICAgICAgICAgICAnI2ZhYzgwYScsIC8vZGFyayB5ZWxsb3dcbiAgICAgICAgICAgICcjYmI4MDVhJywgLy9icm93blxuICAgICAgICAgICAgJyNkNjc5MjMnLCAvL21vc3RhcmRcbiAgICAgICAgICAgICcjY2I0ZTI5JywgLy9yZWRpc2hcbiAgICAgICAgICAgICcjYjQwMDAwJywgLy9yZWRcbiAgICAgICAgICAgICcjNzIwMDEyJywgLy9kYXJrIHJlZFxuICAgICAgICAgICAgLy9cInB1cnBsZVwiLFxuICAgICAgICAgICAgLy9cIiNlZWVcIiAvL3doaXRoZVxuICAgICAgICBdXG5cbiAgICAgICAgb3B0cy5jb2xEYXJrID0gb3B0cy5jb2xEYXJrIHx8ICcjMzMzJ1xuICAgICAgICBvcHRzLmNvbEJyaWdodCA9IG9wdHMuY29sQnJpZ2h0IHx8ICcjYWFhJ1xuICAgICAgICBvcHRzLndpZHRoRmFjdG9yID0gb3B0cy53aWR0aEZhY3RvciB8fCAwLjEyXG5cbiAgICAgICAgLy9yZXVzZSB0YW5ha2EgYXMgYmFzaXNcbiAgICAgICAgY29uc3QgdHMgPSBUYW5ha2FTdHlsZS5nZXQoY29sLCBvcHRzKVxuICAgICAgICAvL3N0eWxlIHRvIHNob3cgbGltaXRzIGJldHdlZW4gcGllY2VzXG4gICAgICAgIGNvbnN0IHNzdCA9IG5ldyBTdHJva2VTdHlsZSh7XG4gICAgICAgICAgICBzdHJva2VDb2xvcjogKCkgPT4gJyM2NjYnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICh2LCByLCBzLCB6KSA9PiAwLjIgKiB6LFxuICAgICAgICAgICAgZmlsdGVyOiBvcHRzLmZpbHRlcixcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdHNbMF0sXG4gICAgICAgICAgICBzc3QsXG4gICAgICAgICAgICB0c1sxXSxcbiAgICAgICAgICAgIG5ldyBMZWdvVG9wU3R5bGUoeyBjb2xEYXJrOiBvcHRzLmNvbERhcmssIGNvbEJyaWdodDogb3B0cy5jb2xCcmlnaHQsIGZpbHRlcjogb3B0cy5maWx0ZXIgfSksXG4gICAgICAgIF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk6c3RyaW5nfSBjb2xcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48U3R5bGU+fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDYXQoY29sLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgb3B0cy5jb2xEYXJrID0gb3B0cy5jb2xEYXJrIHx8ICcjMzMzJ1xuICAgICAgICBvcHRzLmNvbEJyaWdodCA9IG9wdHMuY29sQnJpZ2h0IHx8ICcjYWFhJ1xuXG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IHMgPSBuZXcgU3F1YXJlQ29sb3JDYXRXR0xTdHlsZSh7IGNvbG9yQ29sOiBjb2wsIGNvbG9yOiBvcHRzLmNvbG9yIH0pXG4gICAgICAgIC8vc3R5bGUgdG8gc2hvdyBsaW1pdHMgYmV0d2VlbiBwaWVjZXNcbiAgICAgICAgY29uc3Qgc3N0ID0gbmV3IFN0cm9rZVN0eWxlKHsgc3Ryb2tlQ29sb3I6ICgpID0+ICcjNjY2Jywgc3Ryb2tlV2lkdGg6ICh2LCByLCBzLCB6KSA9PiAwLjIgKiB6IH0pXG5cbiAgICAgICAgcmV0dXJuIFtzLCBzc3QsIG5ldyBMZWdvVG9wU3R5bGUoeyBjb2xEYXJrOiBvcHRzLmNvbERhcmssIGNvbEJyaWdodDogb3B0cy5jb2xCcmlnaHQgfSldXG4gICAgfVxufVxuXG4vKipcbiAqIEEgc3R5bGUgdG8gZHJhdyB0b3AgY2lyY2xlIG9mIGxlZ28gYnJpY2tzLlxuICovXG5jbGFzcyBMZWdvVG9wU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fHVuZGVmaW5lZH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cbiAgICAgICAgdGhpcy5jb2xEYXJrID0gb3B0cy5jb2xEYXJrIHx8ICcjMzMzJ1xuICAgICAgICB0aGlzLmNvbEJyaWdodCA9IG9wdHMuY29sQnJpZ2h0IHx8ICcjYWFhJ1xuICAgIH1cblxuICAgIGRyYXcoY2VsbHMsIHIsIGNnKSB7XG4gICAgICAgIC8vZmlsdGVyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXG5cbiAgICAgICAgY2cuY3R4LmxpbmVXaWR0aCA9IDAuNiAqIGNnLmdldFpmKClcblxuICAgICAgICAvL2RhcmsgcGFydFxuICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbERhcmtcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjZWxscykge1xuICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICBjZy5jdHguYXJjKGMueCArIHIgKiAwLjUsIGMueSArIHIgKiAwLjUsIHIgKiAwLjU1ICogMC41LCBNYXRoLlBJIC8gNCwgLU1hdGguUEkgKiAoMyAvIDQpLCB0cnVlKVxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXG4gICAgICAgIH1cblxuICAgICAgICAvL2JyaWdodCBwYXJ0XG4gICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sQnJpZ2h0XG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgY2cuY3R4LmFyYyhjLnggKyByICogMC41LCBjLnkgKyByICogMC41LCByICogMC41NSAqIDAuNSwgTWF0aC5QSSAvIDQsIC1NYXRoLlBJICogKDMgLyA0KSwgZmFsc2UpXG4gICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcblxuLyoqXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBNb3NhaWNTdHlsZSBleHRlbmRzIFN0eWxlIHtcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjb2x1bW4vYXR0cmlidXRlIG9mIHRoZSB0YWJ1bGFyIGRhdGEgd2hlcmUgdG8gcmV0cmlldmUgdGhlIHZhcmlhYmxlIGZvciBjb2xvci5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvckNvbCA9IG9wdHMuY29sb3JDb2xcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCk6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKCkgPT4gJyNFQTZCQUMnKVxuXG4gICAgICAgIC8qKiBUaGUgbW9zYWljIGZhY3Rvciwgd2l0aGluIFswLDAuNV0uIFNldCB0byAwIGZvciBubyBtb3NhaWMgZWZmZWN0LiBTZXQgdG8gMC41IGZvciBzdHJvbmcgbW9zYWljIGVmZmVjdC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5tb3NhaWNGYWN0b3IgPSBvcHRzLm1vc2FpY0ZhY3RvciB8fCAwLjE1XG5cbiAgICAgICAgLyoqIFRoZSBtb3NhaWMgc2hhZG93IGZhY3Rvciwgd2l0aGluIFswLDAuNV0uIFNldCB0byAwIGZvciBubyBtb3NhaWMgc2hhZG93LiBTZXQgdG8gMC41IGZvciBzdHJvbmcgbW9zYWljIHNoYWRvdy5cbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zaGFkb3dGYWN0b3IgPSBvcHRzLnNoYWRvd0ZhY3RvciB8fCAwLjJcblxuICAgICAgICAvKiogVGhlIG1vc2FpYyBzaGFkb3cgY29sb3IuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuc2hhZG93Q29sb3IgPSBvcHRzLnNoYWRvd0NvbG9yIHx8ICcjNTU1J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCByZXNvbHV0aW9uLCBjZykge1xuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vem9vbSBmYWN0b3JcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXG5cbiAgICAgICAgbGV0IHN0YXRDb2xvclxuICAgICAgICBpZiAodGhpcy5jb2xvckNvbCkge1xuICAgICAgICAgICAgLy9jb21wdXRlIGNvbG9yIHZhcmlhYmxlIHN0YXRpc3RpY3NcbiAgICAgICAgICAgIHN0YXRDb2xvciA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuY29sb3JDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9zZXQgc3Ryb2tlIHN0eWxlLCBmb3Igc2hhZG93XG4gICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc2hhZG93Q29sb3JcbiAgICAgICAgY2cuY3R4LmxpbmVXaWR0aCA9IHRoaXMuc2hhZG93RmFjdG9yICogcmVzb2x1dGlvblxuICAgICAgICBjZy5jdHgubGluZUpvaW4gPSAncm91bmQnXG4gICAgICAgIGNnLmN0eC5saW5lQ2FwID0gJ2J1dHQnXG5cbiAgICAgICAgLy9mdW5jdGlvbiB0byBjb21wdXRlIHBvc2l0aW9uIG1vc2FpYyBlZmZlY3RcbiAgICAgICAgY29uc3QgZCA9IHJlc29sdXRpb24gKiB0aGlzLm1vc2FpY0ZhY3RvclxuICAgICAgICBjb25zdCBtb3NhaWMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBNYXRoLnJhbmRvbSgpICogZCwgeTogTWF0aC5yYW5kb20oKSAqIGQgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9kcmF3IHdpdGggSFRNTCBjYW52YXMgaW4gZ2VvIGNvb3JkaW5hdGVzXG4gICAgICAgIGNnLnNldENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xuICAgICAgICAgICAgLy9zZXQgZmlsbCBjb2xvclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3IoY2VsbFt0aGlzLmNvbG9yQ29sXSwgcmVzb2x1dGlvbiwgc3RhdENvbG9yKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFjb2wgfHwgY29sID09PSAnbm9uZScpIGNvbnRpbnVlXG4gICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sXG5cbiAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoY2VsbCwgcmVzb2x1dGlvbiwgemYpXG5cbiAgICAgICAgICAgIC8vY29tcHV0ZSBwb3NpdGlvbiBtb3NhaWMgZWZmZWN0XG4gICAgICAgICAgICBjb25zdCBsbCA9IG1vc2FpYygpLFxuICAgICAgICAgICAgICAgIHVsID0gbW9zYWljKCksXG4gICAgICAgICAgICAgICAgbHIgPSBtb3NhaWMoKSxcbiAgICAgICAgICAgICAgICB1ciA9IG1vc2FpYygpXG5cbiAgICAgICAgICAgIC8vc3Ryb2tlXG4gICAgICAgICAgICBpZiAodGhpcy5zaGFkb3dGYWN0b3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhjZWxsLnggKyBvZmZzZXQuZHggKyBsbC54LCBjZWxsLnkgKyBvZmZzZXQuZHkgKyBsbC55KVxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgcmVzb2x1dGlvbiAtIGxyLngsIGNlbGwueSArIG9mZnNldC5keSArIGxyLnkpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjZWxsLnggKyBvZmZzZXQuZHggKyByZXNvbHV0aW9uIC0gdXIueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgcmVzb2x1dGlvbiAtIHVyLnkpXG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZmlsbFxuXG4gICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgbGwueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgbGwueSlcbiAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgcmVzb2x1dGlvbiAtIGxyLngsIGNlbGwueSArIG9mZnNldC5keSArIGxyLnkpXG4gICAgICAgICAgICBjZy5jdHgubGluZVRvKGNlbGwueCArIG9mZnNldC5keCArIHJlc29sdXRpb24gLSB1ci54LCBjZWxsLnkgKyBvZmZzZXQuZHkgKyByZXNvbHV0aW9uIC0gdXIueSlcbiAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgdWwueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgcmVzb2x1dGlvbiAtIHVsLnkpXG4gICAgICAgICAgICBjZy5jdHguZmlsbCgpXG4gICAgICAgIH1cblxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByOiByZXNvbHV0aW9uLCB6ZjogemYsIHNDb2xvcjogc3RhdENvbG9yIH0pXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xuXG4vKipcbiAqXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBOaW5qYVN0YXJTdHlsZSBleHRlbmRzIFN0eWxlIHtcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjb2x1bW4vYXR0cmlidXRlIG9mIHRoZSB0YWJ1bGFyIGRhdGEgd2hlcmUgdG8gcmV0cmlldmUgdGhlIHZhcmlhYmxlIGZvciBjb2xvci5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvckNvbCA9IG9wdHMuY29sb3JDb2xcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKCgpID0+ICcjRUE2QkFDJykgLy8odixyLHMsemYpID0+IHt9XG5cbiAgICAgICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjb2x1bW4vYXR0cmlidXRlIG9mIHRoZSB0YWJ1bGFyIGRhdGEgd2hlcmUgdG8gcmV0cmlldmUgdGhlIHZhcmlhYmxlIGZvciBzaXplLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnNpemVDb2wgPSBvcHRzLnNpemVDb2xcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgYSBjZWxsLCB3aXRoaW4gWzAsMV06XG4gICAgICAgICAqICAtIDAsIG5vdGhpbmcgc2hvd25cbiAgICAgICAgICogIC0gMSwgZW50aXJlIHNxdWFyZVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaGFwZS5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbCk6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnNoYXBlID0gb3B0cy5zaGFwZSB8fCAoKCkgPT4gJ28nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCByLCBjZykge1xuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vem9vbSBmYWN0b3JcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXG5cbiAgICAgICAgbGV0IHN0YXRTaXplXG4gICAgICAgIGlmICh0aGlzLnNpemVDb2wpIHtcbiAgICAgICAgICAgIC8vaWYgc2l6ZSBpcyB1c2VkLCBzb3J0IGNlbGxzIGJ5IHNpemUgc28gdGhhdCB0aGUgYmlnZ2VzdCBhcmUgZHJhd24gZmlyc3RcbiAgICAgICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gYzJbdGhpcy5zaXplQ29sXSAtIGMxW3RoaXMuc2l6ZUNvbF0pXG4gICAgICAgICAgICAvL2FuZCBjb21wdXRlIHNpemUgdmFyaWFibGUgc3RhdGlzdGljc1xuICAgICAgICAgICAgc3RhdFNpemUgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLnNpemVDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXRDb2xvclxuICAgICAgICBpZiAodGhpcy5jb2xvckNvbCkge1xuICAgICAgICAgICAgLy9jb21wdXRlIGNvbG9yIHZhcmlhYmxlIHN0YXRpc3RpY3NcbiAgICAgICAgICAgIHN0YXRDb2xvciA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuY29sb3JDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9kcmF3IHdpdGggSFRNTCBjYW52YXNcbiAgICAgICAgLy9pbiBnZW8gY29vcmRpbmF0ZXNcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICBjb25zdCByMiA9IHIgKiAwLjVcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xuICAgICAgICAgICAgLy9jb2xvclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3IoY2VsbFt0aGlzLmNvbG9yQ29sXSwgciwgc3RhdENvbG9yLCB6ZikgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxuICAgICAgICAgICAgY2cuY3R4LmZpbGxTdHlsZSA9IGNvbFxuXG4gICAgICAgICAgICAvL3NoYXBlXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuc2hhcGUgPyB0aGlzLnNoYXBlKGNlbGwpIDogJ28nXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdub25lJykgY29udGludWVcblxuICAgICAgICAgICAgLy9zaXplXG4gICAgICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgICAgICBsZXQgc18gPSB0aGlzLnNpemUgfHwgKCgpID0+IDAuNSlcbiAgICAgICAgICAgIC8vc2l6ZSAtIGluIGdlbyB1bml0XG4gICAgICAgICAgICBjb25zdCBzRzIgPSBzXyhjZWxsW3RoaXMuc2l6ZUNvbF0sIHIsIHN0YXRTaXplLCB6ZikgKiByMlxuXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgICAgIC8vVE9ETyB1c2VcbiAgICAgICAgICAgIC8vY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoY2VsbCwgciwgemYpXG5cbiAgICAgICAgICAgIC8vY2VudGVyIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBjeCA9IGNlbGwueCArIHIyXG4gICAgICAgICAgICBjb25zdCBjeSA9IGNlbGwueSArIHIyXG5cbiAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhjeCwgY3kgKyByMilcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4ICsgc0cyLCBjeSArIHNHMilcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4ICsgcjIsIGN5KVxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3ggKyBzRzIsIGN5IC0gc0cyKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3gsIGN5IC0gcjIpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjeCAtIHNHMiwgY3kgLSBzRzIpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjeCAtIHIyLCBjeSlcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4IC0gc0cyLCBjeSArIHNHMilcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbCgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAnbycpIHtcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKGN4LCBjeSArIHNHMilcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4ICsgcjIsIGN5ICsgcjIpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjeCArIHNHMiwgY3kpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjeCArIHIyLCBjeSAtIHIyKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3gsIGN5IC0gc0cyKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3ggLSByMiwgY3kgLSByMilcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4IC0gc0cyLCBjeSlcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4IC0gcjIsIGN5ICsgcjIpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGwoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2hhcGU6JyArIHNoYXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcjogciwgemY6IHpmLCBzU2l6ZTogc3RhdFNpemUsIHNDb2xvcjogc3RhdENvbG9yIH0pXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xuXG4vKipcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFBpbGxhclN0eWxlIGV4dGVuZHMgU3R5bGUge1xuICAgIC8vVE9ETyBtYWtlIGEgd2ViR0wgdmVyc2lvbiA/XG5cbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuaGVpZ2h0Q29sID0gb3B0cy5oZWlnaHRDb2xcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGhlaWdodCBvZiB0aGUgbGluZSByZXByZXNlbnRpbmcgYSBjZWxsLCBpbiBnZW8gdW5pdFxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodFxuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNvbG9yQ29sID0gb3B0cy5jb2xvckNvbFxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIGxpbmUgcmVwcmVzZW50aW5nIGEgY2VsbC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKCgpID0+ICcjYzA4YzU5JykgLy9iYlxuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLndpZHRoQ29sID0gb3B0cy53aWR0aENvbFxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgd2lkdGggb2YgdGhlIGxpbmUgcmVwcmVzZW50aW5nIGEgY2VsbCwgaW4gZ2VvIHVuaXRcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8ICgodiwgcikgPT4gMC41ICogcilcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuc2ltcGxlID0gb3B0cy5zaW1wbGUgPT0gdHJ1ZVxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnZpZXdIZWlnaHRGYWN0b3IgPSBvcHRzLnZpZXdIZWlnaHRGYWN0b3IgfHwgMS41XG4gICAgICAgIC8vMCwwIGlzIHRoZSBjZW50ZXJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudmlld1NYID0gb3B0cy52aWV3U1ggPT0gdW5kZWZpbmVkID8gMCA6IG9wdHMudmlld1NYXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnZpZXdTWSA9IG9wdHMudmlld1NZID09IHVuZGVmaW5lZCA/IC0wLjUgOiBvcHRzLnZpZXdTWVxuXG4gICAgICAgIC8vVE9ETyByZXBsYWNlIHdpdGggc3VuIGxvY2F0aW9uID9cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc2hhZG93RGlyZWN0aW9uID1cbiAgICAgICAgICAgIG9wdHMuc2hhZG93RGlyZWN0aW9uID09IHVuZGVmaW5lZCA/ICgtNDAuMyAqIE1hdGguUEkpIC8gMTgwLjAgOiBvcHRzLnNoYWRvd0RpcmVjdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zaGFkb3dGYWN0b3IgPSBvcHRzLnNoYWRvd0ZhY3RvciB8fCAwLjNcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuc2hhZG93Q29sb3IgPSBvcHRzLnNoYWRvd0NvbG9yIHx8ICcjMDAwMDAwMzMnXG5cbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMub3V0bGluZUNvbCA9IG9wdHMub3V0bGluZUNvbCB8fCAnI0ZGRkZGRidcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMub3V0bGluZVdpZHRoUGl4ID0gb3B0cy5vdXRsaW5lV2lkdGhQaXggPT0gdW5kZWZpbmVkID8gMC41IDogb3B0cy5vdXRsaW5lV2lkdGhQaXhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGNlbGxzIGFzIHNlZ21lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCByLCBjZykge1xuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vem9vbSBmYWN0b3JcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXG5cbiAgICAgICAgbGV0IHN0YXRIZWlnaHRcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0Q29sKSB7XG4gICAgICAgICAgICAvL2NvbXB1dGUgc2l6ZSB2YXJpYWJsZSBzdGF0aXN0aWNzXG4gICAgICAgICAgICBzdGF0SGVpZ2h0ID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5oZWlnaHRDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXRDb2xvclxuICAgICAgICBpZiAodGhpcy5jb2xvckNvbCkge1xuICAgICAgICAgICAgLy9jb21wdXRlIGNvbG9yIHZhcmlhYmxlIHN0YXRpc3RpY3NcbiAgICAgICAgICAgIHN0YXRDb2xvciA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuY29sb3JDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXRXaWR0aFxuICAgICAgICBpZiAodGhpcy53aWR0aENvbCkge1xuICAgICAgICAgICAgLy9hbmQgY29tcHV0ZSBzaXplIHZhcmlhYmxlIHN0YXRpc3RpY3NcbiAgICAgICAgICAgIHN0YXRXaWR0aCA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMud2lkdGhDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9nZXQgdmlldyBjZW50ZXIgZ2VvIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGN2eCA9IGNnLmdldENlbnRlcigpLnggKyB0aGlzLnZpZXdTWCAqIGNnLncgKiB6ZlxuICAgICAgICBjb25zdCBjdnkgPSBjZy5nZXRDZW50ZXIoKS55ICsgdGhpcy52aWV3U1kgKiBjZy5oICogemZcbiAgICAgICAgLy9nZXQgdmlldyBoZWlnaHRcbiAgICAgICAgY29uc3QgSCA9IHRoaXMudmlld0hlaWdodEZhY3RvciAqIChjZy53ICsgY2cuaCkgKiAwLjUgKiB6ZlxuXG4gICAgICAgIC8vc29ydCBjZWxscyBieSB5IGFuZCB4XG4gICAgICAgIC8vY29uc3QgZGlzdFRvVmlld0NlbnRlciA9IChjKSA9PiB7IGNvbnN0IGR4ID0gY3Z4IC0gYy54LCBkeSA9IGN2eSAtIGMueTsgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgfVxuICAgICAgICBjZWxscy5zb3J0KChjMSwgYzIpID0+IDEwMDAwMDAwMCAqIChjMi55IC0gYzEueSkgKyBjMS54IC0gYzIueClcblxuICAgICAgICBjZy5jdHgubGluZUNhcCA9IHRoaXMuc2ltcGxlID8gJ2J1dHQnIDogJ3JvdW5kJ1xuXG4gICAgICAgIC8vZHJhdyBpbiBnZW8gY29vcmRpbmF0ZXNcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICAvL2RyYXcgc2hhZG93c1xuICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnNoYWRvd0NvbG9yXG4gICAgICAgIGNnLmN0eC5maWxsU3R5bGUgPSB0aGlzLnNoYWRvd0NvbG9yXG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgIC8vd2lkdGhcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIGNvbnN0IHdHID0gdGhpcy53aWR0aCA/IHRoaXMud2lkdGgoY1t0aGlzLndpZHRoQ29sXSwgciwgc3RhdFdpZHRoLCB6ZikgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghd0cgfHwgd0cgPCAwKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL2hlaWdodFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgY29uc3QgaEcgPSB0aGlzLmhlaWdodCA/IHRoaXMuaGVpZ2h0KGNbdGhpcy5oZWlnaHRDb2xdLCByLCBzdGF0SGVpZ2h0LCB6ZikgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghaEcgfHwgaEcgPCAwKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgICAgIC8vVE9ETyB1c2UgdGhhdFxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoYywgciwgemYpXG5cbiAgICAgICAgICAgIC8vc2V0IHdpZHRoXG4gICAgICAgICAgICBjZy5jdHgubGluZVdpZHRoID0gd0dcblxuICAgICAgICAgICAgLy9jb21wdXRlIGNlbGwgY2VudHJlIHBvc3RpdGlvblxuICAgICAgICAgICAgY29uc3QgY3ggPSBjLnggKyByIC8gMlxuICAgICAgICAgICAgY29uc3QgY3kgPSBjLnkgKyByIC8gMlxuICAgICAgICAgICAgY29uc3QgbHMgPSBoRyAqIHRoaXMuc2hhZG93RmFjdG9yXG5cbiAgICAgICAgICAgIC8vZHJhdyBzZWdtZW50XG4gICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oY3gsIGN5KVxuICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjeCArIGxzICogTWF0aC5jb3ModGhpcy5zaGFkb3dEaXJlY3Rpb24pLCBjeSArIGxzICogTWF0aC5zaW4odGhpcy5zaGFkb3dEaXJlY3Rpb24pKVxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBpZiAodGhpcy5zaW1wbGUpIHtcbiAgICAgICAgICAgICAgICAvL2RyYXcgYmFzZSBjaXJjbGVcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY2cuY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgY3gsIGN5LFxuICAgICAgICAgICAgICAgICAgICB3RyAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvL2NnLmN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbCgpO1xuICAgICAgICAgICAgfSovXG4gICAgICAgIH1cblxuICAgICAgICAvL2RyYXcgcGlsbGFyc1xuICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XG4gICAgICAgICAgICAvL2NvbG9yXG4gICAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yID8gdGhpcy5jb2xvcihjW3RoaXMuY29sb3JDb2xdLCByLCBzdGF0Q29sb3IpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoIWNvbCkgY29udGludWVcblxuICAgICAgICAgICAgLy93aWR0aFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgY29uc3Qgd0cgPSB0aGlzLndpZHRoID8gdGhpcy53aWR0aChjW3RoaXMud2lkdGhDb2xdLCByLCBzdGF0V2lkdGgsIHpmKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCF3RyB8fCB3RyA8IDApIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vaGVpZ2h0XG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICBjb25zdCBoRyA9IHRoaXMuaGVpZ2h0ID8gdGhpcy5oZWlnaHQoY1t0aGlzLmhlaWdodENvbF0sIHIsIHN0YXRIZWlnaHQsIHpmKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFoRyB8fCBoRyA8IDApIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxuICAgICAgICAgICAgLy9UT0RPIHVzZSB0aGF0XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjLCByLCB6ZilcblxuICAgICAgICAgICAgLy9jb21wdXRlIGNlbGwgY2VudHJlIHBvc3RpdGlvblxuICAgICAgICAgICAgY29uc3QgY3ggPSBjLnggKyByIC8gMlxuICAgICAgICAgICAgY29uc3QgY3kgPSBjLnkgKyByIC8gMlxuXG4gICAgICAgICAgICAvL2NvbXB1dGUgYW5nbGVcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gY3ggLSBjdngsXG4gICAgICAgICAgICAgICAgZHkgPSBjeSAtIGN2eVxuICAgICAgICAgICAgY29uc3QgYSA9IE1hdGguYXRhbjIoZHksIGR4KVxuICAgICAgICAgICAgY29uc3QgRCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbiAgICAgICAgICAgIGNvbnN0IGQgPSAoRCAqIGhHKSAvIChIIC0gaEcpXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNpbXBsZSkge1xuICAgICAgICAgICAgICAgIC8vZHJhdyBzZWdtZW50XG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gY29sXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVXaWR0aCA9IHdHXG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhjeCwgY3kpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjeCArIGQgKiBNYXRoLmNvcyhhKSwgY3kgKyBkICogTWF0aC5zaW4oYSkpXG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZHJhdyBiYWNrZ3JvdW5kIHNlZ21lbnRcbiAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLm91dGxpbmVDb2xcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVdpZHRoID0gd0cgKyAyICogdGhpcy5vdXRsaW5lV2lkdGhQaXggKiB6ZlxuICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oY3gsIGN5KVxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3ggKyBkICogTWF0aC5jb3MoYSksIGN5ICsgZCAqIE1hdGguc2luKGEpKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKVxuXG4gICAgICAgICAgICAgICAgLy9kcmF3IHNlZ21lbnRcbiAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVdpZHRoID0gd0dcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKGN4LCBjeSlcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4ICsgZCAqIE1hdGguY29zKGEpLCBjeSArIGQgKiBNYXRoLnNpbihhKSlcbiAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcblxuICAgICAgICAgICAgICAgIC8vZHJhdyB0b3AgY2lyY2xlXG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5vdXRsaW5lQ29sXG4gICAgICAgICAgICAgICAgLy9jZy5jdHguZmlsbFN0eWxlID0gXCIjYzA4YzU5XCJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVdpZHRoID0gdGhpcy5vdXRsaW5lV2lkdGhQaXggKiB6ZlxuICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5hcmMoY3ggKyBkICogTWF0aC5jb3MoYSksIGN5ICsgZCAqIE1hdGguc2luKGEpLCB3RyAqIDAuNSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKVxuICAgICAgICAgICAgICAgIC8vY2cuY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vaW4gY2FzZS4uLlxuICAgICAgICBjZy5jdHgubGluZUNhcCA9ICdidXR0J1xuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6Ziwgc0NvbG9yOiBzdGF0Q29sb3IgfSlcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vU3R5bGUuanMnXG5cbi8qKlxuICogQSBzdHlsZSB3aGVyZSBlYWNoIGNlbGwgaXMgcmVwcmVzZW50ZWQgYnkgYSBzZWdtZW50IHdob3NlIGxlbmd0aCwgd2lkdGgsIGNvbG9yIGFuZCBvcmllbnRhdGlvbiBjYW4gdmFyeSBhY2NvcmRpbmcgdG8gc3RhdGlzdGljYWwgdmFsdWVzLlxuICpcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFNlZ21lbnRTdHlsZSBleHRlbmRzIFN0eWxlIHtcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBvcmllbnRhdGlvbiAoaW4gZGVncmVlcykgb2YgdGhlIHNlZ21lbnQgcmVwcmVzZW50aW5nIGEgY2VsbC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gb3B0cy5vcmllbnRhdGlvbiB8fCAoKCkgPT4gMClcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2xvckNvbCA9IG9wdHMuY29sb3JDb2xcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsIHNlZ21lbnQuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiAnI0VBNkJBQycpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMubGVuZ3RoQ29sID0gb3B0cy5sZW5ndGhDb2xcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGxlbmd0aCBvZiB0aGUgc2VnbWVudCByZXByZXNlbnRpbmcgYSBjZWxsLCBpbiBnZW8gdW5pdFxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5sZW5ndGggPSBvcHRzLmxlbmd0aFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLndpZHRoQ29sID0gb3B0cy53aWR0aENvbFxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgd2lkdGggb2YgdGhlIHNlZ21lbnQgcmVwcmVzZW50aW5nIGEgY2VsbCwgaW4gZ2VvIHVuaXRcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBjZWxscyBhcyBzZWdtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGNnXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL3pvb20gZmFjdG9yXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxuXG4gICAgICAgIGxldCBzdGF0Q29sb3JcbiAgICAgICAgaWYgKHRoaXMuY29sb3JDb2wpIHtcbiAgICAgICAgICAgIC8vY29tcHV0ZSBjb2xvciB2YXJpYWJsZSBzdGF0aXN0aWNzXG4gICAgICAgICAgICBzdGF0Q29sb3IgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLmNvbG9yQ29sXSwgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGF0TGVuZ3RoXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aENvbCkge1xuICAgICAgICAgICAgLy9pZiBsZW5ndGggaXMgdXNlZCwgc29ydCBjZWxscyBieSBsZW5ndGggc28gdGhhdCB0aGUgbG9uZ2VzdHMgYXJlIGRyYXduIGZpcnN0XG4gICAgICAgICAgICBjZWxscy5zb3J0KChjMSwgYzIpID0+IGMyW3RoaXMubGVuZ3RoQ29sXSAtIGMxW3RoaXMubGVuZ3RoQ29sXSlcbiAgICAgICAgICAgIC8vYW5kIGNvbXB1dGUgc2l6ZSB2YXJpYWJsZSBzdGF0aXN0aWNzXG4gICAgICAgICAgICBzdGF0TGVuZ3RoID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5sZW5ndGhDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXRXaWR0aFxuICAgICAgICBpZiAodGhpcy53aWR0aENvbCkge1xuICAgICAgICAgICAgLy9hbmQgY29tcHV0ZSBzaXplIHZhcmlhYmxlIHN0YXRpc3RpY3NcbiAgICAgICAgICAgIHN0YXRXaWR0aCA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMud2lkdGhDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgY2cuY3R4LmxpbmVDYXAgPSAnYnV0dCdcblxuICAgICAgICAvL2NvbnZlcnNpb24gZmFjdG9yIGRlZ3JlZSAtPiByYWRpYW5cbiAgICAgICAgY29uc3QgZiA9IE1hdGguUEkgLyAxODBcblxuICAgICAgICAvL2RyYXcgaW4gZ2VvIGNvb3JkaW5hdGVzXG4gICAgICAgIGNnLnNldENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgZm9yIChsZXQgYyBvZiBjZWxscykge1xuICAgICAgICAgICAgLy9jb2xvclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3IoY1t0aGlzLmNvbG9yQ29sXSwgciwgc3RhdENvbG9yKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFjb2wpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vd2lkdGhcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIGNvbnN0IHdHID0gdGhpcy53aWR0aCA/IHRoaXMud2lkdGgoY1t0aGlzLndpZHRoQ29sXSwgciwgc3RhdFdpZHRoLCB6ZikgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghd0cgfHwgd0cgPCAwKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL2xlbmd0aFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgY29uc3QgbEcgPSB0aGlzLmxlbmd0aCA/IHRoaXMubGVuZ3RoKGNbdGhpcy5sZW5ndGhDb2xdLCByLCBzdGF0TGVuZ3RoLCB6ZikgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghbEcgfHwgbEcgPCAwKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL29yaWVudGF0aW9uIChpbiByYWRpYW4pXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgIGNvbnN0IG9yID0gdGhpcy5vcmllbnRhdGlvbihjKSAqIGZcbiAgICAgICAgICAgIGlmIChvciA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKG9yKSkgY29udGludWVcblxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjLCByLCB6ZilcblxuICAgICAgICAgICAgLy9zZXQgY29sb3IgYW5kIHdpZHRoXG4gICAgICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xcbiAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3R1xuXG4gICAgICAgICAgICAvL2NvbXB1dGUgc2VnbWVudCBjZW50cmUgcG9zdGl0aW9uXG4gICAgICAgICAgICBjb25zdCBjeCA9IGMueCArIHIgLyAyICsgb2Zmc2V0LmR4XG4gICAgICAgICAgICBjb25zdCBjeSA9IGMueSArIHIgLyAyICsgb2Zmc2V0LmR5XG5cbiAgICAgICAgICAgIC8vY29tcHV0ZSBzZWdtZW50IGRpcmVjdGlvblxuICAgICAgICAgICAgY29uc3QgZHggPSAwLjUgKiBNYXRoLmNvcyhvcikgKiBsR1xuICAgICAgICAgICAgY29uc3QgZHkgPSAwLjUgKiBNYXRoLnNpbihvcikgKiBsR1xuXG4gICAgICAgICAgICAvL2RyYXcgc2VnbWVudFxuICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICBjZy5jdHgubW92ZVRvKGN4IC0gZHgsIGN5IC0gZHkpXG4gICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4ICsgZHgsIGN5ICsgZHkpXG4gICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZCwgaWYgYW55XG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7XG4gICAgICAgICAgICB3aWR0aEZ1bjogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIHI6IHIsXG4gICAgICAgICAgICB6ZjogemYsXG4gICAgICAgICAgICBzQ29sb3I6IHN0YXRDb2xvcixcbiAgICAgICAgICAgIC8vc0xlbmd0aDogc3RhdExlbmd0aCxcbiAgICAgICAgICAgIHNXaWR0aDogc3RhdFdpZHRoLFxuICAgICAgICB9KVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnZDMtY29sb3InXG5cbi8qKlxuICogQSB2ZXJ5IGdlbmVyaWMgc3R5bGUgdGhhdCBzaG93cyBncmlkIGNlbGxzIHdpdGggc3BlY2lmaWMgY29sb3IsIHNpemUgYW5kIHNoYXBlLlxuICogSXQgY2FuIGJlIHVzZWQgdG8gc2hvdyB2YXJpYWJsZXMgYXMgY2VsbCBjb2xvcnMsIGNlbGwgc2l6ZSwgY2VsbCBzaGFwZSwgb3IgYW55IGNvbWJpbmF0aW9uIG9mIHRoZSB0aHJlZSB2aXN1YWwgdmFyaWFibGVzLlxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFNoYXBlQ29sb3JTaXplU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3IgY29sb3IuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuY29sb3JDb2wgPSBvcHRzLmNvbG9yQ29sXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvciBvZiB0aGUgY2VsbC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiAnI0VBNkJBQycpIC8vKHYscixzLHpmKSA9PiB7fVxuXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3Igc2l6ZS5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5zaXplQ29sID0gb3B0cy5zaXplQ29sXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIGEgY2VsbCBpbiBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2hhcGUgb2YgYSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsKTppbXBvcnQoXCIuLi9TdHlsZVwiKS5TaGFwZX0gKi9cbiAgICAgICAgdGhpcy5zaGFwZSA9IG9wdHMuc2hhcGUgfHwgKCgpID0+ICdzcXVhcmUnKVxuXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3IgY29sb3IgYWxwaGEuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuYWxwaGFDb2wgPSBvcHRzLmFscGhhQ29sXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvciBhbHBoYSBvZiB0aGUgY2VsbC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuYWxwaGFGID0gb3B0cy5hbHBoYUZcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGNlbGxzIGFzIHNxdWFyZXMsIHdpdGggdmFyaW91cyBjb2xvcnMgYW5kIHNpemUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9HZW9DYW52YXNcIikuR2VvQ2FudmFzfSBjZ1xuICAgICAqL1xuICAgIGRyYXcoY2VsbHMsIHIsIGNnKSB7XG4gICAgICAgIC8vZmlsdGVyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXG5cbiAgICAgICAgLy96b29tIGZhY3RvclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcblxuICAgICAgICBsZXQgc3RhdFNpemVcbiAgICAgICAgaWYgKHRoaXMuc2l6ZUNvbCkge1xuICAgICAgICAgICAgLy9pZiBzaXplIGlzIHVzZWQsIHNvcnQgY2VsbHMgYnkgc2l6ZSBzbyB0aGF0IHRoZSBiaWdnZXN0IGFyZSBkcmF3biBmaXJzdFxuICAgICAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiBjMlt0aGlzLnNpemVDb2xdIC0gYzFbdGhpcy5zaXplQ29sXSlcbiAgICAgICAgICAgIC8vYW5kIGNvbXB1dGUgc2l6ZSB2YXJpYWJsZSBzdGF0aXN0aWNzXG4gICAgICAgICAgICBzdGF0U2l6ZSA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuc2l6ZUNvbF0sIHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RhdENvbG9yXG4gICAgICAgIGlmICh0aGlzLmNvbG9yQ29sKSB7XG4gICAgICAgICAgICAvL2NvbXB1dGUgY29sb3IgdmFyaWFibGUgc3RhdGlzdGljc1xuICAgICAgICAgICAgc3RhdENvbG9yID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5jb2xvckNvbF0sIHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RhdEFscGhhXG4gICAgICAgIGlmICh0aGlzLmFscGhhQ29sKSB7XG4gICAgICAgICAgICAvL2NvbXB1dGUgY29sb3IgYWxwaGEgdmFyaWFibGUgc3RhdGlzdGljc1xuICAgICAgICAgICAgc3RhdEFscGhhID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5hbHBoYUNvbF0sIHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICAvL2RyYXcgd2l0aCBIVE1MIGNhbnZhc1xuICAgICAgICAvL2luIGdlbyBjb29yZGluYXRlc1xuICAgICAgICBjZy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgIGNvbnN0IHIyID0gciAqIDAuNVxuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIGNlbGxzKSB7XG4gICAgICAgICAgICAvL2NvbG9yXG4gICAgICAgICAgICBsZXQgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3IoY2VsbFt0aGlzLmNvbG9yQ29sXSwgciwgc3RhdENvbG9yLCB6ZikgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL2FscGhhXG4gICAgICAgICAgICBpZiAodGhpcy5hbHBoYUNvbCAmJiB0aGlzLmFscGhhRikge1xuICAgICAgICAgICAgICAgIC8vZ2V0IGFscGhhXG4gICAgICAgICAgICAgICAgY29uc3QgYWxwaGEgPSB0aGlzLmFscGhhRihjZWxsW3RoaXMuYWxwaGFDb2xdLCByLCBzdGF0QWxwaGEsIHpmKVxuICAgICAgICAgICAgICAgIGlmIChhbHBoYSA9PSAwKSBjb250aW51ZVxuICAgICAgICAgICAgICAgIC8vYXBwbHkgYWxwaGEgdG8gY29sb3IgY29sXG4gICAgICAgICAgICAgICAgY29uc3QgY29sXyA9IGNvbG9yKGNvbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbF8pIGNvbCA9IGByZ2JhKCR7Y29sXy5yfSwgJHtjb2xfLmd9LCAke2NvbF8uYn0sICR7YWxwaGF9KWA7XG4gICAgICAgICAgICAgICAgZWxzZSBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZGVjb2RlIGNvbG9yIFwiICsgY29sICsgXCIgaW4gU2hhcGVDb2xvclNpemVTdHlsZVwiKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3NoYXBlXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuc2hhcGUgPyB0aGlzLnNoYXBlKGNlbGwpIDogJ3NxdWFyZSdcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ25vbmUnKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL3NpemVcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgICAgIGxldCBzXyA9IHRoaXMuc2l6ZSB8fCAoKCkgPT4gcilcbiAgICAgICAgICAgIC8vc2l6ZSAtIGluIGdlbyB1bml0XG4gICAgICAgICAgICBjb25zdCBzRyA9IHNfKGNlbGxbdGhpcy5zaXplQ29sXSwgciwgc3RhdFNpemUsIHpmKVxuXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGNlbGwsIHIsIHpmKVxuXG4gICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdzcXVhcmUnKSB7XG4gICAgICAgICAgICAgICAgLy9kcmF3IHNxdWFyZVxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSByICogKDEgLSBzRyAvIHIpICogMC41XG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxSZWN0KGNlbGwueCArIGQgKyBvZmZzZXQuZHgsIGNlbGwueSArIGQgKyBvZmZzZXQuZHksIHNHLCBzRylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICAgICAgLy9kcmF3IGNpcmNsZVxuICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5hcmMoY2VsbC54ICsgcjIgKyBvZmZzZXQuZHgsIGNlbGwueSArIHIyICsgb2Zmc2V0LmR5LCBzRyAqIDAuNSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgICAgICAgICAvL2RyYXcgZG9udXRcbiAgICAgICAgICAgICAgICBjb25zdCB4YyA9IGNlbGwueCArIHIyICsgb2Zmc2V0LmR4LFxuICAgICAgICAgICAgICAgICAgICB5YyA9IGNlbGwueSArIHIyICsgb2Zmc2V0LmR5XG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyh4YywgeWMpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmFyYyh4YywgeWMsIHIyLCAwLCAyICogTWF0aC5QSSlcbiAgICAgICAgICAgICAgICBjZy5jdHguYXJjKHhjLCB5YywgKDEgLSBzRyAvIHIpICogcjIsIDAsIDIgKiBNYXRoLlBJLCB0cnVlKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5jbG9zZVBhdGgoKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdkaWFtb25kJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMyID0gc0cgKiAwLjVcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKGNlbGwueCArIHIyIC0gczIsIGNlbGwueSArIHIyKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY2VsbC54ICsgcjIsIGNlbGwueSArIHIyICsgczIpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjZWxsLnggKyByMiArIHMyLCBjZWxsLnkgKyByMilcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGNlbGwueCArIHIyLCBjZWxsLnkgKyByMiAtIHMyKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNoYXBlOicgKyBzaGFwZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6Ziwgc1NpemU6IHN0YXRTaXplLCBzQ29sb3I6IHN0YXRDb2xvciwgc0FscGhhOiBzdGF0QWxwaGEgfSlcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vU3R5bGUuanMnXG5cbi8qKlxuICogQSB2ZXJ5IGdlbmVyaWMgc3R5bGUgdGhhdCBzaG93cyBncmlkIGNlbGxzIHdpdGggc3BlY2lmaWMgY29sb3IsIHNpemUgYW5kIHNoYXBlLlxuICogSXQgY2FuIGJlIHVzZWQgdG8gc2hvdyB2YXJpYWJsZXMgYXMgY2VsbCBjb2xvcnMsIGNlbGwgc2l6ZSwgY2VsbCBzaGFwZSwgb3IgYW55IGNvbWJpbmF0aW9uIG9mIHRoZSB0aHJlZSB2aXN1YWwgdmFyaWFibGVzLlxuICpcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFNoYXBlQ29sb3JTaXplU3R5bGVfIGV4dGVuZHMgU3R5bGUge1xuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHZpZXcgc2NhbGUuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihBcnJheS48aW1wb3J0KCcuLi9EYXRhc2V0LmpzJykuQ2VsbD4sbnVtYmVyLCBudW1iZXIpOm9iamVjdH0gKi9cbiAgICAgICAgdGhpcy52aWV3U2NhbGUgPSBvcHRzLnZpZXdTY2FsZSAvLyhjZWxscyxyLHopID0+IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvciBvZiB0aGUgY2VsbC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vRGF0YXNldC5qcycpLkNlbGwsbnVtYmVyLCBudW1iZXIsb2JqZWN0KTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIC8vKGMscix6LG8pID0+IHt9XG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIGEgY2VsbCBpbiBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vRGF0YXNldC5qcycpLkNlbGwsbnVtYmVyLCBudW1iZXIsb2JqZWN0KTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZSAvLyhjLHIseixvKSA9PiB7fVxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2hhcGUgb2YgYSBjZWxsLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlciwgbnVtYmVyLG9iamVjdCk6aW1wb3J0KFwiLi4vU3R5bGUuanNcIikuU2hhcGV9ICovXG4gICAgICAgIHRoaXMuc2hhcGUgPSBvcHRzLnNoYXBlIC8vKGMscix6LG8pID0+IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBjZWxscyBhcyBzcXVhcmVzLCB3aXRoIHZhcmlvdXMgY29sb3JzIGFuZCBzaXplcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0dlb0NhbnZhcy5qc1wiKS5HZW9DYW52YXN9IGNnXG4gICAgICovXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL3pvb20gZmFjdG9yXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxuXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcbiAgICAgICAgY29uc3QgdmMgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByLCB6ZikgOiB1bmRlZmluZWRcblxuICAgICAgICAvL2RyYXcgd2l0aCBIVE1MIGNhbnZhcyBpbiBnZW8gY29vcmRpbmF0ZXNcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICBjb25zdCByMiA9IHIgKiAwLjVcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjZWxscykge1xuICAgICAgICAgICAgLy9jb2xvclxuICAgICAgICAgICAgbGV0IGNvbCA9IHRoaXMuY29sb3IgPyB0aGlzLmNvbG9yKGMsIHIsIHpmLCB2YykgOiBcImJsYWNrXCJcbiAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL3NpemVcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemUgPyB0aGlzLnNpemUoYywgciwgemYsIHZjKSA6IHJcbiAgICAgICAgICAgIGlmICghc2l6ZSkgY29udGludWVcblxuICAgICAgICAgICAgLy9zaGFwZVxuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLnNoYXBlID8gdGhpcy5zaGFwZShjLCByLCB6ZiwgdmMpIDogJ3NxdWFyZSdcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ25vbmUnKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGMsIHIsIHpmKVxuXG4gICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdzcXVhcmUnKSB7XG4gICAgICAgICAgICAgICAgLy9kcmF3IHNxdWFyZVxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSByICogKDEgLSBzaXplIC8gcikgKiAwLjVcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoYy54ICsgZCArIG9mZnNldC5keCwgYy55ICsgZCArIG9mZnNldC5keSwgc2l6ZSwgc2l6ZSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICAgICAgLy9kcmF3IGNpcmNsZVxuICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5hcmMoYy54ICsgcjIgKyBvZmZzZXQuZHgsIGMueSArIHIyICsgb2Zmc2V0LmR5LCBzaXplICogMC41LCAwLCAyICogTWF0aC5QSSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGwoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2RvbnV0Jykge1xuICAgICAgICAgICAgICAgIC8vZHJhdyBkb251dFxuICAgICAgICAgICAgICAgIGNvbnN0IHhjID0gYy54ICsgcjIgKyBvZmZzZXQuZHgsXG4gICAgICAgICAgICAgICAgICAgIHljID0gYy55ICsgcjIgKyBvZmZzZXQuZHlcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKHhjLCB5YylcbiAgICAgICAgICAgICAgICBjZy5jdHguYXJjKHhjLCB5YywgcjIsIDAsIDIgKiBNYXRoLlBJKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5hcmMoeGMsIHljLCAoMSAtIHNpemUgLyByKSAqIHIyLCAwLCAyICogTWF0aC5QSSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICBjZy5jdHguY2xvc2VQYXRoKClcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbCgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAnZGlhbW9uZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzMiA9IHNpemUgKiAwLjVcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKGMueCArIHIyIC0gczIsIGMueSArIHIyKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oYy54ICsgcjIsIGMueSArIHIyICsgczIpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjLnggKyByMiArIHMyLCBjLnkgKyByMilcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGMueCArIHIyLCBjLnkgKyByMiAtIHMyKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNoYXBlOicgKyBzaGFwZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6Ziwgdmlld1NjYWxlOiB2YyB9KVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcblxuLyoqIEB0eXBlZGVmIHt7eDpudW1iZXIseTpudW1iZXIsb3I6XCJ2XCJ8XCJoXCIsdjE6c3RyaW5nfHVuZGVmaW5lZCx2MjpzdHJpbmd8dW5kZWZpbmVkfX0gU2lkZSAqL1xuXG4vKipcbiAqIEEgc3R5bGUgdG8gc2hvdyB0aGUgc2lkZXMgb2YgZ3JpZCBjZWxscyBiYXNlZCBvbiB0aGVpciBkaWZmZXJlbnQgY2F0ZWdvcmllcy5cbiAqXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWRlQ2F0U3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSBjYXRlZ29yaWNhbCB2YWx1ZS5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5jb2wgPSBvcHRzLmNvbFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGljdGlvbmFyeSAoc3RyaW5nIC0+IGNvbG9yKSB3aGljaCBnaXZlIHRoZSBjb2xvciBvZiBlYWNoIGNhdGVnb3J5LlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fSAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvclxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgd2lkdGggb2YgYSBjZWxsIHNpZGUgbGluZSwgaW4gZ2VvIHVuaXRcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKFNpZGUsbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKHNpZGUsIHIsIHopID0+IHIgKiAwLjIpXG5cbiAgICAgICAgLyoqIEEgZmlsbCBjb2xvciBmb3IgdGhlIGNlbGxzLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gb3B0cy5maWxsQ29sb3JcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9HZW9DYW52YXNcIikuR2VvQ2FudmFzfSBjZ1xuICAgICAqL1xuICAgIGRyYXcoY2VsbHMsIHIsIGNnKSB7XG4gICAgICAgIC8vZmlsdGVyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXG5cbiAgICAgICAgaWYgKCFjZWxscyB8fCBjZWxscy5sZW5ndGggPT0gMCkgcmV0dXJuXG5cbiAgICAgICAgLy96b29tIGZhY3RvclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcblxuICAgICAgICAvKiogIEB0eXBlIHtBcnJheS48U2lkZT59ICovXG4gICAgICAgIGNvbnN0IHNpZGVzID0gW11cblxuICAgICAgICAvL21ha2UgaG9yaXpvbnRhbCBzaWRlc1xuICAgICAgICAvL3NvcnQgY2VsbHMgYnkgeCBhbmQgeVxuICAgICAgICBjZWxscy5zb3J0KChjMSwgYzIpID0+IChjMi54ID09IGMxLnggPyBjMS55IC0gYzIueSA6IGMxLnggLSBjMi54KSlcbiAgICAgICAgbGV0IGMxID0gY2VsbHNbMF1cbiAgICAgICAgbGV0IHYxID0gYzFbdGhpcy5jb2xdXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjMiA9IGNlbGxzW2ldXG4gICAgICAgICAgICBsZXQgdjIgPSBjMlt0aGlzLmNvbF1cblxuICAgICAgICAgICAgaWYgKGMxLnkgKyByID09IGMyLnkgJiYgYzEueCA9PSBjMi54KSB7XG4gICAgICAgICAgICAgICAgLy9jZWxscyBpbiBzYW1lIGNvbHVtbiBhbmQgdG91Y2ggYWxvbmcgaG9yaXpvbnRhbCBzaWRlXG4gICAgICAgICAgICAgICAgLy9tYWtlIHNoYXJlZCBzaWRlXG4gICAgICAgICAgICAgICAgaWYgKHYxICE9IHYyKSBzaWRlcy5wdXNoKHsgeDogYzEueCwgeTogYzIueSwgb3I6ICdoJywgdjE6IHYxLCB2MjogdjIgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jZWxscyBkbyBub3QgdG91Y2ggYWxvbmcgaG9yaXpvbnRhbCBzaWRlXG4gICAgICAgICAgICAgICAgLy9tYWtlIHR3byBzaWRlczogdG9wIG9uZSBmb3IgYzEsIGJvdHRvbSBmb3IgYzJcbiAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHsgeDogYzEueCwgeTogYzEueSArIHIsIG9yOiAnaCcsIHYxOiB2MSwgdjI6IHVuZGVmaW5lZCB9KVxuICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goeyB4OiBjMi54LCB5OiBjMi55LCBvcjogJ2gnLCB2MTogdW5kZWZpbmVkLCB2MjogdjIgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYzEgPSBjMlxuICAgICAgICAgICAgdjEgPSB2MlxuICAgICAgICB9XG5cbiAgICAgICAgLy9tYWtlIHZlcnRpY2FsIHNpZGVzXG4gICAgICAgIC8vc29ydCBjZWxscyBieSB5IGFuZCB4XG4gICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gKGMyLnkgPT0gYzEueSA/IGMxLnggLSBjMi54IDogYzEueSAtIGMyLnkpKVxuICAgICAgICBjMSA9IGNlbGxzWzBdXG4gICAgICAgIHYxID0gYzFbdGhpcy5jb2xdXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjMiA9IGNlbGxzW2ldXG4gICAgICAgICAgICBsZXQgdjIgPSBjMlt0aGlzLmNvbF1cblxuICAgICAgICAgICAgaWYgKGMxLnggKyByID09IGMyLnggJiYgYzEueSA9PSBjMi55KSB7XG4gICAgICAgICAgICAgICAgLy9jZWxscyBpbiBzYW1lIHJvdyBhbmQgdG91Y2ggYWxvbmcgdmVydGljYWwgc2lkZVxuICAgICAgICAgICAgICAgIC8vbWFrZSBzaGFyZWQgc2lkZVxuICAgICAgICAgICAgICAgIGlmICh2MSAhPSB2Mikgc2lkZXMucHVzaCh7IHg6IGMxLnggKyByLCB5OiBjMS55LCBvcjogJ3YnLCB2MTogdjEsIHYyOiB2MiB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2NlbGxzIGRvIG5vdCB0b3VjaCBhbG9uZyB2ZXJ0aWNhbCBzaWRlXG4gICAgICAgICAgICAgICAgLy9tYWtlIHR3byBzaWRlczogcmlnaHQgb25lIGZvciBjMSwgbGVmdCBmb3IgYzJcbiAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHsgeDogYzEueCArIHIsIHk6IGMxLnksIG9yOiAndicsIHYxOiB2MSwgdjI6IHVuZGVmaW5lZCB9KVxuICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goeyB4OiBjMi54LCB5OiBjMi55LCBvcjogJ3YnLCB2MTogdW5kZWZpbmVkLCB2MjogdjIgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYzEgPSBjMlxuICAgICAgICAgICAgdjEgPSB2MlxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHNpZGVzLmxlbmd0aCA9PSAwKSByZXR1cm5cblxuICAgICAgICAvL2RyYXcgaW4gZ2VvIGNvb3JkaW5hdGVzXG4gICAgICAgIGNnLnNldENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgLy9kcmF3IGNlbGxzLCBpZiBmaWxsQ29sb3Igc3BlY2lmaWVkXG4gICAgICAgIGlmICh0aGlzLmZpbGxDb2xvcilcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYyA9IHRoaXMuZmlsbENvbG9yKGMpXG4gICAgICAgICAgICAgICAgaWYgKCFmYyB8fCBmYyA9PSAnbm9uZScpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxTdHlsZSA9IGZjXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxSZWN0KGMueCwgYy55LCByLCByKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8vZHJhdyBzaWRlc1xuICAgICAgICBjZy5jdHgubGluZUNhcCA9ICdidXR0J1xuICAgICAgICBmb3IgKGxldCBzIG9mIHNpZGVzKSB7XG4gICAgICAgICAgICAvL3dpZHRoXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICBjb25zdCB3RyA9IHRoaXMud2lkdGggPyB0aGlzLndpZHRoKHMsIHIsIHpmKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCF3RyB8fCB3RyA8PSAwKSBjb250aW51ZVxuICAgICAgICAgICAgY29uc3QgdzIgPSB3RyAqIDAuNVxuXG4gICAgICAgICAgICAvL3NldCBjb2xvciBhbmQgd2lkdGhcbiAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3R1xuXG4gICAgICAgICAgICAvL2RyYXcgc2VnbWVudCB3aXRoIGNvcnJlY3Qgb3JpZW50YXRpb25cbiAgICAgICAgICAgIGlmIChzLm9yID09PSAnaCcpIHtcbiAgICAgICAgICAgICAgICAvL3RvcCBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKHMudjIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3Jbcy52Ml1cbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhzLngsIHMueSArIHcyKVxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKHMueCArIHIsIHMueSArIHcyKVxuICAgICAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2JvdHRvbSBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKHMudjEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3Jbcy52MV1cbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhzLngsIHMueSAtIHcyKVxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKHMueCArIHIsIHMueSAtIHcyKVxuICAgICAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vcmlnaHQgbGluZVxuICAgICAgICAgICAgICAgIGlmIChzLnYyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yW3MudjJdXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8ocy54ICsgdzIsIHMueSlcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhzLnggKyB3Miwgcy55ICsgcilcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9sZWZ0IGxpbmVcbiAgICAgICAgICAgICAgICBpZiAocy52MSkge1xuICAgICAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcltzLnYxXVxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKHMueCAtIHcyLCBzLnkpXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8ocy54IC0gdzIsIHMueSArIHIpXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6ZiB9KVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcblxuLyoqIEB0eXBlZGVmIHt7eDpudW1iZXIseTpudW1iZXIsb3I6XCJ2XCJ8XCJoXCIsdmFsdWU6bnVtYmVyfX0gU2lkZSAqL1xuXG4vKipcbiAqXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWRlU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3IgdGhlIGNlbGwgdmFsdWVzLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnZhbHVlQ29sID0gb3B0cy52YWx1ZUNvbFxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgdmFsdWUgb2YgYSBjZWxsIHNpZGUuIFRoaXMgdmFsdWUgaXMgY29tcHV0ZWQgZnJvbSB0aGUgdHdvIGFkamFjZW50IGNlbGwgdmFsdWVzLlxuICAgICAgICAgKiBGb3IgaG9yaXpvbnRhbCBzaWRlcywgdjEgaXMgdGhlIHZhbHVlIG9mIHRoZSBjZWxsIGJlbG93IGFuZCB2MiB0aGUgdmFsdWUgb2YgdGhlIGNlbGwgYWJvdmUuXG4gICAgICAgICAqIEZvciB2ZXJ0aWNhbCBzaWRlcywgdjEgaXMgdGhlIHZhbHVlIG9mIHRoZSBjZWxsIGxlZnQgYW5kIHYyIHRoZSB2YWx1ZSBvZiB0aGUgY2VsbCByaWdodC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcnx1bmRlZmluZWQsbnVtYmVyfHVuZGVmaW5lZCxudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudmFsdWUgPSBvcHRzLnZhbHVlIHx8ICgodjEsIHYyLCByLCBzLCB6ZikgPT4gMSlcblxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIGEgY2VsbCBzaWRlLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oU2lkZSxudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiAnI0VBNkJBQycpXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB3aWR0aCBvZiBhIGNlbGwgc2lkZSwgaW4gZ2VvIHVuaXRcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKFNpZGUsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKHNpZGUsIHIsIHMsIHpmKSA9PiAociAqIHNpZGUudmFsdWUpIC8gNSlcblxuICAgICAgICAvKiogb3JpZW50YXRpb24uIFNldCB0byA5MCB0byBzaG93IHNpZGVzIGFzIHNsb3BlIGxpbmVzIGZvciBleGFtcGxlLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gb3B0cy5vcmllbnRhdGlvbiB8fCAwXG5cbiAgICAgICAgLyoqIEEgZmlsbCBjb2xvciBmb3IgdGhlIGNlbGxzLlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gb3B0cy5maWxsQ29sb3JcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9HZW9DYW52YXNcIikuR2VvQ2FudmFzfSBjZ1xuICAgICAqL1xuICAgIGRyYXcoY2VsbHMsIHIsIGNnKSB7XG4gICAgICAgIC8vZmlsdGVyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXG5cbiAgICAgICAgLy96b29tIGZhY3RvclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcblxuICAgICAgICAvL2NvbXB1dGUgc3RhdHMgb24gY2VsbCB2YWx1ZXNcbiAgICAgICAgbGV0IHN0YXRWYWx1ZVxuICAgICAgICBpZiAodGhpcy52YWx1ZUNvbCkge1xuICAgICAgICAgICAgLy9jb21wdXRlIGNvbG9yIHZhcmlhYmxlIHN0YXRpc3RpY3NcbiAgICAgICAgICAgIHN0YXRWYWx1ZSA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMudmFsdWVDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqICBAdHlwZSB7QXJyYXkuPFNpZGU+fSAqL1xuICAgICAgICBjb25zdCBzaWRlcyA9IFtdXG5cbiAgICAgICAgLy9tYWtlIGhvcml6b250YWwgc2lkZXNcbiAgICAgICAgLy9zb3J0IGNlbGxzIGJ5IHggYW5kIHlcbiAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiAoYzIueCA9PSBjMS54ID8gYzEueSAtIGMyLnkgOiBjMS54IC0gYzIueCkpXG4gICAgICAgIGxldCBjMSA9IGNlbGxzWzBdXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjMiA9IGNlbGxzW2ldXG5cbiAgICAgICAgICAgIGlmICgoYzEueSArIHIgPT0gYzIueSkgJiYgKGMxLnggPT0gYzIueCkpXG4gICAgICAgICAgICAgICAgLy9jZWxscyBpbiBzYW1lIGNvbHVtbiBhbmQgdG91Y2ggYWxvbmcgaG9yaXpvbnRhbCBzaWRlXG4gICAgICAgICAgICAgICAgLy9tYWtlIHNoYXJlZCBzaWRlXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IGMxLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IGMyLnksXG4gICAgICAgICAgICAgICAgICAgIG9yOiAnaCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlKGMxW3RoaXMudmFsdWVDb2xdLCBjMlt0aGlzLnZhbHVlQ29sXSwgciwgc3RhdFZhbHVlLCB6ZiksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY2VsbHMgZG8gbm90IHRvdWNoIGFsb25nIGhvcml6b250YWwgc2lkZVxuICAgICAgICAgICAgICAgIC8vbWFrZSB0d28gc2lkZXM6IHRvcCBvbmUgZm9yIGMxLCBib3R0b20gZm9yIGMyXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IGMxLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IGMxLnkgKyByLFxuICAgICAgICAgICAgICAgICAgICBvcjogJ2gnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZShjMVt0aGlzLnZhbHVlQ29sXSwgdW5kZWZpbmVkLCByLCBzdGF0VmFsdWUsIHpmKSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB4OiBjMi54LFxuICAgICAgICAgICAgICAgICAgICB5OiBjMi55LFxuICAgICAgICAgICAgICAgICAgICBvcjogJ2gnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSh1bmRlZmluZWQsIGMyW3RoaXMudmFsdWVDb2xdLCByLCBzdGF0VmFsdWUsIHpmKSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjMSA9IGMyXG4gICAgICAgIH1cblxuICAgICAgICAvL21ha2UgdmVydGljYWwgc2lkZXNcbiAgICAgICAgLy9zb3J0IGNlbGxzIGJ5IHkgYW5kIHhcbiAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiAoYzIueSA9PSBjMS55ID8gYzEueCAtIGMyLnggOiBjMS55IC0gYzIueSkpXG4gICAgICAgIGMxID0gY2VsbHNbMF1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGMyID0gY2VsbHNbaV1cblxuICAgICAgICAgICAgaWYgKChjMS54ICsgciA9PSBjMi54KSAmJiAoYzEueSA9PSBjMi55KSlcbiAgICAgICAgICAgICAgICAvL2NlbGxzIGluIHNhbWUgcm93IGFuZCB0b3VjaCBhbG9uZyB2ZXJ0aWNhbCBzaWRlXG4gICAgICAgICAgICAgICAgLy9tYWtlIHNoYXJlZCBzaWRlXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IGMxLnggKyByLFxuICAgICAgICAgICAgICAgICAgICB5OiBjMS55LFxuICAgICAgICAgICAgICAgICAgICBvcjogJ3YnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZShjMVt0aGlzLnZhbHVlQ29sXSwgYzJbdGhpcy52YWx1ZUNvbF0sIHIsIHN0YXRWYWx1ZSwgemYpLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2NlbGxzIGRvIG5vdCB0b3VjaCBhbG9uZyB2ZXJ0aWNhbCBzaWRlXG4gICAgICAgICAgICAgICAgLy9tYWtlIHR3byBzaWRlczogcmlnaHQgb25lIGZvciBjMSwgbGVmdCBmb3IgYzJcbiAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgeDogYzEueCArIHIsXG4gICAgICAgICAgICAgICAgICAgIHk6IGMxLnksXG4gICAgICAgICAgICAgICAgICAgIG9yOiAndicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlKGMxW3RoaXMudmFsdWVDb2xdLCB1bmRlZmluZWQsIHIsIHN0YXRWYWx1ZSwgemYpLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IGMyLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IGMyLnksXG4gICAgICAgICAgICAgICAgICAgIG9yOiAndicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlKHVuZGVmaW5lZCwgYzJbdGhpcy52YWx1ZUNvbF0sIHIsIHN0YXRWYWx1ZSwgemYpLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGMxID0gYzJcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChzaWRlcy5sZW5ndGggPT0gMCkgcmV0dXJuXG5cbiAgICAgICAgLy9jb21wdXRlIHN0YXRzIG9uIHNpZGVzXG4gICAgICAgIGNvbnN0IHN0YXRTaWRlcyA9IFNpZGVTdHlsZS5nZXRTaWRlU3RhdGlzdGljcyhzaWRlcywgdHJ1ZSlcblxuICAgICAgICAvL2RyYXcgaW4gZ2VvIGNvb3JkaW5hdGVzXG4gICAgICAgIGNnLnNldENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgLy9kcmF3IGNlbGxzLCBpZiBmaWxsQ29sb3Igc3BlY2lmaWVkXG4gICAgICAgIGlmICh0aGlzLmZpbGxDb2xvcilcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYyA9IHRoaXMuZmlsbENvbG9yKGMpXG4gICAgICAgICAgICAgICAgaWYgKCFmYyB8fCBmYyA9PSAnbm9uZScpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxTdHlsZSA9IGZjXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxSZWN0KGMueCwgYy55LCByLCByKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8vZHJhdyBzaWRlc1xuICAgICAgICBjZy5jdHgubGluZUNhcCA9ICdidXR0J1xuICAgICAgICBjb25zdCByMiA9IHIgLyAyXG4gICAgICAgIGZvciAobGV0IHMgb2Ygc2lkZXMpIHtcbiAgICAgICAgICAgIC8vY29sb3JcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IgPyB0aGlzLmNvbG9yKHMsIHIsIHN0YXRTaWRlcywgemYpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoIWNvbCB8fCBjb2wgPT0gJ25vbmUnKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL3dpZHRoXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICBjb25zdCB3RyA9IHRoaXMud2lkdGggPyB0aGlzLndpZHRoKHMsIHIsIHN0YXRTaWRlcywgemYpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoIXdHIHx8IHdHIDw9IDApIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8vc2V0IGNvbG9yIGFuZCB3aWR0aFxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gY29sXG4gICAgICAgICAgICBjZy5jdHgubGluZVdpZHRoID0gd0dcblxuICAgICAgICAgICAgLy9kcmF3IHNlZ21lbnQgd2l0aCBjb3JyZWN0IG9yaWVudGF0aW9uXG4gICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09IDkwKSB7XG4gICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhzLnggKyByMiwgcy55ICsgcjIpXG4gICAgICAgICAgICAgICAgaWYgKHMub3IgPT09ICdoJykgY2cuY3R4LmxpbmVUbyhzLnggKyByMiwgcy55IC0gcjIpXG4gICAgICAgICAgICAgICAgZWxzZSBjZy5jdHgubGluZVRvKHMueCAtIHIyLCBzLnkgKyByMilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhzLngsIHMueSlcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKHMueCArIChzLm9yID09PSAnaCcgPyByIDogMCksIHMueSArIChzLm9yID09PSAndicgPyByIDogMCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6ZiB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgc29tZSBzdGF0aXN0aWNzIG9uIGEgdmFsdWUgb2Ygc29tZSBzaWRlcy5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gZGVmaW5lIGhvdyB0byBkcmF3IHNwZWNpZmljYWxseSB0aGUgc2lkZXMgd2l0aGluIHRoZSB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48U2lkZT59IHNpZGVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVaZXJvc1xuICAgICAqIEByZXR1cm5zIHtpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0IHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaWRlU3RhdGlzdGljcyhzaWRlcywgaWdub3JlWmVyb3MpIHtcbiAgICAgICAgaWYgKCFzaWRlcyB8fCBzaWRlcy5sZW5ndGggPT0gMCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBsZXQgbWluID0gSW5maW5pdHlcbiAgICAgICAgbGV0IG1heCA9IC1JbmZpbml0eVxuICAgICAgICAvL2xldCBzdW0gPSAwXG4gICAgICAgIC8vbGV0IG5iID0gMFxuICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc2lkZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBzLnZhbHVlXG4gICAgICAgICAgICBpZiAoaWdub3JlWmVyb3MgJiYgIXYpIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAodiA8IG1pbikgbWluID0gdlxuICAgICAgICAgICAgaWYgKHYgPiBtYXgpIG1heCA9IHZcbiAgICAgICAgICAgIC8vc3VtICs9IHZcbiAgICAgICAgICAgIC8vbmIrK1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1pbjogbWluLCBtYXg6IG1heCB9XG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xuaW1wb3J0IHsgbWFrZVdlYkdMQ2FudmFzIH0gZnJvbSAnLi4vdXRpbHMvd2ViR0xVdGlscy5qcydcbmltcG9ydCB7IFdlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZCB9IGZyb20gJy4uL3V0aWxzL1dlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZC5qcydcbmltcG9ydCB7IG1vbml0b3IsIG1vbml0b3JEdXJhdGlvbiB9IGZyb20gJy4uL3V0aWxzL1V0aWxzLmpzJ1xuXG4vKipcbiAqIFN0eWxlIGJhc2VkIG9uIHdlYkdMXG4gKiBUbyBzaG93IGNlbGxzIGFzIGNvbG9yZWQgc3F1YXJlcywgZnJvbSBjYXRlZ29yaWVzLlxuICogQWxscyBzcXVhcmVzIHdpdGggdGhlIHNhbWUgc2l6ZVxuICpcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFNxdWFyZUNvbG9yQ2F0V0dMU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSBjYXRlZ29yeSBvZiB0aGUgY2VsbCwgZm9yIGNvbG9yaW5nLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNvbG9yQ29sID0gb3B0cy5jb2xvckNvbFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGljdGlvbmFyeSAoc3RyaW5nIC0+IGNvbG9yKSB3aGljaCBnaXZlIHRoZSBjb2xvciBvZiBlYWNoIGNhdGVnb3J5LlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fSAqL1xuICAgICAgICBvcHRzLmNvbG9yID0gb3B0cy5jb2xvciB8fCB1bmRlZmluZWRcblxuICAgICAgICAvKiogQHR5cGUgeyBBcnJheS48c3RyaW5nPiB9IEBwcml2YXRlICovXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRzLmNvbG9yKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7IG9iamVjdCB9IEBwcml2YXRlICovXG4gICAgICAgIHRoaXMuY2F0VG9JID0ge31cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB0aGlzLmNhdFRvSVtrZXlzW2ldXSA9IGkgKyAnJ1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IEFycmF5LjxzdHJpbmc+IH0gQHByaXZhdGUgKi9cbiAgICAgICAgdGhpcy5jb2xvcnMgPSBbXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JzLnB1c2gob3B0cy5jb2xvclsnJyArIGtleXNbaV1dKVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIHRoZSBjZWxscywgaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuIEFsbCBjZWxscyBoYXZlIHRoZSBzYW1lIHNpemUuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZSAvLyAocmVzb2x1dGlvbiwgemYpID0+IC4uLlxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7IFdlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZCB9ICovXG4gICAgICAgIHRoaXMud2dwID0gbmV3IFdlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZCh0aGlzLmNvbG9ycylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9HZW9DYW52YXNcIikuR2VvQ2FudmFzfSBjZ1xuICAgICAqL1xuICAgIGRyYXcoY2VsbHMsIHIsIGNnKSB7XG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyoqKiBTcXVhcmVDb2xvckNhdFdHTFN0eWxlIGRyYXcnKVxuXG4gICAgICAgIC8vZmlsdGVyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXG5cbiAgICAgICAgLy96b29tIGZhY3RvclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcblxuICAgICAgICAvL2FkZCB2ZXJ0aWNlIGFuZCBmcmFnbWVudCBkYXRhXG4gICAgICAgIGNvbnN0IHIyID0gciAvIDJcbiAgICAgICAgbGV0IGMsXG4gICAgICAgICAgICBuYiA9IGNlbGxzLmxlbmd0aFxuICAgICAgICBjb25zdCB2ZXJ0aWNlc0J1ZmZlciA9IFtdXG4gICAgICAgIGNvbnN0IGlCdWZmZXIgPSBbXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIHtcbiAgICAgICAgICAgIGMgPSBjZWxsc1tpXVxuICAgICAgICAgICAgY29uc3QgY2F0ID0gY1t0aGlzLmNvbG9yQ29sXVxuICAgICAgICAgICAgaWYgKGNhdCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5leHBlY3RlZCBjYXRlZ29yeTogJyArIGNhdClcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICBjb25zdCBpXyA9IHRoaXMuY2F0VG9JW2NhdF1cbiAgICAgICAgICAgIGlmIChpc05hTigraV8pKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuZXhwZWN0ZWQgY2F0ZWdvcnkgaW5kZXg6ICcgKyBjYXQgKyAnICcgKyBpXylcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmVydGljZXNCdWZmZXIucHVzaChjLnggKyByMiwgYy55ICsgcjIpXG4gICAgICAgICAgICBpQnVmZmVyLnB1c2goK2lfKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignICAgd2ViZ2wgcHJvZ3JhbSBpbnB1dHMgcHJlcGFyYXRpb24nKVxuXG4gICAgICAgIC8vY3JlYXRlIGNhbnZhcyBhbmQgd2ViZ2wgcmVuZGVyZXJcbiAgICAgICAgY29uc3QgY3ZXR0wgPSBtYWtlV2ViR0xDYW52YXMoY2cudyArICcnLCBjZy5oICsgJycpXG4gICAgICAgIGlmICghY3ZXR0wpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHdlYkdMJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyAgIHdlYiBHTCBjYW52YXMgY3JlYXRpb24nKVxuXG4gICAgICAgIC8vZHJhd1xuICAgICAgICBjb25zdCBzaXplR2VvID0gdGhpcy5zaXplID8gdGhpcy5zaXplKHIsIHpmKSA6IHIgKyAwLjIgKiB6ZlxuICAgICAgICB0aGlzLndncC5kcmF3KGN2V0dMLmdsLCB2ZXJ0aWNlc0J1ZmZlciwgaUJ1ZmZlciwgY2cuZ2V0V2ViR0xUcmFuc2Zvcm0oKSwgc2l6ZUdlbyAvIHpmKVxuXG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyAgIHdlYmdsIGRyYXdpbmcnKVxuXG4gICAgICAgIC8vZHJhdyBpbiBjYW52YXMgZ2VvXG4gICAgICAgIGNnLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICBjZy5jdHguZHJhd0ltYWdlKGN2V0dMLmNhbnZhcywgMCwgMClcblxuICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcgICBjYW52YXMgZHJhd2luZycpXG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcjogciwgemY6IHpmIH0pXG5cbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignKioqIFNxdWFyZUNvbG9yQ2F0V0dMU3R5bGUgZW5kIGRyYXcnKVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcbmltcG9ydCB7IG1ha2VXZWJHTENhbnZhcyB9IGZyb20gJy4uL3V0aWxzL3dlYkdMVXRpbHMuanMnXG5pbXBvcnQgeyBXZWJHTFNxdWFyZUNvbG9yaW5nQWR2YW5jZWQgfSBmcm9tICcuLi91dGlscy9XZWJHTFNxdWFyZUNvbG9yaW5nQWR2YW5jZWQuanMnXG5pbXBvcnQgeyBtb25pdG9yLCBtb25pdG9yRHVyYXRpb24gfSBmcm9tICcuLi91dGlscy9VdGlscy5qcydcblxuLyoqXG4gKiBTdHlsZSBiYXNlZCBvbiB3ZWJHTFxuICogVG8gc2hvdyBjZWxscyBhcyBjb2xvcmVkIHNxdWFyZXMsIHdpdGggY29tcHV0YXRpb24gb2YgdGhlIGNvbG9ycyBvbiBHUFUgc2lkZSAoZmFzdGVyIHRoYW4gSmF2YVNjcmlwdCBzaWRlKS5cbiAqIEFsbHMgc3F1YXJlcyB3aXRoIHRoZSBzYW1lIHNpemVcbiAqXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBTcXVhcmVDb2xvcldHTFN0eWxlIGV4dGVuZHMgU3R5bGUge1xuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGNvbHVtbi9hdHRyaWJ1dGUgb2YgdGhlIHRhYnVsYXIgZGF0YSB3aGVyZSB0byByZXRyaWV2ZSB0aGUgdmFyaWFibGUgZm9yIGNvbG9yLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNvbG9yQ29sID0gb3B0cy5jb2xvckNvbFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgdCB2YWx1ZSAod2l0aGluIFswLDFdKSBvZiB0aGUgY2VsbC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCk6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnRGdW4gPSBvcHRzLnRGdW4gfHwgKCh2LCByLCBzKSA9PiB2IC8gcy5tYXgpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3RyaWJ1dGlvbiBzdHJldGNoaW5nIG1ldGhvZC5cbiAgICAgICAgICogVGhlIHN0cmV0Y2hpbmcgaXMgcGVyZm9ybWVkIG9uIEdQVSBzaWRlIChmcmFnbWVudCBzaGFkZXIpLlxuICAgICAgICAgKiBAdHlwZSB7eyBmdW46c3RyaW5nLCBhbHBoYTpudW1iZXIgfX0gKi9cbiAgICAgICAgdGhpcy5zdHJldGNoaW5nID0gb3B0cy5zdHJldGNoaW5nXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzYW1wbGUgb2YgdGhlIGNvbG9yIHJhbXAuXG4gICAgICAgICAqIFRoZSBjb2xvciBpcyBjb21wdXRlZCBvbiBHUFUgc2lkZSAoZnJhZ21lbnQgc2hhZGVyKSBiYXNlZCBvbiB0aG9zZSB2YWx1ZXMgKGxpbmVhciBpbnRlcnBvbGF0aW9uKS5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fSAqL1xuICAgICAgICB0aGlzLmNvbG9ycyA9XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyB8fFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdyZ2IoMTU4LCAxLCA2NiknLFxuICAgICAgICAgICAgICAgICdyZ2IoMjQ4LCAxNDIsIDgzKScsXG4gICAgICAgICAgICAgICAgJ3JnYigyNTEsIDI0OCwgMTc2KScsXG4gICAgICAgICAgICAgICAgJ3JnYigxMzcsIDIwNywgMTY1KScsXG4gICAgICAgICAgICAgICAgJ3JnYig5NCwgNzksIDE2MiknLFxuICAgICAgICAgICAgXS5yZXZlcnNlKClcbiAgICAgICAgaWYgKG9wdHMuY29sb3IpXG4gICAgICAgICAgICB0aGlzLmNvbG9ycyA9IFtcbiAgICAgICAgICAgICAgICBvcHRzLmNvbG9yKDApLFxuICAgICAgICAgICAgICAgIG9wdHMuY29sb3IoMC4yKSxcbiAgICAgICAgICAgICAgICBvcHRzLmNvbG9yKDAuNCksXG4gICAgICAgICAgICAgICAgb3B0cy5jb2xvcigwLjYpLFxuICAgICAgICAgICAgICAgIG9wdHMuY29sb3IoMC44KSxcbiAgICAgICAgICAgICAgICBvcHRzLmNvbG9yKDEpLFxuICAgICAgICAgICAgXVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgdGhlIG9wYWNpdHkgb2YgdGhlIHN0eWxlLCB3aXRoaW4gWzAsMV0uXG4gICAgICAgICAqIElmIHRoaXMgb3BhY2l0eSBpcyBkZWZpbmVkLCB0aGUgaW5kaXZpZHVhbCBjb2xvciBvcGFjaXR5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3B0cy5vcGFjaXR5IC8vIChyLHpmKSA9PiAuLi5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgdGhlIGNlbGxzLCBpbiBnZW9ncmFwaGljYWwgdW5pdC4gQWxsIGNlbGxzIGhhdmUgdGhlIHNhbWUgc2l6ZS5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplIC8vIChyZXNvbHV0aW9uLCB6ZikgPT4gLi4uXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCByLCBjZykge1xuICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcqKiogU3F1YXJlQ29sb3JXR0xTdHlsZSBkcmF3JylcblxuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vem9vbSBmYWN0b3JcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXG5cbiAgICAgICAgLy9jb21wdXRlIGNvbG9yIHZhcmlhYmxlIHN0YXRpc3RpY3NcbiAgICAgICAgY29uc3Qgc3RhdENvbG9yID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5jb2xvckNvbF0sIHRydWUpXG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyAgIGNvbG9yIHN0YXRzIGNvbXB1dGF0aW9uJylcblxuICAgICAgICBpZiAoIXN0YXRDb2xvcikgcmV0dXJuXG5cbiAgICAgICAgLy9jcmVhdGUgY2FudmFzIGFuZCB3ZWJnbCByZW5kZXJlclxuICAgICAgICAvL2ZvciBvcGFjaXR5IGNvbnRyb2wsIHNlZTogaHR0cHM6Ly93ZWJnbGZ1bmRhbWVudGFscy5vcmcvd2ViZ2wvbGVzc29ucy93ZWJnbC1hbmQtYWxwaGEuaHRtbFxuICAgICAgICBjb25zdCBjdldHTCA9IG1ha2VXZWJHTENhbnZhcyhcbiAgICAgICAgICAgIGNnLncgKyAnJyxcbiAgICAgICAgICAgIGNnLmggKyAnJyxcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSAhPSB1bmRlZmluZWQgPyB7IHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UgfSA6IHVuZGVmaW5lZFxuICAgICAgICApXG4gICAgICAgIGlmICghY3ZXR0wpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHdlYkdMJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyAgIHdlYiBHTCBjYW52YXMgY3JlYXRpb24nKVxuXG4gICAgICAgIC8vYWRkIHZlcnRpY2UgYW5kIGZyYWdtZW50IGRhdGFcbiAgICAgICAgY29uc3QgcjIgPSByIC8gMlxuICAgICAgICBjb25zdCB2ZXJ0aWNlc0J1ZmZlciA9IFtdXG4gICAgICAgIGNvbnN0IHRCdWZmZXIgPSBbXVxuICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcy50RnVuKGNbdGhpcy5jb2xvckNvbF0sIHIsIHN0YXRDb2xvcilcbiAgICAgICAgICAgIGlmICh0ID09IG51bGwgfHwgdCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXG4gICAgICAgICAgICB2ZXJ0aWNlc0J1ZmZlci5wdXNoKGMueCArIHIyLCBjLnkgKyByMilcbiAgICAgICAgICAgIHRCdWZmZXIucHVzaCh0ID4gMSA/IDEgOiB0IDwgMCA/IDAgOiB0KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignICAgd2ViZ2wgZHJhd2luZyBkYXRhIHByZXBhcmF0aW9uJylcblxuICAgICAgICAvL2NvbXB1dGUgcGl4ZWwgc2l6ZVxuICAgICAgICBjb25zdCBzaXplR2VvID0gdGhpcy5zaXplID8gdGhpcy5zaXplKHIsIHpmKSA6IHIgKyAwLjIgKiB6ZlxuXG4gICAgICAgIC8vY29tcHV0ZSBvcGFjaXR5XG4gICAgICAgIGNvbnN0IG9wID0gdGhpcy5vcGFjaXR5ID8gdGhpcy5vcGFjaXR5KHIsIHpmKSA6IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IHdncCA9IG5ldyBXZWJHTFNxdWFyZUNvbG9yaW5nQWR2YW5jZWQoY3ZXR0wuZ2wsIHRoaXMuY29sb3JzLCB0aGlzLnN0cmV0Y2hpbmcsIHNpemVHZW8gLyB6Ziwgb3ApXG5cbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignICAgd2ViZ2wgcHJvZ3JhbSBwcmVwYXJhdGlvbicpXG5cbiAgICAgICAgLy9kcmF3XG4gICAgICAgIHdncC5kcmF3KHZlcnRpY2VzQnVmZmVyLCB0QnVmZmVyLCBjZy5nZXRXZWJHTFRyYW5zZm9ybSgpKVxuXG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyAgIHdlYmdsIGRyYXdpbmcnKVxuXG4gICAgICAgIC8vZHJhdyBpbiBjYW52YXMgZ2VvXG4gICAgICAgIGNnLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICBjZy5jdHguZHJhd0ltYWdlKGN2V0dMLmNhbnZhcywgMCwgMClcblxuICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcgICBjYW52YXMgZHJhd2luZycpXG5cbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcjogciwgemY6IHpmLCBzQ29sb3I6IHN0YXRDb2xvciB9KVxuXG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyoqKiBTcXVhcmVDb2xvcldHTFN0eWxlIGVuZCBkcmF3JylcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vU3R5bGUuanMnXG5cbi8qKlxuICpcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cm9rZVN0eWxlIGV4dGVuZHMgU3R5bGUge1xuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cylcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGNvbHVtbi9hdHRyaWJ1dGUgb2YgdGhlIHRhYnVsYXIgZGF0YSB3aGVyZSB0byByZXRyaWV2ZSB0aGUgdmFyaWFibGUgZm9yIGNvbG9yLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yQ29sID0gb3B0cy5zdHJva2VDb2xvckNvbFxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIHN0cm9rZS5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQpOnN0cmluZ30gKi9cbiAgICAgICAgdGhpcy5zdHJva2VDb2xvciA9IG9wdHMuc3Ryb2tlQ29sb3IgfHwgKCgpID0+ICcjNjY2JylcblxuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGNvbHVtbi9hdHRyaWJ1dGUgb2YgdGhlIHRhYnVsYXIgZGF0YSB3aGVyZSB0byByZXRyaWV2ZSB0aGUgdmFyaWFibGUgZm9yIHNpemUuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuc2l6ZUNvbCA9IG9wdHMuc2l6ZUNvbFxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2l6ZSBvZiBhIGNlbGwgaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnNpemUgPSBvcHRzLnNpemVcblxuICAgICAgICAvKiogVGhlIHN0cm9rZSBsaW5lIHdpZHRoLCBpbiBwaXhlbHMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGhDb2wgPSBvcHRzLnN0cm9rZVdpZHRoQ29sXG5cbiAgICAgICAgLyoqIFRoZSBzdHJva2UgbGluZSB3aWR0aCBpbiBnZW9ncmFwaGljYWwgdW5pdC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoIC8vICh2LHIscyx6KT0+Li4uXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaGFwZSBvZiBhIGNlbGwuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGwpOmltcG9ydChcIi4uL1N0eWxlXCIpLlNoYXBlfSAqL1xuICAgICAgICB0aGlzLnNoYXBlID0gb3B0cy5zaGFwZSB8fCAoKCkgPT4gJ3NxdWFyZScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBjZWxscyBhcyBzcXVhcmVzLCB3aXRoIHZhcmlvdXMgY29sb3JzIGFuZCBzaXplLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCByLCBjZykge1xuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vem9vbSBmYWN0b3JcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXG5cbiAgICAgICAgbGV0IHN0YXRDb2xvclxuICAgICAgICBpZiAodGhpcy5zdHJva2VDb2xvckNvbCkgc3RhdENvbG9yID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5zdHJva2VDb2xvckNvbF0sIHRydWUpXG5cbiAgICAgICAgbGV0IHN0YXRTaXplXG4gICAgICAgIGlmICh0aGlzLnNpemVDb2wpIHN0YXRTaXplID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5zaXplQ29sXSwgdHJ1ZSlcblxuICAgICAgICBsZXQgc3RhdFdpZHRoXG4gICAgICAgIGlmICh0aGlzLnN0cm9rZVdpZHRoQ29sKSBzdGF0V2lkdGggPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLnN0cm9rZVdpZHRoQ29sXSwgdHJ1ZSlcblxuICAgICAgICAvL2RyYXcgd2l0aCBIVE1MIGNhbnZhc1xuICAgICAgICAvL2luIGdlbyBjb29yZGluYXRlc1xuICAgICAgICBjZy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgIGNvbnN0IHIyID0gciAqIDAuNVxuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIGNlbGxzKSB7XG4gICAgICAgICAgICAvL2NvbG9yXG4gICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLnN0cm9rZUNvbG9yXG4gICAgICAgICAgICAgICAgPyB0aGlzLnN0cm9rZUNvbG9yKGNlbGxbdGhpcy5zdHJva2VDb2xvckNvbF0sIHIsIHN0YXRDb2xvcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFjb2wgfHwgY29sID09PSAnbm9uZScpIGNvbnRpbnVlXG4gICAgICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xcblxuICAgICAgICAgICAgLy9zaXplXG4gICAgICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgICAgICBsZXQgc18gPSB0aGlzLnNpemUgfHwgKCgpID0+IHIpXG4gICAgICAgICAgICAvL3NpemUgLSBpbiBnZW8gdW5pdFxuICAgICAgICAgICAgY29uc3Qgc0cgPSBzXyhjZWxsW3RoaXMuc2l6ZUNvbF0sIHIsIHN0YXRTaXplLCB6ZilcblxuICAgICAgICAgICAgLy93aWR0aFxuICAgICAgICAgICAgY29uc3Qgd2kgPSB0aGlzLnN0cm9rZVdpZHRoXG4gICAgICAgICAgICAgICAgPyB0aGlzLnN0cm9rZVdpZHRoKGNlbGxbdGhpcy5zdHJva2VXaWR0aENvbF0sIHIsIHN0YXRXaWR0aCwgemYpXG4gICAgICAgICAgICAgICAgOiAxICogemZcbiAgICAgICAgICAgIGlmICghd2kgfHwgd2kgPD0gMCkgY29udGludWVcbiAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3aVxuXG4gICAgICAgICAgICAvL3NoYXBlXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuc2hhcGUgPyB0aGlzLnNoYXBlKGNlbGwpIDogJ3NxdWFyZSdcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ25vbmUnKSBjb250aW51ZVxuXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGNlbGwsIHIsIHpmKVxuXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdzcXVhcmUnKSB7XG4gICAgICAgICAgICAgICAgLy9kcmF3IHNxdWFyZVxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSByICogKDEgLSBzRyAvIHIpICogMC41XG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY2cuY3R4LnJlY3QoY2VsbC54ICsgZCArIG9mZnNldC5keCwgY2VsbC55ICsgZCArIG9mZnNldC5keSwgc0csIHNHKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICAvL2RyYXcgY2lyY2xlXG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmFyYyhjZWxsLnggKyByMiArIG9mZnNldC5keCwgY2VsbC55ICsgcjIgKyBvZmZzZXQuZHksIHNHICogMC41LCAwLCAyICogTWF0aC5QSSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAnZGlhbW9uZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzMiA9IHNHICogMC41XG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhjZWxsLnggKyByMiAtIHMyLCBjZWxsLnkgKyByMilcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGNlbGwueCArIHIyLCBjZWxsLnkgKyByMiArIHMyKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY2VsbC54ICsgcjIgKyBzMiwgY2VsbC55ICsgcjIpXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjZWxsLnggKyByMiwgY2VsbC55ICsgcjIgLSBzMilcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGNlbGwueCArIHIyIC0gczIsIGNlbGwueSArIHIyKVxuICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2RvbnV0Jykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzaGFwZTonICsgc2hhcGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXG4gICAgICAgIC8vdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHJlc29sdXRpb24sIHpmOiB6Ziwgc1NpemU6IHN0YXRTaXplLCBzQ29sb3I6IHN0YXRDb2xvciB9KTtcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IFNxdWFyZUNvbG9yV0dMU3R5bGUgfSBmcm9tICcuL1NxdWFyZUNvbG9yV0dMU3R5bGUuanMnXG5pbXBvcnQgeyBTaWRlU3R5bGUgfSBmcm9tICcuL1NpZGVTdHlsZS5qcydcblxuLyoqXG4gKlxuICogQHNlZSBodHRwczovL21hbmlmb2xkLm5ldC9kb2MvbWZkOS9leGFtcGxlX190YW5ha2FfY29udG91cnMuaHRtXG4gKlxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgVGFuYWthU3R5bGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48aW1wb3J0KFwiLi4vU3R5bGVcIikuU3R5bGU+fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQoY29sLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLy9nZXQgY29sb3JzIGZyb20gZDMgcmFtcHMsIGlmICduYicgaXMgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRzLm5iICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKG9wdHMubmIgPCAyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndW5leHBlY3RlZCBudW1iZXIgb2YgY29sb3JzIGluIHRhbmFrYSAoPDIpOiAnICsgb3B0cy5uYilcbiAgICAgICAgICAgICAgICBvcHRzLm5iID0gMlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignY29sb3IgZnVuY3Rpb24gbm90IGRlZmluZWQgaW4gdGFuYWthJylcbiAgICAgICAgICAgICAgICBvcHRzLmNvbG9yID0gKCkgPT4gJ2dyYXknXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IFtdXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdHMubmI7IGkrKykgb3B0cy5jb2xvcnMucHVzaChvcHRzLmNvbG9yKGkgLyAob3B0cy5uYiAtIDEpKSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29sb3JzLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59ICovXG4gICAgICAgIG9wdHMuY29sb3JzID0gb3B0cy5jb2xvcnMgfHwgWycjYTliYjllJywgJyNjOWRjYWEnLCAnI2ZkZTg5ZicsICcjZjlhNTc5JywgJyNlYjQ0NGInXVxuICAgICAgICBjb25zdCBuYiA9IG9wdHMuY29sb3JzLmxlbmd0aFxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHRvIGNvbXB1dGUgJ3QnIGZyb20gdGhlIHZhbHVlIHZcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCk6bnVtYmVyfSAqL1xuICAgICAgICBvcHRzLnRGdW4gPSBvcHRzLnRGdW4gfHwgKCh2LCByLCBzKSA9PiAodiAtIHMubWluKSAvIChzLm1heCAtIHMubWluKSlcblxuICAgICAgICAvL3NoYWRvdyBjb2xvcnNcbiAgICAgICAgb3B0cy5jb2xEYXJrID0gb3B0cy5jb2xEYXJrIHx8ICcjMTExJ1xuICAgICAgICBvcHRzLmNvbEJyaWdodCA9IG9wdHMuY29sQnJpZ2h0IHx8ICcjZGRkJ1xuXG4gICAgICAgIC8vd2lkdGggb2YgdGhlIHNlZ21lbnQgKHNoYXJlIG9mIHRoZSByZXNvbHV0aW9uKVxuICAgICAgICBvcHRzLndpZHRoRmFjdG9yID0gb3B0cy53aWR0aEZhY3RvciB8fCAwLjA4XG5cbiAgICAgICAgLy9zaGFkaW5nXG4gICAgICAgIG9wdHMubmV3U2hhZGluZyA9IG9wdHMubmV3U2hhZGluZ1xuICAgICAgICBvcHRzLm5ld1NoYWRpbmdXaWR0aFBpeCA9IG9wdHMubmV3U2hhZGluZ1dpZHRoUGl4IHx8IDJcbiAgICAgICAgLy90cmFuc3BhcmVuY3kgdmFsdWUsIHdpdGhpbiBbMCwxXVxuICAgICAgICBvcHRzLm5ld1NoYWRpbmdUciA9XG4gICAgICAgICAgICBvcHRzLm5ld1NoYWRpbmdUciB8fFxuICAgICAgICAgICAgKChzaWRlVmFsdWUsIHNpZGVTdGF0KSA9PlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNpZGVWYWx1ZSkgLyBNYXRoLm1heChNYXRoLmFicyhzaWRlU3RhdC5taW4pLCBNYXRoLmFicyhzaWRlU3RhdC5tYXgpKSlcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHQgQSBjZWxsIHQgdmFsdWUsIHdpdGhpbiBbMCwxXS5cbiAgICAgICAgICogQHJldHVybnMgdGhlIGNsYXNzIG51bWJlciBmb3IgdGhlIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBnZXRDbGFzcyA9ICh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odCkgfHwgdCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIHQgdmFsdWUgMTogJyArIHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC05XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIGlmICh0IDw9IChpICsgMSkgLyBuYikgcmV0dXJuIGlcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgdCB2YWx1ZSAyOiAnICsgdClcbiAgICAgICAgICAgIHJldHVybiAtOVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29sU3R5bGUgPSBuZXcgU3F1YXJlQ29sb3JXR0xTdHlsZSh7XG4gICAgICAgICAgICBjb2xvckNvbDogY29sLFxuICAgICAgICAgICAgY29sb3JzOiBvcHRzLmNvbG9ycyxcbiAgICAgICAgICAgIHRGdW46ICh2LCByLCBzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IG9wdHMudEZ1bih2LCByLCBzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBnZXRDbGFzcyh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBjIC8gKG5iIC0gMSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL3N0cmV0Y2hpbmc6IHsgZnVuOiBcImV4cFJldlwiLCBhbHBoYTogLTcgfSxcbiAgICAgICAgICAgIHNpemU6IChyLCB6ZikgPT4gciArIDAuNSAqIHpmLCAvL3RoYXQgaXMgdG8gZW5zdXJlIG5vIGdhcCBiZXR3ZWVuIHNhbWUgY2xhc3MgY2VsbHMgaXMgdmlzaWJsZVxuICAgICAgICAgICAgZmlsdGVyOiBvcHRzLmZpbHRlcixcbiAgICAgICAgfSlcblxuICAgICAgICAvKlxuICAgICAgICBpZiBubyB3ZWIgZ2w6ICAgIFxuICAgICAgICAgICAgY29uc3QgY29sU3R5bGUgPSBuZXcgU2hhcGVDb2xvclNpemVTdHlsZSh7XG4gICAgICAgICAgICAgICAgY29sb3JDb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAvL3RoZSBjb2xvciBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzc1xuICAgICAgICAgICAgICAgIGNvbG9yOiAodiwgciwgcywgemYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT0gMCAmJiBvcHRzLnRGdW4gJiYgaXNOYU4ob3B0cy50RnVuKHYsIHIsIHMpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMuY29sb3JzW2dldENsYXNzKG9wdHMudEZ1biA/IG9wdHMudEZ1bih2LCByLCBzKSA6IHYpXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2hhcGU6ICgpID0+IFwic3F1YXJlXCIsXG4gICAgICAgICAgICAgICAgc2l6ZTogKHYsIHIsIHMsIHpmKSA9PiByICsgMC41ICogemYsIC8vdGhhdCBpcyB0byBlbnN1cmUgbm8gZ2FwIGJldHdlZW4gc2FtZSBjbGFzcyBjZWxscyBpcyB2aXNpYmxlXG4gICAgICAgICAgICB9KVxuICAgICAgICAqL1xuXG4gICAgICAgIC8qKiBUaGUgc2lkZSBzdHlsZSwgZm9yIHRoZSBzaGFkb3cgZWZmZWN0ICovXG4gICAgICAgIGNvbnN0IHNpZGVTdHlsZSA9IG5ldyBTaWRlU3R5bGUoe1xuICAgICAgICAgICAgdmFsdWVDb2w6IGNvbCxcbiAgICAgICAgICAgIHZhbHVlOiAodjEsIHYyLCByLCBzLCB6ZikgPT4ge1xuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSB0aGUgbnVtYmVyIG9mIGNsYXNzZXMgb2YgZGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkICYmIHYyID09PSB1bmRlZmluZWQpIHJldHVybiAwXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gb3B0cy50RnVuKHYxLCByLCBzKVxuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSB1bmRlZmluZWQgfHwgaXNOYU4odCkpIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZTogJyArIHYxICsgJyAtICcgKyB0KVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gZ2V0Q2xhc3ModClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKyAxXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2MSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBvcHRzLnRGdW4odjIsIHIsIHMpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09IHVuZGVmaW5lZCB8fCBpc05hTih0KSkgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlOiAnICsgdjIgKyAnIC0gJyArIHQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBnZXRDbGFzcyh0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWMgLSAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHQxID0gb3B0cy50RnVuKHYxLCByLCBzKVxuICAgICAgICAgICAgICAgIGlmICh0MSA9PSB1bmRlZmluZWQgfHwgaXNOYU4odDEpKSB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdmFsdWU6ICcgKyB2MSArICcgLSAnICsgdDEpXG4gICAgICAgICAgICAgICAgY29uc3QgdDIgPSBvcHRzLnRGdW4odjIsIHIsIHMpXG4gICAgICAgICAgICAgICAgaWYgKHQyID09IHVuZGVmaW5lZCB8fCBpc05hTih0MikpIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZTogJyArIHYyICsgJyAtICcgKyB0MilcbiAgICAgICAgICAgICAgICBjb25zdCBjMSA9IGdldENsYXNzKHQxKVxuICAgICAgICAgICAgICAgIGNvbnN0IGMyID0gZ2V0Q2xhc3ModDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC1jMiArIGMxXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb2xvcjogb3B0cy5uZXdTaGFkaW5nXG4gICAgICAgICAgICAgICAgPyAvL2JsYWNrIHdpdGggdHJhbnNwYXJlbmN5IGRlcGVuZGluZyBvbiBkaWZmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAoc2lkZSwgciwgcywgeikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gb3B0cy5uZXdTaGFkaW5nVHIoc2lkZS52YWx1ZSwgcylcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNpZGUudmFsdWUgPiAwICYmIHNpZGUub3IgPT09ICdoJykgfHwgKHNpZGUudmFsdWUgPCAwICYmIHNpZGUub3IgPT09ICd2JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAncmdiYSgyNTUsMjU1LDEwMCwnICsgdHIgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAncmdiYSgwLDAsMCwnICsgdHIgKyAnKSdcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IC8vd2hpdGUgb3IgYmxhY2ssIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvbiBhbmQgdmFsdWVcbiAgICAgICAgICAgICAgICAgIChzaWRlLCByLCBzLCB6KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUudmFsdWUgPT09IDApIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIFwiZ3JheVwiXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUub3IgPT09ICd2JykgcmV0dXJuIHNpZGUudmFsdWUgPCAwID8gb3B0cy5jb2xCcmlnaHQgOiBvcHRzLmNvbERhcmtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZS52YWx1ZSA8IDAgPyBvcHRzLmNvbERhcmsgOiBvcHRzLmNvbEJyaWdodFxuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgd2lkdGg6IG9wdHMubmV3U2hhZGluZ1xuICAgICAgICAgICAgICAgID8gLy9maWxsIHNpemVcbiAgICAgICAgICAgICAgICAgIChzaWRlLCByLCBzLCB6KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMubmV3U2hhZGluZ1dpZHRoUGl4ICogelxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogLy93aWR0aCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSwgdGhhdCBpcyB0aGUgbnVtYmVyIG9mIGNsYXNzZXMgb2YgZGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgKHNpZGUsIHIsIHMsIHopID0+XG4gICAgICAgICAgICAgICAgICAgICAgb3B0cy53aWR0aEZhY3RvciAqIHIgKiBNYXRoLmFicyhzaWRlLnZhbHVlKSAqIChzaWRlLm9yID09PSAndicgPyAwLjUgOiAxKSxcblxuICAgICAgICAgICAgZmlsdGVyOiBvcHRzLmZpbHRlcixcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gW2NvbFN0eWxlLCBzaWRlU3R5bGVdXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xuXG4vKipcbiAqXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0U3R5bGUgZXh0ZW5kcyBTdHlsZSB7XG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3IgdGV4dC5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy50ZXh0Q29sID0gb3B0cy50ZXh0Q29sXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB0ZXh0IG9mIGEgY2VsbC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMudGV4dCA9IG9wdHMudGV4dCB8fCAoKHYsIHIsIHMsIHopID0+ICdYJylcblxuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGNvbHVtbi9hdHRyaWJ1dGUgb2YgdGhlIHRhYnVsYXIgZGF0YSB3aGVyZSB0byByZXRyaWV2ZSB0aGUgdmFyaWFibGUgZm9yIGNvbG9yLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNvbG9yQ29sID0gb3B0cy5jb2xvckNvbFxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIGNlbGwuXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKCkgPT4gJyNFQTZCQUMnKVxuXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3IgZm9udCBzaXplLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmZvbnRTaXplQ29sID0gb3B0cy5mb250U2l6ZUNvbFxuXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgZm9udCBzaXplIG9mIGEgY2VsbCBpbiBnZW8gdW5pdC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSBvcHRzLmZvbnRTaXplIHx8ICgodiwgciwgcywgeikgPT4gciAqIDAuOClcblxuICAgICAgICAvKiogVGhlIHRleHQgZm9udCBmYW1pbHkuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9IG9wdHMuZm9udEZhbWlseSB8fCAnQXJpYWwnXG5cbiAgICAgICAgLyoqIFRoZSB0ZXh0IGZvbnQgd2VpZ2h0LlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmZvbnRXZWlnaHQgPSBvcHRzLmZvbnRXZWlnaHQgfHwgJ2JvbGQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBjZWxscyBhcyB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcbiAgICAgKi9cbiAgICBkcmF3KGNlbGxzLCByLCBjZykge1xuICAgICAgICAvL2ZpbHRlclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxuXG4gICAgICAgIC8vem9vbSBmYWN0b3JcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXG5cbiAgICAgICAgbGV0IHN0YXRUZXh0XG4gICAgICAgIGlmICh0aGlzLnRleHRDb2wpIHtcbiAgICAgICAgICAgIC8vY29tcHV0ZSB0ZXh0IHZhcmlhYmxlIHN0YXRpc3RpY3NcbiAgICAgICAgICAgIHN0YXRUZXh0ID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy50ZXh0Q29sXSwgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGF0Q29sb3JcbiAgICAgICAgaWYgKHRoaXMuY29sb3JDb2wpIHtcbiAgICAgICAgICAgIC8vY29tcHV0ZSBjb2xvciB2YXJpYWJsZSBzdGF0aXN0aWNzXG4gICAgICAgICAgICBzdGF0Q29sb3IgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLmNvbG9yQ29sXSwgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGF0Rm9udFNpemVcbiAgICAgICAgaWYgKHRoaXMuZm9udFNpemVDb2wpIHtcbiAgICAgICAgICAgIC8vaWYgc2l6ZSBpcyB1c2VkLCBzb3J0IGNlbGxzIGJ5IHNpemUgc28gdGhhdCB0aGUgYmlnZ2VzdCBhcmUgZHJhd24gZmlyc3RcbiAgICAgICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gYzJbdGhpcy5mb250U2l6ZUNvbF0gLSBjMVt0aGlzLmZvbnRTaXplQ29sXSlcbiAgICAgICAgICAgIC8vYW5kIGNvbXB1dGUgc2l6ZSB2YXJpYWJsZSBzdGF0aXN0aWNzXG4gICAgICAgICAgICBzdGF0Rm9udFNpemUgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLmZvbnRTaXplQ29sXSwgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZHJhdyB3aXRoIEhUTUwgY2FudmFzXG4gICAgICAgIC8vaW4gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgICAgIGNnLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgIC8vZ2V0IGNlbGwgdGV4dFxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMudGV4dCA/IHRoaXMudGV4dChjZWxsW3RoaXMudGV4dENvbF0sIHIsIHN0YXRUZXh0LCB6ZikgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICh0ZXh0ID09IHVuZGVmaW5lZCB8fCB0ZXh0ID09IG51bGwgfHwgdGV4dCArICcnID09PSAnJykgY29udGludWVcblxuICAgICAgICAgICAgLy9jb2xvclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3IoY2VsbFt0aGlzLmNvbG9yQ29sXSwgciwgc3RhdENvbG9yLCB6ZikgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghY29sKSBjb250aW51ZVxuICAgICAgICAgICAgY2cuY3R4LmZpbGxTdHlsZSA9IGNvbFxuXG4gICAgICAgICAgICAvL2ZvbnQgc2l6ZVxuICAgICAgICAgICAgLy9zaXplIC0gaW4gcGl4ZWwgdW5pdFxuICAgICAgICAgICAgY29uc3QgZm9udFNpemVQaXggPSB0aGlzLmZvbnRTaXplKGNlbGxbdGhpcy5mb250U2l6ZUNvbF0sIHIsIHN0YXRGb250U2l6ZSwgemYpIC8gemZcblxuICAgICAgICAgICAgLy9zZXQgZm9udFxuICAgICAgICAgICAgY29uc3QgZm9udEZhbWlseSA9IHRoaXMuZm9udEZhbWlseSB8fCAnQXJpYWwnXG4gICAgICAgICAgICBjb25zdCBmb250V2VpZ2h0ID0gdGhpcy5mb250V2VpZ2h0IHx8ICdib2xkJ1xuICAgICAgICAgICAgY2cuY3R4LmZvbnQgPSBmb250V2VpZ2h0ICsgJyAnICsgZm9udFNpemVQaXggKyAncHggJyArIGZvbnRGYW1pbHlcblxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjZWxsLCByLCB6ZilcblxuICAgICAgICAgICAgLy90ZXh0IHBvc2l0aW9uXG4gICAgICAgICAgICBjZy5jdHgudGV4dEFsaWduID0gJ2NlbnRlcidcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gY2cuZ2VvVG9QaXhYKGNlbGwueCArIHIgKiAwLjUgKyBvZmZzZXQuZHgpXG4gICAgICAgICAgICBjb25zdCB0eSA9IGNnLmdlb1RvUGl4WShjZWxsLnkgKyByICogMC41ICsgb2Zmc2V0LmR5KSArIGZvbnRTaXplUGl4ICogMC4zIC8vaXQgc2hvdWxkIGJlIDAuNSBidXQgMC4zIHNlZW1zIHRvIHdvcmsgYmV0dGVyXG5cbiAgICAgICAgICAgIC8vZHJhdyB0aGUgdGV4dFxuICAgICAgICAgICAgY2cuY3R4LmZpbGxUZXh0KHRleHQsIHR4LCB0eSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6Ziwgc0NvbG9yOiBzdGF0Q29sb3IgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCBhIGZ1bmN0aW9uIFswLDFdLT5zdHJpbmcgZm9yIGNoYXJhY3RlcnMgbGVnZW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFyc1xuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihudW1iZXIpOnN0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhckxlZ2VuZEZ1bihjaGFycykge1xuICAgICAgICBjb25zdCBuYiA9IGNoYXJzLmxlbmd0aFxuICAgICAgICByZXR1cm4gKHQpID0+ICh0ID09IDAgPyAnJyA6IHQgPT0gMSA/IGNoYXJzW25iIC0gMV0gOiBjaGFyc1tNYXRoLmZsb29yKHQgKiBuYildKVxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcblxuLyoqIEB0eXBlZGVmIHtcImZpcnN0XCJ8XCJib3R0b21cInxcImNlbnRlclwifFwidG9wXCJ8XCJsYXN0XCJ9IEFuY2hvck1vZGVZRW51bSAqL1xuXG4vKipcbiAqIFNob3cgY2VsbCBhcyB0aW1lc2VyaWVzIGNoYXJ0XG4gKiBDYW4gYmUgdXNlZCBmb3Igc3BhcmtsaW5lIG1hcCBvZiBodHRwczovL2RhdGFnaXN0aXBzLmh5cG90aGVzZXMub3JnLzQ4OFxuICpcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIFRpbWVTZXJpZXNTdHlsZSBleHRlbmRzIFN0eWxlIHtcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICAgICAgLyoqIFRoZSBjb2x1bW5zIG9mIHRoZSB0aW1lIHNlcmllcywgb3JkZXJlZCBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59ICovXG4gICAgICAgIHRoaXMudHMgPSBvcHRzLnRzXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gc3BlY2lmeWluZyB3aGVuIGEgdmFsdWUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgXCJubyBkYXRhXCIgYW5kIHRodXMgbm90IGlnbm9yZWQuIFRoZSBsaW5lIHdpbGwgaGF2ZSBhIGJyZWFrIGF0IHRoZXNlIHZhbHVlcy5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKHN0cmluZyk6Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5ub0RhdGEgPSBvcHRzLm5vRGF0YSB8fCAoKHYpID0+IHYgPT09IHVuZGVmaW5lZCB8fCB2ID09IFwiXCIgfHwgdiA9PT0gbnVsbCB8fCBpc05hTigrdikpXG5cbiAgICAgICAgLy94XG4gICAgICAgIC8qKiBpbiBnZW8gdW5pdFxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy5vZmZzZXRYID0gb3B0cy5vZmZzZXRYIHx8ICgoYywgciwgemYpID0+IDApXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdHMud2lkdGggfHwgKChjLCByLCB6ZikgPT4gcilcblxuICAgICAgICAvL3lcbiAgICAgICAgLyoqIGluIGdlbyB1bml0XG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0LmpzXCIpLkNlbGwsbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm9mZnNldFkgPSBvcHRzLm9mZnNldFkgfHwgKChjLCByLCB6ZikgPT4gMClcbiAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0LmpzXCIpLkNlbGwsbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8ICgoYywgciwgemYpID0+IHIpXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIpOkFuY2hvck1vZGVZRW51bX0gKi9cbiAgICAgICAgdGhpcy5hbmNob3JNb2RlWSA9IG9wdHMuYW5jaG9yTW9kZVkgfHwgKChjLCByLCB6ZikgPT4gXCJjZW50ZXJcIilcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmxpbmVXaWR0aENvbCA9IG9wdHMubGluZVdpZHRoQ29sXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB3aWR0aCBvZiB0aGUgbGluZSwgaW4gZ2VvIHVuaXRcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGUuanNcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gb3B0cy5saW5lV2lkdGggfHwgKCh2LCByLCBzLCB6ZikgPT4gMS41ICogemYpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuY29sb3JDb2wgPSBvcHRzLmNvbG9yQ29sXG5cbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvciBvZiB0aGUgY2VsbC5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGUuanNcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgodiwgciwgcywgemYpID0+ICdibGFjaycpXG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGNlbGxzIGFzIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0LmpzXCIpLkNlbGw+fSBjZWxsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9HZW9DYW52YXMuanNcIikuR2VvQ2FudmFzfSBjZ1xuICAgICAqL1xuICAgIGRyYXcoY2VsbHMsIHIsIGNnKSB7XG5cbiAgICAgICAgLy9maWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcblxuICAgICAgICAvL3pvb20gZmFjdG9yXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxuXG4gICAgICAgIGxldCBzdGF0V2lkdGhcbiAgICAgICAgaWYgKHRoaXMubGluZVdpZHRoQ29sKSB7XG4gICAgICAgICAgICAvL2FuZCBjb21wdXRlIHNpemUgdmFyaWFibGUgc3RhdGlzdGljc1xuICAgICAgICAgICAgc3RhdFdpZHRoID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5saW5lV2lkdGhDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXRDb2xvclxuICAgICAgICBpZiAodGhpcy5jb2xvckNvbCkge1xuICAgICAgICAgICAgLy9jb21wdXRlIGNvbG9yIHZhcmlhYmxlIHN0YXRpc3RpY3NcbiAgICAgICAgICAgIHN0YXRDb2xvciA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuY29sb3JDb2xdLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9jb21wdXRlIGNlbGwgYW1wbGl0dWRlXG4gICAgICAgIGNvbnN0IGdldEFtcGxpdHVkZSA9IGMgPT4ge1xuICAgICAgICAgICAgbGV0IG1pbiwgbWF4XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBjW3RdO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT0gdW5kZWZpbmVkIHx8IHZhbCA8IG1pbikgbWluID0gdmFsXG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PSB1bmRlZmluZWQgfHwgdmFsID4gbWF4KSBtYXggPSB2YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaW4gPT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gbWF4IC0gbWluXG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbXB1dGUgbWF4IGFtcGxpdHVkZVxuICAgICAgICBsZXQgYW1wTWF4XG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFtcCA9IGdldEFtcGxpdHVkZShjKVxuICAgICAgICAgICAgaWYgKGFtcCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoYW1wTWF4ID09IHVuZGVmaW5lZCB8fCBhbXAgPiBhbXBNYXgpIGFtcE1heCA9IGFtcFxuICAgICAgICB9XG4gICAgICAgIGlmICghYW1wTWF4KSByZXR1cm5cblxuICAgICAgICBjb25zdCBuYiA9IHRoaXMudHMubGVuZ3RoXG5cbiAgICAgICAgLy9kcmF3IHdpdGggSFRNTCBjYW52YXNcbiAgICAgICAgLy9pbiBnZW8gY29vcmRpbmF0ZXNcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICBjZy5jdHgubGluZUNhcCA9IFwiYnV0dFwiXG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcblxuICAgICAgICAgICAgLy9saW5lIHdpZHRoXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICBjb25zdCB3RyA9IHRoaXMubGluZVdpZHRoID8gdGhpcy5saW5lV2lkdGgoY1t0aGlzLmxpbmVXaWR0aENvbF0sIHIsIHN0YXRXaWR0aCwgemYpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAoIXdHIHx8IHdHIDwgMCkgY29udGludWVcblxuICAgICAgICAgICAgLy9saW5lIGNvbG9yXG4gICAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yID8gdGhpcy5jb2xvcihjW3RoaXMuY29sb3JDb2xdLCByLCBzdGF0Q29sb3IsIHpmKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFjb2wpIGNvbnRpbnVlXG5cblxuICAgICAgICAgICAgLy94XG4gICAgICAgICAgICBjb25zdCBvZmZYID0gdGhpcy5vZmZzZXRYID8gdGhpcy5vZmZzZXRYKGMsIHIsIHpmKSA6IDBcbiAgICAgICAgICAgIGlmIChvZmZYID09IHVuZGVmaW5lZCB8fCBpc05hTihvZmZYKSkgY29udGludWVcbiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID8gdGhpcy53aWR0aChjLCByLCB6ZikgOiByXG4gICAgICAgICAgICBpZiAodyA9PSB1bmRlZmluZWQgfHwgaXNOYU4odykpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIC8veVxuICAgICAgICAgICAgY29uc3Qgb2ZmWSA9IHRoaXMub2Zmc2V0WSA/IHRoaXMub2Zmc2V0WShjLCByLCB6ZikgOiAwXG4gICAgICAgICAgICBpZiAob2ZmWSA9PSB1bmRlZmluZWQgfHwgaXNOYU4ob2ZmWSkpIGNvbnRpbnVlXG4gICAgICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgPyB0aGlzLmhlaWdodChjLCByLCB6ZikgOiByXG4gICAgICAgICAgICBpZiAoaCA9PSB1bmRlZmluZWQgfHwgaXNOYU4oaCkpIGNvbnRpbnVlXG4gICAgICAgICAgICBjb25zdCBhbmNoWSA9IHRoaXMuYW5jaG9yTW9kZVkgPyB0aGlzLmFuY2hvck1vZGVZKGMsIHIsIHpmKSA6IFwiY2VudGVyXCJcbiAgICAgICAgICAgIGlmICghYW5jaFkpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3R1xuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gY29sXG5cbiAgICAgICAgICAgIC8vY29tcHV0ZSBhbmNob3IgWSBmaWd1cmVzXG4gICAgICAgICAgICBsZXQgdmFsMCwgeTBcbiAgICAgICAgICAgIGlmIChhbmNoWSA9PT0gXCJmaXJzdFwiKSB7XG4gICAgICAgICAgICAgICAgLy9nZXQgZmlyc3QgdmFsdWVcbiAgICAgICAgICAgICAgICB2YWwwID0gY1t0aGlzLnRzWzBdXVxuICAgICAgICAgICAgICAgIHkwID0gMFxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmNoWSA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgICAgICAgICAvL2dldCBsYXN0IHZhbHVlXG4gICAgICAgICAgICAgICAgdmFsMCA9IGNbdGhpcy50c1t0aGlzLnRzLmxlbmd0aCAtIDFdXVxuICAgICAgICAgICAgICAgIHkwID0gMFxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmNoWSA9PT0gXCJib3R0b21cIikge1xuICAgICAgICAgICAgICAgIC8vZ2V0IG1pblxuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSArY1t0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwwID09IHVuZGVmaW5lZCB8fCB2YWwgPCB2YWwwKSB2YWwwID0gdmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkwID0gMFxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmNoWSA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgICAgIC8vZ2V0IG1heFxuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSArY1t0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwwID09IHVuZGVmaW5lZCB8fCB2YWwgPiB2YWwwKSB2YWwwID0gdmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkwID0gclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmNoWSA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgICAgICAgIC8vZ2V0IG1pbiBhbmQgbWF4XG4gICAgICAgICAgICAgICAgbGV0IG1pbiwgbWF4XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNbdF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICBpZiAobWluID09IHVuZGVmaW5lZCB8fCB2YWwgPCBtaW4pIG1pbiA9IHZhbFxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4ID09IHVuZGVmaW5lZCB8fCB2YWwgPiBtYXgpIG1heCA9IHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWwwID0gKCttYXggKyArbWluKSAqIDAuNVxuICAgICAgICAgICAgICAgIHkwID0gciAvIDJcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmV4cGVjdGVkIGFuY2hvck1vZGVZOiBcIiArIGFuY2hZKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKi9kcmF3IGxpbmVcbiAgICAgICAgICAgIGlmICh2YWwwID09IHVuZGVmaW5lZCB8fCBpc05hTih2YWwwKSkgY29udGludWVcbiAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgY29uc3Qgc1ggPSB3IC8gKG5iIC0gMSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNbdGhpcy50c1tpXV1cbiAgICAgICAgICAgICAgICBpZiAodmFsID09IHVuZGVmaW5lZCB8fCBpc05hTih2YWwpKSBicmVha1xuICAgICAgICAgICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oYy54ICsgaSAqIHNYICsgb2ZmWCwgYy55ICsgeTAgKyAodmFsIC0gdmFsMCkgKiBoIC8gYW1wTWF4ICsgb2ZmWSlcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oYy54ICsgaSAqIHNYICsgb2ZmWCwgYy55ICsgeTAgKyAodmFsIC0gdmFsMCkgKiBoIC8gYW1wTWF4ICsgb2ZmWSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKSovXG5cblxuICAgICAgICAgICAgLy9kcmF3IGxpbmUsIHNlZ21lbnQgYnkgc2VnbWVudFxuICAgICAgICAgICAgY29uc3Qgc1ggPSB3IC8gKG5iIC0gMSlcblxuICAgICAgICAgICAgLy9oYW5kbGUgZmlyc3QgcG9pbnRcbiAgICAgICAgICAgIGxldCB2MCA9IGNbdGhpcy50c1swXV1cbiAgICAgICAgICAgIGlmICghdGhpcy5ub0RhdGEodjApKSB7XG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhjLnggKyBvZmZYLCBjLnkgKyB5MCArICh2MCAtIHZhbDApICogaCAvIGFtcE1heCArIG9mZlkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHYwLCBpc05hTih2MCkpXG5cbiAgICAgICAgICAgIGxldCB2MVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuYjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBjW3RoaXMudHNbaV1dXG5cbiAgICAgICAgICAgICAgICAvL2RyYXcgc2VnbWVudCBmcm9tIHYwIHRvIHYxXG5cbiAgICAgICAgICAgICAgICAvL2JvdGggcG9pbnRzICdubyBkYXRhJ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vRGF0YSh2MCkgJiYgdGhpcy5ub0RhdGEodjEpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9zZWNvbmQgcG9pbnQgJ25vIGRhdGEnXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5ub0RhdGEodjApICYmIHRoaXMubm9EYXRhKHYxKSkge1xuICAgICAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcblxuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IHBvaW50ICdubyBkYXRhJ1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ub0RhdGEodjApICYmICF0aGlzLm5vRGF0YSh2MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oYy54ICsgaSAqIHNYICsgb2ZmWCwgYy55ICsgeTAgKyAodjEgLSB2YWwwKSAqIGggLyBhbXBNYXggKyBvZmZZKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vYm90aCBwb2ludHMgaGF2ZSBkYXRhOiB0cmFjZSBsaW5lXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjLnggKyBpICogc1ggKyBvZmZYLCBjLnkgKyB5MCArICh2MSAtIHZhbDApICogaCAvIGFtcE1heCArIG9mZlkpXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgaXQgaXMgdGhlIGxhc3QgcG9pbnQsIHN0cm9rZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBuYiAtIDEpIGNnLmN0eC5zdHJva2UoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2MCA9IHYxXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZCwgaWYgYW55XG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7XG4gICAgICAgICAgICB3aWR0aEZ1bjogdGhpcy5saW5lV2lkdGgsXG4gICAgICAgICAgICByOiByLFxuICAgICAgICAgICAgemY6IHpmLFxuICAgICAgICAgICAgc0NvbG9yOiBzdGF0Q29sb3IsXG4gICAgICAgICAgICAvL3NMZW5ndGg6IHN0YXRMZW5ndGgsXG4gICAgICAgICAgICBzV2lkdGg6IHN0YXRXaWR0aCxcbiAgICAgICAgfSlcblxuICAgIH1cblxufVxuXG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogR2V0IHRoZSBjbGFzcyBpZCBmcm9tIGEgdmFsdWUgYW5kIGNsYXNzIGJyZWFrIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IHRoZSB2YWx1ZVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYnJlYWtzIHRoZSBicmVha3NcbiAqIEByZXR1cm5zIFRoZSBjbGFzcyBpZCwgZnJvbSAwIHRvIGJyZWFrcy5sZW5ndGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENsYXNzKHYsIGJyZWFrcykge1xuICAgIGlmICghYnJlYWtzKSByZXR1cm5cbiAgICBpZiAoYnJlYWtzLmxlbmd0aCA9PSAwKSByZXR1cm4gMFxuICAgIGlmICh2IDw9IGJyZWFrc1swXSkgcmV0dXJuIDBcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGJyZWFrcy5sZW5ndGg7IGkrKykgaWYgKGJyZWFrc1tpIC0gMV0gPCB2ICYmIHYgPD0gYnJlYWtzW2ldKSByZXR1cm4gaVxuICAgIHJldHVybiBicmVha3MubGVuZ3RoXG59XG5cbmV4cG9ydCBsZXQgbW9uaXRvciA9IGZhbHNlXG5cbmxldCBwcmV2aW91c0RhdGVcbmV4cG9ydCBmdW5jdGlvbiBtb25pdG9yRHVyYXRpb24obWVzc2FnZSkge1xuICAgIGNvbnN0IG5vd0RhdGUgPSBEYXRlLm5vdygpXG5cbiAgICAvL2ZpcnN0IGNhbGxcbiAgICBpZiAoIXByZXZpb3VzRGF0ZSkge1xuICAgICAgICBwcmV2aW91c0RhdGUgPSBub3dEYXRlXG4gICAgICAgIGNvbnNvbGUubG9nKHByZXZpb3VzRGF0ZSwgbWVzc2FnZSlcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZCA9IG5vd0RhdGUgLSBwcmV2aW91c0RhdGVcbiAgICBwcmV2aW91c0RhdGUgPSBub3dEYXRlXG4gICAgY29uc29sZS5sb2coZCwgbWVzc2FnZSlcbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgaW5pdFNoYWRlclByb2dyYW0sIGNyZWF0ZVNoYWRlciB9IGZyb20gJy4vd2ViR0xVdGlscy5qcydcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnZDMtY29sb3InXG5cbi8qKlxuICogRXZlcnl0aGluZyB0byBlYXNpbHkgZHJhdyBjb2xvcmVkIHNxdWFyZXMgd2l0aCB3ZWJHTC5cbiAqIEFsbCB0aGUgc2FtZSBzaXplLCBidXQgZGlmZmVyZW50IGZpbGwgY29sb3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHTFNxdWFyZUNvbG9yaW5nIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdsLCBzaXplUGl4KSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbFxuICAgICAgICB0aGlzLnNpemVQaXggPSBzaXplUGl4IHx8IDEwLjBcblxuICAgICAgICB0aGlzLnByb2dyYW0gPSBpbml0U2hhZGVyUHJvZ3JhbShcbiAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgY3JlYXRlU2hhZGVyKFxuICAgICAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgICAgIGdsLlZFUlRFWF9TSEFERVIsXG4gICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgcG9zO1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCBzaXplUGl4O1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIG1hdDtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGNvbG9yO1xuICAgICAgICAgICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KG1hdCAqIHZlYzMocG9zLCAxLjApLCAxLjApO1xuICAgICAgICAgICAgICBnbF9Qb2ludFNpemUgPSBzaXplUGl4O1xuICAgICAgICAgICAgICB2Q29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBgXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY3JlYXRlU2hhZGVyKFxuICAgICAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgICAgICAgICB2b2lkIG1haW4odm9pZCkge1xuICAgICAgICAgICAgICAgIHZlYzQgdkNvbG9yXyA9IHZDb2xvciAvIDI1NS4wO1xuICAgICAgICAgICAgICAgIHZDb2xvcl9bM10gPSAyNTUuMCAqIHZDb2xvcl9bM107XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yXztcbiAgICAgICAgICAgIH1gXG4gICAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pXG5cbiAgICAgICAgLy9idWZmZXIgZGF0YVxuICAgICAgICB0aGlzLnZlcnRpY2VzQnVmZmVyID0gW11cbiAgICAgICAgdGhpcy5jb2xvcnNCdWZmZXIgPSBbXVxuICAgIH1cblxuICAgIC8qKiBBZGQgZGF0YSB0byB2ZXJ0aWNlcy9zaXplL2NvbG9yIGJ1ZmZlcnMgZm9yIGNvbG9yIHNxdWFyZXMgZHJhd2luZyAqL1xuICAgIGFkZFBvaW50RGF0YSh4QywgeUMsIGNvbCkge1xuICAgICAgICAvL2NvbnZlcnQgY29sb3JcbiAgICAgICAgY29uc3QgY2MgPSBjb2xvcihjb2wpXG4gICAgICAgIC8vY29uc3QgY2MgPSB7cjo0NSxnOjg3LGI6OTgsb3BhY2l0eTowLjl9XG4gICAgICAgIGlmICghY2MpIHJldHVyblxuXG4gICAgICAgIC8vdmVydGljZXNcbiAgICAgICAgdGhpcy52ZXJ0aWNlc0J1ZmZlci5wdXNoKHhDLCB5QylcbiAgICAgICAgLy9jb2xvclxuICAgICAgICB0aGlzLmNvbG9yc0J1ZmZlci5wdXNoKGNjLnIsIGNjLmcsIGNjLmIsIGNjLm9wYWNpdHkpXG4gICAgfVxuXG4gICAgYWRkUG9pbnREYXRhMih4QywgeUMsIHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgICAgICAgLy92ZXJ0aWNlc1xuICAgICAgICB0aGlzLnZlcnRpY2VzQnVmZmVyLnB1c2goeEMsIHlDKVxuICAgICAgICAvL2NvbG9yXG4gICAgICAgIHRoaXMuY29sb3JzQnVmZmVyLnB1c2gociwgZywgYiwgb3BhY2l0eSlcbiAgICB9XG5cbiAgICAvKiogICovXG4gICAgZHJhdyh0cmFuc2ZvTWF0KSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbFxuXG4gICAgICAgIC8vdmVydGljZSBkYXRhXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSlcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0aWNlc0J1ZmZlciksIGdsLlNUQVRJQ19EUkFXKVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ3BvcycpXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIDIsIC8vbnVtQ29tcG9uZW50c1xuICAgICAgICAgICAgZ2wuRkxPQVQsIC8vdHlwZVxuICAgICAgICAgICAgZmFsc2UsIC8vbm9ybWFsaXNlXG4gICAgICAgICAgICAwLCAvL3N0cmlkZVxuICAgICAgICAgICAgMCAvL29mZnNldFxuICAgICAgICApXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uKVxuXG4gICAgICAgIC8vY29sb3IgZGF0YVxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY29sb3JzQnVmZmVyKSwgZ2wuU1RBVElDX0RSQVcpXG4gICAgICAgIHZhciBjb2xvciA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2NvbG9yJylcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihjb2xvciwgNCwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKVxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvcilcblxuICAgICAgICAvL3NpemVQaXhcbiAgICAgICAgZ2wudW5pZm9ybTFmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICdzaXplUGl4JyksIDEuMCAqIHRoaXMuc2l6ZVBpeClcblxuICAgICAgICAvL3RyYW5zZm9ybWF0aW9uXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ21hdCcpLCBmYWxzZSwgbmV3IEZsb2F0MzJBcnJheSh0cmFuc2ZvTWF0KSlcblxuICAgICAgICAvLyBFbmFibGUgdGhlIGRlcHRoIHRlc3RcbiAgICAgICAgLy9nbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIC8vIENsZWFyIHRoZSBjb2xvciBidWZmZXIgYml0XG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXG4gICAgICAgIC8vIFNldCB0aGUgdmlldyBwb3J0XG4gICAgICAgIC8vZ2wudmlld3BvcnQoMCwgMCwgY2cudywgY2cuaCk7XG5cbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIHRoaXMudmVydGljZXNCdWZmZXIubGVuZ3RoIC8gMilcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IGluaXRTaGFkZXJQcm9ncmFtLCBjcmVhdGVTaGFkZXIgfSBmcm9tICcuL3dlYkdMVXRpbHMuanMnXG5pbXBvcnQgeyBjb2xvciB9IGZyb20gJ2QzLWNvbG9yJ1xuXG4vKipcbiAqIEV2ZXJ5dGhpbmcgdG8gZWFzaWx5IGRyYXcgY29sb3JlZCBzcXVhcmVzIHdpdGggd2ViR0wuXG4gKiBBbGwgdGhlIHNhbWUgc2l6ZSwgYnV0IGRpZmZlcmVudCBmaWxsIGNvbG9yLlxuICogVGhlIGNvbG9yIGludGVycG9sYXRpb24gaXMgY29tcHV0ZWQgaW4gdGhlIGZyYWdtZW50IHNoYWRlciBwcm9ncmFtLCBieSB0aGUgR1BVLCB0aHVzIGl0IGlzIGxlc3MgZmxleGlibGUgYnV0IGZhc3Rlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYkdMU3F1YXJlQ29sb3JpbmdBZHZhbmNlZCB7XG4gICAgLy9zZWU6XG4gICAgLy9odHRwczovL3dlYmdsZnVuZGFtZW50YWxzLm9yZy93ZWJnbC9sZXNzb25zL2ZyL3dlYmdsLXNoYWRlcnMtYW5kLWdsc2wuaHRtbCNsZXMtdW5pZm9ybXMtZGFucy1sZXMtc2hhZGVycy1kZS12ZXJ0ZXhcbiAgICAvL2h0dHBzOi8vdGhlYm9va29mc2hhZGVycy5jb20vZ2xvc3NhcnkvP3NlYXJjaD1taXhcbiAgICAvL2h0dHBzOi8vdGhlYm9va29mc2hhZGVycy5jb20vMDYvXG4gICAgLy9odHRwczovL3RoZWJvb2tvZnNoYWRlcnMuY29tL2dsb3NzYXJ5L1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGdsXG4gICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gY29sb3JzXG4gICAgICogQHBhcmFtIHt7ZnVuOnN0cmluZyxhbHBoYTpudW1iZXJ9fSBzdHJldGNoaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVQaXhcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGdsb2JhbE9wYWNpdHlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnbCwgY29sb3JzLCBzdHJldGNoaW5nLCBzaXplUGl4ID0gMTAsIGdsb2JhbE9wYWNpdHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9ICovXG4gICAgICAgIHRoaXMuZ2wgPSBnbFxuICAgICAgICAvL2dsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdHJ1ZSk7XG4gICAgICAgIC8vZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgIC8vZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFNoYWRlcn0gKi9cbiAgICAgICAgY29uc3QgdlNoYWRlciA9IGNyZWF0ZVNoYWRlcihcbiAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgZ2wuVkVSVEVYX1NIQURFUixcbiAgICAgICAgICAgIGBcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgcG9zO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHNpemVQaXg7XG4gICAgICAgIHVuaWZvcm0gbWF0MyBtYXQ7XG5cbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IHQ7XG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdnQ7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChtYXQgKiB2ZWMzKHBvcywgMS4wKSwgMS4wKTtcbiAgICAgICAgICBnbF9Qb2ludFNpemUgPSBzaXplUGl4O1xuICAgICAgICAgIHZ0ID0gdDtcbiAgICAgICAgfVxuICAgICAgYFxuICAgICAgICApXG5cbiAgICAgICAgLy9wcmVwYXJlIGZyYWdtZW50IHNoYWRlciBjb2RlXG4gICAgICAgIC8vZGVjbGFyZSB0aGUgdW5pZm9ybSBhbmQgb3RoZXIgdmFyaWFibGVzXG4gICAgICAgIGxldCBmc2hTdHJpbmcgPVxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbicgK1xuICAgICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdnQ7XFxuJyArXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBhbHBoYTtcXG4nICtcbiAgICAgICAgICAgICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gW11cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykgb3V0LnB1c2goJ3VuaWZvcm0gdmVjNCBjJyArIGkgKyAnO1xcbicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5qb2luKCcnKVxuICAgICAgICAgICAgfSkoKSArXG4gICAgICAgICAgICAvL3N0YXJ0IHRoZSBtYWluIGZ1bmN0aW9uLCBhcHBseSB0aGUgc3RyZXRjaGluZyBvZiB0XG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHtcXG4nXG5cbiAgICAgICAgaWYgKHN0cmV0Y2hpbmcpIHtcbiAgICAgICAgICAgIGlmIChzdHJldGNoaW5nLmZ1biA9PSAncG93JylcbiAgICAgICAgICAgICAgICAvL3NQb3cgPSAodCwgYWxwaGEgPSAzKSA9PiBNYXRoLnBvdyh0LCBhbHBoYSk7XG4gICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gcG93KHZ0LCBhbHBoYSk7XFxuJ1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZXRjaGluZy5mdW4gPT0gJ3Bvd1JldicpXG4gICAgICAgICAgICAgICAgLy9zUG93UmV2ID0gKHQsIGFscGhhID0gMykgPT4gMSAtIE1hdGgucG93KDEgLSB0LCAxIC8gYWxwaGEpO1xuICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgZmxvYXQgdCA9IDEuMC1wb3coMS4wLXZ0LCAxLjAvYWxwaGEpO1xcbidcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmV0Y2hpbmcuZnVuID09ICdleHAnKVxuICAgICAgICAgICAgICAgIC8vc0V4cCA9ICh0LCBhbHBoYSA9IDMpID0+IGFscGhhID09IDAgPyB0IDogKE1hdGguZXhwKHQgKiBhbHBoYSkgLSAxKSAvIChNYXRoLmV4cChhbHBoYSkgLSAxKTtcbiAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz1cbiAgICAgICAgICAgICAgICAgICAgc3RyZXRjaGluZy5hbHBoYSA9PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBmbG9hdCB0ID0gdnQ7YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnICAgZmxvYXQgdCA9IChleHAodnQgKiBhbHBoYSkgLSAxLjApIC8gKGV4cChhbHBoYSkgLSAxLjApO1xcbidcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmV0Y2hpbmcuZnVuID09ICdleHBSZXYnKVxuICAgICAgICAgICAgICAgIC8vc0V4cFJldiA9ICh0LCBhbHBoYSA9IDMpID0+IGFscGhhID09IDAgPyB0IDogMSAtICgxIC8gYWxwaGEpICogTWF0aC5sb2coTWF0aC5leHAoYWxwaGEpICogKDEgLSB0KSArIHQpO1xuICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPVxuICAgICAgICAgICAgICAgICAgICBzdHJldGNoaW5nLmFscGhhID09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGZsb2F0IHQgPSB2dDtgXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICcgICBmbG9hdCB0ID0gMS4wIC0gKDEuMCAvIGFscGhhKSAqIGxvZyhleHAoYWxwaGEpICogKDEuMCAtIHZ0KSArIHZ0KTtcXG4nXG4gICAgICAgICAgICBlbHNlIGlmIChzdHJldGNoaW5nLmZ1biA9PSAnY2lyY2xlTG93Jykge1xuICAgICAgICAgICAgICAgIGlmIChzdHJldGNoaW5nLmFscGhhID09IDApXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKGFscGhhID09IDApIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGZsb2F0IHQgPSB2dDtcXG4nXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyZXRjaGluZy5hbHBoYSA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoYWxwaGEgPT0gMSkgcmV0dXJuIE1hdGguc3FydCgyICogdCAtIHQgKiB0KTtcbiAgICAgICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gc3FydCh2dCAqICgyLjAgLSB2dCkpO1xcbidcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBhID0gYWxwaGEgLyAoMSAtIGFscGhhKTtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gTWF0aC5zcXJ0KDEgLyAoYSAqIGEpICsgdCAqICgyIC8gYSArIDIgLSB0KSkgLSAxIC8gYTtcbiAgICAgICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAnICAgZmxvYXQgYSA9IGFscGhhIC8gKDEuMCAtIGFscGhhKTtcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgICBmbG9hdCB0ID0gc3FydCgxLjAgLyAoYSAqIGEpICsgdnQgKiAoIDIuMC9hICsgMi4wIC0gdnQgKSkgLSAxLjAgLyBhO1xcbidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmV0Y2hpbmcuZnVuID09ICdjaXJjbGVIaWdoJykge1xuICAgICAgICAgICAgICAgIC8vIDEgLSBzQ2lyY2xlTG93KDEgLSB0LCBhbHBoYSlcbiAgICAgICAgICAgICAgICBpZiAoc3RyZXRjaGluZy5hbHBoYSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAvL2lmIChhbHBoYSA9PSAwKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gdnQ7XFxuJ1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cmV0Y2hpbmcuYWxwaGEgPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGFscGhhID09IDEpIHJldHVybiBNYXRoLnNxcnQoMiAqIHQgLSB0ICogdCk7XG4gICAgICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgZmxvYXQgdCA9IDEuMCAtIHNxcnQoKDEuMCAtIHZ0KSAqICgxLjAgKyB2dCkpO1xcbidcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBhID0gYWxwaGEgLyAoMSAtIGFscGhhKTtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gTWF0aC5zcXJ0KDEgLyAoYSAqIGEpICsgKDIgKiB0KSAvIGEgKyAyICogdCAtIHQgKiB0KSAtIDEgLyBhO1xuICAgICAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICcgICBmbG9hdCBhID0gYWxwaGEgLyAoMS4wIC0gYWxwaGEpO1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgIGZsb2F0IHQgPSAxLjAgLSBzcXJ0KDEuMCAvIChhICogYSkgKyAoMS4wLXZ0KSAqICggMi4wL2EgKyAxLjAgKyB2dCApKSArIDEuMCAvIGE7XFxuJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBzdHJldGNoaW5nIGZ1bmN0aW9uIGNvZGU6ICcgKyBzdHJldGNoaW5nLmZ1bilcbiAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGZsb2F0IHQgPSB2dDtcXG4nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGZsb2F0IHQgPSB2dDtcXG4nXG4gICAgICAgIH1cblxuICAgICAgICAvL2Nob29zZSBpbml0aWFsIGFuZCBmaW5hbCBjb2xvcnMsIGFuZCBhZGp1c3QgdCB2YWx1ZVxuICAgICAgICBpZiAoY29sb3JzLmxlbmd0aCA9PSAxKSBmc2hTdHJpbmcgKz0gJyAgIHZlYzQgY0k9YzA7XFxuICAgdmVjNCBjRj1jMDtcXG4nXG4gICAgICAgIGVsc2UgaWYgKGNvbG9ycy5sZW5ndGggPT0gMikgZnNoU3RyaW5nICs9ICcgICB2ZWM0IGNJPWMwO1xcbiAgIHZlYzQgY0Y9YzE7XFxuJ1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5iID0gY29sb3JzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgIGNvbnN0IG5icyA9IG5iICsgJy4wJ1xuICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICB2ZWM0IGNJO1xcbidcbiAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgdmVjNCBjRjtcXG4nXG4gICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGlmKHQ8MS4wLycgKyBuYnMgKyAnKSB7IGNJPWMwOyBjRj1jMTsgdD10KicgKyBuYnMgKyAnOyB9XFxuJ1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBuYjsgaSsrKVxuICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPVxuICAgICAgICAgICAgICAgICAgICAnICAgZWxzZSBpZih0PCcgK1xuICAgICAgICAgICAgICAgICAgICBpICtcbiAgICAgICAgICAgICAgICAgICAgJy4wLycgK1xuICAgICAgICAgICAgICAgICAgICBuYnMgK1xuICAgICAgICAgICAgICAgICAgICAnKSB7IGNJPWMnICtcbiAgICAgICAgICAgICAgICAgICAgKGkgLSAxKSArXG4gICAgICAgICAgICAgICAgICAgICc7IGNGPWMnICtcbiAgICAgICAgICAgICAgICAgICAgaSArXG4gICAgICAgICAgICAgICAgICAgICc7IHQ9JyArXG4gICAgICAgICAgICAgICAgICAgIG5icyArXG4gICAgICAgICAgICAgICAgICAgICcqdC0nICtcbiAgICAgICAgICAgICAgICAgICAgKGkgLSAxKSArXG4gICAgICAgICAgICAgICAgICAgICcuMDsgfVxcbidcbiAgICAgICAgICAgIGZzaFN0cmluZyArPVxuICAgICAgICAgICAgICAgICcgICBlbHNlIHsgY0k9YycgKyAobmIgLSAxKSArICc7IGNGPWMnICsgbmIgKyAnOyB0PScgKyBuYnMgKyAnKnQtJyArIChuYiAtIDEpICsgJy4wOyB9XFxuJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy9vbmUgc2luZ2xlIGNvbG9yXG4gICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID09IDEpIGZzaFN0cmluZyArPSAnICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjMFswXSwgYzBbMV0sIGMwWzJdLCBjMFszXSk7fVxcbidcbiAgICAgICAgLy9zZXQgaW50ZXJwb2xhdGVkIGNvbG9yLCBiZXR3ZWVuIGluaXRpYWwgYW5kIGZpbmFsIG9uZVxuICAgICAgICBlbHNlIGZzaFN0cmluZyArPSAnICAgZ2xfRnJhZ0NvbG9yID0gbWl4KGNJLCBjRiwgdCk7fVxcbidcblxuICAgICAgICAvL2NvbnNvbGUubG9nKGZzaFN0cmluZylcblxuICAgICAgICAvKiogQHR5cGUge1dlYkdMU2hhZGVyfSAqL1xuICAgICAgICBjb25zdCBmU2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZzaFN0cmluZylcblxuICAgICAgICAvKiogQHR5cGUge1dlYkdMUHJvZ3JhbX0gKi9cbiAgICAgICAgdGhpcy5wcm9ncmFtID0gaW5pdFNoYWRlclByb2dyYW0oZ2wsIHZTaGFkZXIsIGZTaGFkZXIpXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKVxuXG4gICAgICAgIC8vc2V0IHVuaWZvcm1zXG5cbiAgICAgICAgLy9zaXplUGl4XG4gICAgICAgIC8vVE9ETzogYnVnIGhlcmUuIFNlZW1zIHRvIGJlIGxpbWl0ZWQgdG8gc29tZSB0aHJlc2hvbGQgdmFsdWUgKGFyb3VuZCAyNTApLlxuICAgICAgICBnbC51bmlmb3JtMWYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ3NpemVQaXgnKSwgMS4wICogc2l6ZVBpeClcblxuICAgICAgICAvL3N0cmV0Y2hpbmcgYWxwaGEgZmFjdG9yXG4gICAgICAgIGdsLnVuaWZvcm0xZihnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnYWxwaGEnKSwgc3RyZXRjaGluZyA/IDEuMCAqIHN0cmV0Y2hpbmcuYWxwaGEgOiAwLjApXG5cbiAgICAgICAgLy9jb2xvcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb2xvcihjb2xvcnNbaV0pXG5cbiAgICAgICAgICAgIGxldCBvcGFjaXR5ID0gYy5vcGFjaXR5XG4gICAgICAgICAgICBpZiAoYy5vcGFjaXR5ID09IDEgJiYgZ2xvYmFsT3BhY2l0eSAhPSB1bmRlZmluZWQpIG9wYWNpdHkgPSBnbG9iYWxPcGFjaXR5XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm00ZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2MnICsgaSksIFtcbiAgICAgICAgICAgICAgICArYy5yIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgK2MuZyAvIDI1NS4wLFxuICAgICAgICAgICAgICAgICtjLmIgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICArb3BhY2l0eSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogICovXG4gICAgZHJhdyh2ZXJ0aWNlc0J1ZmZlciwgdEJ1ZmZlciwgdHJhbnNmb01hdCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2xcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbVxuXG4gICAgICAgIC8vdmVydGljZSBkYXRhXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSlcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXNCdWZmZXIpLCBnbC5TVEFUSUNfRFJBVylcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAncG9zJylcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgMiwgLy9udW1Db21wb25lbnRzXG4gICAgICAgICAgICBnbC5GTE9BVCwgLy90eXBlXG4gICAgICAgICAgICBmYWxzZSwgLy9ub3JtYWxpc2VcbiAgICAgICAgICAgIDAsIC8vc3RyaWRlXG4gICAgICAgICAgICAwIC8vb2Zmc2V0XG4gICAgICAgIClcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb24pXG5cbiAgICAgICAgLy90IGRhdGFcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGdsLmNyZWF0ZUJ1ZmZlcigpKVxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh0QnVmZmVyKSwgZ2wuU1RBVElDX0RSQVcpXG4gICAgICAgIGNvbnN0IHQgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAndCcpXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodCwgMSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKVxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0KVxuXG4gICAgICAgIC8vdHJhbnNmb3JtYXRpb25cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ21hdCcpLCBmYWxzZSwgbmV3IEZsb2F0MzJBcnJheSh0cmFuc2ZvTWF0KSlcblxuICAgICAgICAvLyBFbmFibGUgdGhlIGRlcHRoIHRlc3RcbiAgICAgICAgLy9nbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIC8vIENsZWFyIHRoZSBjb2xvciBidWZmZXIgYml0XG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXG4gICAgICAgIC8vIFNldCB0aGUgdmlldyBwb3J0XG4gICAgICAgIC8vZ2wudmlld3BvcnQoMCwgMCwgY2cudywgY2cuaCk7XG5cbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIHZlcnRpY2VzQnVmZmVyLmxlbmd0aCAvIDIpXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBpbml0U2hhZGVyUHJvZ3JhbSwgY3JlYXRlU2hhZGVyIH0gZnJvbSAnLi93ZWJHTFV0aWxzLmpzJ1xuaW1wb3J0IHsgY29sb3IgfSBmcm9tICdkMy1jb2xvcidcblxuLyoqXG4gKiBFdmVyeXRoaW5nIHRvIGVhc2lseSBkcmF3IGNvbG9yZWQgc3F1YXJlcyB3aXRoIHdlYkdMLlxuICogQWxsIHRoZSBzYW1lIHNpemUsIGJ1dCBkaWZmZXJlbnQgZmlsbCBjb2xvci5cbiAqIENvbG9yIGJhc2VkIG9uIGNhdGVnb3JpZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHTFNxdWFyZUNvbG9yaW5nQ2F0QWR2YW5jZWQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9yc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbG9ycykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fSAqL1xuICAgICAgICB0aGlzLmNvbG9ycyA9IGNvbG9yc1xuXG4gICAgICAgIC8qKiBWZWN0b3Igc2hhZGVyIHByb2dyYW1cbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy52c2hTdHJpbmcgPSBgXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvcztcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBzaXplUGl4O1xuICAgICAgICB1bmlmb3JtIG1hdDMgbWF0O1xuXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBpO1xuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZpO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQobWF0ICogdmVjMyhwb3MsIDEuMCksIDEuMCk7XG4gICAgICAgICAgZ2xfUG9pbnRTaXplID0gc2l6ZVBpeDtcbiAgICAgICAgICB2aSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgYFxuXG4gICAgICAgIC8vcHJlcGFyZSBmcmFnbWVudCBzaGFkZXIgY29kZVxuICAgICAgICAvL2RlY2xhcmUgdGhlIHVuaWZvcm0gYW5kIG90aGVyIHZhcmlhYmxlc1xuICAgICAgICBjb25zdCBvdXQgPSBbXVxuICAgICAgICBvdXQucHVzaCgncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudmFyeWluZyBmbG9hdCB2aTtcXG4nKVxuICAgICAgICAvL2FkZCBjb2xvciB1bmlmb3Jtc1xuICAgICAgICBvdXQucHVzaCgndW5pZm9ybSB2ZWM0JylcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkgb3V0LnB1c2goJywnKVxuICAgICAgICAgICAgb3V0LnB1c2goJyBjJyArIGkpXG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2goJztcXG4nKVxuICAgICAgICAvL3N0YXJ0IHRoZSBtYWluIGZ1bmN0aW9uXG4gICAgICAgIG91dC5wdXNoKCd2b2lkIG1haW4odm9pZCkge1xcbicpXG4gICAgICAgIC8vY2hvb3NlIGNvbG9yIGlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkgb3V0LnB1c2goJ2Vsc2UgJylcbiAgICAgICAgICAgIG91dC5wdXNoKCdpZih2aT09JylcbiAgICAgICAgICAgIG91dC5wdXNoKGkpXG4gICAgICAgICAgICBvdXQucHVzaCgnLjApIGdsX0ZyYWdDb2xvciA9IHZlYzQoYycpXG4gICAgICAgICAgICBvdXQucHVzaChpKVxuICAgICAgICAgICAgb3V0LnB1c2goJ1swXSwgYycpXG4gICAgICAgICAgICBvdXQucHVzaChpKVxuICAgICAgICAgICAgb3V0LnB1c2goJ1sxXSwgYycpXG4gICAgICAgICAgICBvdXQucHVzaChpKVxuICAgICAgICAgICAgb3V0LnB1c2goJ1syXSwgYycpXG4gICAgICAgICAgICBvdXQucHVzaChpKVxuICAgICAgICAgICAgb3V0LnB1c2goJ1szXSk7XFxuJylcbiAgICAgICAgfVxuICAgICAgICBvdXQucHVzaCgnZWxzZSBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxufScpXG4gICAgICAgIC8qKiBGcmFnbWVudCBzaGFkZXIgcHJvZ3JhbVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmZzaFN0cmluZyA9IG91dC5qb2luKCcnKVxuICAgIH1cblxuICAgIC8qKiAgKi9cbiAgICBkcmF3KGdsLCB2ZXJ0aWNlc0J1ZmZlciwgaUJ1ZmZlciwgdHJhbnNmb01hdCwgc2l6ZVBpeCA9IDEwKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7V2ViR0xTaGFkZXJ9ICovXG4gICAgICAgIGNvbnN0IHZTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHRoaXMudnNoU3RyaW5nKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViR0xTaGFkZXJ9ICovXG4gICAgICAgIGNvbnN0IGZTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgdGhpcy5mc2hTdHJpbmcpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFByb2dyYW19ICovXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBpbml0U2hhZGVyUHJvZ3JhbShnbCwgdlNoYWRlciwgZlNoYWRlcilcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKVxuXG4gICAgICAgIC8vc2V0IHVuaWZvcm1zXG5cbiAgICAgICAgLy9zaXplUGl4XG4gICAgICAgIGdsLnVuaWZvcm0xZihnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3NpemVQaXgnKSwgMS4wICogc2l6ZVBpeClcblxuICAgICAgICAvL2NvbG9yc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29sb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gY29sb3IodGhpcy5jb2xvcnNbaV0pXG4gICAgICAgICAgICBnbC51bmlmb3JtNGZ2KGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnYycgKyBpKSwgW1xuICAgICAgICAgICAgICAgICtjLnIgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICArYy5nIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgK2MuYiAvIDI1NS4wLFxuICAgICAgICAgICAgICAgICtjLm9wYWNpdHksXG4gICAgICAgICAgICBdKVxuICAgICAgICB9XG5cbiAgICAgICAgLy92ZXJ0aWNlIGRhdGFcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGdsLmNyZWF0ZUJ1ZmZlcigpKVxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlc0J1ZmZlciksIGdsLlNUQVRJQ19EUkFXKVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3MnKVxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAyLCAvL251bUNvbXBvbmVudHNcbiAgICAgICAgICAgIGdsLkZMT0FULCAvL3R5cGVcbiAgICAgICAgICAgIGZhbHNlLCAvL25vcm1hbGlzZVxuICAgICAgICAgICAgMCwgLy9zdHJpZGVcbiAgICAgICAgICAgIDAgLy9vZmZzZXRcbiAgICAgICAgKVxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbilcblxuICAgICAgICAvL2kgZGF0YVxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KGlCdWZmZXIpLCBnbC5TVEFUSUNfRFJBVylcbiAgICAgICAgY29uc3QgaSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdpJylcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpLCAxLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG5cbiAgICAgICAgLy90cmFuc2Zvcm1hdGlvblxuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnbWF0JyksIGZhbHNlLCBuZXcgRmxvYXQzMkFycmF5KHRyYW5zZm9NYXQpKVxuXG4gICAgICAgIC8vIEVuYWJsZSB0aGUgZGVwdGggdGVzdFxuICAgICAgICAvL2dsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGNvbG9yIGJ1ZmZlciBiaXRcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVClcbiAgICAgICAgLy8gU2V0IHRoZSB2aWV3IHBvcnRcbiAgICAgICAgLy9nbC52aWV3cG9ydCgwLCAwLCBjZy53LCBjZy5oKTtcblxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgdmVydGljZXNCdWZmZXIubGVuZ3RoIC8gMilcbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cblxuLyoqXG4gKiBTb21lIGZ1bmN0aW9uIFswLDFdLT5bMCwxXSB0byBzdHJldGNoIHJhbmdlIG9mIHZhbHVlcy5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2V1cm9zdGF0L2dyaWR2aXovYmxvYi9tYXN0ZXIvZG9jcy9yZWZlcmVuY2UubWQjc3RyZXRjaGluZ1xuICogQHNlZSBodHRwczovL29ic2VydmFibGVocS5jb20vQGpnYWZmdXJpL3N0cmV0Y2hpbmdcbiAqL1xuXG5cbmV4cG9ydCBjb25zdCBwb3dlclNjYWxlID0gKGV4cG9uZW50ID0gMykgPT4gdCA9PiBNYXRoLnBvdyh0LCBleHBvbmVudClcbmV4cG9ydCBjb25zdCBwb3dlckludmVyc2VTY2FsZSA9IChleHBvbmVudCA9IDMpID0+IHQgPT4gMSAtIE1hdGgucG93KDEgLSB0LCAxIC8gZXhwb25lbnQpXG5leHBvcnQgY29uc3QgZXhwb25lbnRpYWxTY2FsZSA9IChiYXNlID0gMykgPT4ge1xuICAgIGlmIChiYXNlID09IDApIHJldHVybiB0ID0+IHRcbiAgICBjb25zdCBhID0gKE1hdGguZXhwKGJhc2UpIC0gMSlcbiAgICByZXR1cm4gdCA9PiAoTWF0aC5leHAodCAqIGJhc2UpIC0gMSkgLyBhXG59XG5leHBvcnQgY29uc3QgbG9nYXJpdGhtaWNTY2FsZSA9IChiYXNlID0gMykgPT4ge1xuICAgIGlmIChiYXNlID09IDApIHJldHVybiB0ID0+IHRcbiAgICByZXR1cm4gdCA9PiAxIC0gKDEgLyBiYXNlKSAqIE1hdGgubG9nKE1hdGguZXhwKGJhc2UpICogKDEgLSB0KSArIHQpXG59XG5cbmV4cG9ydCBjb25zdCBjaXJjdWxhclNjYWxlID0gKGFscGhhID0gMC44KSA9PiB7XG4gICAgaWYgKGFscGhhID09IDApIHJldHVybiB0ID0+IHRcbiAgICBpZiAoYWxwaGEgPT0gMSkgcmV0dXJuIHQgPT4gTWF0aC5zcXJ0KHQgKiAoMiAtIHQpKVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBhID0gYWxwaGEgLyAoMSAtIGFscGhhKVxuICAgICAgICByZXR1cm4gdCA9PiBNYXRoLnNxcnQoMSAvIChhICogYSkgKyB0ICogKDIgLyBhICsgMiAtIHQpKSAtIDEgLyBhXG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGNpcmN1bGFySW52ZXJzZVNjYWxlID0gKGFscGhhID0gMC44KSA9PiB7XG4gICAgY29uc3QgZiA9IGNpcmN1bGFyU2NhbGUoYWxwaGEpXG4gICAgcmV0dXJuIHQgPT4gMSAtIGYoMSAtIHQpXG59XG5cblxuXG5cblxuXG5cblxuLy8gZGVwcmVjYXRlZFxuXG5cbi8qKlxuICogRnVuY3Rpb24gWzAsMV0tPlswLDFdIHRvIHN0cmV0Y2ggcmFuZ2Ugb2YgdmFsdWVzLlxuICogUG9seW5vbWlhbFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0IFRoZSB2YWx1ZSB0byBzdHJldGNoLCB3aXRoaW4gWzAsMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudCAxOiBubyBzdHJldGNoaW5nLiA8MTogc2hvdyBsb3cgdmFsdWVzLiA+MTogc2hvdyBoaWdoIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdHJldGNoZWQgdmFsdWUsIHdpdGhpbiBbMCwxXVxuICovXG5leHBvcnQgY29uc3Qgc1BvdyA9ICh0LCBleHBvbmVudCA9IDMpID0+IE1hdGgucG93KHQsIGV4cG9uZW50KVxuXG4vKipcbiAqIEZ1bmN0aW9uIFswLDFdLT5bMCwxXSB0byBzdHJldGNoIHJhbmdlIG9mIHZhbHVlcy5cbiAqIFBvbHlub21pYWwgKHJldmVyc2UpXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHQgVGhlIHZhbHVlIHRvIHN0cmV0Y2gsIHdpdGhpbiBbMCwxXVxuICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50IDE6IG5vIHN0cmV0Y2hpbmcuIDwxOiBzaG93IGxvdyB2YWx1ZXMuID4xOiBzaG93IGhpZ2ggdmFsdWVzLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHN0cmV0Y2hlZCB2YWx1ZSwgd2l0aGluIFswLDFdXG4gKi9cbmV4cG9ydCBjb25zdCBzUG93UmV2ID0gKHQsIGV4cG9uZW50ID0gMykgPT4gMSAtIE1hdGgucG93KDEgLSB0LCAxIC8gZXhwb25lbnQpXG5cbi8qKlxuICogRnVuY3Rpb24gWzAsMV0tPlswLDFdIHRvIHN0cmV0Y2ggcmFuZ2Ugb2YgdmFsdWVzLlxuICogRXhwb25lbnRpYWxcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdCBUaGUgdmFsdWUgdG8gc3RyZXRjaCwgd2l0aGluIFswLDFdXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZSAwOiBubyBzdHJldGNoaW5nLiAtSW5mOiBzaG93IGxvdyB2YWx1ZXMuIEluZjogc2hvdyBoaWdoIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdHJldGNoZWQgdmFsdWUsIHdpdGhpbiBbMCwxXVxuICovXG5leHBvcnQgY29uc3Qgc0V4cCA9ICh0LCBiYXNlID0gMykgPT4gKGJhc2UgPT0gMCA/IHQgOiAoTWF0aC5leHAodCAqIGJhc2UpIC0gMSkgLyAoTWF0aC5leHAoYmFzZSkgLSAxKSlcblxuLyoqXG4gKiBGdW5jdGlvbiBbMCwxXS0+WzAsMV0gdG8gc3RyZXRjaCByYW5nZSBvZiB2YWx1ZXMuXG4gKiBFeHBvbmVudGlhbCAocmV2ZXJzZSlcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdCBUaGUgdmFsdWUgdG8gc3RyZXRjaCwgd2l0aGluIFswLDFdXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZSAwOiBubyBzdHJldGNoaW5nLiAtSW5mOiBzaG93IGxvdyB2YWx1ZXMuIEluZjogc2hvdyBoaWdoIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdHJldGNoZWQgdmFsdWUsIHdpdGhpbiBbMCwxXVxuICovXG5leHBvcnQgY29uc3Qgc0V4cFJldiA9ICh0LCBiYXNlID0gMykgPT5cbiAgICBiYXNlID09IDAgPyB0IDogMSAtICgxIC8gYmFzZSkgKiBNYXRoLmxvZyhNYXRoLmV4cChiYXNlKSAqICgxIC0gdCkgKyB0KVxuXG4vKipcbiAqIEZ1bmN0aW9uIFswLDFdLT5bMCwxXSB0byBzdHJldGNoIHJhbmdlIG9mIHZhbHVlcy5cbiAqIENpcmNsZSwgc2hvdyBsb3cgdmFsdWVzXG4gKiBOQjogc0NpcmNsZUhpZ2ggYW5kIHNDaXJjbGVMb3cgYXJlIGludmVyc2UgZnVuY3Rpb25zIG9mIGVhY2ggb3RoZXIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHQgVGhlIHZhbHVlIHRvIHN0cmV0Y2gsIHdpdGhpbiBbMCwxXVxuICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIDA6IG5vIHN0cmV0Y2hpbmcuIDE6IHBlcmZlY3QgY2lyY2xlIHNlY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdHJldGNoZWQgdmFsdWUsIHdpdGhpbiBbMCwxXVxuICovXG5leHBvcnQgY29uc3Qgc0NpcmNsZUxvdyA9ICh0LCBhbHBoYSA9IDAuOCkgPT4ge1xuICAgIGlmIChhbHBoYSA9PSAwKSByZXR1cm4gdFxuICAgIGlmIChhbHBoYSA9PSAxKSByZXR1cm4gTWF0aC5zcXJ0KHQgKiAoMiAtIHQpKVxuICAgIGNvbnN0IGEgPSBhbHBoYSAvICgxIC0gYWxwaGEpXG4gICAgcmV0dXJuIE1hdGguc3FydCgxIC8gKGEgKiBhKSArIHQgKiAoMiAvIGEgKyAyIC0gdCkpIC0gMSAvIGFcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBbMCwxXS0+WzAsMV0gdG8gc3RyZXRjaCByYW5nZSBvZiB2YWx1ZXMuXG4gKiBDaXJjbGUsIHNob3cgaGlnaCB2YWx1ZXNcbiAqIE5COiBzQ2lyY2xlSGlnaCBhbmQgc0NpcmNsZUxvdyBhcmUgaW52ZXJzZSBmdW5jdGlvbnMgb2YgZWFjaCBvdGhlci5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdCBUaGUgdmFsdWUgdG8gc3RyZXRjaCwgd2l0aGluIFswLDFdXG4gKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgMDogbm8gc3RyZXRjaGluZy4gMTogcGVyZmVjdCBjaXJjbGUgc2VjdGlvblxuICogQHJldHVybnMge251bWJlcn0gVGhlIHN0cmV0Y2hlZCB2YWx1ZSwgd2l0aGluIFswLDFdXG4gKi9cbmV4cG9ydCBjb25zdCBzQ2lyY2xlSGlnaCA9ICh0LCBhbHBoYSA9IDAuOCkgPT4gMSAtIHNDaXJjbGVMb3coMSAtIHQsIGFscGhhKVxuXG4vKipcbiAqIEludmVyc2UgZnVuY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBJbnZlcnNlIGZ1bmN0aW9uIG9mIHNFeHBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHNFeHBJbnZlcnNlID0gKHksIGJhc2UgPSAzKSA9PlxuICAgIGJhc2UgPT0gMCA/IHkgOiAoMSAvIGJhc2UpICogTWF0aC5sb2coMSAtIHkgKyB5ICogTWF0aC5leHAoYmFzZSkpXG5cbi8qKlxuICogSW52ZXJzZSBmdW5jdGlvbiBvZiBzRXhwUmV2XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBzRXhwUmV2SW52ZXJzZSA9ICh5LCBiYXNlID0gMykgPT4gKE1hdGguZXhwKC1iYXNlICogeSkgLSAxKSAvIChNYXRoLmV4cCgtYmFzZSkgLSAxKVxuXG4vKipcbiAqIEludmVyc2UgZnVuY3Rpb24gb2Ygc1Bvd1xuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuXG5leHBvcnQgY29uc3Qgc1Bvd0ludmVyc2UgPSAoeSwgZXhwb25lbnQgPSAzKSA9PiBNYXRoLnBvdyh5LCAxIC8gZXhwb25lbnQpXG5cblxuXG5cblxuLyoqXG4gKiBJbnZlcnNlIGZ1bmN0aW9uIG9mIHNQb3dSZXZcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBzUG93UmV2SW52ZXJzZSA9ICh5LCBleHBvbmVudCA9IDMpID0+IDEgLSBNYXRoLnBvdygxIC0geSwgZXhwb25lbnQpXG5cbi8vdGVzdCBjb2RlXG4vKlxuZm9yIChsZXQgaSA9IDA7IGkgPD0gMTsgaSArPSAwLjAwMSkge1xuICAvL2NvbnN0IHYgPSBndml6LnNFeHAoZ3Zpei5zRXhwSW52ZXJzZShpKSk7XG4gIC8vY29uc3QgdiA9IGd2aXouc0V4cEludmVyc2UoZ3Zpei5zRXhwKGkpKTtcbiAgLy9jb25zdCB2ID0gZ3Zpei5zRXhwUmV2KGd2aXouc0V4cFJldkludmVyc2UoaSkpO1xuICAvL2NvbnN0IHYgPSBndml6LnNFeHBSZXZJbnZlcnNlKGd2aXouc0V4cFJldihpKSk7XG4gIC8vY29uc3QgdiA9IGd2aXouc1Bvdyhndml6LnNQb3dJbnZlcnNlKGkpKTtcbiAgLy9jb25zdCB2ID0gZ3Zpei5zUG93SW52ZXJzZShndml6LnNQb3coaSkpO1xuICAvL2NvbnN0IHYgPSBndml6LnNQb3dSZXYoZ3Zpei5zUG93UmV2SW52ZXJzZShpKSk7XG4gIC8vY29uc3QgdiA9IGd2aXouc1Bvd1JldkludmVyc2UoZ3Zpei5zUG93UmV2KGkpKTtcbiAgLy9jb25zdCB2ID0gZ3Zpei5zQ2lyY2xlTG93KGd2aXouc0NpcmNsZUhpZ2goaSkpO1xuICAvL2NvbnN0IHYgPSBndml6LnNDaXJjbGVIaWdoKGd2aXouc0NpcmNsZUxvdyhpKSk7XG4gIGNvbnNvbGUubG9nKGkgLSB2KVxufVxuKi9cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gd2lkdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gKiBAcmV0dXJucyB7e2NhbnZhczpIVE1MQ2FudmFzRWxlbWVudCwgZ2w6V2ViR0xSZW5kZXJpbmdDb250ZXh0fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VXZWJHTENhbnZhcyh3aWR0aCwgaGVpZ2h0LCBvcHRzKSB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKVxuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodClcbiAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdHMpXG4gICAgaWYgKCFnbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBpbml0aWFsaXplIFdlYkdMLiBZb3VyIGJyb3dzZXIgb3IgbWFjaGluZSBtYXkgbm90IHN1cHBvcnQgaXQuJylcbiAgICB9XG4gICAgcmV0dXJuIHsgY2FudmFzOiBjYW52YXMsIGdsOiBnbCB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIHNoYWRlciBwcm9ncmFtLCBzbyBXZWJHTCBrbm93cyBob3cgdG8gZHJhdyBvdXIgZGF0YVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICogQHBhcmFtICB7Li4uV2ViR0xTaGFkZXJ9IHNoYWRlcnNcbiAqIEByZXR1cm5zIHtXZWJHTFByb2dyYW19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0U2hhZGVyUHJvZ3JhbShnbCwgLi4uc2hhZGVycykge1xuICAgIC8qKiBAdHlwZSB7V2ViR0xQcm9ncmFtfG51bGx9ICovXG4gICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKVxuICAgIGlmIChwcm9ncmFtID09IG51bGwpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSB3ZWJHTCBwcm9ncmFtJylcbiAgICBmb3IgKGNvbnN0IHNoYWRlciBvZiBzaGFkZXJzKSBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgc2hhZGVyKVxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pXG4gICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSByZXR1cm4gcHJvZ3JhbVxuICAgIHRocm93IG5ldyBFcnJvcihnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSB8fCAnQ2Fubm90IGNyZWF0ZSB3ZWJHTCBwcm9ncmFtICgyKScpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWRlciBvZiB0aGUgZ2l2ZW4gdHlwZSwgdXBsb2FkcyB0aGUgc291cmNlIGFuZCBjb21waWxlcyBpdC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcGFyYW0gIHsuLi5zdHJpbmd9IHNvdXJjZXNcbiAqIEByZXR1cm5zIHtXZWJHTFNoYWRlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNoYWRlcihnbCwgdHlwZSwgLi4uc291cmNlcykge1xuICAgIC8qKiBAdHlwZSB7V2ViR0xTaGFkZXJ8bnVsbH0gKi9cbiAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSlcbiAgICBpZiAoc2hhZGVyID09IG51bGwpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSB3ZWJHTCBzaGFkZXInKVxuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZXMuam9pbignXFxuJykpXG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpXG4gICAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkgcmV0dXJuIHNoYWRlclxuICAgIHRocm93IG5ldyBFcnJvcihnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikgfHwgJ0Nhbm5vdCBjcmVhdGUgd2ViR0wgc2hhZGVyICgyKScpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgd2ViR0wgaXMgc3VwcG9ydGVkXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1dlYkdMU3VwcG9ydCgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICByZXR1cm4gISF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmXG4gICAgICAgICAgICAoY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpKVxuICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICA6IGZhbHNlXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGlzTGlzdExpa2UsIGlzTWFwTGlrZSB9IGZyb20gJy4vc2NoZW1hLmpzJ1xuXG4vKipcbiAqIERyZW1lbC1hc3NlbWJseSBvZiBhcnJheXMgb2YgdmFsdWVzIGludG8gbGlzdHNcbiAqXG4gKiBSZWNvbnN0cnVjdHMgYSBjb21wbGV4IG5lc3RlZCBzdHJ1Y3R1cmUgZnJvbSBmbGF0IGFycmF5cyBvZiBkZWZpbml0aW9uIGFuZCByZXBldGl0aW9uIGxldmVscyxcbiAqIGFjY29yZGluZyB0byBEcmVtZWwgZW5jb2RpbmcuXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcy5kLnRzJykuRGVjb2RlZEFycmF5fSBEZWNvZGVkQXJyYXlcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuZC50cycpLkZpZWxkUmVwZXRpdGlvblR5cGV9IEZpZWxkUmVwZXRpdGlvblR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyW10gfCB1bmRlZmluZWR9IGRlZmluaXRpb25MZXZlbHNcbiAqIEBwYXJhbSB7bnVtYmVyW119IHJlcGV0aXRpb25MZXZlbHNcbiAqIEBwYXJhbSB7RGVjb2RlZEFycmF5fSB2YWx1ZXNcbiAqIEBwYXJhbSB7KEZpZWxkUmVwZXRpdGlvblR5cGUgfCB1bmRlZmluZWQpW119IHJlcGV0aXRpb25QYXRoXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGVmaW5pdGlvbkxldmVsIGRlZmluaXRpb24gbGV2ZWwgdGhhdCBjb3JyZXNwb25kcyB0byBub24tbnVsbFxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJlcGV0aXRpb25MZXZlbCByZXBldGl0aW9uIGxldmVsIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBuZXcgcm93XG4gKiBAcmV0dXJucyB7RGVjb2RlZEFycmF5fSBhcnJheSBvZiB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VtYmxlTGlzdHMoXG4gIGRlZmluaXRpb25MZXZlbHMsIHJlcGV0aXRpb25MZXZlbHMsIHZhbHVlcywgcmVwZXRpdGlvblBhdGgsIG1heERlZmluaXRpb25MZXZlbCwgbWF4UmVwZXRpdGlvbkxldmVsXG4pIHtcbiAgY29uc3QgbiA9IGRlZmluaXRpb25MZXZlbHM/Lmxlbmd0aCB8fCByZXBldGl0aW9uTGV2ZWxzLmxlbmd0aFxuICBsZXQgdmFsdWVJbmRleCA9IDBcbiAgLyoqIEB0eXBlIHthbnlbXX0gKi9cbiAgY29uc3Qgb3V0cHV0ID0gW11cblxuICAvLyBUcmFjayBzdGF0ZSBvZiBuZXN0ZWQgc3RydWN0dXJlc1xuICBjb25zdCBjb250YWluZXJTdGFjayA9IFtvdXRwdXRdXG4gIGxldCBjdXJyZW50Q29udGFpbmVyID0gb3V0cHV0XG4gIGxldCBjdXJyZW50RGVwdGggPSAwIC8vIHNjaGVtYSBkZXB0aFxuICBsZXQgY3VycmVudERlZkxldmVsID0gMCAvLyBsaXN0IGRlcHRoXG4gIGxldCBjdXJyZW50UmVwTGV2ZWwgPSAwXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAvLyBhc3NlcnQoY3VycmVudERlZkxldmVsID09PSBjb250YWluZXJTdGFjay5sZW5ndGggLSAxKVxuICAgIGNvbnN0IGRlZiA9IGRlZmluaXRpb25MZXZlbHM/Lmxlbmd0aCA/IGRlZmluaXRpb25MZXZlbHNbaV0gOiBtYXhEZWZpbml0aW9uTGV2ZWxcbiAgICBjb25zdCByZXAgPSByZXBldGl0aW9uTGV2ZWxzW2ldXG5cbiAgICAvLyBQb3AgdXAgdG8gc3RhcnQgb2YgcmVwIGxldmVsXG4gICAgd2hpbGUgKGN1cnJlbnREZXB0aCAmJiAocmVwIDwgY3VycmVudFJlcExldmVsIHx8IHJlcGV0aXRpb25QYXRoW2N1cnJlbnREZXB0aF0gIT09ICdSRVBFQVRFRCcpKSB7XG4gICAgICBpZiAocmVwZXRpdGlvblBhdGhbY3VycmVudERlcHRoXSAhPT0gJ1JFUVVJUkVEJykge1xuICAgICAgICBjb250YWluZXJTdGFjay5wb3AoKVxuICAgICAgICBjdXJyZW50RGVmTGV2ZWwtLVxuICAgICAgfVxuICAgICAgaWYgKHJlcGV0aXRpb25QYXRoW2N1cnJlbnREZXB0aF0gPT09ICdSRVBFQVRFRCcpIGN1cnJlbnRSZXBMZXZlbC0tXG4gICAgICBjdXJyZW50RGVwdGgtLVxuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHdvbid0IGJlIGVtcHR5XG4gICAgY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lclN0YWNrLmF0KC0xKVxuXG4gICAgLy8gR28gZGVlcGVyIHRvIGVuZCBvZiBkZWZpbml0aW9uIGxldmVsXG4gICAgd2hpbGUgKFxuICAgICAgKGN1cnJlbnREZXB0aCA8IHJlcGV0aXRpb25QYXRoLmxlbmd0aCAtIDIgfHwgcmVwZXRpdGlvblBhdGhbY3VycmVudERlcHRoICsgMV0gPT09ICdSRVBFQVRFRCcpICYmXG4gICAgICAoY3VycmVudERlZkxldmVsIDwgZGVmIHx8IHJlcGV0aXRpb25QYXRoW2N1cnJlbnREZXB0aCArIDFdID09PSAnUkVRVUlSRUQnKVxuICAgICkge1xuICAgICAgY3VycmVudERlcHRoKytcbiAgICAgIGlmIChyZXBldGl0aW9uUGF0aFtjdXJyZW50RGVwdGhdICE9PSAnUkVRVUlSRUQnKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7YW55W119ICovXG4gICAgICAgIGNvbnN0IG5ld0xpc3QgPSBbXVxuICAgICAgICBjdXJyZW50Q29udGFpbmVyLnB1c2gobmV3TGlzdClcbiAgICAgICAgY3VycmVudENvbnRhaW5lciA9IG5ld0xpc3RcbiAgICAgICAgY29udGFpbmVyU3RhY2sucHVzaChuZXdMaXN0KVxuICAgICAgICBjdXJyZW50RGVmTGV2ZWwrK1xuICAgICAgfVxuICAgICAgaWYgKHJlcGV0aXRpb25QYXRoW2N1cnJlbnREZXB0aF0gPT09ICdSRVBFQVRFRCcpIGN1cnJlbnRSZXBMZXZlbCsrXG4gICAgfVxuXG4gICAgLy8gQWRkIHZhbHVlIG9yIG51bGwgYmFzZWQgb24gZGVmaW5pdGlvbiBsZXZlbFxuICAgIGlmIChkZWYgPT09IG1heERlZmluaXRpb25MZXZlbCkge1xuICAgICAgLy8gYXNzZXJ0KGN1cnJlbnREZXB0aCA9PT0gbWF4RGVmaW5pdGlvbkxldmVsIHx8IGN1cnJlbnREZXB0aCA9PT0gcmVwZXRpdGlvblBhdGgubGVuZ3RoIC0gMilcbiAgICAgIGN1cnJlbnRDb250YWluZXIucHVzaCh2YWx1ZXNbdmFsdWVJbmRleCsrXSlcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnREZXB0aCA9PT0gcmVwZXRpdGlvblBhdGgubGVuZ3RoIC0gMikge1xuICAgICAgY3VycmVudENvbnRhaW5lci5wdXNoKG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDb250YWluZXIucHVzaChbXSlcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgZWRnZSBjYXNlcyBmb3IgZW1wdHkgaW5wdXRzIG9yIHNpbmdsZS1sZXZlbCBkYXRhXG4gIGlmIChvdXRwdXQubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwICYmIG1heFJlcGV0aXRpb25MZXZlbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHZhbHVlcyAvLyBmbGF0IGxpc3RcbiAgICB9XG4gICAgLy8gcmV0dXJuIG1heCBkZWZpbml0aW9uIGxldmVsIG9mIG5lc3RlZCBsaXN0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4RGVmaW5pdGlvbkxldmVsOyBpKyspIHtcbiAgICAgIC8qKiBAdHlwZSB7YW55W119ICovXG4gICAgICBjb25zdCBuZXdMaXN0ID0gW11cbiAgICAgIGN1cnJlbnRDb250YWluZXIucHVzaChuZXdMaXN0KVxuICAgICAgY3VycmVudENvbnRhaW5lciA9IG5ld0xpc3RcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbi8qKlxuICogQXNzZW1ibGUgYSBuZXN0ZWQgc3RydWN0dXJlIGZyb20gc3ViY29sdW1uIGRhdGEuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXBhY2hlL3BhcnF1ZXQtZm9ybWF0L2Jsb2IvYXBhY2hlLXBhcnF1ZXQtZm9ybWF0LTIuMTAuMC9Mb2dpY2FsVHlwZXMubWQjbmVzdGVkLXR5cGVzXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcy5kLnRzJykuU2NoZW1hVHJlZX0gU2NoZW1hVHJlZVxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBhbnlbXT59IHN1YmNvbHVtbkRhdGFcbiAqIEBwYXJhbSB7U2NoZW1hVHJlZX0gc2NoZW1hIHRvcC1sZXZlbCBzY2hlbWEgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aF0gZGVwdGggb2YgbmVzdGVkIHN0cnVjdHVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZW1ibGVOZXN0ZWQoc3ViY29sdW1uRGF0YSwgc2NoZW1hLCBkZXB0aCA9IDApIHtcbiAgY29uc3QgcGF0aCA9IHNjaGVtYS5wYXRoLmpvaW4oJy4nKVxuICBjb25zdCBvcHRpb25hbCA9IHNjaGVtYS5lbGVtZW50LnJlcGV0aXRpb25fdHlwZSA9PT0gJ09QVElPTkFMJ1xuICBjb25zdCBuZXh0RGVwdGggPSBvcHRpb25hbCA/IGRlcHRoICsgMSA6IGRlcHRoXG5cbiAgaWYgKGlzTGlzdExpa2Uoc2NoZW1hKSkge1xuICAgIGxldCBzdWJsaXN0ID0gc2NoZW1hLmNoaWxkcmVuWzBdXG4gICAgbGV0IHN1YkRlcHRoID0gbmV4dERlcHRoXG4gICAgaWYgKHN1Ymxpc3QuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICBzdWJsaXN0ID0gc3VibGlzdC5jaGlsZHJlblswXVxuICAgICAgc3ViRGVwdGgrK1xuICAgIH1cbiAgICBhc3NlbWJsZU5lc3RlZChzdWJjb2x1bW5EYXRhLCBzdWJsaXN0LCBzdWJEZXB0aClcblxuICAgIGNvbnN0IHN1YmNvbHVtbiA9IHN1Ymxpc3QucGF0aC5qb2luKCcuJylcbiAgICBjb25zdCB2YWx1ZXMgPSBzdWJjb2x1bW5EYXRhLmdldChzdWJjb2x1bW4pXG4gICAgaWYgKCF2YWx1ZXMpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBsaXN0LWxpa2UgY29sdW1uIG1pc3NpbmcgdmFsdWVzJylcbiAgICBpZiAob3B0aW9uYWwpIGZsYXR0ZW5BdERlcHRoKHZhbHVlcywgZGVwdGgpXG4gICAgc3ViY29sdW1uRGF0YS5zZXQocGF0aCwgdmFsdWVzKVxuICAgIHN1YmNvbHVtbkRhdGEuZGVsZXRlKHN1YmNvbHVtbilcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChpc01hcExpa2Uoc2NoZW1hKSkge1xuICAgIGNvbnN0IG1hcE5hbWUgPSBzY2hlbWEuY2hpbGRyZW5bMF0uZWxlbWVudC5uYW1lXG5cbiAgICAvLyBBc3NlbWJsZSBrZXlzIGFuZCB2YWx1ZXNcbiAgICBhc3NlbWJsZU5lc3RlZChzdWJjb2x1bW5EYXRhLCBzY2hlbWEuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0sIG5leHREZXB0aCArIDEpXG4gICAgYXNzZW1ibGVOZXN0ZWQoc3ViY29sdW1uRGF0YSwgc2NoZW1hLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzFdLCBuZXh0RGVwdGggKyAxKVxuXG4gICAgY29uc3Qga2V5cyA9IHN1YmNvbHVtbkRhdGEuZ2V0KGAke3BhdGh9LiR7bWFwTmFtZX0ua2V5YClcbiAgICBjb25zdCB2YWx1ZXMgPSBzdWJjb2x1bW5EYXRhLmdldChgJHtwYXRofS4ke21hcE5hbWV9LnZhbHVlYClcblxuICAgIGlmICgha2V5cykgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IG1hcC1saWtlIGNvbHVtbiBtaXNzaW5nIGtleXMnKVxuICAgIGlmICghdmFsdWVzKSB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgbWFwLWxpa2UgY29sdW1uIG1pc3NpbmcgdmFsdWVzJylcbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFycXVldCBtYXAtbGlrZSBjb2x1bW4ga2V5L3ZhbHVlIGxlbmd0aCBtaXNtYXRjaCcpXG4gICAgfVxuXG4gICAgY29uc3Qgb3V0ID0gYXNzZW1ibGVNYXBzKGtleXMsIHZhbHVlcywgbmV4dERlcHRoKVxuICAgIGlmIChvcHRpb25hbCkgZmxhdHRlbkF0RGVwdGgob3V0LCBkZXB0aClcblxuICAgIHN1YmNvbHVtbkRhdGEuZGVsZXRlKGAke3BhdGh9LiR7bWFwTmFtZX0ua2V5YClcbiAgICBzdWJjb2x1bW5EYXRhLmRlbGV0ZShgJHtwYXRofS4ke21hcE5hbWV9LnZhbHVlYClcbiAgICBzdWJjb2x1bW5EYXRhLnNldChwYXRoLCBvdXQpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBTdHJ1Y3QtbGlrZSBjb2x1bW5cbiAgaWYgKHNjaGVtYS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAvLyBjb25zdHJ1Y3QgYSBtZXRhIHN0cnVjdCBhbmQgdGhlbiBpbnZlcnRcbiAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovXG4gICAgY29uc3Qgc3RydWN0ID0ge31cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHNjaGVtYS5jaGlsZHJlbikge1xuICAgICAgYXNzZW1ibGVOZXN0ZWQoc3ViY29sdW1uRGF0YSwgY2hpbGQsIG5leHREZXB0aClcbiAgICAgIGNvbnN0IGNoaWxkRGF0YSA9IHN1YmNvbHVtbkRhdGEuZ2V0KGNoaWxkLnBhdGguam9pbignLicpKVxuICAgICAgaWYgKCFjaGlsZERhdGEpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBzdHJ1Y3QtbGlrZSBjb2x1bW4gbWlzc2luZyBjaGlsZCBkYXRhJylcbiAgICAgIHN0cnVjdFtjaGlsZC5lbGVtZW50Lm5hbWVdID0gY2hpbGREYXRhXG4gICAgfVxuICAgIC8vIHJlbW92ZSBjaGlsZHJlblxuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc2NoZW1hLmNoaWxkcmVuKSB7XG4gICAgICBzdWJjb2x1bW5EYXRhLmRlbGV0ZShjaGlsZC5wYXRoLmpvaW4oJy4nKSlcbiAgICB9XG4gICAgLy8gaW52ZXJ0IHN0cnVjdCBieSBkZXB0aFxuICAgIGNvbnN0IGludmVydERlcHRoID0gc2NoZW1hLmVsZW1lbnQucmVwZXRpdGlvbl90eXBlID09PSAnUkVRVUlSRUQnID8gZGVwdGggOiBkZXB0aCArIDFcbiAgICBjb25zdCBpbnZlcnRlZCA9IGludmVydFN0cnVjdChzdHJ1Y3QsIGludmVydERlcHRoKVxuICAgIGlmIChvcHRpb25hbCkgZmxhdHRlbkF0RGVwdGgoaW52ZXJ0ZWQsIGRlcHRoKVxuICAgIHN1YmNvbHVtbkRhdGEuc2V0KHBhdGgsIGludmVydGVkKVxuICB9XG4gIC8vIGFzc2VydChzY2hlbWEuZWxlbWVudC5yZXBldGl0aW9uX3R5cGUgIT09ICdSRVBFQVRFRCcpXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGhcbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkF0RGVwdGgoYXJyLCBkZXB0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkZXB0aCkge1xuICAgICAgZmxhdHRlbkF0RGVwdGgoYXJyW2ldLCBkZXB0aCAtIDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFycltpXSA9IGFycltpXVswXVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55W119IGtleXNcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoXG4gKiBAcmV0dXJucyB7YW55W119XG4gKi9cbmZ1bmN0aW9uIGFzc2VtYmxlTWFwcyhrZXlzLCB2YWx1ZXMsIGRlcHRoKSB7XG4gIGNvbnN0IG91dCA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkZXB0aCkge1xuICAgICAgb3V0LnB1c2goYXNzZW1ibGVNYXBzKGtleXNbaV0sIHZhbHVlc1tpXSwgZGVwdGggLSAxKSkgLy8gZ28gZGVlcGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrZXlzW2ldKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgICAgICAgY29uc3Qgb2JqID0ge31cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV1bal1cbiAgICAgICAgICBvYmpba2V5c1tpXVtqXV0gPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2gob2JqKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0LnB1c2godW5kZWZpbmVkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogSW52ZXJ0IGEgc3RydWN0LWxpa2Ugb2JqZWN0IGJ5IGRlcHRoLlxuICpcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55W10+fSBzdHJ1Y3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aFxuICogQHJldHVybnMge2FueVtdfVxuICovXG5mdW5jdGlvbiBpbnZlcnRTdHJ1Y3Qoc3RydWN0LCBkZXB0aCkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc3RydWN0KVxuICBjb25zdCBsZW5ndGggPSBzdHJ1Y3Rba2V5c1swXV0/Lmxlbmd0aFxuICBjb25zdCBvdXQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqL1xuICAgIGNvbnN0IG9iaiA9IHt9XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgb2JqW2tleV0gPSBzdHJ1Y3Rba2V5XVtpXVxuICAgIH1cbiAgICBpZiAoZGVwdGgpIHtcbiAgICAgIG91dC5wdXNoKGludmVydFN0cnVjdChvYmosIGRlcHRoIC0gMSkpIC8vIGRlZXBlclxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQucHVzaChvYmopXG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsImltcG9ydCB7IGFzc2VtYmxlTGlzdHMgfSBmcm9tICcuL2Fzc2VtYmxlLmpzJ1xuaW1wb3J0IHsgY29udmVydCwgZGVyZWZlcmVuY2VEaWN0aW9uYXJ5IH0gZnJvbSAnLi9jb252ZXJ0LmpzJ1xuaW1wb3J0IHsgcmVhZERhdGFQYWdlLCByZWFkRGljdGlvbmFyeVBhZ2UgfSBmcm9tICcuL2RhdGFwYWdlLmpzJ1xuaW1wb3J0IHsgcmVhZERhdGFQYWdlVjIgfSBmcm9tICcuL2RhdGFwYWdlVjIuanMnXG5pbXBvcnQgeyBwYXJxdWV0SGVhZGVyIH0gZnJvbSAnLi9oZWFkZXIuanMnXG5pbXBvcnQgeyBnZXRNYXhEZWZpbml0aW9uTGV2ZWwsIGdldE1heFJlcGV0aXRpb25MZXZlbCB9IGZyb20gJy4vc2NoZW1hLmpzJ1xuaW1wb3J0IHsgc25hcHB5VW5jb21wcmVzcyB9IGZyb20gJy4vc25hcHB5LmpzJ1xuaW1wb3J0IHsgY29uY2F0IH0gZnJvbSAnLi91dGlscy5qcydcblxuLyoqXG4gKiBQYXJzZSBjb2x1bW4gZGF0YSBmcm9tIGEgYnVmZmVyLlxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5Db2x1bW5NZXRhRGF0YX0gQ29sdW1uTWV0YURhdGFcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5EZWNvZGVkQXJyYXl9IERlY29kZWRBcnJheVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5EYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzLmpzJykuUm93R3JvdXB9IHJvd0dyb3VwIHJvdyBncm91cCBtZXRhZGF0YVxuICogQHBhcmFtIHtDb2x1bW5NZXRhRGF0YX0gY29sdW1uTWV0YWRhdGEgY29sdW1uIG1ldGFkYXRhXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy5qcycpLlNjaGVtYVRyZWVbXX0gc2NoZW1hUGF0aCBzY2hlbWEgcGF0aCBmb3IgdGhlIGNvbHVtblxuICogQHBhcmFtIHtpbXBvcnQoJy4vaHlwYXJxdWV0LmpzJykuUGFycXVldFJlYWRPcHRpb25zfSBvcHRpb25zIHJlYWQgb3B0aW9uc1xuICogQHJldHVybnMge2FueVtdfSBhcnJheSBvZiB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRDb2x1bW4ocmVhZGVyLCByb3dHcm91cCwgY29sdW1uTWV0YWRhdGEsIHNjaGVtYVBhdGgsIHsgY29tcHJlc3NvcnMsIHV0ZjggfSkge1xuICBjb25zdCB7IGVsZW1lbnQgfSA9IHNjaGVtYVBhdGhbc2NoZW1hUGF0aC5sZW5ndGggLSAxXVxuICAvKiogQHR5cGUge0RlY29kZWRBcnJheSB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGRpY3Rpb25hcnkgPSB1bmRlZmluZWRcbiAgbGV0IHNlZW4gPSAwXG4gIC8qKiBAdHlwZSB7YW55W119ICovXG4gIGNvbnN0IHJvd0RhdGEgPSBbXVxuXG4gIHdoaWxlIChzZWVuIDwgcm93R3JvdXAubnVtX3Jvd3MpIHtcbiAgICAvLyBwYXJzZSBjb2x1bW4gaGVhZGVyXG4gICAgY29uc3QgaGVhZGVyID0gcGFycXVldEhlYWRlcihyZWFkZXIpXG4gICAgLy8gYXNzZXJ0KGhlYWRlci5jb21wcmVzc2VkX3BhZ2Vfc2l6ZSAhPT0gdW5kZWZpbmVkKVxuXG4gICAgLy8gcmVhZCBjb21wcmVzc2VkX3BhZ2Vfc2l6ZSBieXRlcyBzdGFydGluZyBhdCBvZmZzZXRcbiAgICBjb25zdCBjb21wcmVzc2VkQnl0ZXMgPSBuZXcgVWludDhBcnJheShcbiAgICAgIHJlYWRlci52aWV3LmJ1ZmZlciwgcmVhZGVyLnZpZXcuYnl0ZU9mZnNldCArIHJlYWRlci5vZmZzZXQsIGhlYWRlci5jb21wcmVzc2VkX3BhZ2Vfc2l6ZVxuICAgIClcblxuICAgIC8vIHBhcnNlIHBhZ2UgZGF0YSBieSB0eXBlXG4gICAgLyoqIEB0eXBlIHtEZWNvZGVkQXJyYXl9ICovXG4gICAgbGV0IHZhbHVlc1xuICAgIGlmIChoZWFkZXIudHlwZSA9PT0gJ0RBVEFfUEFHRScpIHtcbiAgICAgIGNvbnN0IGRhcGggPSBoZWFkZXIuZGF0YV9wYWdlX2hlYWRlclxuICAgICAgaWYgKCFkYXBoKSB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgZGF0YSBwYWdlIGhlYWRlciBpcyB1bmRlZmluZWQnKVxuXG4gICAgICBjb25zdCBwYWdlID0gZGVjb21wcmVzc1BhZ2UoY29tcHJlc3NlZEJ5dGVzLCBOdW1iZXIoaGVhZGVyLnVuY29tcHJlc3NlZF9wYWdlX3NpemUpLCBjb2x1bW5NZXRhZGF0YS5jb2RlYywgY29tcHJlc3NvcnMpXG4gICAgICBjb25zdCB7IGRlZmluaXRpb25MZXZlbHMsIHJlcGV0aXRpb25MZXZlbHMsIGRhdGFQYWdlIH0gPSByZWFkRGF0YVBhZ2UocGFnZSwgZGFwaCwgc2NoZW1hUGF0aCwgY29sdW1uTWV0YWRhdGEpXG4gICAgICBzZWVuICs9IGRhcGgubnVtX3ZhbHVlc1xuICAgICAgLy8gYXNzZXJ0KCFkYXBoLnN0YXRpc3RpY3MgfHwgZGFwaC5zdGF0aXN0aWNzLm51bGxfY291bnQgPT09IEJpZ0ludChkYXBoLm51bV92YWx1ZXMgLSBkYXRhUGFnZS5sZW5ndGgpKVxuXG4gICAgICAvLyBjb25zdHJ1Y3Qgb3V0cHV0IHZhbHVlczogc2tpcCBudWxscyBhbmQgY29uc3RydWN0IGxpc3RzXG4gICAgICB2YWx1ZXMgPSBkZXJlZmVyZW5jZURpY3Rpb25hcnkoZGljdGlvbmFyeSwgZGF0YVBhZ2UpXG4gICAgICB2YWx1ZXMgPSBjb252ZXJ0KHZhbHVlcywgZWxlbWVudCwgdXRmOClcbiAgICAgIGlmIChyZXBldGl0aW9uTGV2ZWxzLmxlbmd0aCB8fCBkZWZpbml0aW9uTGV2ZWxzPy5sZW5ndGgpIHtcbiAgICAgICAgLy8gVXNlIHJlcGV0aXRpb24gbGV2ZWxzIHRvIGNvbnN0cnVjdCBsaXN0c1xuICAgICAgICBjb25zdCBtYXhEZWZpbml0aW9uTGV2ZWwgPSBnZXRNYXhEZWZpbml0aW9uTGV2ZWwoc2NoZW1hUGF0aClcbiAgICAgICAgY29uc3QgbWF4UmVwZXRpdGlvbkxldmVsID0gZ2V0TWF4UmVwZXRpdGlvbkxldmVsKHNjaGVtYVBhdGgpXG4gICAgICAgIGNvbnN0IHJlcGV0aXRpb25QYXRoID0gc2NoZW1hUGF0aC5tYXAoKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnJlcGV0aXRpb25fdHlwZSlcbiAgICAgICAgdmFsdWVzID0gYXNzZW1ibGVMaXN0cyhcbiAgICAgICAgICBkZWZpbml0aW9uTGV2ZWxzLCByZXBldGl0aW9uTGV2ZWxzLCB2YWx1ZXMsIHJlcGV0aXRpb25QYXRoLCBtYXhEZWZpbml0aW9uTGV2ZWwsIG1heFJlcGV0aXRpb25MZXZlbFxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3cmFwIG5lc3RlZCBmbGF0IGRhdGEgYnkgZGVwdGhcbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBzY2hlbWFQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNjaGVtYVBhdGhbaV0uZWxlbWVudC5yZXBldGl0aW9uX3R5cGUgIT09ICdSRVFVSVJFRCcpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IEFycmF5LmZyb20odmFsdWVzLCBlID0+IFtlXSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFzc2VydChCaWdJbnQodmFsdWVzLmxlbmd0aCkgPT09IHJvd0dyb3VwLm51bV9yb3dzKVxuICAgICAgY29uY2F0KHJvd0RhdGEsIHZhbHVlcylcbiAgICB9IGVsc2UgaWYgKGhlYWRlci50eXBlID09PSAnREFUQV9QQUdFX1YyJykge1xuICAgICAgY29uc3QgZGFwaDIgPSBoZWFkZXIuZGF0YV9wYWdlX2hlYWRlcl92MlxuICAgICAgaWYgKCFkYXBoMikgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGRhdGEgcGFnZSBoZWFkZXIgdjIgaXMgdW5kZWZpbmVkJylcblxuICAgICAgY29uc3QgeyBkZWZpbml0aW9uTGV2ZWxzLCByZXBldGl0aW9uTGV2ZWxzLCBkYXRhUGFnZSB9ID0gcmVhZERhdGFQYWdlVjIoXG4gICAgICAgIGNvbXByZXNzZWRCeXRlcywgaGVhZGVyLCBzY2hlbWFQYXRoLCBjb2x1bW5NZXRhZGF0YSwgY29tcHJlc3NvcnNcbiAgICAgIClcbiAgICAgIHNlZW4gKz0gZGFwaDIubnVtX3ZhbHVlc1xuXG4gICAgICB2YWx1ZXMgPSBkZXJlZmVyZW5jZURpY3Rpb25hcnkoZGljdGlvbmFyeSwgZGF0YVBhZ2UpXG4gICAgICB2YWx1ZXMgPSBjb252ZXJ0KHZhbHVlcywgZWxlbWVudCwgdXRmOClcbiAgICAgIGlmIChyZXBldGl0aW9uTGV2ZWxzLmxlbmd0aCB8fCBkZWZpbml0aW9uTGV2ZWxzPy5sZW5ndGgpIHtcbiAgICAgICAgLy8gVXNlIHJlcGV0aXRpb24gbGV2ZWxzIHRvIGNvbnN0cnVjdCBsaXN0c1xuICAgICAgICBjb25zdCBtYXhEZWZpbml0aW9uTGV2ZWwgPSBnZXRNYXhEZWZpbml0aW9uTGV2ZWwoc2NoZW1hUGF0aClcbiAgICAgICAgY29uc3QgbWF4UmVwZXRpdGlvbkxldmVsID0gZ2V0TWF4UmVwZXRpdGlvbkxldmVsKHNjaGVtYVBhdGgpXG4gICAgICAgIGNvbnN0IHJlcGV0aXRpb25QYXRoID0gc2NoZW1hUGF0aC5tYXAoKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnJlcGV0aXRpb25fdHlwZSlcbiAgICAgICAgdmFsdWVzID0gYXNzZW1ibGVMaXN0cyhcbiAgICAgICAgICBkZWZpbml0aW9uTGV2ZWxzLCByZXBldGl0aW9uTGV2ZWxzLCB2YWx1ZXMsIHJlcGV0aXRpb25QYXRoLCBtYXhEZWZpbml0aW9uTGV2ZWwsIG1heFJlcGV0aXRpb25MZXZlbFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBjb25jYXQocm93RGF0YSwgdmFsdWVzKVxuICAgIH0gZWxzZSBpZiAoaGVhZGVyLnR5cGUgPT09ICdESUNUSU9OQVJZX1BBR0UnKSB7XG4gICAgICBjb25zdCBkaXBoID0gaGVhZGVyLmRpY3Rpb25hcnlfcGFnZV9oZWFkZXJcbiAgICAgIGlmICghZGlwaCkgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGRpY3Rpb25hcnkgcGFnZSBoZWFkZXIgaXMgdW5kZWZpbmVkJylcblxuICAgICAgY29uc3QgcGFnZSA9IGRlY29tcHJlc3NQYWdlKFxuICAgICAgICBjb21wcmVzc2VkQnl0ZXMsIE51bWJlcihoZWFkZXIudW5jb21wcmVzc2VkX3BhZ2Vfc2l6ZSksIGNvbHVtbk1ldGFkYXRhLmNvZGVjLCBjb21wcmVzc29yc1xuICAgICAgKVxuICAgICAgZGljdGlvbmFyeSA9IHJlYWREaWN0aW9uYXJ5UGFnZShwYWdlLCBkaXBoLCBjb2x1bW5NZXRhZGF0YSwgZWxlbWVudC50eXBlX2xlbmd0aClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJxdWV0IHVuc3VwcG9ydGVkIHBhZ2UgdHlwZTogJHtoZWFkZXIudHlwZX1gKVxuICAgIH1cbiAgICByZWFkZXIub2Zmc2V0ICs9IGhlYWRlci5jb21wcmVzc2VkX3BhZ2Vfc2l6ZVxuICB9XG4gIGlmIChyb3dEYXRhLmxlbmd0aCAhPT0gTnVtYmVyKHJvd0dyb3VwLm51bV9yb3dzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFycXVldCByb3cgZGF0YSBsZW5ndGggJHtyb3dEYXRhLmxlbmd0aH0gZG9lcyBub3QgbWF0Y2ggcm93IGdyb3VwIGxlbmd0aCAke3Jvd0dyb3VwLm51bV9yb3dzfX1gKVxuICB9XG4gIHJldHVybiByb3dEYXRhXG59XG5cbi8qKlxuICogRmluZCB0aGUgc3RhcnQgYnl0ZSBvZmZzZXQgZm9yIGEgY29sdW1uIGNodW5rLlxuICpcbiAqIEBwYXJhbSB7Q29sdW1uTWV0YURhdGF9IGNvbHVtbk1ldGFkYXRhXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBieXRlIG9mZnNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sdW1uT2Zmc2V0KHsgZGljdGlvbmFyeV9wYWdlX29mZnNldCwgZGF0YV9wYWdlX29mZnNldCB9KSB7XG4gIGxldCBjb2x1bW5PZmZzZXQgPSBkaWN0aW9uYXJ5X3BhZ2Vfb2Zmc2V0XG4gIGlmICghZGljdGlvbmFyeV9wYWdlX29mZnNldCB8fCBkYXRhX3BhZ2Vfb2Zmc2V0IDwgZGljdGlvbmFyeV9wYWdlX29mZnNldCkge1xuICAgIGNvbHVtbk9mZnNldCA9IGRhdGFfcGFnZV9vZmZzZXRcbiAgfVxuICByZXR1cm4gTnVtYmVyKGNvbHVtbk9mZnNldClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbXByZXNzZWRCeXRlc1xuICogQHBhcmFtIHtudW1iZXJ9IHVuY29tcHJlc3NlZF9wYWdlX3NpemVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzLmpzJykuQ29tcHJlc3Npb25Db2RlY30gY29kZWNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzLmpzJykuQ29tcHJlc3NvcnMgfCB1bmRlZmluZWR9IGNvbXByZXNzb3JzXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcHJlc3NQYWdlKGNvbXByZXNzZWRCeXRlcywgdW5jb21wcmVzc2VkX3BhZ2Vfc2l6ZSwgY29kZWMsIGNvbXByZXNzb3JzKSB7XG4gIC8qKiBAdHlwZSB7VWludDhBcnJheX0gKi9cbiAgbGV0IHBhZ2VcbiAgY29uc3QgY3VzdG9tRGVjb21wcmVzc29yID0gY29tcHJlc3NvcnM/Lltjb2RlY11cbiAgaWYgKGNvZGVjID09PSAnVU5DT01QUkVTU0VEJykge1xuICAgIHBhZ2UgPSBjb21wcmVzc2VkQnl0ZXNcbiAgfSBlbHNlIGlmIChjdXN0b21EZWNvbXByZXNzb3IpIHtcbiAgICBwYWdlID0gY3VzdG9tRGVjb21wcmVzc29yKGNvbXByZXNzZWRCeXRlcywgdW5jb21wcmVzc2VkX3BhZ2Vfc2l6ZSlcbiAgfSBlbHNlIGlmIChjb2RlYyA9PT0gJ1NOQVBQWScpIHtcbiAgICBwYWdlID0gbmV3IFVpbnQ4QXJyYXkodW5jb21wcmVzc2VkX3BhZ2Vfc2l6ZSlcbiAgICBzbmFwcHlVbmNvbXByZXNzKGNvbXByZXNzZWRCeXRlcywgcGFnZSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnF1ZXQgdW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gY29kZWM6ICR7Y29kZWN9YClcbiAgfVxuICBpZiAocGFnZT8ubGVuZ3RoICE9PSB1bmNvbXByZXNzZWRfcGFnZV9zaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYXJxdWV0IGRlY29tcHJlc3NlZCBwYWdlIGxlbmd0aCAke3BhZ2U/Lmxlbmd0aH0gZG9lcyBub3QgbWF0Y2ggaGVhZGVyICR7dW5jb21wcmVzc2VkX3BhZ2Vfc2l6ZX1gKVxuICB9XG4gIHJldHVybiBwYWdlXG59XG4iLCIvKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5QYXJxdWV0VHlwZVtdfVxuICovXG5leHBvcnQgY29uc3QgUGFycXVldFR5cGUgPSBbXG4gICdCT09MRUFOJyxcbiAgJ0lOVDMyJyxcbiAgJ0lOVDY0JyxcbiAgJ0lOVDk2JywgLy8gZGVwcmVjYXRlZFxuICAnRkxPQVQnLFxuICAnRE9VQkxFJyxcbiAgJ0JZVEVfQVJSQVknLFxuICAnRklYRURfTEVOX0JZVEVfQVJSQVknLFxuXVxuXG5leHBvcnQgY29uc3QgRW5jb2RpbmcgPSBbXG4gICdQTEFJTicsXG4gIHVuZGVmaW5lZCxcbiAgJ1BMQUlOX0RJQ1RJT05BUlknLFxuICAnUkxFJyxcbiAgJ0JJVF9QQUNLRUQnLCAvLyBkZXByZWNhdGVkXG4gICdERUxUQV9CSU5BUllfUEFDS0VEJyxcbiAgJ0RFTFRBX0xFTkdUSF9CWVRFX0FSUkFZJyxcbiAgJ0RFTFRBX0JZVEVfQVJSQVknLFxuICAnUkxFX0RJQ1RJT05BUlknLFxuICAnQllURV9TVFJFQU1fU1BMSVQnLFxuXVxuXG5leHBvcnQgY29uc3QgRmllbGRSZXBldGl0aW9uVHlwZSA9IFtcbiAgJ1JFUVVJUkVEJyxcbiAgJ09QVElPTkFMJyxcbiAgJ1JFUEVBVEVEJyxcbl1cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzLmpzJykuQ29udmVydGVkVHlwZVtdfVxuICovXG5leHBvcnQgY29uc3QgQ29udmVydGVkVHlwZSA9IFtcbiAgJ1VURjgnLFxuICAnTUFQJyxcbiAgJ01BUF9LRVlfVkFMVUUnLFxuICAnTElTVCcsXG4gICdFTlVNJyxcbiAgJ0RFQ0lNQUwnLFxuICAnREFURScsXG4gICdUSU1FX01JTExJUycsXG4gICdUSU1FX01JQ1JPUycsXG4gICdUSU1FU1RBTVBfTUlMTElTJyxcbiAgJ1RJTUVTVEFNUF9NSUNST1MnLFxuICAnVUlOVF84JyxcbiAgJ1VJTlRfMTYnLFxuICAnVUlOVF8zMicsXG4gICdVSU5UXzY0JyxcbiAgJ0lOVF84JyxcbiAgJ0lOVF8xNicsXG4gICdJTlRfMzInLFxuICAnSU5UXzY0JyxcbiAgJ0pTT04nLFxuICAnQlNPTicsXG4gICdJTlRFUlZBTCcsXG5dXG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi90eXBlcy5qcycpLkxvZ2ljYWxUeXBlVHlwZVtdfVxuICovXG5leHBvcnQgY29uc3QgbG9naWNhbFR5cGVUeXBlID0gW1xuICAnTlVMTCcsXG4gICdTVFJJTkcnLFxuICAnTUFQJyxcbiAgJ0xJU1QnLFxuICAnRU5VTScsXG4gICdERUNJTUFMJyxcbiAgJ0RBVEUnLFxuICAnVElNRScsXG4gICdUSU1FU1RBTVAnLFxuICAnSU5URVJWQUwnLFxuICAnSU5URUdFUicsXG4gICdOVUxMJyxcbiAgJ0pTT04nLFxuICAnQlNPTicsXG4gICdVVUlEJyxcbl1cblxuZXhwb3J0IGNvbnN0IENvbXByZXNzaW9uQ29kZWMgPSBbXG4gICdVTkNPTVBSRVNTRUQnLFxuICAnU05BUFBZJyxcbiAgJ0daSVAnLFxuICAnTFpPJyxcbiAgJ0JST1RMSScsXG4gICdMWjQnLFxuICAnWlNURCcsXG4gICdMWjRfUkFXJyxcbl1cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzLmpzJykuUGFnZVR5cGVbXX1cbiAqL1xuZXhwb3J0IGNvbnN0IFBhZ2VUeXBlID0gW1xuICAnREFUQV9QQUdFJyxcbiAgJ0lOREVYX1BBR0UnLFxuICAnRElDVElPTkFSWV9QQUdFJyxcbiAgJ0RBVEFfUEFHRV9WMicsXG5dXG4iLCJjb25zdCBkYXlNaWxsaXMgPSA4NjQwMDAwMCAvLyAxIGRheSBpbiBtaWxsaXNlY29uZHNcblxuLyoqXG4gKiBDb252ZXJ0IGtub3duIHR5cGVzIGZyb20gcHJpbWl0aXZlIHRvIHJpY2guXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcy5qcycpLkRlY29kZWRBcnJheX0gRGVjb2RlZEFycmF5XG4gKiBAcGFyYW0ge0RlY29kZWRBcnJheX0gZGF0YSBzZXJpZXMgb2YgcHJpbWl0aXZlIHR5cGVzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy5qcycpLlNjaGVtYUVsZW1lbnR9IHNjaGVtYUVsZW1lbnQgc2NoZW1hIGVsZW1lbnQgZm9yIHRoZSBkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCB1bmRlZmluZWR9IHV0ZjggZGVjb2RlIGJ5dGVzIGFzIHV0Zjg/XG4gKiBAcmV0dXJucyB7RGVjb2RlZEFycmF5fSBzZXJpZXMgb2YgcmljaCB0eXBlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydChkYXRhLCBzY2hlbWFFbGVtZW50LCB1dGY4ID0gdHJ1ZSkge1xuICBjb25zdCBjdHlwZSA9IHNjaGVtYUVsZW1lbnQuY29udmVydGVkX3R5cGVcbiAgaWYgKGN0eXBlID09PSAnREVDSU1BTCcpIHtcbiAgICBjb25zdCBzY2FsZSA9IHNjaGVtYUVsZW1lbnQuc2NhbGUgfHwgMFxuICAgIGNvbnN0IGZhY3RvciA9IE1hdGgucG93KDEwLCAtc2NhbGUpXG4gICAgY29uc3QgYXJyID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZGF0YVswXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgYXJyW2ldID0gcGFyc2VEZWNpbWFsKGRhdGFbaV0pICogZmFjdG9yXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJbaV0gPSBOdW1iZXIoZGF0YVtpXSkgKiBmYWN0b3JcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyclxuICB9XG4gIGlmIChjdHlwZSA9PT0gdW5kZWZpbmVkICYmIHNjaGVtYUVsZW1lbnQudHlwZSA9PT0gJ0lOVDk2Jykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGRhdGEpLm1hcChwYXJzZUludDk2RGF0ZSlcbiAgfVxuICBpZiAoY3R5cGUgPT09ICdEQVRFJykge1xuICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShkYXRhLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyW2ldID0gbmV3IERhdGUoZGF0YVtpXSAqIGRheU1pbGxpcylcbiAgICB9XG4gICAgcmV0dXJuIGFyclxuICB9XG4gIGlmIChjdHlwZSA9PT0gJ1RJTUVTVEFNUF9NSUxMSVMnKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJbaV0gPSBuZXcgRGF0ZShOdW1iZXIoZGF0YVtpXSkpXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuICBpZiAoY3R5cGUgPT09ICdUSU1FU1RBTVBfTUlDUk9TJykge1xuICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShkYXRhLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyW2ldID0gbmV3IERhdGUoTnVtYmVyKGRhdGFbaV0gLyAxMDAwbikpXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuICBpZiAoY3R5cGUgPT09ICdKU09OJykge1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICAgIHJldHVybiBkYXRhLm1hcCh2ID0+IEpTT04ucGFyc2UoZGVjb2Rlci5kZWNvZGUodikpKVxuICB9XG4gIGlmIChjdHlwZSA9PT0gJ0JTT04nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGJzb24gbm90IHN1cHBvcnRlZCcpXG4gIH1cbiAgaWYgKGN0eXBlID09PSAnSU5URVJWQUwnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGludGVydmFsIG5vdCBzdXBwb3J0ZWQnKVxuICB9XG4gIGlmIChjdHlwZSA9PT0gJ1VURjgnIHx8IHV0ZjggJiYgc2NoZW1hRWxlbWVudC50eXBlID09PSAnQllURV9BUlJBWScpIHtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycltpXSA9IGRhdGFbaV0gJiYgZGVjb2Rlci5kZWNvZGUoZGF0YVtpXSlcbiAgICB9XG4gICAgcmV0dXJuIGFyclxuICB9XG4gIGlmIChjdHlwZSA9PT0gJ1VJTlRfNjQnKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IEJpZ1VpbnQ2NEFycmF5KGRhdGEubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJbaV0gPSBCaWdJbnQoZGF0YVtpXSlcbiAgICB9XG4gICAgcmV0dXJuIGFyclxuICB9XG4gIGNvbnN0IGxvZ2ljYWxUeXBlID0gc2NoZW1hRWxlbWVudC5sb2dpY2FsX3R5cGU/LnR5cGVcbiAgaWYgKGxvZ2ljYWxUeXBlID09PSAnRkxPQVQxNicpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShkYXRhKS5tYXAocGFyc2VGbG9hdDE2KVxuICB9XG4gIGlmIChsb2dpY2FsVHlwZSA9PT0gJ1RJTUVTVEFNUCcpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycltpXSA9IG5ldyBEYXRlKE51bWJlcihkYXRhW2ldKSlcbiAgICB9XG4gICAgcmV0dXJuIGFyclxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcGFyc2VEZWNpbWFsKGJ5dGVzKSB7XG4gIC8vIFRPRE86IGhhbmRsZSBzaWduZWRcbiAgbGV0IHZhbHVlID0gMFxuICBmb3IgKGNvbnN0IGJ5dGUgb2YgYnl0ZXMpIHtcbiAgICB2YWx1ZSA9IHZhbHVlIDw8IDggfCBieXRlXG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtiaWdpbnR9IHZhbHVlXG4gKiBAcmV0dXJucyB7RGF0ZX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VJbnQ5NkRhdGUodmFsdWUpIHtcbiAgY29uc3QgZGF5cyA9IE51bWJlcigodmFsdWUgPj4gNjRuKSAtIDI0NDA1ODhuKVxuICBjb25zdCBuYW5vID0gTnVtYmVyKCh2YWx1ZSAmIDB4ZmZmZmZmZmZmZmZmZmZmZm4pIC8gMTAwMDAwMG4pXG4gIGNvbnN0IG1pbGxpcyA9IGRheXMgKiBkYXlNaWxsaXMgKyBuYW5vXG4gIHJldHVybiBuZXcgRGF0ZShtaWxsaXMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5IHwgdW5kZWZpbmVkfSBieXRlc1xuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmxvYXQxNihieXRlcykge1xuICBpZiAoIWJ5dGVzKSByZXR1cm4gdW5kZWZpbmVkXG4gIGNvbnN0IGludDE2ID0gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdXG4gIGNvbnN0IHNpZ24gPSBpbnQxNiA+PiAxNSA/IC0xIDogMVxuICBjb25zdCBleHAgPSBpbnQxNiA+PiAxMCAmIDB4MWZcbiAgY29uc3QgZnJhYyA9IGludDE2ICYgMHgzZmZcbiAgaWYgKGV4cCA9PT0gMCkgcmV0dXJuIHNpZ24gKiBNYXRoLnBvdygyLCAtMTQpICogKGZyYWMgLyAxMDI0KSAvLyBzdWJub3JtYWxzXG4gIGlmIChleHAgPT09IDB4MWYpIHJldHVybiBmcmFjID8gTmFOIDogc2lnbiAqIEluZmluaXR5XG4gIHJldHVybiBzaWduICogTWF0aC5wb3coMiwgZXhwIC0gMTUpICogKDEgKyBmcmFjIC8gMTAyNClcbn1cblxuLyoqXG4gKiBNYXAgZGF0YSB0byBkaWN0aW9uYXJ5IHZhbHVlcyBpbiBwbGFjZS5cbiAqXG4gKiBAcGFyYW0ge0RlY29kZWRBcnJheSB8IHVuZGVmaW5lZH0gZGljdGlvbmFyeVxuICogQHBhcmFtIHtEZWNvZGVkQXJyYXl9IGRhdGFQYWdlXG4gKiBAcmV0dXJucyB7RGVjb2RlZEFycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVyZWZlcmVuY2VEaWN0aW9uYXJ5KGRpY3Rpb25hcnksIGRhdGFQYWdlKSB7XG4gIGxldCBvdXRwdXQgPSBkYXRhUGFnZVxuICBpZiAoZGljdGlvbmFyeSkge1xuICAgIGlmIChkYXRhUGFnZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgIShkaWN0aW9uYXJ5IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIC8vIHVwZ3JhZGUgZGF0YVBhZ2UgdG8gbWF0Y2ggZGljdGlvbmFyeSB0eXBlXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG5vdCBteSBmYXVsdCB0eXBlc2NyaXB0IGRvZXNuJ3QgdW5kZXJzdGFuZCBjb25zdHJ1Y3RvcnNcbiAgICAgIG91dHB1dCA9IG5ldyBkaWN0aW9uYXJ5LmNvbnN0cnVjdG9yKGRhdGFQYWdlLmxlbmd0aClcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhUGFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0W2ldID0gZGljdGlvbmFyeVtkYXRhUGFnZVtpXV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwiaW1wb3J0IHsgYml0V2lkdGgsIGJ5dGVTdHJlYW1TcGxpdCwgcmVhZFJsZUJpdFBhY2tlZEh5YnJpZCB9IGZyb20gJy4vZW5jb2RpbmcuanMnXG5pbXBvcnQgeyByZWFkUGxhaW4gfSBmcm9tICcuL3BsYWluLmpzJ1xuaW1wb3J0IHsgZ2V0TWF4RGVmaW5pdGlvbkxldmVsLCBnZXRNYXhSZXBldGl0aW9uTGV2ZWwgfSBmcm9tICcuL3NjaGVtYS5qcydcblxuLyoqXG4gKiBSZWFkIGEgZGF0YSBwYWdlIGZyb20gdW5jb21wcmVzc2VkIHJlYWRlci5cbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkRhdGFQYWdlfSBEYXRhUGFnZVxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5Db2x1bW5NZXRhRGF0YX0gQ29sdW1uTWV0YURhdGFcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuRGF0YVBhZ2VIZWFkZXJ9IERhdGFQYWdlSGVhZGVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLlNjaGVtYVRyZWV9IFNjaGVtYVRyZWVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuRGVjb2RlZEFycmF5fSBEZWNvZGVkQXJyYXlcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXMgcmF3IHBhZ2UgZGF0YSAoc2hvdWxkIGFscmVhZHkgYmUgZGVjb21wcmVzc2VkKVxuICogQHBhcmFtIHtEYXRhUGFnZUhlYWRlcn0gZGFwaCBkYXRhIHBhZ2UgaGVhZGVyXG4gKiBAcGFyYW0ge1NjaGVtYVRyZWVbXX0gc2NoZW1hUGF0aFxuICogQHBhcmFtIHtDb2x1bW5NZXRhRGF0YX0gY29sdW1uTWV0YWRhdGFcbiAqIEByZXR1cm5zIHtEYXRhUGFnZX0gZGVmaW5pdGlvbiBsZXZlbHMsIHJlcGV0aXRpb24gbGV2ZWxzLCBhbmQgYXJyYXkgb2YgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkRGF0YVBhZ2UoYnl0ZXMsIGRhcGgsIHNjaGVtYVBhdGgsIHsgdHlwZSB9KSB7XG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKVxuICBjb25zdCByZWFkZXIgPSB7IHZpZXcsIG9mZnNldDogMCB9XG4gIC8qKiBAdHlwZSB7RGVjb2RlZEFycmF5fSAqL1xuICBsZXQgZGF0YVBhZ2VcblxuICAvLyByZXBldGl0aW9uIGFuZCBkZWZpbml0aW9uIGxldmVsc1xuICBjb25zdCByZXBldGl0aW9uTGV2ZWxzID0gcmVhZFJlcGV0aXRpb25MZXZlbHMocmVhZGVyLCBkYXBoLCBzY2hlbWFQYXRoKVxuICBjb25zdCB7IGRlZmluaXRpb25MZXZlbHMsIG51bU51bGxzIH0gPSByZWFkRGVmaW5pdGlvbkxldmVscyhyZWFkZXIsIGRhcGgsIHNjaGVtYVBhdGgpXG5cbiAgLy8gcmVhZCB2YWx1ZXMgYmFzZWQgb24gZW5jb2RpbmdcbiAgY29uc3QgblZhbHVlcyA9IGRhcGgubnVtX3ZhbHVlcyAtIG51bU51bGxzXG4gIGlmIChkYXBoLmVuY29kaW5nID09PSAnUExBSU4nKSB7XG4gICAgY29uc3QgeyB0eXBlX2xlbmd0aCB9ID0gc2NoZW1hUGF0aFtzY2hlbWFQYXRoLmxlbmd0aCAtIDFdLmVsZW1lbnRcbiAgICBkYXRhUGFnZSA9IHJlYWRQbGFpbihyZWFkZXIsIHR5cGUsIG5WYWx1ZXMsIHR5cGVfbGVuZ3RoKVxuICB9IGVsc2UgaWYgKFxuICAgIGRhcGguZW5jb2RpbmcgPT09ICdQTEFJTl9ESUNUSU9OQVJZJyB8fFxuICAgIGRhcGguZW5jb2RpbmcgPT09ICdSTEVfRElDVElPTkFSWScgfHxcbiAgICBkYXBoLmVuY29kaW5nID09PSAnUkxFJ1xuICApIHtcbiAgICBjb25zdCBiaXRXaWR0aCA9IHR5cGUgPT09ICdCT09MRUFOJyA/IDEgOiB2aWV3LmdldFVpbnQ4KHJlYWRlci5vZmZzZXQrKylcbiAgICBpZiAoYml0V2lkdGgpIHtcbiAgICAgIGRhdGFQYWdlID0gbmV3IEFycmF5KG5WYWx1ZXMpXG4gICAgICByZWFkUmxlQml0UGFja2VkSHlicmlkKHJlYWRlciwgYml0V2lkdGgsIHZpZXcuYnl0ZUxlbmd0aCAtIHJlYWRlci5vZmZzZXQsIGRhdGFQYWdlKVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhUGFnZSA9IG5ldyBVaW50OEFycmF5KG5WYWx1ZXMpIC8vIG5WYWx1ZSB6ZXJvZXNcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGFwaC5lbmNvZGluZyA9PT0gJ0JZVEVfU1RSRUFNX1NQTElUJykge1xuICAgIGNvbnN0IHsgdHlwZV9sZW5ndGggfSA9IHNjaGVtYVBhdGhbc2NoZW1hUGF0aC5sZW5ndGggLSAxXS5lbGVtZW50XG4gICAgZGF0YVBhZ2UgPSBieXRlU3RyZWFtU3BsaXQocmVhZGVyLCBuVmFsdWVzLCB0eXBlLCB0eXBlX2xlbmd0aClcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnF1ZXQgdW5zdXBwb3J0ZWQgZW5jb2Rpbmc6ICR7ZGFwaC5lbmNvZGluZ31gKVxuICB9XG5cbiAgcmV0dXJuIHsgZGVmaW5pdGlvbkxldmVscywgcmVwZXRpdGlvbkxldmVscywgZGF0YVBhZ2UgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXMgcmF3IHBhZ2UgZGF0YVxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuRGljdGlvbmFyeVBhZ2VIZWFkZXJ9IGRpcGggZGljdGlvbmFyeSBwYWdlIGhlYWRlclxuICogQHBhcmFtIHtDb2x1bW5NZXRhRGF0YX0gY29sdW1uTWV0YWRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSB0eXBlTGVuZ3RoIC0gdHlwZV9sZW5ndGggZnJvbSBzY2hlbWFcbiAqIEByZXR1cm5zIHtEZWNvZGVkQXJyYXl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkRGljdGlvbmFyeVBhZ2UoYnl0ZXMsIGRpcGgsIGNvbHVtbk1ldGFkYXRhLCB0eXBlTGVuZ3RoKSB7XG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKVxuICBjb25zdCByZWFkZXIgPSB7IHZpZXcsIG9mZnNldDogMCB9XG4gIHJldHVybiByZWFkUGxhaW4ocmVhZGVyLCBjb2x1bW5NZXRhZGF0YS50eXBlLCBkaXBoLm51bV92YWx1ZXMsIHR5cGVMZW5ndGgpXG59XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5EYXRhUmVhZGVyfSBEYXRhUmVhZGVyXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciBkYXRhIHZpZXcgZm9yIHRoZSBwYWdlXG4gKiBAcGFyYW0ge0RhdGFQYWdlSGVhZGVyfSBkYXBoIGRhdGEgcGFnZSBoZWFkZXJcbiAqIEBwYXJhbSB7U2NoZW1hVHJlZVtdfSBzY2hlbWFQYXRoXG4gKiBAcmV0dXJucyB7YW55W119IHJlcGV0aXRpb24gbGV2ZWxzIGFuZCBudW1iZXIgb2YgYnl0ZXMgcmVhZFxuICovXG5mdW5jdGlvbiByZWFkUmVwZXRpdGlvbkxldmVscyhyZWFkZXIsIGRhcGgsIHNjaGVtYVBhdGgpIHtcbiAgaWYgKHNjaGVtYVBhdGgubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG1heFJlcGV0aXRpb25MZXZlbCA9IGdldE1heFJlcGV0aXRpb25MZXZlbChzY2hlbWFQYXRoKVxuICAgIGlmIChtYXhSZXBldGl0aW9uTGV2ZWwpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShkYXBoLm51bV92YWx1ZXMpXG4gICAgICByZWFkUmxlQml0UGFja2VkSHlicmlkKHJlYWRlciwgYml0V2lkdGgobWF4UmVwZXRpdGlvbkxldmVsKSwgMCwgdmFsdWVzKVxuICAgICAgcmV0dXJuIHZhbHVlc1xuICAgIH1cbiAgfVxuICByZXR1cm4gW11cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciBkYXRhIHZpZXcgZm9yIHRoZSBwYWdlXG4gKiBAcGFyYW0ge0RhdGFQYWdlSGVhZGVyfSBkYXBoIGRhdGEgcGFnZSBoZWFkZXJcbiAqIEBwYXJhbSB7U2NoZW1hVHJlZVtdfSBzY2hlbWFQYXRoXG4gKiBAcmV0dXJucyB7eyBkZWZpbml0aW9uTGV2ZWxzOiBudW1iZXJbXSwgbnVtTnVsbHM6IG51bWJlciB9fSBkZWZpbml0aW9uIGxldmVsc1xuICovXG5mdW5jdGlvbiByZWFkRGVmaW5pdGlvbkxldmVscyhyZWFkZXIsIGRhcGgsIHNjaGVtYVBhdGgpIHtcbiAgY29uc3QgbWF4RGVmaW5pdGlvbkxldmVsID0gZ2V0TWF4RGVmaW5pdGlvbkxldmVsKHNjaGVtYVBhdGgpXG4gIGlmICghbWF4RGVmaW5pdGlvbkxldmVsKSByZXR1cm4geyBkZWZpbml0aW9uTGV2ZWxzOiBbXSwgbnVtTnVsbHM6IDAgfVxuXG4gIGNvbnN0IGRlZmluaXRpb25MZXZlbHMgPSBuZXcgQXJyYXkoZGFwaC5udW1fdmFsdWVzKVxuICByZWFkUmxlQml0UGFja2VkSHlicmlkKHJlYWRlciwgYml0V2lkdGgobWF4RGVmaW5pdGlvbkxldmVsKSwgMCwgZGVmaW5pdGlvbkxldmVscylcblxuICAvLyBjb3VudCBudWxsc1xuICBsZXQgbnVtTnVsbHMgPSBkYXBoLm51bV92YWx1ZXNcbiAgZm9yIChjb25zdCBkZWYgb2YgZGVmaW5pdGlvbkxldmVscykge1xuICAgIGlmIChkZWYgPT09IG1heERlZmluaXRpb25MZXZlbCkgbnVtTnVsbHMtLVxuICB9XG4gIGlmIChudW1OdWxscyA9PT0gMCkgZGVmaW5pdGlvbkxldmVscy5sZW5ndGggPSAwXG5cbiAgcmV0dXJuIHsgZGVmaW5pdGlvbkxldmVscywgbnVtTnVsbHMgfVxufVxuIiwiaW1wb3J0IHsgZGVjb21wcmVzc1BhZ2UgfSBmcm9tICcuL2NvbHVtbi5qcydcbmltcG9ydCB7IGRlbHRhQmluYXJ5VW5wYWNrLCBkZWx0YUJ5dGVBcnJheSwgZGVsdGFMZW5ndGhCeXRlQXJyYXkgfSBmcm9tICcuL2RlbHRhLmpzJ1xuaW1wb3J0IHsgYml0V2lkdGgsIGJ5dGVTdHJlYW1TcGxpdCwgcmVhZFJsZUJpdFBhY2tlZEh5YnJpZCB9IGZyb20gJy4vZW5jb2RpbmcuanMnXG5pbXBvcnQgeyByZWFkUGxhaW4gfSBmcm9tICcuL3BsYWluLmpzJ1xuaW1wb3J0IHsgZ2V0TWF4RGVmaW5pdGlvbkxldmVsLCBnZXRNYXhSZXBldGl0aW9uTGV2ZWwgfSBmcm9tICcuL3NjaGVtYS5qcydcblxuLyoqXG4gKiBSZWFkIGEgZGF0YSBwYWdlIGZyb20gdGhlIGdpdmVuIFVpbnQ4QXJyYXkuXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5EYXRhUGFnZX0gRGF0YVBhZ2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuQ29sdW1uTWV0YURhdGF9IENvbHVtbk1ldGFEYXRhXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkNvbXByZXNzb3JzfSBDb21wcmVzc29yc1xuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5EYXRhUGFnZUhlYWRlclYyfSBEYXRhUGFnZUhlYWRlclYyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLlNjaGVtYVRyZWV9IFNjaGVtYVRyZWVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gY29tcHJlc3NlZEJ5dGVzIHJhdyBwYWdlIGRhdGFcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLlBhZ2VIZWFkZXJ9IHBoIHBhZ2UgaGVhZGVyXG4gKiBAcGFyYW0ge1NjaGVtYVRyZWVbXX0gc2NoZW1hUGF0aFxuICogQHBhcmFtIHtDb2x1bW5NZXRhRGF0YX0gY29sdW1uTWV0YWRhdGFcbiAqIEBwYXJhbSB7Q29tcHJlc3NvcnMgfCB1bmRlZmluZWR9IGNvbXByZXNzb3JzXG4gKiBAcmV0dXJucyB7RGF0YVBhZ2V9IGRlZmluaXRpb24gbGV2ZWxzLCByZXBldGl0aW9uIGxldmVscywgYW5kIGFycmF5IG9mIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZERhdGFQYWdlVjIoY29tcHJlc3NlZEJ5dGVzLCBwaCwgc2NoZW1hUGF0aCwgY29sdW1uTWV0YWRhdGEsIGNvbXByZXNzb3JzKSB7XG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoY29tcHJlc3NlZEJ5dGVzLmJ1ZmZlciwgY29tcHJlc3NlZEJ5dGVzLmJ5dGVPZmZzZXQsIGNvbXByZXNzZWRCeXRlcy5ieXRlTGVuZ3RoKVxuICBjb25zdCByZWFkZXIgPSB7IHZpZXcsIG9mZnNldDogMCB9XG4gIGNvbnN0IHsgY29kZWMsIHR5cGUgfSA9IGNvbHVtbk1ldGFkYXRhXG4gIGNvbnN0IGRhcGgyID0gcGguZGF0YV9wYWdlX2hlYWRlcl92MlxuICBpZiAoIWRhcGgyKSB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgZGF0YSBwYWdlIGhlYWRlciB2MiBpcyB1bmRlZmluZWQnKVxuXG4gIC8vIHJlcGV0aXRpb24gbGV2ZWxzXG4gIGNvbnN0IHJlcGV0aXRpb25MZXZlbHMgPSByZWFkUmVwZXRpdGlvbkxldmVsc1YyKHJlYWRlciwgZGFwaDIsIHNjaGVtYVBhdGgpXG4gIHJlYWRlci5vZmZzZXQgPSBkYXBoMi5yZXBldGl0aW9uX2xldmVsc19ieXRlX2xlbmd0aCAvLyByZWFkVmFySW50KCkgPT4gbGVuIGZvciBib29sZWFuIHYyP1xuXG4gIC8vIGRlZmluaXRpb24gbGV2ZWxzXG4gIGNvbnN0IGRlZmluaXRpb25MZXZlbHMgPSByZWFkRGVmaW5pdGlvbkxldmVsc1YyKHJlYWRlciwgZGFwaDIsIHNjaGVtYVBhdGgpXG4gIC8vIGFzc2VydChyZWFkZXIub2Zmc2V0ID09PSBkYXBoMi5yZXBldGl0aW9uX2xldmVsc19ieXRlX2xlbmd0aCArIGRhcGgyLmRlZmluaXRpb25fbGV2ZWxzX2J5dGVfbGVuZ3RoKVxuXG4gIGNvbnN0IHVuY29tcHJlc3NlZFBhZ2VTaXplID0gcGgudW5jb21wcmVzc2VkX3BhZ2Vfc2l6ZSAtIGRhcGgyLmRlZmluaXRpb25fbGV2ZWxzX2J5dGVfbGVuZ3RoIC0gZGFwaDIucmVwZXRpdGlvbl9sZXZlbHNfYnl0ZV9sZW5ndGhcblxuICBsZXQgcGFnZSA9IGNvbXByZXNzZWRCeXRlcy5zdWJhcnJheShyZWFkZXIub2Zmc2V0KVxuICBpZiAoZGFwaDIuaXNfY29tcHJlc3NlZCAhPT0gZmFsc2UpIHtcbiAgICBwYWdlID0gZGVjb21wcmVzc1BhZ2UocGFnZSwgdW5jb21wcmVzc2VkUGFnZVNpemUsIGNvZGVjLCBjb21wcmVzc29ycylcbiAgfVxuICBjb25zdCBwYWdlVmlldyA9IG5ldyBEYXRhVmlldyhwYWdlLmJ1ZmZlciwgcGFnZS5ieXRlT2Zmc2V0LCBwYWdlLmJ5dGVMZW5ndGgpXG4gIGNvbnN0IHBhZ2VSZWFkZXIgPSB7IHZpZXc6IHBhZ2VWaWV3LCBvZmZzZXQ6IDAgfVxuXG4gIC8vIHJlYWQgdmFsdWVzIGJhc2VkIG9uIGVuY29kaW5nXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzLmQudHMnKS5EZWNvZGVkQXJyYXl9ICovXG4gIGxldCBkYXRhUGFnZVxuICBjb25zdCBuVmFsdWVzID0gZGFwaDIubnVtX3ZhbHVlcyAtIGRhcGgyLm51bV9udWxsc1xuICBpZiAoZGFwaDIuZW5jb2RpbmcgPT09ICdQTEFJTicpIHtcbiAgICBjb25zdCB7IHR5cGVfbGVuZ3RoIH0gPSBzY2hlbWFQYXRoW3NjaGVtYVBhdGgubGVuZ3RoIC0gMV0uZWxlbWVudFxuICAgIGRhdGFQYWdlID0gcmVhZFBsYWluKHBhZ2VSZWFkZXIsIHR5cGUsIG5WYWx1ZXMsIHR5cGVfbGVuZ3RoKVxuICB9IGVsc2UgaWYgKGRhcGgyLmVuY29kaW5nID09PSAnUkxFJykge1xuICAgIC8vIGFzc2VydChjb2x1bW5NZXRhZGF0YS50eXBlID09PSAnQk9PTEVBTicpXG4gICAgZGF0YVBhZ2UgPSBuZXcgQXJyYXkoblZhbHVlcylcbiAgICByZWFkUmxlQml0UGFja2VkSHlicmlkKHBhZ2VSZWFkZXIsIDEsIDAsIGRhdGFQYWdlKVxuICAgIGRhdGFQYWdlID0gZGF0YVBhZ2UubWFwKHggPT4gISF4KVxuICB9IGVsc2UgaWYgKFxuICAgIGRhcGgyLmVuY29kaW5nID09PSAnUExBSU5fRElDVElPTkFSWScgfHxcbiAgICBkYXBoMi5lbmNvZGluZyA9PT0gJ1JMRV9ESUNUSU9OQVJZJ1xuICApIHtcbiAgICBjb25zdCBiaXRXaWR0aCA9IHBhZ2VWaWV3LmdldFVpbnQ4KHBhZ2VSZWFkZXIub2Zmc2V0KyspXG4gICAgZGF0YVBhZ2UgPSBuZXcgQXJyYXkoblZhbHVlcylcbiAgICByZWFkUmxlQml0UGFja2VkSHlicmlkKHBhZ2VSZWFkZXIsIGJpdFdpZHRoLCB1bmNvbXByZXNzZWRQYWdlU2l6ZSAtIDEsIGRhdGFQYWdlKVxuICB9IGVsc2UgaWYgKGRhcGgyLmVuY29kaW5nID09PSAnREVMVEFfQklOQVJZX1BBQ0tFRCcpIHtcbiAgICBjb25zdCBpbnQzMiA9IHR5cGUgPT09ICdJTlQzMidcbiAgICBkYXRhUGFnZSA9IGludDMyID8gbmV3IEludDMyQXJyYXkoblZhbHVlcykgOiBuZXcgQmlnSW50NjRBcnJheShuVmFsdWVzKVxuICAgIGRlbHRhQmluYXJ5VW5wYWNrKHBhZ2VSZWFkZXIsIG5WYWx1ZXMsIGRhdGFQYWdlKVxuICB9IGVsc2UgaWYgKGRhcGgyLmVuY29kaW5nID09PSAnREVMVEFfTEVOR1RIX0JZVEVfQVJSQVknKSB7XG4gICAgZGF0YVBhZ2UgPSBuZXcgQXJyYXkoblZhbHVlcylcbiAgICBkZWx0YUxlbmd0aEJ5dGVBcnJheShwYWdlUmVhZGVyLCBuVmFsdWVzLCBkYXRhUGFnZSlcbiAgfSBlbHNlIGlmIChkYXBoMi5lbmNvZGluZyA9PT0gJ0RFTFRBX0JZVEVfQVJSQVknKSB7XG4gICAgZGF0YVBhZ2UgPSBuZXcgQXJyYXkoblZhbHVlcylcbiAgICBkZWx0YUJ5dGVBcnJheShwYWdlUmVhZGVyLCBuVmFsdWVzLCBkYXRhUGFnZSlcbiAgfSBlbHNlIGlmIChkYXBoMi5lbmNvZGluZyA9PT0gJ0JZVEVfU1RSRUFNX1NQTElUJykge1xuICAgIGNvbnN0IHsgdHlwZV9sZW5ndGggfSA9IHNjaGVtYVBhdGhbc2NoZW1hUGF0aC5sZW5ndGggLSAxXS5lbGVtZW50XG4gICAgZGF0YVBhZ2UgPSBieXRlU3RyZWFtU3BsaXQocmVhZGVyLCBuVmFsdWVzLCB0eXBlLCB0eXBlX2xlbmd0aClcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnF1ZXQgdW5zdXBwb3J0ZWQgZW5jb2Rpbmc6ICR7ZGFwaDIuZW5jb2Rpbmd9YClcbiAgfVxuXG4gIHJldHVybiB7IGRlZmluaXRpb25MZXZlbHMsIHJlcGV0aXRpb25MZXZlbHMsIGRhdGFQYWdlIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkRhdGFSZWFkZXJ9IERhdGFSZWFkZXJcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge0RhdGFQYWdlSGVhZGVyVjJ9IGRhcGgyIGRhdGEgcGFnZSBoZWFkZXIgdjJcbiAqIEBwYXJhbSB7U2NoZW1hVHJlZVtdfSBzY2hlbWFQYXRoXG4gKiBAcmV0dXJucyB7YW55W119IHJlcGV0aXRpb24gbGV2ZWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkUmVwZXRpdGlvbkxldmVsc1YyKHJlYWRlciwgZGFwaDIsIHNjaGVtYVBhdGgpIHtcbiAgY29uc3QgbWF4UmVwZXRpdGlvbkxldmVsID0gZ2V0TWF4UmVwZXRpdGlvbkxldmVsKHNjaGVtYVBhdGgpXG4gIGlmICghbWF4UmVwZXRpdGlvbkxldmVsKSByZXR1cm4gW11cblxuICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkoZGFwaDIubnVtX3ZhbHVlcylcbiAgcmVhZFJsZUJpdFBhY2tlZEh5YnJpZChcbiAgICByZWFkZXIsIGJpdFdpZHRoKG1heFJlcGV0aXRpb25MZXZlbCksIGRhcGgyLnJlcGV0aXRpb25fbGV2ZWxzX2J5dGVfbGVuZ3RoLCB2YWx1ZXNcbiAgKVxuICByZXR1cm4gdmFsdWVzXG59XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7RGF0YVBhZ2VIZWFkZXJWMn0gZGFwaDIgZGF0YSBwYWdlIGhlYWRlciB2MlxuICogQHBhcmFtIHtTY2hlbWFUcmVlW119IHNjaGVtYVBhdGhcbiAqIEByZXR1cm5zIHtudW1iZXJbXSB8IHVuZGVmaW5lZH0gZGVmaW5pdGlvbiBsZXZlbHNcbiAqL1xuZnVuY3Rpb24gcmVhZERlZmluaXRpb25MZXZlbHNWMihyZWFkZXIsIGRhcGgyLCBzY2hlbWFQYXRoKSB7XG4gIGNvbnN0IG1heERlZmluaXRpb25MZXZlbCA9IGdldE1heERlZmluaXRpb25MZXZlbChzY2hlbWFQYXRoKVxuICBpZiAobWF4RGVmaW5pdGlvbkxldmVsKSB7XG4gICAgLy8gVjIgd2Uga25vdyB0aGUgbGVuZ3RoXG4gICAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KGRhcGgyLm51bV92YWx1ZXMpXG4gICAgcmVhZFJsZUJpdFBhY2tlZEh5YnJpZChyZWFkZXIsIGJpdFdpZHRoKG1heERlZmluaXRpb25MZXZlbCksIGRhcGgyLmRlZmluaXRpb25fbGV2ZWxzX2J5dGVfbGVuZ3RoLCB2YWx1ZXMpXG4gICAgcmV0dXJuIHZhbHVlc1xuICB9XG59XG4iLCJpbXBvcnQgeyByZWFkVmFySW50LCByZWFkWmlnWmFnQmlnSW50IH0gZnJvbSAnLi90aHJpZnQuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcy5kLnRzJykuRGF0YVJlYWRlcn0gRGF0YVJlYWRlclxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBudW1iZXIgb2YgdmFsdWVzIHRvIHJlYWRcbiAqIEBwYXJhbSB7SW50MzJBcnJheSB8IEJpZ0ludDY0QXJyYXl9IG91dHB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsdGFCaW5hcnlVbnBhY2socmVhZGVyLCBjb3VudCwgb3V0cHV0KSB7XG4gIGNvbnN0IGludDMyID0gb3V0cHV0IGluc3RhbmNlb2YgSW50MzJBcnJheVxuICBjb25zdCBibG9ja1NpemUgPSByZWFkVmFySW50KHJlYWRlcilcbiAgY29uc3QgbWluaWJsb2NrUGVyQmxvY2sgPSByZWFkVmFySW50KHJlYWRlcilcbiAgcmVhZFZhckludChyZWFkZXIpIC8vIGFzc2VydCg9PT0gY291bnQpXG4gIGxldCB2YWx1ZSA9IHJlYWRaaWdaYWdCaWdJbnQocmVhZGVyKSAvLyBmaXJzdCB2YWx1ZVxuICBsZXQgb3V0cHV0SW5kZXggPSAwXG4gIG91dHB1dFtvdXRwdXRJbmRleCsrXSA9IGludDMyID8gTnVtYmVyKHZhbHVlKSA6IHZhbHVlXG5cbiAgY29uc3QgdmFsdWVzUGVyTWluaWJsb2NrID0gYmxvY2tTaXplIC8gbWluaWJsb2NrUGVyQmxvY2tcblxuICB3aGlsZSAob3V0cHV0SW5kZXggPCBjb3VudCkge1xuICAgIC8vIG5ldyBibG9ja1xuICAgIGNvbnN0IG1pbkRlbHRhID0gcmVhZFppZ1phZ0JpZ0ludChyZWFkZXIpXG4gICAgY29uc3QgYml0V2lkdGhzID0gbmV3IFVpbnQ4QXJyYXkobWluaWJsb2NrUGVyQmxvY2spXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW5pYmxvY2tQZXJCbG9jazsgaSsrKSB7XG4gICAgICBiaXRXaWR0aHNbaV0gPSByZWFkZXIudmlldy5nZXRVaW50OChyZWFkZXIub2Zmc2V0KyspXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW5pYmxvY2tQZXJCbG9jayAmJiBvdXRwdXRJbmRleCA8IGNvdW50OyBpKyspIHtcbiAgICAgIC8vIG5ldyBtaW5pYmxvY2tcbiAgICAgIGNvbnN0IGJpdFdpZHRoID0gQmlnSW50KGJpdFdpZHRoc1tpXSlcbiAgICAgIGlmIChiaXRXaWR0aCkge1xuICAgICAgICBsZXQgYml0cGFja1BvcyA9IDBuXG4gICAgICAgIGxldCBtaW5pYmxvY2tDb3VudCA9IHZhbHVlc1Blck1pbmlibG9ja1xuICAgICAgICBjb25zdCBtYXNrID0gKDFuIDw8IGJpdFdpZHRoKSAtIDFuXG4gICAgICAgIHdoaWxlIChtaW5pYmxvY2tDb3VudCAmJiBvdXRwdXRJbmRleCA8IGNvdW50KSB7XG4gICAgICAgICAgbGV0IGJpdHMgPSBCaWdJbnQocmVhZGVyLnZpZXcuZ2V0VWludDgocmVhZGVyLm9mZnNldCkpID4+IGJpdHBhY2tQb3MgJiBtYXNrIC8vIFRPRE86IGRvbid0IHJlLXJlYWQgdmFsdWUgZXZlcnkgdGltZVxuICAgICAgICAgIGJpdHBhY2tQb3MgKz0gYml0V2lkdGhcbiAgICAgICAgICB3aGlsZSAoYml0cGFja1BvcyA+PSA4KSB7XG4gICAgICAgICAgICBiaXRwYWNrUG9zIC09IDhuXG4gICAgICAgICAgICByZWFkZXIub2Zmc2V0KytcbiAgICAgICAgICAgIGlmIChiaXRwYWNrUG9zKSB7XG4gICAgICAgICAgICAgIGJpdHMgfD0gQmlnSW50KHJlYWRlci52aWV3LmdldFVpbnQ4KHJlYWRlci5vZmZzZXQpKSA8PCBiaXRXaWR0aCAtIGJpdHBhY2tQb3MgJiBtYXNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRlbHRhID0gbWluRGVsdGEgKyBiaXRzXG4gICAgICAgICAgdmFsdWUgKz0gZGVsdGFcbiAgICAgICAgICBvdXRwdXRbb3V0cHV0SW5kZXgrK10gPSBpbnQzMiA/IE51bWJlcih2YWx1ZSkgOiB2YWx1ZVxuICAgICAgICAgIG1pbmlibG9ja0NvdW50LS1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluaWJsb2NrQ291bnQpIHtcbiAgICAgICAgICAvLyBjb25zdW1lIGxlZnRvdmVyIG1pbmlibG9ja1xuICAgICAgICAgIHJlYWRlci5vZmZzZXQgKz0gTWF0aC5jZWlsKChtaW5pYmxvY2tDb3VudCAqIE51bWJlcihiaXRXaWR0aCkgKyBOdW1iZXIoYml0cGFja1BvcykpIC8gOClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXNQZXJNaW5pYmxvY2sgJiYgb3V0cHV0SW5kZXggPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgdmFsdWUgKz0gbWluRGVsdGFcbiAgICAgICAgICBvdXRwdXRbb3V0cHV0SW5kZXgrK10gPSBpbnQzMiA/IE51bWJlcih2YWx1ZSkgOiB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtVaW50OEFycmF5W119IG91dHB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsdGFMZW5ndGhCeXRlQXJyYXkocmVhZGVyLCBjb3VudCwgb3V0cHV0KSB7XG4gIGNvbnN0IGxlbmd0aHMgPSBuZXcgSW50MzJBcnJheShjb3VudClcbiAgZGVsdGFCaW5hcnlVbnBhY2socmVhZGVyLCBjb3VudCwgbGVuZ3RocylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgb3V0cHV0W2ldID0gbmV3IFVpbnQ4QXJyYXkocmVhZGVyLnZpZXcuYnVmZmVyLCByZWFkZXIudmlldy5ieXRlT2Zmc2V0ICsgcmVhZGVyLm9mZnNldCwgbGVuZ3Roc1tpXSlcbiAgICByZWFkZXIub2Zmc2V0ICs9IGxlbmd0aHNbaV1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBvdXRwdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbHRhQnl0ZUFycmF5KHJlYWRlciwgY291bnQsIG91dHB1dCkge1xuICBjb25zdCBwcmVmaXhEYXRhID0gbmV3IEludDMyQXJyYXkoY291bnQpXG4gIGRlbHRhQmluYXJ5VW5wYWNrKHJlYWRlciwgY291bnQsIHByZWZpeERhdGEpXG4gIGNvbnN0IHN1ZmZpeERhdGEgPSBuZXcgSW50MzJBcnJheShjb3VudClcbiAgZGVsdGFCaW5hcnlVbnBhY2socmVhZGVyLCBjb3VudCwgc3VmZml4RGF0YSlcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICBjb25zdCBzdWZmaXggPSBuZXcgVWludDhBcnJheShyZWFkZXIudmlldy5idWZmZXIsIHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0LCBzdWZmaXhEYXRhW2ldKVxuICAgIGlmIChwcmVmaXhEYXRhW2ldKSB7XG4gICAgICAvLyBjb3B5IGZyb20gcHJldmlvdXMgdmFsdWVcbiAgICAgIG91dHB1dFtpXSA9IG5ldyBVaW50OEFycmF5KHByZWZpeERhdGFbaV0gKyBzdWZmaXhEYXRhW2ldKVxuICAgICAgb3V0cHV0W2ldLnNldChvdXRwdXRbaSAtIDFdLnN1YmFycmF5KDAsIHByZWZpeERhdGFbaV0pKVxuICAgICAgb3V0cHV0W2ldLnNldChzdWZmaXgsIHByZWZpeERhdGFbaV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dFtpXSA9IHN1ZmZpeFxuICAgIH1cbiAgICByZWFkZXIub2Zmc2V0ICs9IHN1ZmZpeERhdGFbaV1cbiAgfVxufVxuIiwiaW1wb3J0IHsgcmVhZFZhckludCB9IGZyb20gJy4vdGhyaWZ0LmpzJ1xuXG4vKipcbiAqIE1pbmltdW0gYml0cyBuZWVkZWQgdG8gc3RvcmUgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0V2lkdGgodmFsdWUpIHtcbiAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih2YWx1ZSlcbn1cblxuLyoqXG4gKiBSZWFkIHZhbHVlcyBmcm9tIGEgcnVuLWxlbmd0aCBlbmNvZGVkL2JpdC1wYWNrZWQgaHlicmlkIGVuY29kaW5nLlxuICpcbiAqIElmIGxlbmd0aCBpcyB6ZXJvLCB0aGVuIHJlYWQgaW50MzIgbGVuZ3RoIGF0IHRoZSBzdGFydC5cbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkRhdGFSZWFkZXJ9IERhdGFSZWFkZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuRGVjb2RlZEFycmF5fSBEZWNvZGVkQXJyYXlcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB3aWR0aCBvZiBlYWNoIGJpdC1wYWNrZWQgZ3JvdXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggLSBsZW5ndGggb2YgdGhlIGVuY29kZWQgZGF0YVxuICogQHBhcmFtIHtEZWNvZGVkQXJyYXl9IG91dHB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZFJsZUJpdFBhY2tlZEh5YnJpZChyZWFkZXIsIHdpZHRoLCBsZW5ndGgsIG91dHB1dCkge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIC8vIGxlbmd0aCA9IHJlYWRlci52aWV3LmdldFVpbnQzMihyZWFkZXIub2Zmc2V0LCB0cnVlKVxuICAgIHJlYWRlci5vZmZzZXQgKz0gNFxuICB9XG4gIGxldCBzZWVuID0gMFxuICB3aGlsZSAoc2VlbiA8IG91dHB1dC5sZW5ndGgpIHtcbiAgICBjb25zdCBoZWFkZXIgPSByZWFkVmFySW50KHJlYWRlcilcbiAgICBpZiAoaGVhZGVyICYgMSkge1xuICAgICAgLy8gYml0LXBhY2tlZFxuICAgICAgc2VlbiA9IHJlYWRCaXRQYWNrZWQocmVhZGVyLCBoZWFkZXIsIHdpZHRoLCBvdXRwdXQsIHNlZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJsZVxuICAgICAgY29uc3QgY291bnQgPSBoZWFkZXIgPj4+IDFcbiAgICAgIHJlYWRSbGUocmVhZGVyLCBjb3VudCwgd2lkdGgsIG91dHB1dCwgc2VlbilcbiAgICAgIHNlZW4gKz0gY291bnRcbiAgICB9XG4gIH1cbiAgLy8gYXNzZXJ0KHJlYWRlci5vZmZzZXQgLSBzdGFydE9mZnNldCA9PT0gbGVuZ3RoKVxufVxuXG4vKipcbiAqIFJ1bi1sZW5ndGggZW5jb2Rpbmc6IHJlYWQgdmFsdWUgd2l0aCBiaXRXaWR0aCBhbmQgcmVwZWF0IGl0IGNvdW50IHRpbWVzLlxuICpcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRXaWR0aFxuICogQHBhcmFtIHtEZWNvZGVkQXJyYXl9IG91dHB1dFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZW5cbiAqL1xuZnVuY3Rpb24gcmVhZFJsZShyZWFkZXIsIGNvdW50LCBiaXRXaWR0aCwgb3V0cHV0LCBzZWVuKSB7XG4gIGNvbnN0IHdpZHRoID0gYml0V2lkdGggKyA3ID4+IDNcbiAgbGV0IHZhbHVlID0gMFxuICBpZiAod2lkdGggPT09IDEpIHtcbiAgICB2YWx1ZSA9IHJlYWRlci52aWV3LmdldFVpbnQ4KHJlYWRlci5vZmZzZXQpXG4gICAgLy8gYXNzZXJ0KHZhbHVlIDwgMSA8PCBiaXRXaWR0aClcbiAgfSBlbHNlIGlmICh3aWR0aCA9PT0gMikge1xuICAgIHZhbHVlID0gcmVhZGVyLnZpZXcuZ2V0VWludDE2KHJlYWRlci5vZmZzZXQsIHRydWUpXG4gIH0gZWxzZSBpZiAod2lkdGggPT09IDQpIHtcbiAgICB2YWx1ZSA9IHJlYWRlci52aWV3LmdldFVpbnQzMihyZWFkZXIub2Zmc2V0LCB0cnVlKVxuICB9IGVsc2UgaWYgKHdpZHRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYXJxdWV0IGludmFsaWQgcmxlIHdpZHRoICR7d2lkdGh9YClcbiAgfVxuICByZWFkZXIub2Zmc2V0ICs9IHdpZHRoXG5cbiAgLy8gcmVwZWF0IHZhbHVlIGNvdW50IHRpbWVzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIG91dHB1dFtzZWVuICsgaV0gPSB2YWx1ZVxuICB9XG59XG5cbi8qKlxuICogUmVhZCBhIGJpdC1wYWNrZWQgcnVuIG9mIHRoZSBybGUvYml0cGFjayBoeWJyaWQuXG4gKiBTdXBwb3J0cyB3aWR0aCA+IDggKGNyb3NzaW5nIGJ5dGVzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHBhcmFtIHtudW1iZXJ9IGhlYWRlciAtIGJpdC1wYWNrIGhlYWRlclxuICogQHBhcmFtIHtudW1iZXJ9IGJpdFdpZHRoXG4gKiBAcGFyYW0ge0RlY29kZWRBcnJheX0gb3V0cHV0XG4gKiBAcGFyYW0ge251bWJlcn0gc2VlblxuICogQHJldHVybnMge251bWJlcn0gdG90YWwgb3V0cHV0IHZhbHVlcyBzbyBmYXJcbiAqL1xuZnVuY3Rpb24gcmVhZEJpdFBhY2tlZChyZWFkZXIsIGhlYWRlciwgYml0V2lkdGgsIG91dHB1dCwgc2Vlbikge1xuICBsZXQgY291bnQgPSBoZWFkZXIgPj4gMSA8PCAzIC8vIHZhbHVlcyB0byByZWFkXG4gIGNvbnN0IG1hc2sgPSAoMSA8PCBiaXRXaWR0aCkgLSAxXG5cbiAgbGV0IGRhdGEgPSAwXG4gIGlmIChyZWFkZXIub2Zmc2V0IDwgcmVhZGVyLnZpZXcuYnl0ZUxlbmd0aCkge1xuICAgIGRhdGEgPSByZWFkZXIudmlldy5nZXRVaW50OChyZWFkZXIub2Zmc2V0KyspXG4gIH0gZWxzZSBpZiAobWFzaykge1xuICAgIC8vIHNvbWV0aW1lcyBvdXQtb2YtYm91bmRzIHJlYWRzIGFyZSBtYXNrZWQgb3V0XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYXJxdWV0IGJpdHBhY2sgb2Zmc2V0ICR7cmVhZGVyLm9mZnNldH0gb3V0IG9mIHJhbmdlYClcbiAgfVxuICBsZXQgbGVmdCA9IDhcbiAgbGV0IHJpZ2h0ID0gMFxuXG4gIC8vIHJlYWQgdmFsdWVzXG4gIHdoaWxlIChjb3VudCkge1xuICAgIC8vIGlmIHdlIGhhdmUgY3Jvc3NlZCBhIGJ5dGUgYm91bmRhcnksIHNoaWZ0IHRoZSBkYXRhXG4gICAgaWYgKHJpZ2h0ID4gOCkge1xuICAgICAgcmlnaHQgLT0gOFxuICAgICAgbGVmdCAtPSA4XG4gICAgICBkYXRhID4+PSA4XG4gICAgfSBlbHNlIGlmIChsZWZ0IC0gcmlnaHQgPCBiaXRXaWR0aCkge1xuICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBiaXRXaWR0aCBudW1iZXIgb2YgYml0cyB0byByZWFkLCByZWFkIG5leHQgYnl0ZVxuICAgICAgZGF0YSB8PSByZWFkZXIudmlldy5nZXRVaW50OChyZWFkZXIub2Zmc2V0KSA8PCBsZWZ0XG4gICAgICByZWFkZXIub2Zmc2V0KytcbiAgICAgIGxlZnQgKz0gOFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2VlbiA8IG91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gZW1pdCB2YWx1ZVxuICAgICAgICBvdXRwdXRbc2VlbisrXSA9IGRhdGEgPj4gcmlnaHQgJiBtYXNrXG4gICAgICB9XG4gICAgICBjb3VudC0tXG4gICAgICByaWdodCArPSBiaXRXaWR0aFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWVuXG59XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5QYXJxdWV0VHlwZX0gUGFycXVldFR5cGVcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7UGFycXVldFR5cGV9IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSB0eXBlTGVuZ3RoXG4gKiBAcmV0dXJucyB7RGVjb2RlZEFycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN0cmVhbVNwbGl0KHJlYWRlciwgY291bnQsIHR5cGUsIHR5cGVMZW5ndGgpIHtcbiAgY29uc3Qgd2lkdGggPSBieXRlV2lkdGgodHlwZSwgdHlwZUxlbmd0aClcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjb3VudCAqIHdpZHRoKVxuICBmb3IgKGxldCBiID0gMDsgYiA8IHdpZHRoOyBiKyspIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGJ5dGVzW2kgKiB3aWR0aCArIGJdID0gcmVhZGVyLnZpZXcuZ2V0VWludDgocmVhZGVyLm9mZnNldCsrKVxuICAgIH1cbiAgfVxuICAvLyBpbnRlcnByZXQgYnl0ZXMgYXMgdHlwZWQgYXJyYXlcbiAgaWYgKHR5cGUgPT09ICdGTE9BVCcpIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ5dGVzLmJ1ZmZlcilcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ0RPVUJMRScpIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KGJ5dGVzLmJ1ZmZlcilcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ0lOVDMyJykgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGJ5dGVzLmJ1ZmZlcilcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ0lOVDY0JykgcmV0dXJuIG5ldyBCaWdJbnQ2NEFycmF5KGJ5dGVzLmJ1ZmZlcilcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ0ZJWEVEX0xFTl9CWVRFX0FSUkFZJykge1xuICAgIC8vIHNwbGl0IGludG8gYXJyYXlzIG9mIHR5cGVMZW5ndGhcbiAgICBjb25zdCBzcGxpdCA9IG5ldyBBcnJheShjb3VudClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIHNwbGl0W2ldID0gYnl0ZXMuc3ViYXJyYXkoaSAqIHdpZHRoLCAoaSArIDEpICogd2lkdGgpXG4gICAgfVxuICAgIHJldHVybiBzcGxpdFxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgcGFycXVldCBieXRlX3N0cmVhbV9zcGxpdCB1bnN1cHBvcnRlZCB0eXBlOiAke3R5cGV9YClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BhcnF1ZXRUeXBlfSB0eXBlXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gdHlwZUxlbmd0aFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gYnl0ZVdpZHRoKHR5cGUsIHR5cGVMZW5ndGgpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgJ0lOVDMyJzpcbiAgY2FzZSAnRkxPQVQnOlxuICAgIHJldHVybiA0XG4gIGNhc2UgJ0lOVDY0JzpcbiAgY2FzZSAnRE9VQkxFJzpcbiAgICByZXR1cm4gOFxuICBjYXNlICdGSVhFRF9MRU5fQllURV9BUlJBWSc6XG4gICAgaWYgKCF0eXBlTGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgYnl0ZVdpZHRoIG1pc3NpbmcgdHlwZV9sZW5ndGgnKVxuICAgIHJldHVybiB0eXBlTGVuZ3RoXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYXJxdWV0IHVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKVxuICB9XG59XG4iLCJpbXBvcnQgeyBFbmNvZGluZywgUGFnZVR5cGUgfSBmcm9tICcuL2NvbnN0YW50cy5qcydcbmltcG9ydCB7IGRlc2VyaWFsaXplVENvbXBhY3RQcm90b2NvbCB9IGZyb20gJy4vdGhyaWZ0LmpzJ1xuXG4vKipcbiAqIFJlYWQgcGFycXVldCBoZWFkZXIgZnJvbSBhIGJ1ZmZlci5cbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkRhdGFSZWFkZXJ9IERhdGFSZWFkZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuUGFnZUhlYWRlcn0gUGFnZUhlYWRlclxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgLSBwYXJxdWV0IGZpbGUgcmVhZGVyXG4gKiBAcmV0dXJucyB7UGFnZUhlYWRlcn0gbWV0YWRhdGEgb2JqZWN0IGFuZCBieXRlcyByZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJxdWV0SGVhZGVyKHJlYWRlcikge1xuICBjb25zdCBoZWFkZXIgPSBkZXNlcmlhbGl6ZVRDb21wYWN0UHJvdG9jb2wocmVhZGVyKVxuXG4gIC8vIFBhcnNlIHBhcnF1ZXQgaGVhZGVyIGZyb20gdGhyaWZ0IGRhdGFcbiAgY29uc3QgdHlwZSA9IFBhZ2VUeXBlW2hlYWRlci5maWVsZF8xXVxuICBjb25zdCB1bmNvbXByZXNzZWRfcGFnZV9zaXplID0gaGVhZGVyLmZpZWxkXzJcbiAgY29uc3QgY29tcHJlc3NlZF9wYWdlX3NpemUgPSBoZWFkZXIuZmllbGRfM1xuICBjb25zdCBjcmMgPSBoZWFkZXIuZmllbGRfNFxuICBjb25zdCBkYXRhX3BhZ2VfaGVhZGVyID0gaGVhZGVyLmZpZWxkXzUgJiYge1xuICAgIG51bV92YWx1ZXM6IGhlYWRlci5maWVsZF81LmZpZWxkXzEsXG4gICAgZW5jb2Rpbmc6IEVuY29kaW5nW2hlYWRlci5maWVsZF81LmZpZWxkXzJdLFxuICAgIGRlZmluaXRpb25fbGV2ZWxfZW5jb2Rpbmc6IEVuY29kaW5nW2hlYWRlci5maWVsZF81LmZpZWxkXzNdLFxuICAgIHJlcGV0aXRpb25fbGV2ZWxfZW5jb2Rpbmc6IEVuY29kaW5nW2hlYWRlci5maWVsZF81LmZpZWxkXzRdLFxuICAgIHN0YXRpc3RpY3M6IGhlYWRlci5maWVsZF81LmZpZWxkXzUgJiYge1xuICAgICAgbWF4OiBoZWFkZXIuZmllbGRfNS5maWVsZF81LmZpZWxkXzEsXG4gICAgICBtaW46IGhlYWRlci5maWVsZF81LmZpZWxkXzUuZmllbGRfMixcbiAgICAgIG51bGxfY291bnQ6IGhlYWRlci5maWVsZF81LmZpZWxkXzUuZmllbGRfMyxcbiAgICAgIGRpc3RpbmN0X2NvdW50OiBoZWFkZXIuZmllbGRfNS5maWVsZF81LmZpZWxkXzQsXG4gICAgICBtYXhfdmFsdWU6IGhlYWRlci5maWVsZF81LmZpZWxkXzUuZmllbGRfNSxcbiAgICAgIG1pbl92YWx1ZTogaGVhZGVyLmZpZWxkXzUuZmllbGRfNS5maWVsZF82LFxuICAgIH0sXG4gIH1cbiAgY29uc3QgaW5kZXhfcGFnZV9oZWFkZXIgPSBoZWFkZXIuZmllbGRfNlxuICBjb25zdCBkaWN0aW9uYXJ5X3BhZ2VfaGVhZGVyID0gaGVhZGVyLmZpZWxkXzcgJiYge1xuICAgIG51bV92YWx1ZXM6IGhlYWRlci5maWVsZF83LmZpZWxkXzEsXG4gICAgZW5jb2Rpbmc6IEVuY29kaW5nW2hlYWRlci5maWVsZF83LmZpZWxkXzJdLFxuICAgIGlzX3NvcnRlZDogaGVhZGVyLmZpZWxkXzcuZmllbGRfMyxcbiAgfVxuICBjb25zdCBkYXRhX3BhZ2VfaGVhZGVyX3YyID0gaGVhZGVyLmZpZWxkXzggJiYge1xuICAgIG51bV92YWx1ZXM6IGhlYWRlci5maWVsZF84LmZpZWxkXzEsXG4gICAgbnVtX251bGxzOiBoZWFkZXIuZmllbGRfOC5maWVsZF8yLFxuICAgIG51bV9yb3dzOiBoZWFkZXIuZmllbGRfOC5maWVsZF8zLFxuICAgIGVuY29kaW5nOiBFbmNvZGluZ1toZWFkZXIuZmllbGRfOC5maWVsZF80XSxcbiAgICBkZWZpbml0aW9uX2xldmVsc19ieXRlX2xlbmd0aDogaGVhZGVyLmZpZWxkXzguZmllbGRfNSxcbiAgICByZXBldGl0aW9uX2xldmVsc19ieXRlX2xlbmd0aDogaGVhZGVyLmZpZWxkXzguZmllbGRfNixcbiAgICBpc19jb21wcmVzc2VkOiBoZWFkZXIuZmllbGRfOC5maWVsZF83ID09PSB1bmRlZmluZWQgPyB0cnVlIDogaGVhZGVyLmZpZWxkXzguZmllbGRfNywgLy8gZGVmYXVsdCB0cnVlXG4gICAgc3RhdGlzdGljczogaGVhZGVyLmZpZWxkXzguZmllbGRfOCxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICB1bmNvbXByZXNzZWRfcGFnZV9zaXplLFxuICAgIGNvbXByZXNzZWRfcGFnZV9zaXplLFxuICAgIGNyYyxcbiAgICBkYXRhX3BhZ2VfaGVhZGVyLFxuICAgIGluZGV4X3BhZ2VfaGVhZGVyLFxuICAgIGRpY3Rpb25hcnlfcGFnZV9oZWFkZXIsXG4gICAgZGF0YV9wYWdlX2hlYWRlcl92MixcbiAgfVxufVxuIiwiaW1wb3J0IHsgcGFycXVldE1ldGFkYXRhLCBwYXJxdWV0TWV0YWRhdGFBc3luYywgcGFycXVldFNjaGVtYSB9IGZyb20gJy4vbWV0YWRhdGEuanMnXG5leHBvcnQgeyBwYXJxdWV0TWV0YWRhdGEsIHBhcnF1ZXRNZXRhZGF0YUFzeW5jLCBwYXJxdWV0U2NoZW1hIH1cblxuaW1wb3J0IHsgcGFycXVldFJlYWQgfSBmcm9tICcuL3JlYWQuanMnXG5leHBvcnQgeyBwYXJxdWV0UmVhZCB9XG5cbmltcG9ydCB7IHNuYXBweVVuY29tcHJlc3MgfSBmcm9tICcuL3NuYXBweS5qcydcbmV4cG9ydCB7IHNuYXBweVVuY29tcHJlc3MgfVxuXG5pbXBvcnQgeyB0b0pzb24gfSBmcm9tICcuL3V0aWxzLmpzJ1xuZXhwb3J0IHsgdG9Kc29uIH1cbiIsImltcG9ydCB7IENvbXByZXNzaW9uQ29kZWMsIENvbnZlcnRlZFR5cGUsIEVuY29kaW5nLCBGaWVsZFJlcGV0aXRpb25UeXBlLCBQYWdlVHlwZSwgUGFycXVldFR5cGUgfSBmcm9tICcuL2NvbnN0YW50cy5qcydcbmltcG9ydCB7IHBhcnNlRmxvYXQxNiB9IGZyb20gJy4vY29udmVydC5qcydcbmltcG9ydCB7IGdldFNjaGVtYVBhdGggfSBmcm9tICcuL3NjaGVtYS5qcydcbmltcG9ydCB7IGRlc2VyaWFsaXplVENvbXBhY3RQcm90b2NvbCB9IGZyb20gJy4vdGhyaWZ0LmpzJ1xuXG4vKipcbiAqIFJlYWQgcGFycXVldCBtZXRhZGF0YSBmcm9tIGFuIGFzeW5jIGJ1ZmZlci5cbiAqXG4gKiBBbiBBc3luY0J1ZmZlciBpcyBsaWtlIGFuIEFycmF5QnVmZmVyLCBidXQgdGhlIHNsaWNlcyBhcmUgbG9hZGVkXG4gKiBhc3luY2hyb25vdXNseSwgcG9zc2libHkgb3ZlciB0aGUgbmV0d29yay5cbiAqXG4gKiBZb3UgbXVzdCBwcm92aWRlIHRoZSBieXRlTGVuZ3RoIG9mIHRoZSBidWZmZXIsIHR5cGljYWxseSBmcm9tIGEgSEVBRCByZXF1ZXN0LlxuICpcbiAqIEluIHRoZW9yeSwgeW91IGNvdWxkIHVzZSBzdWZmaXgtcmFuZ2UgcmVxdWVzdHMgdG8gZmV0Y2ggdGhlIGVuZCBvZiB0aGUgZmlsZSxcbiAqIGFuZCBzYXZlIGEgcm91bmQgdHJpcC4gQnV0IGluIHByYWN0aWNlLCB0aGlzIGRvZXNuJ3Qgd29yayBiZWNhdXNlIGNocm9tZVxuICogZGVlbXMgc3VmZml4LXJhbmdlIHJlcXVlc3RzIGFzIGEgbm90LXNhZmUtbGlzdGVkIGhlYWRlciwgYW5kIHdpbGwgcmVxdWlyZVxuICogYSBwcmUtZmxpZ2h0LiBTbyB0aGUgYnl0ZUxlbmd0aCBpcyByZXF1aXJlZC5cbiAqXG4gKiBUbyBtYWtlIHRoaXMgZWZmaWNpZW50LCB3ZSBpbml0aWFsbHkgcmVxdWVzdCB0aGUgbGFzdCA1MTJrYiBvZiB0aGUgZmlsZSxcbiAqIHdoaWNoIGlzIGxpa2VseSB0byBjb250YWluIHRoZSBtZXRhZGF0YS4gSWYgdGhlIG1ldGFkYXRhIGxlbmd0aCBleGNlZWRzIHRoZVxuICogaW5pdGlhbCBmZXRjaCwgNTEya2IsIHdlIHJlcXVlc3QgdGhlIHJlc3Qgb2YgdGhlIG1ldGFkYXRhIGZyb20gdGhlIEFzeW5jQnVmZmVyLlxuICpcbiAqIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGVpdGhlciBtYWtlIG9uZSA1MTJrYiBpbml0aWFsIHJlcXVlc3QgZm9yIHRoZSBtZXRhZGF0YSxcbiAqIG9yIGEgc2Vjb25kIHJlcXVlc3QgZm9yIHVwIHRvIHRoZSBtZXRhZGF0YSBzaXplLlxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuQXN5bmNCdWZmZXJ9IEFzeW5jQnVmZmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkZpbGVNZXRhRGF0YX0gRmlsZU1ldGFEYXRhXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLlNjaGVtYUVsZW1lbnR9IFNjaGVtYUVsZW1lbnRcbiAqIEBwYXJhbSB7QXN5bmNCdWZmZXJ9IGFzeW5jQnVmZmVyIHBhcnF1ZXQgZmlsZSBjb250ZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGluaXRpYWxGZXRjaFNpemUgaW5pdGlhbCBmZXRjaCBzaXplIGluIGJ5dGVzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlTWV0YURhdGE+fSBwYXJxdWV0IG1ldGFkYXRhIG9iamVjdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFycXVldE1ldGFkYXRhQXN5bmMoYXN5bmNCdWZmZXIsIGluaXRpYWxGZXRjaFNpemUgPSAxIDw8IDE5IC8qIDUxMmtiICovKSB7XG4gIGlmICghYXN5bmNCdWZmZXIpIHRocm93IG5ldyBFcnJvcigncGFycXVldCBmaWxlIGlzIHJlcXVpcmVkJylcbiAgaWYgKCEoYXN5bmNCdWZmZXIuYnl0ZUxlbmd0aCA+PSAwKSkgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGZpbGUgYnl0ZUxlbmd0aCBpcyByZXF1aXJlZCcpXG5cbiAgLy8gZmV0Y2ggbGFzdCBieXRlcyAoZm9vdGVyKSBvZiB0aGUgZmlsZVxuICBjb25zdCBmb290ZXJPZmZzZXQgPSBNYXRoLm1heCgwLCBhc3luY0J1ZmZlci5ieXRlTGVuZ3RoIC0gaW5pdGlhbEZldGNoU2l6ZSlcbiAgY29uc3QgZm9vdGVyQnVmZmVyID0gYXdhaXQgYXN5bmNCdWZmZXIuc2xpY2UoZm9vdGVyT2Zmc2V0LCBhc3luY0J1ZmZlci5ieXRlTGVuZ3RoKVxuXG4gIC8vIENoZWNrIGZvciBwYXJxdWV0IG1hZ2ljIG51bWJlciBcIlBBUjFcIlxuICBjb25zdCBmb290ZXJWaWV3ID0gbmV3IERhdGFWaWV3KGZvb3RlckJ1ZmZlcilcbiAgaWYgKGZvb3RlclZpZXcuZ2V0VWludDMyKGZvb3RlckJ1ZmZlci5ieXRlTGVuZ3RoIC0gNCwgdHJ1ZSkgIT09IDB4MzE1MjQxNTApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgZmlsZSBpbnZhbGlkIChmb290ZXIgIT0gUEFSMSknKVxuICB9XG5cbiAgLy8gUGFycXVldCBmaWxlcyBzdG9yZSBtZXRhZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlXG4gIC8vIE1ldGFkYXRhIGxlbmd0aCBpcyA0IGJ5dGVzIGJlZm9yZSB0aGUgbGFzdCBQQVIxXG4gIGNvbnN0IG1ldGFkYXRhTGVuZ3RoID0gZm9vdGVyVmlldy5nZXRVaW50MzIoZm9vdGVyQnVmZmVyLmJ5dGVMZW5ndGggLSA4LCB0cnVlKVxuICBpZiAobWV0YWRhdGFMZW5ndGggPiBhc3luY0J1ZmZlci5ieXRlTGVuZ3RoIC0gOCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFycXVldCBtZXRhZGF0YSBsZW5ndGggJHttZXRhZGF0YUxlbmd0aH0gZXhjZWVkcyBhdmFpbGFibGUgYnVmZmVyICR7YXN5bmNCdWZmZXIuYnl0ZUxlbmd0aCAtIDh9YClcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIG1ldGFkYXRhIHNpemUgZml0cyBpbnNpZGUgdGhlIGluaXRpYWwgZmV0Y2hcbiAgaWYgKG1ldGFkYXRhTGVuZ3RoICsgOCA+IGluaXRpYWxGZXRjaFNpemUpIHtcbiAgICAvLyBmZXRjaCB0aGUgcmVzdCBvZiB0aGUgbWV0YWRhdGFcbiAgICBjb25zdCBtZXRhZGF0YU9mZnNldCA9IGFzeW5jQnVmZmVyLmJ5dGVMZW5ndGggLSBtZXRhZGF0YUxlbmd0aCAtIDhcbiAgICBjb25zdCBtZXRhZGF0YUJ1ZmZlciA9IGF3YWl0IGFzeW5jQnVmZmVyLnNsaWNlKG1ldGFkYXRhT2Zmc2V0LCBmb290ZXJPZmZzZXQpXG4gICAgLy8gY29tYmluZSBpbml0aWFsIGZldGNoIHdpdGggdGhlIG5ldyBzbGljZVxuICAgIGNvbnN0IGNvbWJpbmVkQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG1ldGFkYXRhTGVuZ3RoICsgOClcbiAgICBjb25zdCBjb21iaW5lZFZpZXcgPSBuZXcgVWludDhBcnJheShjb21iaW5lZEJ1ZmZlcilcbiAgICBjb21iaW5lZFZpZXcuc2V0KG5ldyBVaW50OEFycmF5KG1ldGFkYXRhQnVmZmVyKSlcbiAgICBjb21iaW5lZFZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGZvb3RlckJ1ZmZlciksIGZvb3Rlck9mZnNldCAtIG1ldGFkYXRhT2Zmc2V0KVxuICAgIHJldHVybiBwYXJxdWV0TWV0YWRhdGEoY29tYmluZWRCdWZmZXIpXG4gIH0gZWxzZSB7XG4gICAgLy8gcGFyc2UgbWV0YWRhdGEgZnJvbSB0aGUgZm9vdGVyXG4gICAgcmV0dXJuIHBhcnF1ZXRNZXRhZGF0YShmb290ZXJCdWZmZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBSZWFkIHBhcnF1ZXQgbWV0YWRhdGEgZnJvbSBhIGJ1ZmZlciBzeW5jaHJvbm91c2x5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIHBhcnF1ZXQgZmlsZSBjb250ZW50c1xuICogQHJldHVybnMge0ZpbGVNZXRhRGF0YX0gcGFycXVldCBtZXRhZGF0YSBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnF1ZXRNZXRhZGF0YShhcnJheUJ1ZmZlcikge1xuICBpZiAoIWFycmF5QnVmZmVyKSB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgZmlsZSBpcyByZXF1aXJlZCcpXG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpXG5cbiAgLy8gVmFsaWRhdGUgZm9vdGVyIG1hZ2ljIG51bWJlciBcIlBBUjFcIlxuICBpZiAodmlldy5ieXRlTGVuZ3RoIDwgOCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFycXVldCBmaWxlIGlzIHRvbyBzaG9ydCcpXG4gIH1cbiAgaWYgKHZpZXcuZ2V0VWludDMyKHZpZXcuYnl0ZUxlbmd0aCAtIDQsIHRydWUpICE9PSAweDMxNTI0MTUwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGZpbGUgaW52YWxpZCAoZm9vdGVyICE9IFBBUjEpJylcbiAgfVxuXG4gIC8vIFBhcnF1ZXQgZmlsZXMgc3RvcmUgbWV0YWRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZVxuICAvLyBNZXRhZGF0YSBsZW5ndGggaXMgNCBieXRlcyBiZWZvcmUgdGhlIGxhc3QgUEFSMVxuICBjb25zdCBtZXRhZGF0YUxlbmd0aE9mZnNldCA9IHZpZXcuYnl0ZUxlbmd0aCAtIDhcbiAgY29uc3QgbWV0YWRhdGFMZW5ndGggPSB2aWV3LmdldFVpbnQzMihtZXRhZGF0YUxlbmd0aE9mZnNldCwgdHJ1ZSlcbiAgaWYgKG1ldGFkYXRhTGVuZ3RoID4gdmlldy5ieXRlTGVuZ3RoIC0gOCkge1xuICAgIC8vIHttZXRhZGF0YX0sIG1ldGFkYXRhX2xlbmd0aCwgUEFSMVxuICAgIHRocm93IG5ldyBFcnJvcihgcGFycXVldCBtZXRhZGF0YSBsZW5ndGggJHttZXRhZGF0YUxlbmd0aH0gZXhjZWVkcyBhdmFpbGFibGUgYnVmZmVyICR7dmlldy5ieXRlTGVuZ3RoIC0gOH1gKVxuICB9XG5cbiAgY29uc3QgbWV0YWRhdGFPZmZzZXQgPSBtZXRhZGF0YUxlbmd0aE9mZnNldCAtIG1ldGFkYXRhTGVuZ3RoXG4gIGNvbnN0IHJlYWRlciA9IHsgdmlldywgb2Zmc2V0OiBtZXRhZGF0YU9mZnNldCB9XG4gIGNvbnN0IG1ldGFkYXRhID0gZGVzZXJpYWxpemVUQ29tcGFjdFByb3RvY29sKHJlYWRlcilcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4gIGZ1bmN0aW9uIGRlY29kZSgvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIGRlY29kZXIuZGVjb2RlKHZhbHVlKVxuICB9XG5cbiAgLy8gUGFyc2UgbWV0YWRhdGEgZnJvbSB0aHJpZnQgZGF0YVxuICBjb25zdCB2ZXJzaW9uID0gbWV0YWRhdGEuZmllbGRfMVxuICAvKiogQHR5cGUge1NjaGVtYUVsZW1lbnRbXX0gKi9cbiAgY29uc3Qgc2NoZW1hID0gbWV0YWRhdGEuZmllbGRfMi5tYXAoKC8qKiBAdHlwZSB7YW55fSAqLyBmaWVsZCkgPT4gKHtcbiAgICB0eXBlOiBQYXJxdWV0VHlwZVtmaWVsZC5maWVsZF8xXSxcbiAgICB0eXBlX2xlbmd0aDogZmllbGQuZmllbGRfMixcbiAgICByZXBldGl0aW9uX3R5cGU6IEZpZWxkUmVwZXRpdGlvblR5cGVbZmllbGQuZmllbGRfM10sXG4gICAgbmFtZTogZGVjb2RlKGZpZWxkLmZpZWxkXzQpLFxuICAgIG51bV9jaGlsZHJlbjogZmllbGQuZmllbGRfNSxcbiAgICBjb252ZXJ0ZWRfdHlwZTogQ29udmVydGVkVHlwZVtmaWVsZC5maWVsZF82XSxcbiAgICBzY2FsZTogZmllbGQuZmllbGRfNyxcbiAgICBwcmVjaXNpb246IGZpZWxkLmZpZWxkXzgsXG4gICAgZmllbGRfaWQ6IGZpZWxkLmZpZWxkXzksXG4gICAgbG9naWNhbF90eXBlOiBsb2dpY2FsVHlwZShmaWVsZC5maWVsZF8xMCksXG4gIH0pKVxuICAvLyBzY2hlbWEgZWxlbWVudCBwZXIgY29sdW1uIGluZGV4XG4gIGNvbnN0IGNvbHVtblNjaGVtYSA9IHNjaGVtYS5maWx0ZXIoZSA9PiBlLnR5cGUpXG4gIGNvbnN0IG51bV9yb3dzID0gbWV0YWRhdGEuZmllbGRfM1xuICBjb25zdCByb3dfZ3JvdXBzID0gbWV0YWRhdGEuZmllbGRfNC5tYXAoKC8qKiBAdHlwZSB7YW55fSAqLyByb3dHcm91cCkgPT4gKHtcbiAgICBjb2x1bW5zOiByb3dHcm91cC5maWVsZF8xLm1hcCgoLyoqIEB0eXBlIHthbnl9ICovIGNvbHVtbiwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGNvbHVtbkluZGV4KSA9PiAoe1xuICAgICAgZmlsZV9wYXRoOiBkZWNvZGUoY29sdW1uLmZpZWxkXzEpLFxuICAgICAgZmlsZV9vZmZzZXQ6IGNvbHVtbi5maWVsZF8yLFxuICAgICAgbWV0YV9kYXRhOiBjb2x1bW4uZmllbGRfMyAmJiB7XG4gICAgICAgIHR5cGU6IFBhcnF1ZXRUeXBlW2NvbHVtbi5maWVsZF8zLmZpZWxkXzFdLFxuICAgICAgICBlbmNvZGluZ3M6IGNvbHVtbi5maWVsZF8zLmZpZWxkXzI/Lm1hcCgoLyoqIEB0eXBlIHtudW1iZXJ9ICovIGUpID0+IEVuY29kaW5nW2VdKSxcbiAgICAgICAgcGF0aF9pbl9zY2hlbWE6IGNvbHVtbi5maWVsZF8zLmZpZWxkXzMubWFwKGRlY29kZSksXG4gICAgICAgIGNvZGVjOiBDb21wcmVzc2lvbkNvZGVjW2NvbHVtbi5maWVsZF8zLmZpZWxkXzRdLFxuICAgICAgICBudW1fdmFsdWVzOiBjb2x1bW4uZmllbGRfMy5maWVsZF81LFxuICAgICAgICB0b3RhbF91bmNvbXByZXNzZWRfc2l6ZTogY29sdW1uLmZpZWxkXzMuZmllbGRfNixcbiAgICAgICAgdG90YWxfY29tcHJlc3NlZF9zaXplOiBjb2x1bW4uZmllbGRfMy5maWVsZF83LFxuICAgICAgICBrZXlfdmFsdWVfbWV0YWRhdGE6IGNvbHVtbi5maWVsZF8zLmZpZWxkXzgsXG4gICAgICAgIGRhdGFfcGFnZV9vZmZzZXQ6IGNvbHVtbi5maWVsZF8zLmZpZWxkXzksXG4gICAgICAgIGluZGV4X3BhZ2Vfb2Zmc2V0OiBjb2x1bW4uZmllbGRfMy5maWVsZF8xMCxcbiAgICAgICAgZGljdGlvbmFyeV9wYWdlX29mZnNldDogY29sdW1uLmZpZWxkXzMuZmllbGRfMTEsXG4gICAgICAgIHN0YXRpc3RpY3M6IGNvbHVtblN0YXRzKGNvbHVtbi5maWVsZF8zLmZpZWxkXzEyLCBjb2x1bW5TY2hlbWFbY29sdW1uSW5kZXhdKSxcbiAgICAgICAgZW5jb2Rpbmdfc3RhdHM6IGNvbHVtbi5maWVsZF8zLmZpZWxkXzEzPy5tYXAoKC8qKiBAdHlwZSB7YW55fSAqLyBlbmNvZGluZ1N0YXQpID0+ICh7XG4gICAgICAgICAgcGFnZV90eXBlOiBQYWdlVHlwZVtlbmNvZGluZ1N0YXQuZmllbGRfMV0sXG4gICAgICAgICAgZW5jb2Rpbmc6IEVuY29kaW5nW2VuY29kaW5nU3RhdC5maWVsZF8yXSxcbiAgICAgICAgICBjb3VudDogZW5jb2RpbmdTdGF0LmZpZWxkXzMsXG4gICAgICAgIH0pKSxcbiAgICAgICAgYmxvb21fZmlsdGVyX29mZnNldDogY29sdW1uLmZpZWxkXzMuZmllbGRfMTQsXG4gICAgICAgIGJsb29tX2ZpbHRlcl9sZW5ndGg6IGNvbHVtbi5maWVsZF8zLmZpZWxkXzE1LFxuICAgICAgICBzaXplX3N0YXRpc3RpY3M6IGNvbHVtbi5maWVsZF8zLmZpZWxkXzE2ICYmIHtcbiAgICAgICAgICB1bmVuY29kZWRfYnl0ZV9hcnJheV9kYXRhX2J5dGVzOiBjb2x1bW4uZmllbGRfMy5maWVsZF8xNi5maWVsZF8xLFxuICAgICAgICAgIHJlcGV0aXRpb25fbGV2ZWxfaGlzdG9ncmFtOiBjb2x1bW4uZmllbGRfMy5maWVsZF8xNi5maWVsZF8yLFxuICAgICAgICAgIGRlZmluaXRpb25fbGV2ZWxfaGlzdG9ncmFtOiBjb2x1bW4uZmllbGRfMy5maWVsZF8xNi5maWVsZF8zLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIG9mZnNldF9pbmRleF9vZmZzZXQ6IGNvbHVtbi5maWVsZF80LFxuICAgICAgb2Zmc2V0X2luZGV4X2xlbmd0aDogY29sdW1uLmZpZWxkXzUsXG4gICAgICBjb2x1bW5faW5kZXhfb2Zmc2V0OiBjb2x1bW4uZmllbGRfNixcbiAgICAgIGNvbHVtbl9pbmRleF9sZW5ndGg6IGNvbHVtbi5maWVsZF83LFxuICAgICAgY3J5cHRvX21ldGFkYXRhOiBjb2x1bW4uZmllbGRfNyxcbiAgICAgIGVuY3J5cHRlZF9jb2x1bW5fbWV0YWRhdGE6IGNvbHVtbi5maWVsZF84LFxuICAgIH0pKSxcbiAgICB0b3RhbF9ieXRlX3NpemU6IHJvd0dyb3VwLmZpZWxkXzIsXG4gICAgbnVtX3Jvd3M6IHJvd0dyb3VwLmZpZWxkXzMsXG4gICAgc29ydGluZ19jb2x1bW5zOiByb3dHcm91cC5maWVsZF80Py5tYXAoKC8qKiBAdHlwZSB7YW55fSAqLyBzb3J0aW5nQ29sdW1uKSA9PiAoe1xuICAgICAgY29sdW1uX2lkeDogc29ydGluZ0NvbHVtbi5maWVsZF8xLFxuICAgICAgZGVzY2VuZGluZzogc29ydGluZ0NvbHVtbi5maWVsZF8yLFxuICAgICAgbnVsbHNfZmlyc3Q6IHNvcnRpbmdDb2x1bW4uZmllbGRfMyxcbiAgICB9KSksXG4gICAgZmlsZV9vZmZzZXQ6IHJvd0dyb3VwLmZpZWxkXzUsXG4gICAgdG90YWxfY29tcHJlc3NlZF9zaXplOiByb3dHcm91cC5maWVsZF82LFxuICAgIG9yZGluYWw6IHJvd0dyb3VwLmZpZWxkXzcsXG4gIH0pKVxuICBjb25zdCBrZXlfdmFsdWVfbWV0YWRhdGEgPSBtZXRhZGF0YS5maWVsZF81Py5tYXAoKC8qKiBAdHlwZSB7YW55fSAqLyBrZXlWYWx1ZSkgPT4gKHtcbiAgICBrZXk6IGRlY29kZShrZXlWYWx1ZS5maWVsZF8xKSxcbiAgICB2YWx1ZTogZGVjb2RlKGtleVZhbHVlLmZpZWxkXzIpLFxuICB9KSlcbiAgY29uc3QgY3JlYXRlZF9ieSA9IGRlY29kZShtZXRhZGF0YS5maWVsZF82KVxuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvbixcbiAgICBzY2hlbWEsXG4gICAgbnVtX3Jvd3MsXG4gICAgcm93X2dyb3VwcyxcbiAgICBrZXlfdmFsdWVfbWV0YWRhdGEsXG4gICAgY3JlYXRlZF9ieSxcbiAgICBtZXRhZGF0YV9sZW5ndGg6IG1ldGFkYXRhTGVuZ3RoLFxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIGEgdHJlZSBvZiBzY2hlbWEgZWxlbWVudHMgZnJvbSBwYXJxdWV0IG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSB7RmlsZU1ldGFEYXRhfSBtZXRhZGF0YSBwYXJxdWV0IG1ldGFkYXRhIG9iamVjdFxuICogQHJldHVybnMge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5TY2hlbWFUcmVlfSB0cmVlIG9mIHNjaGVtYSBlbGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFycXVldFNjaGVtYShtZXRhZGF0YSkge1xuICByZXR1cm4gZ2V0U2NoZW1hUGF0aChtZXRhZGF0YS5zY2hlbWEsIFtdKVswXVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBsb2dpY2FsVHlwZVxuICogQHJldHVybnMge2ltcG9ydChcIi4vdHlwZXMuZC50c1wiKS5Mb2dpY2FsVHlwZSB8IHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gbG9naWNhbFR5cGUobG9naWNhbFR5cGUpIHtcbiAgaWYgKGxvZ2ljYWxUeXBlPy5maWVsZF8xKSByZXR1cm4geyB0eXBlOiAnU1RSSU5HJyB9XG4gIGlmIChsb2dpY2FsVHlwZT8uZmllbGRfMikgcmV0dXJuIHsgdHlwZTogJ01BUCcgfVxuICBpZiAobG9naWNhbFR5cGU/LmZpZWxkXzMpIHJldHVybiB7IHR5cGU6ICdMSVNUJyB9XG4gIGlmIChsb2dpY2FsVHlwZT8uZmllbGRfNCkgcmV0dXJuIHsgdHlwZTogJ0VOVU0nIH1cbiAgaWYgKGxvZ2ljYWxUeXBlPy5maWVsZF81KSByZXR1cm4ge1xuICAgIHR5cGU6ICdERUNJTUFMJyxcbiAgICBzY2FsZTogbG9naWNhbFR5cGUuZmllbGRfNS5maWVsZF8xLFxuICAgIHByZWNpc2lvbjogbG9naWNhbFR5cGUuZmllbGRfNS5maWVsZF8yLFxuICB9XG4gIGlmIChsb2dpY2FsVHlwZT8uZmllbGRfNikgcmV0dXJuIHsgdHlwZTogJ0RBVEUnIH1cbiAgaWYgKGxvZ2ljYWxUeXBlPy5maWVsZF83KSByZXR1cm4ge1xuICAgIHR5cGU6ICdUSU1FJyxcbiAgICBpc0FkanVzdGVkVG9VVEM6IGxvZ2ljYWxUeXBlLmZpZWxkXzcuZmllbGRfMSxcbiAgICB1bml0OiBsb2dpY2FsVHlwZS5maWVsZF83LmZpZWxkXzIsXG4gIH1cbiAgaWYgKGxvZ2ljYWxUeXBlPy5maWVsZF84KSByZXR1cm4ge1xuICAgIHR5cGU6ICdUSU1FU1RBTVAnLFxuICAgIGlzQWRqdXN0ZWRUb1VUQzogbG9naWNhbFR5cGUuZmllbGRfOC5maWVsZF8xLFxuICAgIHVuaXQ6IGxvZ2ljYWxUeXBlLmZpZWxkXzguZmllbGRfMixcbiAgfVxuICBpZiAobG9naWNhbFR5cGU/LmZpZWxkXzEwKSByZXR1cm4ge1xuICAgIHR5cGU6ICdJTlRFR0VSJyxcbiAgICBiaXRXaWR0aDogbG9naWNhbFR5cGUuZmllbGRfMTAuZmllbGRfMSxcbiAgICBpc1NpZ25lZDogbG9naWNhbFR5cGUuZmllbGRfMTAuZmllbGRfMixcbiAgfVxuICBpZiAobG9naWNhbFR5cGU/LmZpZWxkXzExKSByZXR1cm4geyB0eXBlOiAnTlVMTCcgfVxuICBpZiAobG9naWNhbFR5cGU/LmZpZWxkXzEyKSByZXR1cm4geyB0eXBlOiAnSlNPTicgfVxuICBpZiAobG9naWNhbFR5cGU/LmZpZWxkXzEzKSByZXR1cm4geyB0eXBlOiAnQlNPTicgfVxuICBpZiAobG9naWNhbFR5cGU/LmZpZWxkXzE0KSByZXR1cm4geyB0eXBlOiAnVVVJRCcgfVxuICBpZiAobG9naWNhbFR5cGU/LmZpZWxkXzE1KSByZXR1cm4geyB0eXBlOiAnRkxPQVQxNicgfVxuICByZXR1cm4gbG9naWNhbFR5cGVcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGNvbHVtbiBzdGF0aXN0aWNzIGJhc2VkIG9uIGNvbHVtbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBzdGF0c1xuICogQHBhcmFtIHtTY2hlbWFFbGVtZW50fSBzY2hlbWFcbiAqIEByZXR1cm5zIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuU3RhdGlzdGljc31cbiAqL1xuZnVuY3Rpb24gY29sdW1uU3RhdHMoc3RhdHMsIHNjaGVtYSkge1xuICBjb25zdCB7IHR5cGUsIGxvZ2ljYWxfdHlwZSB9ID0gc2NoZW1hXG4gIGZ1bmN0aW9uIGNvbnZlcnQoLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdmFsdWVcbiAgICBpZiAodHlwZSA9PT0gJ0JPT0xFQU4nKSByZXR1cm4gdmFsdWVbMF0gPT09IDFcbiAgICBpZiAodHlwZSA9PT0gJ0JZVEVfQVJSQVknKSByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKVxuICAgIGlmICh0eXBlID09PSAnSU5UMzInKSB7XG4gICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHZhbHVlLmJ1ZmZlciwgdmFsdWUuYnl0ZU9mZnNldCwgdmFsdWUuYnl0ZUxlbmd0aClcbiAgICAgIHJldHVybiB2aWV3LmdldEludDMyKDAsIHRydWUpXG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnSU5UNjQnKSB7XG4gICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHZhbHVlLmJ1ZmZlciwgdmFsdWUuYnl0ZU9mZnNldCwgdmFsdWUuYnl0ZUxlbmd0aClcbiAgICAgIHJldHVybiB2aWV3LmdldEJpZ0ludDY0KDAsIHRydWUpXG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnRkxPQVQnKSB7XG4gICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHZhbHVlLmJ1ZmZlciwgdmFsdWUuYnl0ZU9mZnNldCwgdmFsdWUuYnl0ZUxlbmd0aClcbiAgICAgIHJldHVybiB2aWV3LmdldEZsb2F0MzIoMCwgdHJ1ZSlcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdET1VCTEUnKSB7XG4gICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHZhbHVlLmJ1ZmZlciwgdmFsdWUuYnl0ZU9mZnNldCwgdmFsdWUuYnl0ZUxlbmd0aClcbiAgICAgIHJldHVybiB2aWV3LmdldEZsb2F0NjQoMCwgdHJ1ZSlcbiAgICB9XG4gICAgaWYgKGxvZ2ljYWxfdHlwZT8udHlwZSA9PT0gJ0ZMT0FUMTYnKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdDE2KHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICByZXR1cm4gc3RhdHMgJiYge1xuICAgIG1heDogY29udmVydChzdGF0cy5maWVsZF8xKSxcbiAgICBtaW46IGNvbnZlcnQoc3RhdHMuZmllbGRfMiksXG4gICAgbnVsbF9jb3VudDogc3RhdHMuZmllbGRfMyxcbiAgICBkaXN0aW5jdF9jb3VudDogc3RhdHMuZmllbGRfNCxcbiAgICBtYXhfdmFsdWU6IGNvbnZlcnQoc3RhdHMuZmllbGRfNSksXG4gICAgbWluX3ZhbHVlOiBjb252ZXJ0KHN0YXRzLmZpZWxkXzYpLFxuICAgIGlzX21heF92YWx1ZV9leGFjdDogc3RhdHMuZmllbGRfNyxcbiAgICBpc19taW5fdmFsdWVfZXhhY3Q6IHN0YXRzLmZpZWxkXzgsXG4gIH1cbn1cbiIsIi8qKlxuICogUmVhZCBgY291bnRgIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gdHlwZSBmcm9tIHRoZSByZWFkZXIudmlldy5cbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkRhdGFSZWFkZXJ9IERhdGFSZWFkZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuRGVjb2RlZEFycmF5fSBEZWNvZGVkQXJyYXlcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmQudHNcIikuUGFycXVldFR5cGV9IFBhcnF1ZXRUeXBlXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciAtIGJ1ZmZlciB0byByZWFkIGRhdGEgZnJvbVxuICogQHBhcmFtIHtQYXJxdWV0VHlwZX0gdHlwZSAtIHBhcnF1ZXQgdHlwZSBvZiB0aGUgZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gbnVtYmVyIG9mIHZhbHVlcyB0byByZWFkXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZml4ZWRMZW5ndGggLSBsZW5ndGggb2YgZWFjaCBmaXhlZCBsZW5ndGggYnl0ZSBhcnJheVxuICogQHJldHVybnMge0RlY29kZWRBcnJheX0gYXJyYXkgb2YgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkUGxhaW4ocmVhZGVyLCB0eXBlLCBjb3VudCwgZml4ZWRMZW5ndGgpIHtcbiAgaWYgKGNvdW50ID09PSAwKSByZXR1cm4gW11cbiAgaWYgKHR5cGUgPT09ICdCT09MRUFOJykge1xuICAgIHJldHVybiByZWFkUGxhaW5Cb29sZWFuKHJlYWRlciwgY291bnQpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0lOVDMyJykge1xuICAgIHJldHVybiByZWFkUGxhaW5JbnQzMihyZWFkZXIsIGNvdW50KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdJTlQ2NCcpIHtcbiAgICByZXR1cm4gcmVhZFBsYWluSW50NjQocmVhZGVyLCBjb3VudClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnSU5UOTYnKSB7XG4gICAgcmV0dXJuIHJlYWRQbGFpbkludDk2KHJlYWRlciwgY291bnQpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0ZMT0FUJykge1xuICAgIHJldHVybiByZWFkUGxhaW5GbG9hdChyZWFkZXIsIGNvdW50KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdET1VCTEUnKSB7XG4gICAgcmV0dXJuIHJlYWRQbGFpbkRvdWJsZShyZWFkZXIsIGNvdW50KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdCWVRFX0FSUkFZJykge1xuICAgIHJldHVybiByZWFkUGxhaW5CeXRlQXJyYXkocmVhZGVyLCBjb3VudClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnRklYRURfTEVOX0JZVEVfQVJSQVknKSB7XG4gICAgaWYgKCFmaXhlZExlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IG1pc3NpbmcgZml4ZWQgbGVuZ3RoJylcbiAgICByZXR1cm4gcmVhZFBsYWluQnl0ZUFycmF5Rml4ZWQocmVhZGVyLCBjb3VudCwgZml4ZWRMZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYXJxdWV0IHVuaGFuZGxlZCB0eXBlOiAke3R5cGV9YClcbiAgfVxufVxuXG4vKipcbiAqIFJlYWQgYGNvdW50YCBib29sZWFuIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbltdfVxuICovXG5mdW5jdGlvbiByZWFkUGxhaW5Cb29sZWFuKHJlYWRlciwgY291bnQpIHtcbiAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KGNvdW50KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICBjb25zdCBieXRlT2Zmc2V0ID0gcmVhZGVyLm9mZnNldCArIChpIC8gOCB8IDApXG4gICAgY29uc3QgYml0T2Zmc2V0ID0gaSAlIDhcbiAgICBjb25zdCBieXRlID0gcmVhZGVyLnZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldClcbiAgICB2YWx1ZXNbaV0gPSAoYnl0ZSAmIDEgPDwgYml0T2Zmc2V0KSAhPT0gMFxuICB9XG4gIHJlYWRlci5vZmZzZXQgKz0gTWF0aC5jZWlsKGNvdW50IC8gOClcbiAgcmV0dXJuIHZhbHVlc1xufVxuXG4vKipcbiAqIFJlYWQgYGNvdW50YCBpbnQzMiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHJldHVybnMge0ludDMyQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHJlYWRQbGFpbkludDMyKHJlYWRlciwgY291bnQpIHtcbiAgY29uc3QgdmFsdWVzID0gKHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0KSAlIDRcbiAgICA/IG5ldyBJbnQzMkFycmF5KGFsaWduKHJlYWRlci52aWV3LmJ1ZmZlciwgcmVhZGVyLnZpZXcuYnl0ZU9mZnNldCArIHJlYWRlci5vZmZzZXQsIGNvdW50ICogNCkpXG4gICAgOiBuZXcgSW50MzJBcnJheShyZWFkZXIudmlldy5idWZmZXIsIHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0LCBjb3VudClcbiAgcmVhZGVyLm9mZnNldCArPSBjb3VudCAqIDRcbiAgcmV0dXJuIHZhbHVlc1xufVxuXG4vKipcbiAqIFJlYWQgYGNvdW50YCBpbnQ2NCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHJldHVybnMge0JpZ0ludDY0QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHJlYWRQbGFpbkludDY0KHJlYWRlciwgY291bnQpIHtcbiAgY29uc3QgdmFsdWVzID0gKHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0KSAlIDhcbiAgICA/IG5ldyBCaWdJbnQ2NEFycmF5KGFsaWduKHJlYWRlci52aWV3LmJ1ZmZlciwgcmVhZGVyLnZpZXcuYnl0ZU9mZnNldCArIHJlYWRlci5vZmZzZXQsIGNvdW50ICogOCkpXG4gICAgOiBuZXcgQmlnSW50NjRBcnJheShyZWFkZXIudmlldy5idWZmZXIsIHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0LCBjb3VudClcbiAgcmVhZGVyLm9mZnNldCArPSBjb3VudCAqIDhcbiAgcmV0dXJuIHZhbHVlc1xufVxuXG4vKipcbiAqIFJlYWQgYGNvdW50YCBpbnQ5NiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHJldHVybnMge2JpZ2ludFtdfVxuICovXG5mdW5jdGlvbiByZWFkUGxhaW5JbnQ5NihyZWFkZXIsIGNvdW50KSB7XG4gIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShjb3VudClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgY29uc3QgbG93ID0gcmVhZGVyLnZpZXcuZ2V0QmlnSW50NjQocmVhZGVyLm9mZnNldCArIGkgKiAxMiwgdHJ1ZSlcbiAgICBjb25zdCBoaWdoID0gcmVhZGVyLnZpZXcuZ2V0SW50MzIocmVhZGVyLm9mZnNldCArIGkgKiAxMiArIDgsIHRydWUpXG4gICAgdmFsdWVzW2ldID0gQmlnSW50KGhpZ2gpIDw8IDY0biB8IGxvd1xuICB9XG4gIHJlYWRlci5vZmZzZXQgKz0gY291bnQgKiAxMlxuICByZXR1cm4gdmFsdWVzXG59XG5cbi8qKlxuICogUmVhZCBgY291bnRgIGZsb2F0IHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fVxuICovXG5mdW5jdGlvbiByZWFkUGxhaW5GbG9hdChyZWFkZXIsIGNvdW50KSB7XG4gIGNvbnN0IHZhbHVlcyA9IChyZWFkZXIudmlldy5ieXRlT2Zmc2V0ICsgcmVhZGVyLm9mZnNldCkgJSA0XG4gICAgPyBuZXcgRmxvYXQzMkFycmF5KGFsaWduKHJlYWRlci52aWV3LmJ1ZmZlciwgcmVhZGVyLnZpZXcuYnl0ZU9mZnNldCArIHJlYWRlci5vZmZzZXQsIGNvdW50ICogNCkpXG4gICAgOiBuZXcgRmxvYXQzMkFycmF5KHJlYWRlci52aWV3LmJ1ZmZlciwgcmVhZGVyLnZpZXcuYnl0ZU9mZnNldCArIHJlYWRlci5vZmZzZXQsIGNvdW50KVxuICByZWFkZXIub2Zmc2V0ICs9IGNvdW50ICogNFxuICByZXR1cm4gdmFsdWVzXG59XG5cbi8qKlxuICogUmVhZCBgY291bnRgIGRvdWJsZSB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHJldHVybnMge0Zsb2F0NjRBcnJheX1cbiAqL1xuZnVuY3Rpb24gcmVhZFBsYWluRG91YmxlKHJlYWRlciwgY291bnQpIHtcbiAgY29uc3QgdmFsdWVzID0gKHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0KSAlIDhcbiAgICA/IG5ldyBGbG9hdDY0QXJyYXkoYWxpZ24ocmVhZGVyLnZpZXcuYnVmZmVyLCByZWFkZXIudmlldy5ieXRlT2Zmc2V0ICsgcmVhZGVyLm9mZnNldCwgY291bnQgKiA4KSlcbiAgICA6IG5ldyBGbG9hdDY0QXJyYXkocmVhZGVyLnZpZXcuYnVmZmVyLCByZWFkZXIudmlldy5ieXRlT2Zmc2V0ICsgcmVhZGVyLm9mZnNldCwgY291bnQpXG4gIHJlYWRlci5vZmZzZXQgKz0gY291bnQgKiA4XG4gIHJldHVybiB2YWx1ZXNcbn1cblxuLyoqXG4gKiBSZWFkIGBjb3VudGAgYnl0ZSBhcnJheSB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHJldHVybnMge1VpbnQ4QXJyYXlbXX1cbiAqL1xuZnVuY3Rpb24gcmVhZFBsYWluQnl0ZUFycmF5KHJlYWRlciwgY291bnQpIHtcbiAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KGNvdW50KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICBjb25zdCBsZW5ndGggPSByZWFkZXIudmlldy5nZXRJbnQzMihyZWFkZXIub2Zmc2V0LCB0cnVlKVxuICAgIHJlYWRlci5vZmZzZXQgKz0gNFxuICAgIHZhbHVlc1tpXSA9IG5ldyBVaW50OEFycmF5KHJlYWRlci52aWV3LmJ1ZmZlciwgcmVhZGVyLnZpZXcuYnl0ZU9mZnNldCArIHJlYWRlci5vZmZzZXQsIGxlbmd0aClcbiAgICByZWFkZXIub2Zmc2V0ICs9IGxlbmd0aFxuICB9XG4gIHJldHVybiB2YWx1ZXNcbn1cblxuLyoqXG4gKiBSZWFkIGEgZml4ZWQgbGVuZ3RoIGJ5dGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtudW1iZXJ9IGZpeGVkTGVuZ3RoXG4gKiBAcmV0dXJucyB7VWludDhBcnJheVtdfVxuICovXG5mdW5jdGlvbiByZWFkUGxhaW5CeXRlQXJyYXlGaXhlZChyZWFkZXIsIGNvdW50LCBmaXhlZExlbmd0aCkge1xuICAvLyBhc3NlcnQocmVhZGVyLnZpZXcuYnl0ZUxlbmd0aCAtIHJlYWRlci5vZmZzZXQgPj0gY291bnQgKiBmaXhlZExlbmd0aClcbiAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KGNvdW50KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICB2YWx1ZXNbaV0gPSBuZXcgVWludDhBcnJheShyZWFkZXIudmlldy5idWZmZXIsIHJlYWRlci52aWV3LmJ5dGVPZmZzZXQgKyByZWFkZXIub2Zmc2V0LCBmaXhlZExlbmd0aClcbiAgICByZWFkZXIub2Zmc2V0ICs9IGZpeGVkTGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHZhbHVlc1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBidWZmZXIgd2l0aCB0aGUgb2Zmc2V0IGFuZCBzaXplLlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gYWxpZ24oYnVmZmVyLCBvZmZzZXQsIHNpemUpIHtcbiAgY29uc3QgYWxpZ25lZCA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKVxuICBuZXcgVWludDhBcnJheShhbGlnbmVkKS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQsIHNpemUpKVxuICByZXR1cm4gYWxpZ25lZFxufVxuIiwiXG5pbXBvcnQgeyBhc3NlbWJsZU5lc3RlZCB9IGZyb20gJy4vYXNzZW1ibGUuanMnXG5pbXBvcnQgeyBnZXRDb2x1bW5PZmZzZXQsIHJlYWRDb2x1bW4gfSBmcm9tICcuL2NvbHVtbi5qcydcbmltcG9ydCB7IHBhcnF1ZXRNZXRhZGF0YUFzeW5jIH0gZnJvbSAnLi9tZXRhZGF0YS5qcydcbmltcG9ydCB7IGdldFNjaGVtYVBhdGggfSBmcm9tICcuL3NjaGVtYS5qcydcbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gJy4vdXRpbHMuanMnXG5cbi8qKlxuICogUmVhZCBwYXJxdWV0IGRhdGEgcm93cyBmcm9tIGEgZmlsZS1saWtlIG9iamVjdC5cbiAqIFJlYWRzIHRoZSBtaW5pbWFsIG51bWJlciBvZiByb3cgZ3JvdXBzIGFuZCBjb2x1bW5zIHRvIHNhdGlzZnkgdGhlIHJlcXVlc3QuXG4gKlxuICogUmV0dXJucyBhIHZvaWQgcHJvbWlzZSB3aGVuIGNvbXBsZXRlLCBhbmQgdG8gdGhyb3cgZXJyb3JzLlxuICogRGF0YSBpcyByZXR1cm5lZCBpbiBvbkNvbXBsZXRlLCBub3QgdGhlIHJldHVybiBwcm9taXNlLCBiZWNhdXNlXG4gKiBpZiBvbkNvbXBsZXRlIGlzIHVuZGVmaW5lZCwgd2UgcGFyc2UgdGhlIGRhdGEsIGFuZCBlbWl0IGNodW5rcywgYnV0IHNraXBcbiAqIGNvbXB1dGluZyB0aGUgcm93IHZpZXcgZGlyZWN0bHkuIFRoaXMgc2F2ZXMgb24gYWxsb2NhdGlvbiBpZiB0aGUgY2FsbGVyXG4gKiB3YW50cyB0byBjYWNoZSB0aGUgZnVsbCBjaHVua3MsIGFuZCBtYWtlIHRoZWlyIG93biB2aWV3IG9mIHRoZSBkYXRhIGZyb21cbiAqIHRoZSBjaHVua3MuXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9oeXBhcnF1ZXQuanMnKS5Db2x1bW5EYXRhfSBDb2x1bW5EYXRhXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzLmpzJykuQ29tcHJlc3NvcnN9IENvbXByZXNzb3JzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzLmpzJykuQXN5bmNCdWZmZXJ9IEFzeW5jQnVmZmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzLmpzJykuRmlsZU1ldGFEYXRhfSBGaWxlTWV0YURhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHJlYWQgb3B0aW9uc1xuICogQHBhcmFtIHtBc3luY0J1ZmZlcn0gb3B0aW9ucy5maWxlIGZpbGUtbGlrZSBvYmplY3QgY29udGFpbmluZyBwYXJxdWV0IGRhdGFcbiAqIEBwYXJhbSB7RmlsZU1ldGFEYXRhfSBbb3B0aW9ucy5tZXRhZGF0YV0gcGFycXVldCBmaWxlIG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9ucy5jb2x1bW5zXSBjb2x1bW5zIHRvIHJlYWQsIGFsbCBjb2x1bW5zIGlmIHVuZGVmaW5lZFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvd1N0YXJ0XSBmaXJzdCByZXF1ZXN0ZWQgcm93IGluZGV4IChpbmNsdXNpdmUpXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucm93RW5kXSBsYXN0IHJlcXVlc3RlZCByb3cgaW5kZXggKGV4Y2x1c2l2ZSlcbiAqIEBwYXJhbSB7KGNodW5rOiBDb2x1bW5EYXRhKSA9PiB2b2lkfSBbb3B0aW9ucy5vbkNodW5rXSBjYWxsZWQgd2hlbiBhIGNvbHVtbiBjaHVuayBpcyBwYXJzZWQuIGNodW5rcyBtYXkgaW5jbHVkZSByb3cgZGF0YSBvdXRzaWRlIHRoZSByZXF1ZXN0ZWQgcmFuZ2UuXG4gKiBAcGFyYW0geyhyb3dzOiBhbnlbXVtdKSA9PiB2b2lkfSBbb3B0aW9ucy5vbkNvbXBsZXRlXSBjYWxsZWQgd2hlbiBhbGwgcmVxdWVzdGVkIHJvd3MgYW5kIGNvbHVtbnMgYXJlIHBhcnNlZFxuICogQHBhcmFtIHtDb21wcmVzc29yc30gW29wdGlvbnMuY29tcHJlc3NvcnNdIGN1c3RvbSBkZWNvbXByZXNzb3JzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gcmVzb2x2ZXMgd2hlbiBhbGwgcmVxdWVzdGVkIHJvd3MgYW5kIGNvbHVtbnMgYXJlIHBhcnNlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFycXVldFJlYWQob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMuZmlsZSkgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGZpbGUgaXMgcmVxdWlyZWQnKVxuXG4gIC8vIGxvYWQgbWV0YWRhdGEgaWYgbm90IHByb3ZpZGVkXG4gIG9wdGlvbnMubWV0YWRhdGEgfHw9IGF3YWl0IHBhcnF1ZXRNZXRhZGF0YUFzeW5jKG9wdGlvbnMuZmlsZSlcbiAgaWYgKCFvcHRpb25zLm1ldGFkYXRhKSB0aHJvdyBuZXcgRXJyb3IoJ3BhcnF1ZXQgbWV0YWRhdGEgbm90IGZvdW5kJylcblxuICBjb25zdCB7IG1ldGFkYXRhLCBvbkNvbXBsZXRlLCByb3dFbmQgfSA9IG9wdGlvbnNcbiAgY29uc3Qgcm93U3RhcnQgPSBvcHRpb25zLnJvd1N0YXJ0IHx8IDBcbiAgLyoqIEB0eXBlIHthbnlbXVtdfSAqL1xuICBjb25zdCByb3dEYXRhID0gW11cblxuICAvLyBmaW5kIHdoaWNoIHJvdyBncm91cHMgdG8gcmVhZFxuICBsZXQgZ3JvdXBTdGFydCA9IDAgLy8gZmlyc3Qgcm93IGluZGV4IG9mIHRoZSBjdXJyZW50IGdyb3VwXG4gIGZvciAoY29uc3Qgcm93R3JvdXAgb2YgbWV0YWRhdGEucm93X2dyb3Vwcykge1xuICAgIC8vIG51bWJlciBvZiByb3dzIGluIHRoaXMgcm93IGdyb3VwXG4gICAgY29uc3QgZ3JvdXBSb3dzID0gTnVtYmVyKHJvd0dyb3VwLm51bV9yb3dzKVxuICAgIC8vIGlmIHJvdyBncm91cCBvdmVybGFwcyB3aXRoIHJvdyByYW5nZSwgcmVhZCBpdFxuICAgIGlmIChncm91cFN0YXJ0ICsgZ3JvdXBSb3dzID49IHJvd1N0YXJ0ICYmIChyb3dFbmQgPT09IHVuZGVmaW5lZCB8fCBncm91cFN0YXJ0IDwgcm93RW5kKSkge1xuICAgICAgLy8gcmVhZCByb3cgZ3JvdXBcbiAgICAgIGNvbnN0IGdyb3VwRGF0YSA9IGF3YWl0IHJlYWRSb3dHcm91cChvcHRpb25zLCByb3dHcm91cCwgZ3JvdXBTdGFydClcbiAgICAgIGlmIChvbkNvbXBsZXRlKSB7XG4gICAgICAgIC8vIGZpbHRlciB0byByb3dzIGluIHJhbmdlXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocm93U3RhcnQgLSBncm91cFN0YXJ0LCAwKVxuICAgICAgICBjb25zdCBlbmQgPSByb3dFbmQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJvd0VuZCAtIGdyb3VwU3RhcnRcbiAgICAgICAgY29uY2F0KHJvd0RhdGEsIGdyb3VwRGF0YS5zbGljZShzdGFydCwgZW5kKSlcbiAgICAgIH1cbiAgICB9XG4gICAgZ3JvdXBTdGFydCArPSBncm91cFJvd3NcbiAgfVxuXG4gIGlmIChvbkNvbXBsZXRlKSBvbkNvbXBsZXRlKHJvd0RhdGEpXG59XG5cbi8qKlxuICogUmVhZCBhIHJvdyBncm91cCBmcm9tIGEgZmlsZS1saWtlIG9iamVjdC5cbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzLmpzJykuUm93R3JvdXB9IFJvd0dyb3VwXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyByZWFkIG9wdGlvbnNcbiAqIEBwYXJhbSB7QXN5bmNCdWZmZXJ9IG9wdGlvbnMuZmlsZSBmaWxlLWxpa2Ugb2JqZWN0IGNvbnRhaW5pbmcgcGFycXVldCBkYXRhXG4gKiBAcGFyYW0ge0ZpbGVNZXRhRGF0YX0gW29wdGlvbnMubWV0YWRhdGFdIHBhcnF1ZXQgZmlsZSBtZXRhZGF0YVxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMuY29sdW1uc10gY29sdW1ucyB0byByZWFkLCBhbGwgY29sdW1ucyBpZiB1bmRlZmluZWRcbiAqIEBwYXJhbSB7KGNodW5rOiBDb2x1bW5EYXRhKSA9PiB2b2lkfSBbb3B0aW9ucy5vbkNodW5rXSBjYWxsZWQgd2hlbiBhIGNvbHVtbiBjaHVuayBpcyBwYXJzZWQuIGNodW5rcyBtYXkgaW5jbHVkZSByb3cgZGF0YSBvdXRzaWRlIHRoZSByZXF1ZXN0ZWQgcmFuZ2UuXG4gKiBAcGFyYW0geyhyb3dzOiBhbnlbXVtdKSA9PiB2b2lkfSBbb3B0aW9ucy5vbkNvbXBsZXRlXSBjYWxsZWQgd2hlbiBhbGwgcmVxdWVzdGVkIHJvd3MgYW5kIGNvbHVtbnMgYXJlIHBhcnNlZFxuICogQHBhcmFtIHtDb21wcmVzc29yc30gW29wdGlvbnMuY29tcHJlc3NvcnNdXG4gKiBAcGFyYW0ge1Jvd0dyb3VwfSByb3dHcm91cCByb3cgZ3JvdXAgdG8gcmVhZFxuICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwU3RhcnQgcm93IGluZGV4IG9mIHRoZSBmaXJzdCByb3cgaW4gdGhlIGdyb3VwXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnlbXVtdPn0gcmVzb2x2ZXMgdG8gcm93IGRhdGFcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZFJvd0dyb3VwKG9wdGlvbnMsIHJvd0dyb3VwLCBncm91cFN0YXJ0KSB7XG4gIGNvbnN0IHsgZmlsZSwgbWV0YWRhdGEsIGNvbHVtbnMgfSA9IG9wdGlvbnNcbiAgaWYgKCFtZXRhZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IG1ldGFkYXRhIG5vdCBmb3VuZCcpXG5cbiAgLy8gbG9vcCB0aHJvdWdoIG1ldGFkYXRhIHRvIGZpbmQgbWluL21heCBieXRlcyB0byByZWFkXG4gIGxldCBbZ3JvdXBTdGFydEJ5dGUsIGdyb3VwRW5kQnl0ZV0gPSBbZmlsZS5ieXRlTGVuZ3RoLCAwXVxuICByb3dHcm91cC5jb2x1bW5zLmZvckVhY2goKHsgbWV0YV9kYXRhOiBjb2x1bW5NZXRhZGF0YSB9KSA9PiB7XG4gICAgaWYgKCFjb2x1bW5NZXRhZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGNvbHVtbiBtZXRhZGF0YSBpcyB1bmRlZmluZWQnKVxuICAgIC8vIHNraXAgY29sdW1ucyB0aGF0IGFyZSBub3QgcmVxdWVzdGVkXG4gICAgaWYgKGNvbHVtbnMgJiYgIWNvbHVtbnMuaW5jbHVkZXMoY29sdW1uTWV0YWRhdGEucGF0aF9pbl9zY2hlbWFbMF0pKSByZXR1cm5cblxuICAgIGNvbnN0IHN0YXJ0Qnl0ZSA9IGdldENvbHVtbk9mZnNldChjb2x1bW5NZXRhZGF0YSlcbiAgICBjb25zdCBlbmRCeXRlID0gc3RhcnRCeXRlICsgTnVtYmVyKGNvbHVtbk1ldGFkYXRhLnRvdGFsX2NvbXByZXNzZWRfc2l6ZSlcbiAgICBncm91cFN0YXJ0Qnl0ZSA9IE1hdGgubWluKGdyb3VwU3RhcnRCeXRlLCBzdGFydEJ5dGUpXG4gICAgZ3JvdXBFbmRCeXRlID0gTWF0aC5tYXgoZ3JvdXBFbmRCeXRlLCBlbmRCeXRlKVxuICB9KVxuICBpZiAoZ3JvdXBTdGFydEJ5dGUgPj0gZ3JvdXBFbmRCeXRlICYmIGNvbHVtbnM/Lmxlbmd0aCkge1xuICAgIC8vIFRPRE86IHNob3VsZCB0aHJvdyBpZiBhbnkgY29sdW1uIGlzIG1pc3NpbmdcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnF1ZXQgY29sdW1ucyBub3QgZm91bmQ6ICR7Y29sdW1ucy5qb2luKCcsICcpfWApXG4gIH1cbiAgLy8gaWYgcm93IGdyb3VwIHNpemUgaXMgbGVzcyB0aGFuIDMybWIsIHByZS1sb2FkIGluIG9uZSByZWFkXG4gIGxldCBncm91cEJ1ZmZlclxuICBpZiAoZ3JvdXBFbmRCeXRlIC0gZ3JvdXBTdGFydEJ5dGUgPD0gMSA8PCAyNSkge1xuICAgIC8vIHByZS1sb2FkIHJvdyBncm91cCBieXRlIGRhdGEgaW4gb25lIGJpZyByZWFkLFxuICAgIC8vIG90aGVyd2lzZSByZWFkIGNvbHVtbiBkYXRhIGluZGl2aWR1YWxseVxuICAgIGdyb3VwQnVmZmVyID0gYXdhaXQgZmlsZS5zbGljZShncm91cFN0YXJ0Qnl0ZSwgZ3JvdXBFbmRCeXRlKVxuICB9XG5cbiAgLyoqIEB0eXBlIHthbnlbXVtdfSAqL1xuICBjb25zdCBncm91cENvbHVtbkRhdGEgPSBbXVxuICBjb25zdCBwcm9taXNlcyA9IFtdXG4gIC8vIFRvcC1sZXZlbCBjb2x1bW5zIHRvIGFzc2VtYmxlXG4gIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGdldFNjaGVtYVBhdGgobWV0YWRhdGEuc2NoZW1hLCBbXSlbMF1cbiAgY29uc3Qgc3ViY29sdW1uTmFtZXMgPSBuZXcgTWFwKGNoaWxkcmVuLm1hcChjaGlsZCA9PiBbY2hpbGQuZWxlbWVudC5uYW1lLCBnZXRTdWJjb2x1bW5zKGNoaWxkKV0pKVxuICBjb25zdCBzdWJjb2x1bW5EYXRhID0gbmV3IE1hcCgpIC8vIGNvbHVtbnMgdG8gYXNzZW1ibGUgYXMgbWFwc1xuICAvLyByZWFkIGNvbHVtbiBkYXRhXG4gIGZvciAobGV0IGNvbHVtbkluZGV4ID0gMDsgY29sdW1uSW5kZXggPCByb3dHcm91cC5jb2x1bW5zLmxlbmd0aDsgY29sdW1uSW5kZXgrKykge1xuICAgIGNvbnN0IGNvbHVtbk1ldGFkYXRhID0gcm93R3JvdXAuY29sdW1uc1tjb2x1bW5JbmRleF0ubWV0YV9kYXRhXG4gICAgaWYgKCFjb2x1bW5NZXRhZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdwYXJxdWV0IGNvbHVtbiBtZXRhZGF0YSBpcyB1bmRlZmluZWQnKVxuXG4gICAgLy8gc2tpcCBjb2x1bW5zIHRoYXQgYXJlIG5vdCByZXF1ZXN0ZWRcbiAgICBjb25zdCBjb2x1bW5OYW1lID0gY29sdW1uTWV0YWRhdGEucGF0aF9pbl9zY2hlbWFbMF1cbiAgICBpZiAoY29sdW1ucyAmJiAhY29sdW1ucy5pbmNsdWRlcyhjb2x1bW5OYW1lKSkgY29udGludWVcblxuICAgIGNvbnN0IGNvbHVtblN0YXJ0Qnl0ZSA9IGdldENvbHVtbk9mZnNldChjb2x1bW5NZXRhZGF0YSlcbiAgICBjb25zdCBjb2x1bW5FbmRCeXRlID0gY29sdW1uU3RhcnRCeXRlICsgTnVtYmVyKGNvbHVtbk1ldGFkYXRhLnRvdGFsX2NvbXByZXNzZWRfc2l6ZSlcbiAgICBjb25zdCBjb2x1bW5CeXRlcyA9IGNvbHVtbkVuZEJ5dGUgLSBjb2x1bW5TdGFydEJ5dGVcblxuICAgIC8vIHNraXAgY29sdW1ucyBsYXJnZXIgdGhhbiAxZ2JcbiAgICAvLyBUT0RPOiBzdHJlYW0gcHJvY2VzcyB0aGUgZGF0YSwgcmV0dXJuaW5nIG9ubHkgdGhlIHJlcXVlc3RlZCByb3dzXG4gICAgaWYgKGNvbHVtbkJ5dGVzID4gMSA8PCAzMCkge1xuICAgICAgY29uc29sZS53YXJuKGBwYXJxdWV0IHNraXBwaW5nIGh1Z2UgY29sdW1uIFwiJHtjb2x1bW5NZXRhZGF0YS5wYXRoX2luX3NjaGVtYX1cIiAke2NvbHVtbkJ5dGVzLnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzYClcbiAgICAgIC8vIFRPRE86IHNldCBjb2x1bW4gdG8gbmV3IEVycm9yKCdwYXJxdWV0IGNvbHVtbiB0b28gbGFyZ2UnKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyB1c2UgcHJlLWxvYWRlZCByb3cgZ3JvdXAgYnl0ZSBkYXRhIGlmIGF2YWlsYWJsZSwgZWxzZSByZWFkIGNvbHVtbiBkYXRhXG4gICAgLyoqIEB0eXBlIHtQcm9taXNlPEFycmF5QnVmZmVyPn0gKi9cbiAgICBsZXQgYnVmZmVyXG4gICAgbGV0IGJ1ZmZlck9mZnNldCA9IDBcbiAgICBpZiAoZ3JvdXBCdWZmZXIpIHtcbiAgICAgIGJ1ZmZlciA9IFByb21pc2UucmVzb2x2ZShncm91cEJ1ZmZlcilcbiAgICAgIGJ1ZmZlck9mZnNldCA9IGNvbHVtblN0YXJ0Qnl0ZSAtIGdyb3VwU3RhcnRCeXRlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdyYXAgYXdhaXRhYmxlIHRvIGVuc3VyZSBpdCdzIGEgcHJvbWlzZVxuICAgICAgYnVmZmVyID0gUHJvbWlzZS5yZXNvbHZlKGZpbGUuc2xpY2UoY29sdW1uU3RhcnRCeXRlLCBjb2x1bW5FbmRCeXRlKSlcbiAgICB9XG5cbiAgICAvLyByZWFkIGNvbHVtbiBkYXRhIGFzeW5jXG4gICAgcHJvbWlzZXMucHVzaChidWZmZXIudGhlbihhcnJheUJ1ZmZlciA9PiB7XG4gICAgICBjb25zdCBzY2hlbWFQYXRoID0gZ2V0U2NoZW1hUGF0aChtZXRhZGF0YS5zY2hlbWEsIGNvbHVtbk1ldGFkYXRhLnBhdGhfaW5fc2NoZW1hKVxuICAgICAgY29uc3QgcmVhZGVyID0geyB2aWV3OiBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpLCBvZmZzZXQ6IGJ1ZmZlck9mZnNldCB9XG4gICAgICAvKiogQHR5cGUge2FueVtdIHwgdW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IGNvbHVtbkRhdGEgPSByZWFkQ29sdW1uKHJlYWRlciwgcm93R3JvdXAsIGNvbHVtbk1ldGFkYXRhLCBzY2hlbWFQYXRoLCBvcHRpb25zKVxuICAgICAgLy8gYXNzZXJ0KGNvbHVtbkRhdGEubGVuZ3RoID09PSBOdW1iZXIocm93R3JvdXAubnVtX3Jvd3MpXG5cbiAgICAgIC8vIFRPRE86IGZhc3QgcGF0aCBmb3Igbm9uLW5lc3RlZCBjb2x1bW5zXG4gICAgICAvLyBTYXZlIGNvbHVtbiBkYXRhIGZvciBhc3NlbWJseVxuICAgICAgY29uc3Qgc3ViY29sdW1uID0gY29sdW1uTWV0YWRhdGEucGF0aF9pbl9zY2hlbWEuam9pbignLicpXG4gICAgICBzdWJjb2x1bW5EYXRhLnNldChzdWJjb2x1bW4sIGNvbHVtbkRhdGEpXG4gICAgICBjb2x1bW5EYXRhID0gdW5kZWZpbmVkXG5cbiAgICAgIGNvbnN0IHN1YmNvbHVtbnMgPSBzdWJjb2x1bW5OYW1lcy5nZXQoY29sdW1uTmFtZSlcbiAgICAgIGlmIChzdWJjb2x1bW5zPy5ldmVyeShuYW1lID0+IHN1YmNvbHVtbkRhdGEuaGFzKG5hbWUpKSkge1xuICAgICAgICAvLyBXZSBoYXZlIGFsbCBkYXRhIG5lZWRlZCB0byBhc3NlbWJsZSBhIHRvcCBsZXZlbCBjb2x1bW5cbiAgICAgICAgYXNzZW1ibGVOZXN0ZWQoc3ViY29sdW1uRGF0YSwgc2NoZW1hUGF0aFsxXSlcbiAgICAgICAgY29sdW1uRGF0YSA9IHN1YmNvbHVtbkRhdGEuZ2V0KGNvbHVtbk5hbWUpXG4gICAgICAgIGlmICghY29sdW1uRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFycXVldCBjb2x1bW4gZGF0YSBub3QgYXNzZW1ibGVkOiAke2NvbHVtbk5hbWV9YClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkbyBub3QgZW1pdCBjb2x1bW4gZGF0YSB1bnRpbCBzdHJ1Y3RzIGFyZSBmdWxseSBwYXJzZWRcbiAgICAgIGlmICghY29sdW1uRGF0YSkgcmV0dXJuXG4gICAgICAvLyBub3RpZnkgY2FsbGVyIG9mIGNvbHVtbiBkYXRhXG4gICAgICBvcHRpb25zLm9uQ2h1bms/Lih7XG4gICAgICAgIGNvbHVtbk5hbWUsXG4gICAgICAgIGNvbHVtbkRhdGEsXG4gICAgICAgIHJvd1N0YXJ0OiBncm91cFN0YXJ0LFxuICAgICAgICByb3dFbmQ6IGdyb3VwU3RhcnQgKyBjb2x1bW5EYXRhLmxlbmd0aCxcbiAgICAgIH0pXG4gICAgICAvLyBzYXZlIGNvbHVtbiBkYXRhIG9ubHkgaWYgb25Db21wbGV0ZSBpcyBkZWZpbmVkXG4gICAgICBpZiAob3B0aW9ucy5vbkNvbXBsZXRlKSBncm91cENvbHVtbkRhdGEucHVzaChjb2x1bW5EYXRhKVxuICAgIH0pKVxuICB9XG4gIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuICBpZiAob3B0aW9ucy5vbkNvbXBsZXRlKSB7XG4gICAgLy8gdHJhbnNwb3NlIGNvbHVtbnMgaW50byByb3dzXG4gICAgcmV0dXJuIGdyb3VwQ29sdW1uRGF0YVswXS5tYXAoKF8sIHJvdykgPT4gZ3JvdXBDb2x1bW5EYXRhLm1hcChjb2wgPT4gY29sW3Jvd10pKVxuICB9XG4gIHJldHVybiBbXVxufVxuXG5cbi8qKlxuICogUmV0dXJuIGEgbGlzdCBvZiBzdWItY29sdW1ucyBuZWVkZWQgdG8gY29uc3RydWN0IGEgdG9wLWxldmVsIGNvbHVtbi5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy5qcycpLlNjaGVtYVRyZWV9IHNjaGVtYVxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3V0cHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIGdldFN1YmNvbHVtbnMoc2NoZW1hLCBvdXRwdXQgPSBbXSkge1xuICBpZiAoc2NoZW1hLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc2NoZW1hLmNoaWxkcmVuKSB7XG4gICAgICBnZXRTdWJjb2x1bW5zKGNoaWxkLCBvdXRwdXQpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dHB1dC5wdXNoKHNjaGVtYS5wYXRoLmpvaW4oJy4nKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0XG59XG4iLCIvKipcbiAqIEJ1aWxkIGEgdHJlZSBmcm9tIHRoZSBzY2hlbWEgZWxlbWVudHMuXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcy5qcycpLlNjaGVtYUVsZW1lbnR9IFNjaGVtYUVsZW1lbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5TY2hlbWFUcmVlfSBTY2hlbWFUcmVlXG4gKiBAcGFyYW0ge1NjaGVtYUVsZW1lbnRbXX0gc2NoZW1hXG4gKiBAcGFyYW0ge251bWJlcn0gcm9vdEluZGV4IGluZGV4IG9mIHRoZSByb290IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGggcGF0aCB0byB0aGUgZWxlbWVudFxuICogQHJldHVybnMge1NjaGVtYVRyZWV9IHRyZWUgb2Ygc2NoZW1hIGVsZW1lbnRzXG4gKi9cbmZ1bmN0aW9uIHNjaGVtYVRyZWUoc2NoZW1hLCByb290SW5kZXgsIHBhdGgpIHtcbiAgY29uc3QgZWxlbWVudCA9IHNjaGVtYVtyb290SW5kZXhdXG4gIGNvbnN0IGNoaWxkcmVuID0gW11cbiAgbGV0IGNvdW50ID0gMVxuXG4gIC8vIFJlYWQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgY2hpbGRyZW5cbiAgaWYgKGVsZW1lbnQubnVtX2NoaWxkcmVuKSB7XG4gICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA8IGVsZW1lbnQubnVtX2NoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZEVsZW1lbnQgPSBzY2hlbWFbcm9vdEluZGV4ICsgY291bnRdXG4gICAgICBjb25zdCBjaGlsZCA9IHNjaGVtYVRyZWUoc2NoZW1hLCByb290SW5kZXggKyBjb3VudCwgWy4uLnBhdGgsIGNoaWxkRWxlbWVudC5uYW1lXSlcbiAgICAgIGNvdW50ICs9IGNoaWxkLmNvdW50XG4gICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGNvdW50LCBlbGVtZW50LCBjaGlsZHJlbiwgcGF0aCB9XG59XG5cbi8qKlxuICogR2V0IHNjaGVtYSBlbGVtZW50cyBmcm9tIHRoZSByb290IHRvIHRoZSBnaXZlbiBlbGVtZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtTY2hlbWFFbGVtZW50W119IHNjaGVtYVxuICogQHBhcmFtIHtzdHJpbmdbXX0gbmFtZSBwYXRoIHRvIHRoZSBlbGVtZW50XG4gKiBAcmV0dXJucyB7U2NoZW1hVHJlZVtdfSBsaXN0IG9mIHNjaGVtYSBlbGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hUGF0aChzY2hlbWEsIG5hbWUpIHtcbiAgbGV0IHRyZWUgPSBzY2hlbWFUcmVlKHNjaGVtYSwgMCwgW10pXG4gIGNvbnN0IHBhdGggPSBbdHJlZV1cbiAgZm9yIChjb25zdCBwYXJ0IG9mIG5hbWUpIHtcbiAgICBjb25zdCBjaGlsZCA9IHRyZWUuY2hpbGRyZW4uZmluZChjaGlsZCA9PiBjaGlsZC5lbGVtZW50Lm5hbWUgPT09IHBhcnQpXG4gICAgaWYgKCFjaGlsZCkgdGhyb3cgbmV3IEVycm9yKGBwYXJxdWV0IHNjaGVtYSBlbGVtZW50IG5vdCBmb3VuZDogJHtuYW1lfWApXG4gICAgcGF0aC5wdXNoKGNoaWxkKVxuICAgIHRyZWUgPSBjaGlsZFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbi8qKlxuICogR2V0IHRoZSBtYXggcmVwZXRpdGlvbiBsZXZlbCBmb3IgYSBnaXZlbiBzY2hlbWEgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYVRyZWVbXX0gc2NoZW1hUGF0aFxuICogQHJldHVybnMge251bWJlcn0gbWF4IHJlcGV0aXRpb24gbGV2ZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1heFJlcGV0aXRpb25MZXZlbChzY2hlbWFQYXRoKSB7XG4gIGxldCBtYXhMZXZlbCA9IDBcbiAgZm9yIChjb25zdCB7IGVsZW1lbnQgfSBvZiBzY2hlbWFQYXRoKSB7XG4gICAgaWYgKGVsZW1lbnQucmVwZXRpdGlvbl90eXBlID09PSAnUkVQRUFURUQnKSB7XG4gICAgICBtYXhMZXZlbCsrXG4gICAgfVxuICB9XG4gIHJldHVybiBtYXhMZXZlbFxufVxuXG4vKipcbiAqIEdldCB0aGUgbWF4IGRlZmluaXRpb24gbGV2ZWwgZm9yIGEgZ2l2ZW4gc2NoZW1hIHBhdGguXG4gKlxuICogQHBhcmFtIHtTY2hlbWFUcmVlW119IHNjaGVtYVBhdGhcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1heCBkZWZpbml0aW9uIGxldmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXhEZWZpbml0aW9uTGV2ZWwoc2NoZW1hUGF0aCkge1xuICBsZXQgbWF4TGV2ZWwgPSAwXG4gIGZvciAoY29uc3QgeyBlbGVtZW50IH0gb2Ygc2NoZW1hUGF0aC5zbGljZSgxKSkge1xuICAgIGlmIChlbGVtZW50LnJlcGV0aXRpb25fdHlwZSAhPT0gJ1JFUVVJUkVEJykge1xuICAgICAgbWF4TGV2ZWwrK1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4TGV2ZWxcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbHVtbiBpcyBsaXN0LWxpa2UuXG4gKlxuICogQHBhcmFtIHtTY2hlbWFUcmVlfSBzY2hlbWFcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGxpc3QtbGlrZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMaXN0TGlrZShzY2hlbWEpIHtcbiAgaWYgKCFzY2hlbWEpIHJldHVybiBmYWxzZVxuICBpZiAoc2NoZW1hLmVsZW1lbnQuY29udmVydGVkX3R5cGUgIT09ICdMSVNUJykgcmV0dXJuIGZhbHNlXG4gIGlmIChzY2hlbWEuY2hpbGRyZW4ubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgZmlyc3RDaGlsZCA9IHNjaGVtYS5jaGlsZHJlblswXVxuICBpZiAoZmlyc3RDaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2VcbiAgaWYgKGZpcnN0Q2hpbGQuZWxlbWVudC5yZXBldGl0aW9uX3R5cGUgIT09ICdSRVBFQVRFRCcpIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjb2x1bW4gaXMgbWFwLWxpa2UuXG4gKlxuICogQHBhcmFtIHtTY2hlbWFUcmVlfSBzY2hlbWFcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIG1hcC1saWtlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc01hcExpa2Uoc2NoZW1hKSB7XG4gIGlmICghc2NoZW1hKSByZXR1cm4gZmFsc2VcbiAgaWYgKHNjaGVtYS5lbGVtZW50LmNvbnZlcnRlZF90eXBlICE9PSAnTUFQJykgcmV0dXJuIGZhbHNlXG4gIGlmIChzY2hlbWEuY2hpbGRyZW4ubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgZmlyc3RDaGlsZCA9IHNjaGVtYS5jaGlsZHJlblswXVxuICBpZiAoZmlyc3RDaGlsZC5jaGlsZHJlbi5sZW5ndGggIT09IDIpIHJldHVybiBmYWxzZVxuICBpZiAoZmlyc3RDaGlsZC5lbGVtZW50LnJlcGV0aXRpb25fdHlwZSAhPT0gJ1JFUEVBVEVEJykgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3Qga2V5Q2hpbGQgPSBmaXJzdENoaWxkLmNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQuZWxlbWVudC5uYW1lID09PSAna2V5JylcbiAgaWYgKGtleUNoaWxkPy5lbGVtZW50LnJlcGV0aXRpb25fdHlwZSA9PT0gJ1JFUEVBVEVEJykgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgdmFsdWVDaGlsZCA9IGZpcnN0Q2hpbGQuY2hpbGRyZW4uZmluZChjaGlsZCA9PiBjaGlsZC5lbGVtZW50Lm5hbWUgPT09ICd2YWx1ZScpXG4gIGlmICh2YWx1ZUNoaWxkPy5lbGVtZW50LnJlcGV0aXRpb25fdHlwZSA9PT0gJ1JFUEVBVEVEJykgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgWmhpcGVuZyBKaWFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS96aGlwZW5nLWppYS9zbmFwcHlqc1xuICovXG5cbmNvbnN0IFdPUkRfTUFTSyA9IFswLCAweGZmLCAweGZmZmYsIDB4ZmZmZmZmLCAweGZmZmZmZmZmXVxuXG4vKipcbiAqIENvcHkgYnl0ZXMgZnJvbSBvbmUgYXJyYXkgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZnJvbUFycmF5IHNvdXJjZSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21Qb3Mgc291cmNlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHRvQXJyYXkgZGVzdGluYXRpb24gYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b1BvcyBkZXN0aW5hdGlvbiBwb3NpdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgdG8gY29weVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGNvcHlCeXRlcyhmcm9tQXJyYXksIGZyb21Qb3MsIHRvQXJyYXksIHRvUG9zLCBsZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRvQXJyYXlbdG9Qb3MgKyBpXSA9IGZyb21BcnJheVtmcm9tUG9zICsgaV1cbiAgfVxufVxuXG4vKipcbiAqIENvcHkgYnl0ZXMgd2l0aGluIGFuIGFycmF5XG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnJheSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIHNvdXJjZSBwb3NpdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBvZmZzZXQgYmFjayBmcm9tIGN1cnJlbnQgcG9zaXRpb24gdG8gcmVhZFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgdG8gY29weVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHNlbGZDb3B5Qnl0ZXMoYXJyYXksIHBvcywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFycmF5W3BvcyArIGldID0gYXJyYXlbcG9zIC0gb2Zmc2V0ICsgaV1cbiAgfVxufVxuXG4vKipcbiAqIERlY29tcHJlc3Mgc25hcHB5IGRhdGEuXG4gKiBBY2NlcHRzIGFuIG91dHB1dCBidWZmZXIgdG8gYXZvaWQgYWxsb2NhdGluZyBhIG5ldyBidWZmZXIgZm9yIGVhY2ggY2FsbC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0IGNvbXByZXNzZWQgZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBvdXRwdXQgb3V0cHV0IGJ1ZmZlclxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbmFwcHlVbmNvbXByZXNzKGlucHV0LCBvdXRwdXQpIHtcbiAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5ieXRlTGVuZ3RoXG4gIGNvbnN0IG91dHB1dExlbmd0aCA9IG91dHB1dC5ieXRlTGVuZ3RoXG4gIGxldCBwb3MgPSAwXG4gIGxldCBvdXRQb3MgPSAwXG5cbiAgLy8gc2tpcCBwcmVhbWJsZSAoY29udGFpbnMgdW5jb21wcmVzc2VkIGxlbmd0aCBhcyB2YXJpbnQpXG4gIHdoaWxlIChwb3MgPCBpbnB1dExlbmd0aCkge1xuICAgIGNvbnN0IGMgPSBpbnB1dFtwb3NdXG4gICAgcG9zKytcbiAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dExlbmd0aCAmJiBwb3MgPj0gaW5wdXRMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc25hcHB5IGxlbmd0aCBoZWFkZXInKVxuICB9XG5cbiAgd2hpbGUgKHBvcyA8IGlucHV0TGVuZ3RoKSB7XG4gICAgY29uc3QgYyA9IGlucHV0W3Bvc11cbiAgICBsZXQgbGVuID0gMFxuICAgIHBvcysrXG5cbiAgICBpZiAocG9zID49IGlucHV0TGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgZW9mIG1hcmtlcicpXG4gICAgfVxuXG4gICAgLy8gVGhlcmUgYXJlIHR3byB0eXBlcyBvZiBlbGVtZW50cywgbGl0ZXJhbHMgYW5kIGNvcGllcyAoYmFjayByZWZlcmVuY2VzKVxuICAgIGlmICgoYyAmIDB4MykgPT09IDApIHtcbiAgICAgIC8vIExpdGVyYWxzIGFyZSB1bmNvbXByZXNzZWQgZGF0YSBzdG9yZWQgZGlyZWN0bHkgaW4gdGhlIGJ5dGUgc3RyZWFtXG4gICAgICBsZXQgbGVuID0gKGMgPj4+IDIpICsgMVxuICAgICAgLy8gTG9uZ2VyIGxpdGVyYWwgbGVuZ3RoIGlzIGVuY29kZWQgaW4gbXVsdGlwbGUgYnl0ZXNcbiAgICAgIGlmIChsZW4gPiA2MCkge1xuICAgICAgICBpZiAocG9zICsgMyA+PSBpbnB1dExlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc25hcHB5IGVycm9yIGxpdGVyYWwgcG9zICsgMyA+PSBpbnB1dExlbmd0aCcpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoU2l6ZSA9IGxlbiAtIDYwIC8vIGxlbmd0aCBieXRlcyAtIDFcbiAgICAgICAgbGVuID0gaW5wdXRbcG9zXVxuICAgICAgICAgICsgKGlucHV0W3BvcyArIDFdIDw8IDgpXG4gICAgICAgICAgKyAoaW5wdXRbcG9zICsgMl0gPDwgMTYpXG4gICAgICAgICAgKyAoaW5wdXRbcG9zICsgM10gPDwgMjQpXG4gICAgICAgIGxlbiA9IChsZW4gJiBXT1JEX01BU0tbbGVuZ3RoU2l6ZV0pICsgMVxuICAgICAgICBwb3MgKz0gbGVuZ3RoU2l6ZVxuICAgICAgfVxuICAgICAgaWYgKHBvcyArIGxlbiA+IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc25hcHB5IGVycm9yIGxpdGVyYWwgZXhjZWVkcyBpbnB1dCBsZW5ndGgnKVxuICAgICAgfVxuICAgICAgY29weUJ5dGVzKGlucHV0LCBwb3MsIG91dHB1dCwgb3V0UG9zLCBsZW4pXG4gICAgICBwb3MgKz0gbGVuXG4gICAgICBvdXRQb3MgKz0gbGVuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvcHkgZWxlbWVudHNcbiAgICAgIGxldCBvZmZzZXQgPSAwIC8vIG9mZnNldCBiYWNrIGZyb20gY3VycmVudCBwb3NpdGlvbiB0byByZWFkXG4gICAgICBzd2l0Y2ggKGMgJiAweDMpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLy8gQ29weSB3aXRoIDEtYnl0ZSBvZmZzZXRcbiAgICAgICAgbGVuID0gKGMgPj4+IDIgJiAweDcpICsgNFxuICAgICAgICBvZmZzZXQgPSBpbnB1dFtwb3NdICsgKGMgPj4+IDUgPDwgOClcbiAgICAgICAgcG9zKytcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gQ29weSB3aXRoIDItYnl0ZSBvZmZzZXRcbiAgICAgICAgaWYgKGlucHV0TGVuZ3RoIDw9IHBvcyArIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NuYXBweSBlcnJvciBlbmQgb2YgaW5wdXQnKVxuICAgICAgICB9XG4gICAgICAgIGxlbiA9IChjID4+PiAyKSArIDFcbiAgICAgICAgb2Zmc2V0ID0gaW5wdXRbcG9zXSArIChpbnB1dFtwb3MgKyAxXSA8PCA4KVxuICAgICAgICBwb3MgKz0gMlxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyBDb3B5IHdpdGggNC1ieXRlIG9mZnNldFxuICAgICAgICBpZiAoaW5wdXRMZW5ndGggPD0gcG9zICsgMykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc25hcHB5IGVycm9yIGVuZCBvZiBpbnB1dCcpXG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gKGMgPj4+IDIpICsgMVxuICAgICAgICBvZmZzZXQgPSBpbnB1dFtwb3NdXG4gICAgICAgICAgKyAoaW5wdXRbcG9zICsgMV0gPDwgOClcbiAgICAgICAgICArIChpbnB1dFtwb3MgKyAyXSA8PCAxNilcbiAgICAgICAgICArIChpbnB1dFtwb3MgKyAzXSA8PCAyNClcbiAgICAgICAgcG9zICs9IDRcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0ID09PSAwIHx8IGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9mZnNldCAke29mZnNldH0gcG9zICR7cG9zfSBpbnB1dExlbmd0aCAke2lucHV0TGVuZ3RofWApXG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0ID4gb3V0UG9zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNvcHkgZnJvbSBiZWZvcmUgc3RhcnQgb2YgYnVmZmVyJylcbiAgICAgIH1cbiAgICAgIHNlbGZDb3B5Qnl0ZXMob3V0cHV0LCBvdXRQb3MsIG9mZnNldCwgbGVuKVxuICAgICAgb3V0UG9zICs9IGxlblxuICAgIH1cbiAgfVxuXG4gIGlmIChvdXRQb3MgIT09IG91dHB1dExlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdwcmVtYXR1cmUgZW5kIG9mIGlucHV0Jylcbn1cbiIsIi8vIFRDb21wYWN0UHJvdG9jb2wgdHlwZXNcbmNvbnN0IENvbXBhY3RUeXBlID0ge1xuICBTVE9QOiAwLFxuICBUUlVFOiAxLFxuICBGQUxTRTogMixcbiAgQllURTogMyxcbiAgSTE2OiA0LFxuICBJMzI6IDUsXG4gIEk2NDogNixcbiAgRE9VQkxFOiA3LFxuICBCSU5BUlk6IDgsXG4gIExJU1Q6IDksXG4gIFNFVDogMTAsXG4gIE1BUDogMTEsXG4gIFNUUlVDVDogMTIsXG4gIFVVSUQ6IDEzLFxufVxuXG4vKipcbiAqIFBhcnNlIFRDb21wYWN0UHJvdG9jb2xcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5kLnRzXCIpLkRhdGFSZWFkZXJ9IERhdGFSZWFkZXJcbiAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplVENvbXBhY3RQcm90b2NvbChyZWFkZXIpIHtcbiAgbGV0IGxhc3RGaWQgPSAwXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgY29uc3QgdmFsdWUgPSB7fVxuXG4gIHdoaWxlIChyZWFkZXIub2Zmc2V0IDwgcmVhZGVyLnZpZXcuYnl0ZUxlbmd0aCkge1xuICAgIC8vIFBhcnNlIGVhY2ggZmllbGQgYmFzZWQgb24gaXRzIHR5cGUgYW5kIGFkZCB0byB0aGUgcmVzdWx0IG9iamVjdFxuICAgIGNvbnN0IFt0eXBlLCBmaWQsIG5ld0xhc3RGaWRdID0gcmVhZEZpZWxkQmVnaW4ocmVhZGVyLCBsYXN0RmlkKVxuICAgIGxhc3RGaWQgPSBuZXdMYXN0RmlkXG5cbiAgICBpZiAodHlwZSA9PT0gQ29tcGFjdFR5cGUuU1RPUCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIGZpZWxkIGJhc2VkIG9uIGl0cyB0eXBlXG4gICAgdmFsdWVbYGZpZWxkXyR7ZmlkfWBdID0gcmVhZEVsZW1lbnQocmVhZGVyLCB0eXBlKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogUmVhZCBhIHNpbmdsZSBlbGVtZW50IGJhc2VkIG9uIGl0cyB0eXBlXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcmV0dXJucyB7YW55fSB2YWx1ZVxuICovXG5mdW5jdGlvbiByZWFkRWxlbWVudChyZWFkZXIsIHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgQ29tcGFjdFR5cGUuVFJVRTpcbiAgICByZXR1cm4gdHJ1ZVxuICBjYXNlIENvbXBhY3RUeXBlLkZBTFNFOlxuICAgIHJldHVybiBmYWxzZVxuICBjYXNlIENvbXBhY3RUeXBlLkJZVEU6XG4gICAgLy8gcmVhZCBieXRlIGRpcmVjdGx5XG4gICAgcmV0dXJuIHJlYWRlci52aWV3LmdldEludDgocmVhZGVyLm9mZnNldCsrKVxuICBjYXNlIENvbXBhY3RUeXBlLkkxNjpcbiAgY2FzZSBDb21wYWN0VHlwZS5JMzI6XG4gICAgcmV0dXJuIHJlYWRaaWdaYWcocmVhZGVyKVxuICBjYXNlIENvbXBhY3RUeXBlLkk2NDpcbiAgICByZXR1cm4gcmVhZFppZ1phZ0JpZ0ludChyZWFkZXIpXG4gIGNhc2UgQ29tcGFjdFR5cGUuRE9VQkxFOiB7XG4gICAgY29uc3QgdmFsdWUgPSByZWFkZXIudmlldy5nZXRGbG9hdDY0KHJlYWRlci5vZmZzZXQsIHRydWUpXG4gICAgcmVhZGVyLm9mZnNldCArPSA4XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgY2FzZSBDb21wYWN0VHlwZS5CSU5BUlk6IHtcbiAgICBjb25zdCBzdHJpbmdMZW5ndGggPSByZWFkVmFySW50KHJlYWRlcilcbiAgICBjb25zdCBzdHJCeXRlcyA9IG5ldyBVaW50OEFycmF5KHJlYWRlci52aWV3LmJ1ZmZlciwgcmVhZGVyLnZpZXcuYnl0ZU9mZnNldCArIHJlYWRlci5vZmZzZXQsIHN0cmluZ0xlbmd0aClcbiAgICByZWFkZXIub2Zmc2V0ICs9IHN0cmluZ0xlbmd0aFxuICAgIHJldHVybiBzdHJCeXRlc1xuICB9XG4gIGNhc2UgQ29tcGFjdFR5cGUuTElTVDoge1xuICAgIGNvbnN0IFtlbGVtVHlwZSwgbGlzdFNpemVdID0gcmVhZENvbGxlY3Rpb25CZWdpbihyZWFkZXIpXG4gICAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KGxpc3RTaXplKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdFNpemU7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gcmVhZEVsZW1lbnQocmVhZGVyLCBlbGVtVHlwZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlc1xuICB9XG4gIGNhc2UgQ29tcGFjdFR5cGUuU1RSVUNUOiB7XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqL1xuICAgIGNvbnN0IHN0cnVjdFZhbHVlcyA9IHt9XG4gICAgbGV0IHN0cnVjdExhc3RGaWQgPSAwXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBzdHJ1Y3RGaWVsZFR5cGUsIHN0cnVjdEZpZFxuICAgICAgW3N0cnVjdEZpZWxkVHlwZSwgc3RydWN0RmlkLCBzdHJ1Y3RMYXN0RmlkXSA9IHJlYWRGaWVsZEJlZ2luKHJlYWRlciwgc3RydWN0TGFzdEZpZClcbiAgICAgIGlmIChzdHJ1Y3RGaWVsZFR5cGUgPT09IENvbXBhY3RUeXBlLlNUT1ApIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHN0cnVjdFZhbHVlc1tgZmllbGRfJHtzdHJ1Y3RGaWR9YF0gPSByZWFkRWxlbWVudChyZWFkZXIsIHN0cnVjdEZpZWxkVHlwZSlcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdFZhbHVlc1xuICB9XG4gIC8vIFRPRE86IE1BUCBhbmQgU0VUXG4gIGNhc2UgQ29tcGFjdFR5cGUuVVVJRDoge1xuICAgIC8vIFJlYWQgMTYgYnl0ZXMgdG8gdXVpZCBzdHJpbmdcbiAgICBsZXQgdXVpZCA9ICcnXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB1dWlkICs9IHJlYWRlci52aWV3LmdldFVpbnQ4KHJlYWRlci5vZmZzZXQrKykudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJylcbiAgICB9XG4gICAgcmV0dXJuIHV1aWRcbiAgfVxuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihgdGhyaWZ0IHVuaGFuZGxlZCB0eXBlOiAke3R5cGV9YClcbiAgfVxufVxuXG4vKipcbiAqIFZhciBpbnQsIGFsc28ga25vd24gYXMgVW5zaWduZWQgTEVCMTI4LlxuICogVmFyIGludHMgdGFrZSAxIHRvIDUgYnl0ZXMgKGludDMyKSBvciAxIHRvIDEwIGJ5dGVzIChpbnQ2NCkuXG4gKiBUYWtlcyBhIEJpZyBFbmRpYW4gdW5zaWduZWQgaW50ZWdlciwgbGVmdC1wYWRzIHRoZSBiaXQtc3RyaW5nIHRvIG1ha2UgaXQgYVxuICogbXVsdGlwbGUgb2YgNyBiaXRzLCBzcGxpdHMgaXQgaW50byA3LWJpdCBncm91cHMsIHByZWZpeCB0aGUgbW9zdC1zaWduaWZpY2FudFxuICogNy1iaXQgZ3JvdXAgd2l0aCB0aGUgMCBiaXQsIHByZWZpeGluZyB0aGUgcmVtYWluaW5nIDctYml0IGdyb3VwcyB3aXRoIHRoZVxuICogMSBiaXQgYW5kIGVuY29kZSB0aGUgcmVzdWx0aW5nIGJpdC1zdHJpbmcgYXMgTGl0dGxlIEVuZGlhbi5cbiAqXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRWYXJJbnQocmVhZGVyKSB7XG4gIGxldCByZXN1bHQgPSAwXG4gIGxldCBzaGlmdCA9IDBcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBieXRlID0gcmVhZGVyLnZpZXcuZ2V0VWludDgocmVhZGVyLm9mZnNldCsrKVxuICAgIHJlc3VsdCB8PSAoYnl0ZSAmIDB4N2YpIDw8IHNoaWZ0XG4gICAgaWYgKCEoYnl0ZSAmIDB4ODApKSB7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIHNoaWZ0ICs9IDdcbiAgfVxufVxuXG4vKipcbiAqIFJlYWQgYSB2YXJpbnQgYXMgYSBiaWdpbnQuXG4gKlxuICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXJcbiAqIEByZXR1cm5zIHtiaWdpbnR9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHJlYWRWYXJCaWdJbnQocmVhZGVyKSB7XG4gIGxldCByZXN1bHQgPSAwblxuICBsZXQgc2hpZnQgPSAwblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGJ5dGUgPSByZWFkZXIudmlldy5nZXRVaW50OChyZWFkZXIub2Zmc2V0KyspXG4gICAgcmVzdWx0IHw9IEJpZ0ludChieXRlICYgMHg3ZikgPDwgc2hpZnRcbiAgICBpZiAoIShieXRlICYgMHg4MCkpIHtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgc2hpZnQgKz0gN25cbiAgfVxufVxuXG4vKipcbiAqIFZhbHVlcyBvZiB0eXBlIGludDMyIGFuZCBpbnQ2NCBhcmUgdHJhbnNmb3JtZWQgdG8gYSB6aWd6YWcgaW50LlxuICogQSB6aWd6YWcgaW50IGZvbGRzIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBudW1iZXJzIGludG8gdGhlIHBvc2l0aXZlIG51bWJlciBzcGFjZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gcmVhZFppZ1phZyhyZWFkZXIpIHtcbiAgY29uc3QgemlnemFnID0gcmVhZFZhckludChyZWFkZXIpXG4gIC8vIGNvbnZlcnQgemlnemFnIHRvIGludFxuICByZXR1cm4gemlnemFnID4+PiAxIF4gLSh6aWd6YWcgJiAxKVxufVxuXG4vKipcbiAqIEEgemlnemFnIGludCBmb2xkcyBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgbnVtYmVycyBpbnRvIHRoZSBwb3NpdGl2ZSBudW1iZXIgc3BhY2UuXG4gKiBUaGlzIHZlcnNpb24gcmV0dXJucyBhIEJpZ0ludC5cbiAqXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHJldHVybnMge2JpZ2ludH0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRaaWdaYWdCaWdJbnQocmVhZGVyKSB7XG4gIGNvbnN0IHppZ3phZyA9IHJlYWRWYXJCaWdJbnQocmVhZGVyKVxuICAvLyBjb252ZXJ0IHppZ3phZyB0byBpbnRcbiAgcmV0dXJuIHppZ3phZyA+PiBCaWdJbnQoMSkgXiAtKHppZ3phZyAmIEJpZ0ludCgxKSlcbn1cblxuLyoqXG4gKiBHZXQgdGhyaWZ0IHR5cGUgZnJvbSBoYWxmIGEgYnl0ZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRDb21wYWN0VHlwZShieXRlKSB7XG4gIHJldHVybiBieXRlICYgMHgwZlxufVxuXG4vKipcbiAqIFJlYWQgZmllbGQgdHlwZSBhbmQgZmllbGQgaWRcbiAqXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHBhcmFtIHtudW1iZXJ9IGxhc3RGaWRcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXIsIG51bWJlcl19IFt0eXBlLCBmaWQsIG5ld0xhc3RGaWRdXG4gKi9cbmZ1bmN0aW9uIHJlYWRGaWVsZEJlZ2luKHJlYWRlciwgbGFzdEZpZCkge1xuICBjb25zdCB0eXBlID0gcmVhZGVyLnZpZXcuZ2V0VWludDgocmVhZGVyLm9mZnNldCsrKVxuICBpZiAoKHR5cGUgJiAweDBmKSA9PT0gQ29tcGFjdFR5cGUuU1RPUCkge1xuICAgIC8vIFNUT1AgYWxzbyBlbmRzIGEgc3RydWN0XG4gICAgcmV0dXJuIFswLCAwLCBsYXN0RmlkXVxuICB9XG4gIGNvbnN0IGRlbHRhID0gdHlwZSA+PiA0XG4gIGxldCBmaWQgLy8gZmllbGQgaWRcbiAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgLy8gbm90IGEgZGVsdGEsIHJlYWQgemlnemFnIHZhcmludCBmaWVsZCBpZFxuICAgIGZpZCA9IHJlYWRaaWdaYWcocmVhZGVyKVxuICB9IGVsc2Uge1xuICAgIC8vIGFkZCBkZWx0YSB0byBsYXN0IGZpZWxkIGlkXG4gICAgZmlkID0gbGFzdEZpZCArIGRlbHRhXG4gIH1cbiAgcmV0dXJuIFtnZXRDb21wYWN0VHlwZSh0eXBlKSwgZmlkLCBmaWRdXG59XG5cbi8qKlxuICogUmVhZCBjb2xsZWN0aW9uIHR5cGUgYW5kIHNpemVcbiAqXG4gKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlclxuICogQHJldHVybnMge1tudW1iZXIsIG51bWJlcl19IFt0eXBlLCBzaXplXVxuICovXG5mdW5jdGlvbiByZWFkQ29sbGVjdGlvbkJlZ2luKHJlYWRlcikge1xuICBjb25zdCBzaXplVHlwZSA9IHJlYWRlci52aWV3LmdldFVpbnQ4KHJlYWRlci5vZmZzZXQrKylcbiAgY29uc3Qgc2l6ZSA9IHNpemVUeXBlID4+IDRcbiAgY29uc3QgdHlwZSA9IGdldENvbXBhY3RUeXBlKHNpemVUeXBlKVxuICBpZiAoc2l6ZSA9PT0gMTUpIHtcbiAgICBjb25zdCBuZXdTaXplID0gcmVhZFZhckludChyZWFkZXIpXG4gICAgcmV0dXJuIFt0eXBlLCBuZXdTaXplXVxuICB9XG4gIHJldHVybiBbdHlwZSwgc2l6ZV1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGludCB0byB2YXJpbnQuIE91dHB1dHMgMS01IGJ5dGVzIGZvciBpbnQzMi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHJldHVybnMge251bWJlcltdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9WYXJJbnQobikge1xuICBsZXQgaWR4ID0gMFxuICBjb25zdCB2YXJJbnQgPSBbXVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICgobiAmIH4weDdmKSA9PT0gMCkge1xuICAgICAgdmFySW50W2lkeCsrXSA9IG5cbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhckludFtpZHgrK10gPSBuICYgMHg3ZiB8IDB4ODBcbiAgICAgIG4gPj4+PSA3XG4gICAgfVxuICB9XG4gIHJldHVybiB2YXJJbnRcbn1cbiIsIi8qKlxuICogUmVwbGFjZSBiaWdpbnRzIHdpdGggbnVtYmVycy5cbiAqIFdoZW4gcGFyc2luZyBwYXJxdWV0IGZpbGVzLCBiaWdpbnRzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCA2NC1iaXQgaW50ZWdlcnMuXG4gKiBIb3dldmVyLCBKU09OIGRvZXMgbm90IHN1cHBvcnQgYmlnaW50cywgc28gaXQncyBoZWxwZnVsIHRvIGNvbnZlcnQgdG8gbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge2FueX0gb2JqIG9iamVjdCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7dW5rbm93bn0gY29udmVydGVkIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Kc29uKG9iaikge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnYmlnaW50JykgcmV0dXJuIE51bWJlcihvYmopXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmoubWFwKHRvSnNvbilcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHJldHVybiBBcnJheS5mcm9tKG9iailcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBvYmoudG9JU09TdHJpbmcoKVxuICBpZiAob2JqIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gKi9cbiAgICBjb25zdCBuZXdPYmogPSB7fVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgbmV3T2JqW2tleV0gPSB0b0pzb24ob2JqW2tleV0pXG4gICAgfVxuICAgIHJldHVybiBuZXdPYmpcbiAgfVxuICByZXR1cm4gb2JqXG59XG5cbi8qKlxuICogQ29uY2F0ZW5hdGUgdHdvIGFycmF5cyBmYXN0LlxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5EZWNvZGVkQXJyYXl9IERlY29kZWRBcnJheVxuICogQHBhcmFtIHthbnlbXX0gYWFhIGZpcnN0IGFycmF5XG4gKiBAcGFyYW0ge0RlY29kZWRBcnJheX0gYmJiIHNlY29uZCBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KGFhYSwgYmJiKSB7XG4gIGNvbnN0IGNodW5rID0gMTAwMDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYmIubGVuZ3RoOyBpICs9IGNodW5rKSB7XG4gICAgYWFhLnB1c2goLi4uYmJiLnNsaWNlKGksIGkgKyBjaHVuaykpXG4gIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgRGF0YXNldENvbXBvbmVudCB9IGZyb20gJ2dyaWR2aXonXG5pbXBvcnQgeyBwYXJxdWV0TWV0YWRhdGEgfSBmcm9tICdoeXBhcnF1ZXQnXG4vL2ltcG9ydCB7IHRhYmxlRnJvbUlQQyB9IGZyb20gJ2FwYWNoZS1hcnJvdydcbi8vaW1wb3J0IHsgcmVhZFBhcnF1ZXQgfSBmcm9tIFwicGFycXVldC13YXNtXCJcbi8vaW1wb3J0IHsgcmVhZFBhcnF1ZXQgfSBmcm9tIFwicGFycXVldC13YXNtL2J1bmRsZXIvYXJyb3cxLmpzXCI7XG4vL2ltcG9ydCB7IHJlYWRQYXJxdWV0IH0gZnJvbSBcInBhcnF1ZXQtd2FzbS9ub2RlMlwiO1xuXG4vL3NlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9wYXJxdWV0LXdhc21cblxuLy9zZWUgaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BibXNjaG1pZHQvaGVsbG8tcGFycXVldC13YXNtXG4vKlxucHEgPSB7XG4gIGNvbnN0IHBxID0gYXdhaXQgaW1wb3J0KCdodHRwczovL3VucGtnLmNvbS9wYXJxdWV0LXdhc21AMC4xLjEvd2ViLmpzJylcbiAgLy8gZGVmYXVsdCBzZWVtcyB0byBuZWVkIHRvIHJlc29sdmUgZmlyc3Q/XG4gIGF3YWl0IHBxLmRlZmF1bHQoKVxuICByZXR1cm4gcHFcbn1cbiovXG5cbi8qKlxuICogQSBkYXRhc2V0IGNvbXBvc2VkIG9mIGEgc2luZ2xlIHBhcnF1ZXQgZmlsZSAobm90IHRpbGVkKS5cbiAqXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJxdWV0R3JpZCBleHRlbmRzIERhdGFzZXRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgZGF0YXNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBUaGUgZGF0YXNldCByZXNvbHV0aW9uIGluIGdlb2dyYXBoaWNhbCB1bml0LlxuICAgICAqIEBwYXJhbSB7e3ByZXByb2Nlc3M/OihmdW5jdGlvbihvYmplY3QpOmJvb2xlYW4pLCByZWFkUGFycXVldEZ1bj86RnVuY3Rpb259fSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsLCByZXNvbHV0aW9uLCBvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIodXJsLCByZXNvbHV0aW9uLCBvcHRzKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG9iamVjdD59ICovXG4gICAgICAgIHRoaXMuY2VsbHMgPSBbXVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZSAgKi9cbiAgICAgICAgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9ICdub3RMb2FkZWQnXG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhyZWFkUGFycXVldClcbiAgICAgICAgLy9jb25zdCBwcSA9IGF3YWl0IGltcG9ydCgnaHR0cHM6Ly91bnBrZy5jb20vcGFycXVldC13YXNtQDAuMS4xL3dlYi5qcycpXG4gICAgICAgIC8vYXdhaXQgcHEuZGVmYXVsdCgpXG5cbiAgICAgICAgaWYgKCFvcHRzLnJlYWRQYXJxdWV0RnVuKSB0aHJvdyBuZXcgRXJyb3IoJ3JlYWRQYXJxdWV0IGZ1bmN0aW9uIG5lZWRlZCBmb3IgcGFycXVldCBkYXRhc2V0JylcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKiBAcHJpdmF0ZSAgKi9cbiAgICAgICAgLy90aGlzLnJlYWRQYXJxdWV0RnVuID0gb3B0cy5yZWFkUGFycXVldEZ1blxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgZGF0YSB3aXRoaW4gYSBnZW9ncmFwaGljIGVudmVsb3BlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8dW5kZWZpbmVkfSBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IHJlZHJhd1xuICAgICAqL1xuICAgIGdldERhdGEoZSwgcmVkcmF3KSB7XG4gICAgICAgIC8vY2hlY2sgaWYgZGF0YSBhbHJlYWR5IGxvYWRlZFxuICAgICAgICBpZiAodGhpcy5pbmZvTG9hZGluZ1N0YXR1cyAhPSAnbm90TG9hZGVkJykgcmV0dXJuIHRoaXNcblxuICAgICAgICAvL2xvYWQgZGF0YVxuICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2xvYWRpbmcnXG5cbiAgICAgICAgY29uc3QgcmVzID0gZmV0Y2godGhpcy51cmwpXG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gcmVzLmFycmF5QnVmZmVyKClcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBwYXJxdWV0TWV0YWRhdGEoYXJyYXlCdWZmZXIpXG4gICAgICAgIGNvbnNvbGUubG9nKG1ldGFkYXRhKVxuXG4gICAgICAgIC8qOyhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaCh0aGlzLnVybClcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJxdWV0VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3AuYXJyYXlCdWZmZXIoKSlcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJvd1VpbnQ4QXJyYXkgPSB0aGlzLnJlYWRQYXJxdWV0RnVuKHBhcnF1ZXRVaW50OEFycmF5KVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHRhYmxlRnJvbUlQQyhhcnJvd1VpbnQ4QXJyYXkpXG4gICAgICAgICAgICAgICAgLy9zZWUgaHR0cHM6Ly9hcnJvdy5hcGFjaGUub3JnL2RvY3MvanMvXG4gICAgICAgICAgICAgICAgLy9odHRwczovL2xvYWRlcnMuZ2wvYXJyb3dqcy9kb2NzL2RldmVsb3Blci1ndWlkZS90YWJsZXMjcmVjb3JkLXRvanNvbi1hbmQtdG9hcnJheVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jZWxscyA9IFtdXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgY2VsbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gZS50b0pTT04oKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vcHJlcHJvY2Vzcy9maWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJlcHJvY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMucHJlcHJvY2VzcyhjKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gZmFsc2UpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzLnB1c2goYylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2VsbHMucHVzaChjKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9UT0RPIGNoZWNrIGlmIHJlZHJhdyBpcyBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAvL3RoYXQgaXMgaWYgdGhlIGRhdGFzZXQgYmVsb25ncyB0byBhIGxheWVyIHdoaWNoIGlzIHZpc2libGUgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuXG4gICAgICAgICAgICAgICAgLy9leGVjdXRlIHRoZSBjYWxsYmFjaywgdXN1YWxseSBhIGRyYXcgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3KSByZWRyYXcoKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9ICdsb2FkZWQnXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vbWFyayBhcyBmYWlsZWRcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzID0gW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKSovXG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxsIHRoZSB2aWV3IGNhY2hlIHdpdGggYWxsIGNlbGxzIHdoaWNoIGFyZSB3aXRoaW4gYSBnZW9ncmFwaGljYWwgZW52ZWxvcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXh0R2VvXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlVmlld0NhY2hlKGV4dEdlbykge1xuICAgICAgICAvL2RhdGEgbm90IGxvYWRlZCB5ZXRcbiAgICAgICAgaWYgKCF0aGlzLmNlbGxzKSByZXR1cm5cblxuICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlID0gW11cbiAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHRoaXMuY2VsbHMpIHtcbiAgICAgICAgICAgIGlmICgrY2VsbC54ICsgdGhpcy5yZXNvbHV0aW9uIDwgZXh0R2VvLnhNaW4pIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoK2NlbGwueCAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby54TWF4KSBjb250aW51ZVxuICAgICAgICAgICAgaWYgKCtjZWxsLnkgKyB0aGlzLnJlc29sdXRpb24gPCBleHRHZW8ueU1pbikgY29udGludWVcbiAgICAgICAgICAgIGlmICgrY2VsbC55IC0gdGhpcy5yZXNvbHV0aW9uID4gZXh0R2VvLnlNYXgpIGNvbnRpbnVlXG4gICAgICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlLnB1c2goY2VsbClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLy9AdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5leHBvcnQgeyBQYXJxdWV0R3JpZCB9IGZyb20gXCIuL1BhcnF1ZXRHcmlkLmpzXCJcbi8vZXhwb3J0IHsgVGlsZWRQYXJxdWV0R3JpZCB9IGZyb20gXCIuL1RpbGVkUGFycXVldEdyaWQuanNcIlxuLypcbmltcG9ydCB7IERhdGFzZXQgfSBmcm9tICdncmlkdml6J1xuaW1wb3J0IHsgUGFycXVldEdyaWQgfSBmcm9tIFwiLi9QYXJxdWV0R3JpZC5qc1wiXG5pbXBvcnQgeyBUaWxlZFBhcnF1ZXRHcmlkIH0gZnJvbSBcIi4vVGlsZWRQYXJxdWV0R3JpZC5qc1wiXG5cbi8vaW1wb3J0IHsgcmVhZFBhcnF1ZXQgfSBmcm9tIFwicGFycXVldC13YXNtXCJcbi8vaW1wb3J0IHsgcmVhZFBhcnF1ZXQgfSBmcm9tIFwicGFycXVldC13YXNtL2J1bmRsZXIvYXJyb3cxLmpzXCI7XG4vL2ltcG9ydCB7IHJlYWRQYXJxdWV0IH0gZnJvbSBcInBhcnF1ZXQtd2FzbS9ub2RlMlwiO1xuXG5cblxuLypcbmV4cG9ydCBjb25zdCBtYWtlUGFycXVldEdyaWREYXRhc2V0ID0gZnVuY3Rpb24gKGFwcCwgdXJsLCByZXNvbHV0aW9uLCBvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhc2V0KFtuZXcgUGFycXVldEdyaWQodXJsLCByZXNvbHV0aW9uLCBvcHRzKS5nZXREYXRhKHVuZGVmaW5lZCwgKCkgPT4geyBhcHAuY2cucmVkcmF3KCk7IH0pXSwgW10sIG9wdHMpXG59XG5cbi8qKlxuKiBBZGQgYSBsYXllciBmcm9tIGEgcGFycXVldCBncmlkIGRhdGFzZXQuXG4qXG4qIEBwYXJhbSB7b2JqZWN0fSBhcHAgVGhlIGdyaWR2aXogYXBwbGljYXRpb24uXG4qIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgZGF0YXNldC5cbiogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIGRhdGFzZXQgcmVzb2x1dGlvbiBpbiBnZW9ncmFwaGljYWwgdW5pdC5cbiogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gc3R5bGVzIFRoZSBzdHlsZXMsIG9yZGVyZWQgaW4gZHJhd2luZyBvcmRlci5cbiogQHBhcmFtIHtvYmplY3Q9fSBvcHRzIFRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBkYXRhc2V0IGFuZCBsYXllci5cbiogQHJldHVybnMge29iamVjdH1cbiovXG4vKmV4cG9ydCBjb25zdCBhZGRQYXJxdWV0R3JpZExheWVyID0gZnVuY3Rpb24gKGFwcCwgdXJsLCByZXNvbHV0aW9uLCBzdHlsZXMsIG9wdHMpIHtcbiAgICBjb25zdCBkcyA9IG1ha2VQYXJxdWV0R3JpZERhdGFzZXQoYXBwLCB1cmwsIHJlc29sdXRpb24sIG9wdHMpXG4gICAgcmV0dXJuIGFwcC5hZGRMYXllckZyb21EYXRhc2V0KGRzLCBzdHlsZXMsIG9wdHMpO1xufSovXG5cblxuXG5cblxuXG4vKlxuZXhwb3J0IGNvbnN0IG1ha2VNdWx0aVNjYWxlUGFycXVldEdyaWREYXRhc2V0ID0gZnVuY3Rpb24gKGFwcCwgcmVzb2x1dGlvbnMsIHJlc1RvVVJMLCBvcHRzKSB7XG4gICAgcmV0dXJuIERhdGFzZXQubWFrZShcbiAgICAgICAgcmVzb2x1dGlvbnMsXG4gICAgICAgIChyZXMpID0+IG5ldyBQYXJxdWV0R3JpZChyZXNUb1VSTChyZXMpLCByZXMsIG9wdHMpLmdldERhdGEodW5kZWZpbmVkLCAoKSA9PiB7IGFwcC5jZy5yZWRyYXcoKSB9KSxcbiAgICAgICAgb3B0c1xuICAgIClcbn1cblxuLyoqXG4qIEBwYXJhbSB7b2JqZWN0fSBhcHAgVGhlIGdyaWR2aXogYXBwbGljYXRpb24uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZXNvbHV0aW9uc1xuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOnN0cmluZ30gcmVzVG9VUkxcbiogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gc3R5bGVzIFRoZSBzdHlsZXMsIG9yZGVyZWQgaW4gZHJhd2luZyBvcmRlci5cbiAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0cyBUaGUgcGFyYW1ldGVycyBvZiB0aGUgZGF0YXNldCBhbmQgbGF5ZXIuXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG4vKmV4cG9ydCBjb25zdCBhZGRNdWx0aVNjYWxlUGFycXVldEdyaWRMYXllciA9IGZ1bmN0aW9uIChhcHAsIHJlc29sdXRpb25zLCByZXNUb1VSTCwgc3R5bGVzLCBvcHRzKSB7XG4gICAgY29uc3QgZHMgPSBtYWtlTXVsdGlTY2FsZVBhcnF1ZXRHcmlkRGF0YXNldChhcHAsIHJlc29sdXRpb25zLCByZXNUb1VSTCwgb3B0cylcbiAgICByZXR1cm4gYXBwLmFkZExheWVyRnJvbURhdGFzZXQoZHMsIHN0eWxlcywgb3B0cylcbn1cblxuXG5cblxuXG5cbmV4cG9ydCBjb25zdCBtYWtlVGlsZWRQYXJxdWV0R3JpZERhdGFzZXQgPSBmdW5jdGlvbiAoYXBwLCB1cmwsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IERhdGFzZXQoXG4gICAgICAgIFtuZXcgVGlsZWRQYXJxdWV0R3JpZCh1cmwsIGFwcCwgb3B0cykubG9hZEluZm8oKCkgPT4geyBhcHAuY2cucmVkcmF3KCkgfSksXSxcbiAgICAgICAgW10sXG4gICAgICAgIG9wdHNcbiAgICApXG59XG5cbi8qKlxuKiBAcGFyYW0ge29iamVjdH0gYXBwIFRoZSBncmlkdml6IGFwcGxpY2F0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBzdHlsZXMgVGhlIHN0eWxlcywgb3JkZXJlZCBpbiBkcmF3aW5nIG9yZGVyLlxuICogQHBhcmFtIHt7dmlzaWJsZT86Ym9vbGVhbixtaW5ab29tPzpudW1iZXIsbWF4Wm9vbT86bnVtYmVyLHBpeE5iPzpudW1iZXIsY2VsbEluZm9IVE1MPzpmdW5jdGlvbihvYmplY3QpOnN0cmluZywgcHJlcHJvY2Vzcz86ZnVuY3Rpb24ob2JqZWN0KTpib29sZWFufX0gb3B0c1xuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuLypleHBvcnQgY29uc3QgYWRkVGlsZWRQYXJxdWV0R3JpZExheWVyID0gZnVuY3Rpb24gKGFwcCwgdXJsLCBzdHlsZXMsIG9wdHMpIHtcbiAgICBjb25zdCBkcyA9IG1ha2VUaWxlZFBhcnF1ZXRHcmlkRGF0YXNldChhcHAsIHVybCwgb3B0cylcbiAgICByZXR1cm4gYXBwLmFkZExheWVyRnJvbURhdGFzZXQoZHMsIHN0eWxlcywgb3B0cylcbn1cblxuXG5cblxuXG5cbmV4cG9ydCBjb25zdCBtYWtlTXVsdGlTY2FsZVRpbGVkUGFycXVldEdyaWREYXRhc2V0ID0gZnVuY3Rpb24gKGFwcCwgcmVzb2x1dGlvbnMsIHJlc1RvVVJMLCBvcHRzKSB7XG4gICAgcmV0dXJuIERhdGFzZXQubWFrZShcbiAgICAgICAgcmVzb2x1dGlvbnMsXG4gICAgICAgIChyZXMpID0+IG5ldyBUaWxlZFBhcnF1ZXRHcmlkKHJlc1RvVVJMKHJlcyksIGFwcCwgb3B0cykubG9hZEluZm8oKCkgPT4geyBhcHAuY2cucmVkcmF3KCkgfSksXG4gICAgICAgIG9wdHNcbiAgICApXG59XG5cbi8qKlxuKiBAcGFyYW0ge29iamVjdH0gYXBwIFRoZSBncmlkdml6IGFwcGxpY2F0aW9uLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmVzb2x1dGlvbnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKTpzdHJpbmd9IHJlc1RvVVJMXG4qIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHN0eWxlcyBUaGUgc3R5bGVzLCBvcmRlcmVkIGluIGRyYXdpbmcgb3JkZXIuXG4gKiBAcGFyYW0ge29iamVjdD19IG9wdHMgVGhlIHBhcmFtZXRlcnMgb2YgdGhlIGRhdGFzZXQgYW5kIGxheWVyLlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuLypleHBvcnQgY29uc3QgYWRkTXVsdGlTY2FsZVRpbGVkUGFycXVldEdyaWRMYXllciA9IGZ1bmN0aW9uIChhcHAsIHJlc29sdXRpb25zLCByZXNUb1VSTCwgc3R5bGVzLCBvcHRzKSB7XG4gICAgY29uc3QgZHMgPSBtYWtlTXVsdGlTY2FsZVRpbGVkUGFycXVldEdyaWREYXRhc2V0KGFwcCwgcmVzb2x1dGlvbnMsIHJlc1RvVVJMLCBvcHRzKVxuICAgIHJldHVybiBhcHAuYWRkTGF5ZXJGcm9tRGF0YXNldChkcywgc3R5bGVzLCBvcHRzKVxufVxuXG5cblxuLy90ZXN0IHV0aWxpc2F0aW9uIG9mIHRoYXQ6XG4vLzxzY3JpcHQgc3JjPVwiaHR0cHM6Ly91bnBrZy5jb20vcGFycXVldC13YXNtQDAuNC4wLWJldGEuNS9lc20vYXJyb3cyLmpzXCI+PC9zY3JpcHQ+XG4vKmV4cG9ydCBjb25zdCBsb2FkV2FzbVBhcnF1ZXRSZWFkZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcGFycXVldE1vZHVsZSA9IGF3YWl0IGltcG9ydChcInBhcnF1ZXQtd2FzbVwiKVxuICAgIHJldHVybiBwYXJxdWV0TW9kdWxlLnJlYWRQYXJxdWV0XG4gICAgLy9hd2FpdCBwYXJxdWV0TW9kdWxlLmRlZmF1bHQoKVxuICAgIC8vcmV0dXJuIHBhcnF1ZXRNb2R1bGUucmVhZFBhcnF1ZXRcbn0qL1xuXG5cbi8qKlxuICogUmV0cmlldmUgcGFycXVldCB3YXNtIGRlY29kZXJcbiAqL1xuLypcbmNvbnN0IGdldFJlYWRQYXJxdWV0UCA9ICgpPT4gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHBhcnF1ZXRNb2R1bGUgPSBhd2FpdCBpbXBvcnQoXCJodHRwczovL3VucGtnLmNvbS9wYXJxdWV0LXdhc21AMC40LjAtYmV0YS41L2VzbS9hcnJvdzIuanNcIik7XG4gICAgYXdhaXQgcGFycXVldE1vZHVsZS5kZWZhdWx0KCk7XG4gICAgcmV0dXJuIHBhcnF1ZXRNb2R1bGUucmVhZFBhcnF1ZXQ7XG59XG4qL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9